{"version":3,"file":"static/js/435.083958eb.chunk.js","mappings":"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","sources":["../node_modules/@ledgerhq/hw-app-btc/src/bip32.ts","../node_modules/@ledgerhq/hw-app-btc/src/buffertools.ts","../node_modules/@ledgerhq/hw-app-btc/src/constants.ts","../node_modules/@ledgerhq/hw-app-btc/src/hashPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/accounttype.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkle.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/policy.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtv2.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtFinalizer.ts","../node_modules/@ledgerhq/hw-app-btc/src/varint.ts","../node_modules/@ledgerhq/hw-app-btc/src/serializeTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/BtcNew.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtExtractor.ts","../node_modules/@ledgerhq/hw-app-btc/src/getWalletPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/getTrustedInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/startUntrustedHashTransactionInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/getTrustedInputBIP143.ts","../node_modules/@ledgerhq/hw-app-btc/src/compressPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/signTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/finalizeInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/getAppAndVersion.ts","../node_modules/@ledgerhq/hw-app-btc/src/createTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/shouldUseTrustedInputForSegwit.ts","../node_modules/@ledgerhq/hw-app-btc/src/BtcOld.ts","../node_modules/@ledgerhq/hw-app-btc/src/signMessage.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkleMap.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkelizedPsbt.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/clientCommands.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/appClient.ts","../node_modules/@ledgerhq/hw-app-btc/src/debug.ts","../node_modules/@ledgerhq/hw-app-btc/src/signP2SHTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/Btc.ts","../node_modules/@ledgerhq/hw-app-btc/src/splitTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/node_modules/bech32/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bip32/src/bip32.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bip32/src/crypto.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bip32/src/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/address.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/block.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/bufferutils.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/classify.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/crypto.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/ecpair.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/networks.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/embed.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/lazy.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2ms.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2pk.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2pkh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2sh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2wsh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/psbt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script_number.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script_signature.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/nulldata.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/transaction.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/transaction_builder.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/types.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58check/base.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58check/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/comparator.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/range.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/semver.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/clean.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/cmp.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/coerce.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare-build.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare-loose.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/diff.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/eq.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/gt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/gte.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/inc.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/lt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/lte.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/major.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/minor.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/neq.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/parse.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/patch.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/prerelease.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/rcompare.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/rsort.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/satisfies.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/sort.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/valid.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/constants.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/debug.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/identifiers.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/lrucache.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/parse-options.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/re.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/gtr.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/intersects.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/ltr.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/max-satisfying.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/min-satisfying.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/min-version.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/outside.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/simplify.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/subset.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/to-comparators.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/valid.js","../node_modules/@ledgerhq/logs/src/index.ts","../node_modules/bip32-path/index.js","../node_modules/bitcoin-ops/map.js","../node_modules/invariant/browser.js","../node_modules/pushdata-bitcoin/index.js"],"sourcesContent":["/**\n * @file bip32.ts\n * @description BIP32 Path Handling for Bitcoin Wallets\n *\n * This file provides utility functions to handle BIP32 paths,\n * which are commonly used in hierarchical deterministic (HD) wallets.\n * It includes functions to convert BIP32 paths to and from different formats,\n * extract components from extended public keys (xpubs), and manipulate path elements.\n */\n\nimport bippath from \"bip32-path\";\nimport bs58check from \"bs58check\";\n\nexport function pathElementsToBuffer(paths: number[]): Buffer {\n  const buffer = Buffer.alloc(1 + paths.length * 4);\n  buffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  return buffer;\n}\n\nexport function bip32asBuffer(path: string): Buffer {\n  const pathElements = !path ? [] : pathStringToArray(path);\n  return pathElementsToBuffer(pathElements);\n}\n\nexport function pathArrayToString(pathElements: number[]): string {\n  // Limitation: bippath can't handle and empty path. It shouldn't affect us\n  // right now, but might in the future.\n  // TODO: Fix support for empty path.\n  return bippath.fromPathArray(pathElements).toString();\n}\n\nexport function pathStringToArray(path: string): number[] {\n  return bippath.fromString(path).toPathArray();\n}\n\nexport function pubkeyFromXpub(xpub: string): Buffer {\n  const xpubBuf = bs58check.decode(xpub);\n  return xpubBuf.slice(xpubBuf.length - 33);\n}\n\nexport function getXpubComponents(xpub: string): {\n  chaincode: Buffer;\n  pubkey: Buffer;\n  version: number;\n} {\n  const xpubBuf: Buffer = bs58check.decode(xpub);\n  return {\n    chaincode: xpubBuf.slice(13, 13 + 32),\n    pubkey: xpubBuf.slice(xpubBuf.length - 33),\n    version: xpubBuf.readUInt32BE(0),\n  };\n}\n\nexport function hardenedPathOf(pathElements: number[]): number[] {\n  for (let i = pathElements.length - 1; i >= 0; i--) {\n    if (pathElements[i] >= 0x80000000) {\n      return pathElements.slice(0, i + 1);\n    }\n  }\n  return [];\n}\n","import varuint from \"varuint-bitcoin\";\n\nexport function unsafeTo64bitLE(n: number): Buffer {\n  // we want to represent the input as a 8-bytes array\n  if (n > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"Can't convert numbers > MAX_SAFE_INT\");\n  }\n  const byteArray = Buffer.alloc(8, 0);\n  for (let index = 0; index < byteArray.length; index++) {\n    const byte = n & 0xff;\n    byteArray[index] = byte;\n    n = (n - byte) / 256;\n  }\n  return byteArray;\n}\n\nexport function unsafeFrom64bitLE(byteArray: Buffer): number {\n  let value = 0;\n  if (byteArray.length != 8) {\n    throw new Error(\"Expected Bufffer of lenght 8\");\n  }\n  if (byteArray[7] != 0) {\n    throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n  }\n  if (byteArray[6] > 0x1f) {\n    throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n  }\n  for (let i = byteArray.length - 1; i >= 0; i--) {\n    value = value * 256 + byteArray[i];\n  }\n  return value;\n}\n\nexport class BufferWriter {\n  private bufs: Buffer[] = [];\n\n  write(alloc: number, fn: (b: Buffer) => void): void {\n    const b = Buffer.alloc(alloc);\n    fn(b);\n    this.bufs.push(b);\n  }\n\n  writeUInt8(i: number): void {\n    this.write(1, b => b.writeUInt8(i, 0));\n  }\n\n  writeInt32(i: number): void {\n    this.write(4, b => b.writeInt32LE(i, 0));\n  }\n\n  writeUInt32(i: number): void {\n    this.write(4, b => b.writeUInt32LE(i, 0));\n  }\n\n  writeUInt64(i: number): void {\n    const bytes = unsafeTo64bitLE(i);\n    this.writeSlice(bytes);\n  }\n\n  writeVarInt(i: number): void {\n    this.bufs.push(varuint.encode(i));\n  }\n\n  writeSlice(slice: Buffer): void {\n    this.bufs.push(Buffer.from(slice));\n  }\n\n  writeVarSlice(slice: Buffer): void {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n\n  buffer(): Buffer {\n    return Buffer.concat(this.bufs);\n  }\n}\n\nexport class BufferReader {\n  constructor(\n    public buffer: Buffer,\n    public offset: number = 0,\n  ) {}\n\n  available(): number {\n    return this.buffer.length - this.offset;\n  }\n\n  readUInt8(): number {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n\n  readInt32(): number {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt32(): number {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt64(): number {\n    const buf = this.readSlice(8);\n    const n = unsafeFrom64bitLE(buf);\n    return n;\n  }\n\n  readVarInt(): number {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  readSlice(n: number): Buffer {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error(\"Cannot read slice out of bounds\");\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n\n  readVarSlice(): Buffer {\n    return this.readSlice(this.readVarInt());\n  }\n\n  readVector(): Buffer[] {\n    const count = this.readVarInt();\n    const vector: Buffer[] = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\n","// the maximum number of bytes allowed in a single chunk when processing bitcoin script data.\n// if the Bitcoin script is too large, we will process it in several chunks.\nexport const MAX_SCRIPT_BLOCK = 50;\nexport const DEFAULT_VERSION = 1;\nexport const DEFAULT_LOCKTIME = 0;\n// input sequence for non-rbf transactions\nexport const DEFAULT_SEQUENCE = 0xffffffff;\n// SIGHASH flags(Sign all inputs and outputs)\n// refer to https://wiki.bitcoinsv.io/index.php/SIGHASH_flags for more details\nexport const SIGHASH_ALL = 1;\n// refer to https://en.bitcoin.it/wiki/Script for Opcodes(OP_DUP, OP_HASH160...) that are used in bitcoin script\nexport const OP_DUP = 0x76;\nexport const OP_HASH160 = 0xa9;\nexport const HASH_SIZE = 0x14;\nexport const OP_EQUAL = 0x87;\nexport const OP_EQUALVERIFY = 0x88;\nexport const OP_CHECKSIG = 0xac;\nexport const OP_RETURN = 0x6a;\n","import RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nexport function hashPublicKey(buffer: Buffer): Buffer {\n  return new RIPEMD160().update(sha(\"sha256\").update(buffer).digest()).digest();\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pointAddScalar } from \"tiny-secp256k1\";\nimport { BufferWriter } from \"../buffertools\";\nimport { HASH_SIZE, OP_CHECKSIG, OP_DUP, OP_EQUAL, OP_EQUALVERIFY, OP_HASH160 } from \"../constants\";\nimport { hashPublicKey } from \"../hashPublicKey\";\nimport { DefaultDescriptorTemplate } from \"./policy\";\nimport { PsbtV2 } from \"./psbtv2\";\n\nexport type SpendingCondition = {\n  scriptPubKey: Buffer;\n  redeemScript?: Buffer;\n  // Possible future extension:\n  // witnessScript?: Buffer; // For p2wsh witnessScript\n  // tapScript?: {tapPath: Buffer[], script: Buffer} // For taproot\n};\n\nexport type SpentOutput = { cond: SpendingCondition; amount: Buffer };\n\n/**\n * Encapsulates differences between account types, for example p2wpkh,\n * p2wpkhWrapped, p2tr.\n */\nexport interface AccountType {\n  /**\n   * Generates a scriptPubKey (output script) from a list of public keys. If a\n   * p2sh redeemScript or a p2wsh witnessScript is needed it will also be set on\n   * the returned SpendingCondition.\n   *\n   * The pubkeys are expected to be 33 byte ecdsa compressed pubkeys.\n   */\n  spendingCondition(pubkeys: Buffer[]): SpendingCondition;\n\n  /**\n   * Populates the psbt with account type-specific data for an input.\n   * @param i The index of the input map to populate\n   * @param inputTx The full transaction containing the spent output. This may\n   * be omitted for taproot.\n   * @param spentOutput The amount and spending condition of the spent output\n   * @param pubkeys The 33 byte ecdsa compressed public keys involved in the input\n   * @param pathElems The paths corresponding to the pubkeys, in same order.\n   */\n  setInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkeys: Buffer[],\n    pathElems: number[][],\n  ): void;\n\n  /**\n   * Populates the psbt with account type-specific data for an output. This is typically\n   * done for change outputs and other outputs that goes to the same account as\n   * being spent from.\n   * @param i The index of the output map to populate\n   * @param cond The spending condition for this output\n   * @param pubkeys The 33 byte ecdsa compressed public keys involved in this output\n   * @param paths The paths corresponding to the pubkeys, in same order.\n   */\n  setOwnOutput(i: number, cond: SpendingCondition, pubkeys: Buffer[], paths: number[][]): void;\n\n  /**\n   * Returns the descriptor template for this account type. Currently only\n   * DefaultDescriptorTemplates are allowed, but that might be changed in the\n   * future. See class WalletPolicy for more information on descriptor\n   * templates.\n   */\n  getDescriptorTemplate(): DefaultDescriptorTemplate;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface BaseAccount extends AccountType {}\n\nabstract class BaseAccount implements AccountType {\n  constructor(\n    protected psbt: PsbtV2,\n    protected masterFp: Buffer,\n  ) {}\n}\n\n/**\n * Superclass for single signature accounts. This will make sure that the pubkey\n * arrays and path arrays in the method arguments contains exactly one element\n * and calls an abstract method to do the actual work.\n */\nabstract class SingleKeyAccount extends BaseAccount {\n  spendingCondition(pubkeys: Buffer[]): SpendingCondition {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    return this.singleKeyCondition(pubkeys[0]);\n  }\n  protected abstract singleKeyCondition(pubkey: Buffer): SpendingCondition;\n\n  setInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkeys: Buffer[],\n    pathElems: number[][],\n  ) {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    if (pathElems.length != 1) {\n      throw new Error(\"Expected single path, got \" + pathElems.length);\n    }\n    this.setSingleKeyInput(i, inputTx, spentOutput, pubkeys[0], pathElems[0]);\n  }\n  protected abstract setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  );\n\n  setOwnOutput(i: number, cond: SpendingCondition, pubkeys: Buffer[], paths: number[][]) {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    if (paths.length != 1) {\n      throw new Error(\"Expected single path, got \" + paths.length);\n    }\n    this.setSingleKeyOutput(i, cond, pubkeys[0], paths[0]);\n  }\n  protected abstract setSingleKeyOutput(\n    i: number,\n    cond: SpendingCondition,\n    pubkey: Buffer,\n    path: number[],\n  );\n}\n\nexport class p2pkh extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const pubkeyHash = hashPublicKey(pubkey);\n    buf.writeSlice(Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]));\n    buf.writeSlice(pubkeyHash);\n    buf.writeSlice(Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]));\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    _spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"pkh(@0)\";\n  }\n}\n\nexport class p2tr extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const xonlyPubkey = pubkey.slice(1); // x-only pubkey\n    const buf = new BufferWriter();\n    const outputKey = this.getTaprootOutputKey(xonlyPubkey);\n    buf.writeSlice(Buffer.from([0x51, 32])); // push1, pubkeylen\n    buf.writeSlice(outputKey);\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    _inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    const xonly = pubkey.slice(1);\n    this.psbt.setInputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    const xonly = pubkey.slice(1);\n    this.psbt.setOutputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"tr(@0)\";\n  }\n\n  /*\n  The following two functions are copied from wallet-btc and adapted.\n  They should be moved to a library to avoid code reuse.\n  */\n  private hashTapTweak(x: Buffer): Buffer {\n    // hash_tag(x) = SHA256(SHA256(tag) || SHA256(tag) || x), see BIP340\n    // See https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification\n    const h = crypto.sha256(Buffer.from(\"TapTweak\", \"utf-8\"));\n    return crypto.sha256(Buffer.concat([h, h, x]));\n  }\n\n  /**\n   * Calculates a taproot output key from an internal key. This output key will be\n   * used as witness program in a taproot output. The internal key is tweaked\n   * according to recommendation in BIP341:\n   * https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-22-0\n   *\n   * @param internalPubkey A 32 byte x-only taproot internal key\n   * @returns The output key\n   */\n  getTaprootOutputKey(internalPubkey: Buffer): Buffer {\n    if (internalPubkey.length != 32) {\n      throw new Error(\"Expected 32 byte pubkey. Got \" + internalPubkey.length);\n    }\n    // A BIP32 derived key can be converted to a schnorr pubkey by dropping\n    // the first byte, which represent the oddness/evenness. In schnorr all\n    // pubkeys are even.\n    // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#public-key-conversion\n    const evenEcdsaPubkey = Buffer.concat([Buffer.from([0x02]), internalPubkey]);\n    const tweak = this.hashTapTweak(internalPubkey);\n\n    // Q = P + int(hash_TapTweak(bytes(P)))G\n    const outputEcdsaKey = Buffer.from(pointAddScalar(evenEcdsaPubkey, tweak));\n    // Convert to schnorr.\n    const outputSchnorrKey = outputEcdsaKey.slice(1);\n    // Create address\n    return outputSchnorrKey;\n  }\n}\n\nexport class p2wpkhWrapped extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const redeemScript = this.createRedeemScript(pubkey);\n    const scriptHash = hashPublicKey(redeemScript);\n    buf.writeSlice(Buffer.from([OP_HASH160, HASH_SIZE]));\n    buf.writeSlice(scriptHash);\n    buf.writeUInt8(OP_EQUAL);\n    return { scriptPubKey: buf.buffer(), redeemScript: redeemScript };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n\n    const userSuppliedRedeemScript = spentOutput.cond.redeemScript;\n    const expectedRedeemScript = this.createRedeemScript(pubkey);\n    if (userSuppliedRedeemScript && !expectedRedeemScript.equals(userSuppliedRedeemScript)) {\n      // At what point might a user set the redeemScript on its own?\n      throw new Error(`User-supplied redeemScript ${userSuppliedRedeemScript.toString(\n        \"hex\",\n      )} doesn't\n       match expected ${expectedRedeemScript.toString(\"hex\")} for input ${i}`);\n    }\n    this.psbt.setInputRedeemScript(i, expectedRedeemScript);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputRedeemScript(i, cond.redeemScript!);\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"sh(wpkh(@0))\";\n  }\n\n  private createRedeemScript(pubkey: Buffer): Buffer {\n    const pubkeyHash = hashPublicKey(pubkey);\n    return Buffer.concat([Buffer.from(\"0014\", \"hex\"), pubkeyHash]);\n  }\n}\n\nexport class p2wpkh extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const pubkeyHash = hashPublicKey(pubkey);\n    buf.writeSlice(Buffer.from([0, HASH_SIZE]));\n    buf.writeSlice(pubkeyHash);\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"wpkh(@0)\";\n  }\n}\n","import { crypto } from \"bitcoinjs-lib\";\n\n/**\n * This class implements the merkle tree used by Ledger Bitcoin app v2+,\n * which is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md\n */\nexport class Merkle {\n  private leaves: Buffer[];\n  private rootNode: Node;\n  private leafNodes: Node[];\n  private h: (buf: Buffer) => Buffer;\n  constructor(leaves: Buffer[], hasher: (buf: Buffer) => Buffer = crypto.sha256) {\n    this.leaves = leaves;\n    this.h = hasher;\n    const nodes = this.calculateRoot(leaves);\n    this.rootNode = nodes.root;\n    this.leafNodes = nodes.leaves;\n  }\n  getRoot(): Buffer {\n    return this.rootNode.hash;\n  }\n  size(): number {\n    return this.leaves.length;\n  }\n  getLeaves(): Buffer[] {\n    return this.leaves;\n  }\n  getLeafHash(index: number): Buffer {\n    return this.leafNodes[index].hash;\n  }\n  getProof(index: number): Buffer[] {\n    if (index >= this.leaves.length) throw Error(\"Index out of bounds\");\n    return proveNode(this.leafNodes[index]);\n  }\n\n  calculateRoot(leaves: Buffer[]): { root: Node; leaves: Node[] } {\n    const n = leaves.length;\n    if (n == 0) {\n      return {\n        root: new Node(undefined, undefined, Buffer.alloc(32, 0)),\n        leaves: [],\n      };\n    }\n    if (n == 1) {\n      const newNode = new Node(undefined, undefined, leaves[0]);\n      return { root: newNode, leaves: [newNode] };\n    }\n    const leftCount = highestPowerOf2LessThan(n);\n    const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));\n    const rightBranch = this.calculateRoot(leaves.slice(leftCount));\n    const leftChild = leftBranch.root;\n    const rightChild = rightBranch.root;\n    const hash = this.hashNode(leftChild.hash, rightChild.hash);\n    const node = new Node(leftChild, rightChild, hash);\n    leftChild.parent = node;\n    rightChild.parent = node;\n    return { root: node, leaves: leftBranch.leaves.concat(rightBranch.leaves) };\n  }\n\n  hashNode(left: Buffer, right: Buffer): Buffer {\n    return this.h(Buffer.concat([Buffer.from([1]), left, right]));\n  }\n}\n\nexport function hashLeaf(\n  buf: Buffer,\n  hashFunction: (buf: Buffer) => Buffer = crypto.sha256,\n): Buffer {\n  return hashConcat(Buffer.from([0]), buf, hashFunction);\n}\n\nfunction hashConcat(bufA: Buffer, bufB: Buffer, hashFunction: (buf: Buffer) => Buffer): Buffer {\n  return hashFunction(Buffer.concat([bufA, bufB]));\n}\n\nclass Node {\n  leftChild?: Node;\n  rightChild?: Node;\n  parent?: Node;\n  hash: Buffer;\n  constructor(left: Node | undefined, right: Node | undefined, hash: Buffer) {\n    this.leftChild = left;\n    this.rightChild = right;\n    this.hash = hash;\n  }\n  isLeaf(): boolean {\n    return this.leftChild == undefined;\n  }\n}\n\nfunction proveNode(node: Node): Buffer[] {\n  if (!node.parent) {\n    return [];\n  }\n  if (node.parent.leftChild == node) {\n    if (!node.parent.rightChild) {\n      throw new Error(\"Expected right child to exist\");\n    }\n    return [node.parent.rightChild.hash, ...proveNode(node.parent)];\n  } else {\n    if (!node.parent.leftChild) {\n      throw new Error(\"Expected left child to exist\");\n    }\n    return [node.parent.leftChild.hash, ...proveNode(node.parent)];\n  }\n}\n\nfunction highestPowerOf2LessThan(n: number) {\n  if (n < 2) {\n    throw Error(\"Expected n >= 2\");\n  }\n  if (isPowerOf2(n)) {\n    return n / 2;\n  }\n  return 1 << Math.floor(Math.log2(n));\n}\n\nfunction isPowerOf2(n: number): boolean {\n  return (n & (n - 1)) == 0;\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pathArrayToString } from \"../bip32\";\nimport { BufferWriter } from \"../buffertools\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\nexport type DefaultDescriptorTemplate = \"pkh(@0)\" | \"sh(wpkh(@0))\" | \"wpkh(@0)\" | \"tr(@0)\";\n\n/**\n * The Bitcon hardware app uses a descriptors-like thing to describe\n * how to construct output scripts from keys. A \"Wallet Policy\" consists\n * of a \"Descriptor Template\" and a list of \"keys\". A key is basically\n * a serialized BIP32 extended public key with some added derivation path\n * information. This is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/wallet.md\n */\nexport class WalletPolicy {\n  descriptorTemplate: string;\n  keys: string[];\n  /**\n   * For now, we only support default descriptor templates.\n   */\n  constructor(descriptorTemplate: DefaultDescriptorTemplate, key: string) {\n    this.descriptorTemplate = descriptorTemplate;\n    this.keys = [key];\n  }\n\n  getWalletId(): Buffer {\n    // wallet_id (sha256 of the wallet serialization),\n    return crypto.sha256(this.serialize());\n  }\n\n  serialize(): Buffer {\n    const keyBuffers = this.keys.map(k => {\n      return Buffer.from(k, \"ascii\");\n    });\n    const m = new Merkle(keyBuffers.map(k => hashLeaf(k)));\n\n    const buf = new BufferWriter();\n    buf.writeUInt8(0x01); // wallet type (policy map)\n    buf.writeUInt8(0); // length of wallet name (empty string for default wallets)\n    buf.writeVarSlice(Buffer.from(this.descriptorTemplate, \"ascii\"));\n    buf.writeVarInt(this.keys.length), buf.writeSlice(m.getRoot());\n    return buf.buffer();\n  }\n}\n\nexport function createKey(masterFingerprint: Buffer, path: number[], xpub: string): string {\n  const accountPath = pathArrayToString(path);\n  return `[${masterFingerprint.toString(\"hex\")}${accountPath.substring(1)}]${xpub}/**`;\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { BufferReader, BufferWriter, unsafeFrom64bitLE, unsafeTo64bitLE } from \"../buffertools\";\n\nexport enum psbtGlobal {\n  TX_VERSION = 0x02,\n  FALLBACK_LOCKTIME = 0x03,\n  INPUT_COUNT = 0x04,\n  OUTPUT_COUNT = 0x05,\n  TX_MODIFIABLE = 0x06,\n  VERSION = 0xfb,\n}\nexport enum psbtIn {\n  NON_WITNESS_UTXO = 0x00,\n  WITNESS_UTXO = 0x01,\n  PARTIAL_SIG = 0x02,\n  SIGHASH_TYPE = 0x03,\n  REDEEM_SCRIPT = 0x04,\n  BIP32_DERIVATION = 0x06,\n  FINAL_SCRIPTSIG = 0x07,\n  FINAL_SCRIPTWITNESS = 0x08,\n  PREVIOUS_TXID = 0x0e,\n  OUTPUT_INDEX = 0x0f,\n  SEQUENCE = 0x10,\n  TAP_KEY_SIG = 0x13,\n  TAP_BIP32_DERIVATION = 0x16,\n}\nexport enum psbtOut {\n  REDEEM_SCRIPT = 0x00,\n  BIP_32_DERIVATION = 0x02,\n  AMOUNT = 0x03,\n  SCRIPT = 0x04,\n  TAP_BIP32_DERIVATION = 0x07,\n}\n\nconst PSBT_MAGIC_BYTES = Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]);\n\nexport class NoSuchEntry extends Error {}\n\n/**\n * Implements Partially Signed Bitcoin Transaction version 2, BIP370, as\n * documented at https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki\n * and https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki\n *\n * A psbt is a data structure that can carry all relevant information about a\n * transaction through all stages of the signing process. From constructing an\n * unsigned transaction to extracting the final serialized transaction ready for\n * broadcast.\n *\n * This implementation is limited to what's needed in ledgerjs to carry out its\n * duties, which means that support for features like multisig or taproot script\n * path spending are not implemented. Specifically, it supports p2pkh,\n * p2wpkhWrappedInP2sh, p2wpkh and p2tr key path spending.\n *\n * This class is made purposefully dumb, so it's easy to add support for\n * complemantary fields as needed in the future.\n */\nexport class PsbtV2 {\n  protected globalMap: Map<string, Buffer> = new Map();\n  protected inputMaps: Map<string, Buffer>[] = [];\n  protected outputMaps: Map<string, Buffer>[] = [];\n\n  setGlobalTxVersion(version: number) {\n    this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));\n  }\n  getGlobalTxVersion(): number {\n    return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);\n  }\n  setGlobalFallbackLocktime(locktime: number) {\n    this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));\n  }\n  getGlobalFallbackLocktime(): number | undefined {\n    return this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)?.readUInt32LE(0);\n  }\n  setGlobalInputCount(inputCount: number) {\n    this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));\n  }\n  getGlobalInputCount(): number {\n    return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));\n  }\n  setGlobalOutputCount(outputCount: number) {\n    this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));\n  }\n  getGlobalOutputCount(): number {\n    return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));\n  }\n  setGlobalTxModifiable(byte: Buffer) {\n    this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);\n  }\n  getGlobalTxModifiable(): Buffer | undefined {\n    return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);\n  }\n  setGlobalPsbtVersion(psbtVersion: number) {\n    this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));\n  }\n  getGlobalPsbtVersion(): number {\n    return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);\n  }\n\n  setInputNonWitnessUtxo(inputIndex: number, transaction: Buffer) {\n    this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);\n  }\n  getInputNonWitnessUtxo(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());\n  }\n  setInputWitnessUtxo(inputIndex: number, amount: Buffer, scriptPubKey: Buffer) {\n    const buf = new BufferWriter();\n    buf.writeSlice(amount);\n    buf.writeVarSlice(scriptPubKey);\n    this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());\n  }\n  getInputWitnessUtxo(inputIndex: number): { amount: Buffer; scriptPubKey: Buffer } | undefined {\n    const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());\n    if (!utxo) return undefined;\n    const buf = new BufferReader(utxo);\n    return { amount: buf.readSlice(8), scriptPubKey: buf.readVarSlice() };\n  }\n  setInputPartialSig(inputIndex: number, pubkey: Buffer, signature: Buffer) {\n    this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);\n  }\n  getInputPartialSig(inputIndex: number, pubkey: Buffer): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);\n  }\n  setInputSighashType(inputIndex: number, sigHashtype: number) {\n    this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));\n  }\n  getInputSighashType(inputIndex: number): number | undefined {\n    const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());\n    if (!result) return undefined;\n    return result.readUInt32LE(0);\n  }\n  setInputRedeemScript(inputIndex: number, redeemScript: Buffer) {\n    this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);\n  }\n  getInputRedeemScript(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());\n  }\n  setInputBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    if (pubkey.length != 33) throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n    this.setInput(\n      inputIndex,\n      psbtIn.BIP32_DERIVATION,\n      pubkey,\n      this.encodeBip32Derivation(masterFingerprint, path),\n    );\n  }\n  getInputBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n  ): { masterFingerprint: Buffer; path: number[] } | undefined {\n    const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);\n    if (!buf) return undefined;\n    return this.decodeBip32Derivation(buf);\n  }\n  setInputFinalScriptsig(inputIndex: number, scriptSig: Buffer) {\n    this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);\n  }\n  getInputFinalScriptsig(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());\n  }\n  setInputFinalScriptwitness(inputIndex: number, scriptWitness: Buffer) {\n    this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);\n  }\n  getInputFinalScriptwitness(inputIndex: number): Buffer {\n    return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());\n  }\n  setInputPreviousTxId(inputIndex: number, txid: Buffer) {\n    this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);\n  }\n  getInputPreviousTxid(inputIndex: number): Buffer {\n    return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());\n  }\n  setInputOutputIndex(inputIndex: number, outputIndex: number) {\n    this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));\n  }\n  getInputOutputIndex(inputIndex: number): number {\n    return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);\n  }\n  setInputSequence(inputIndex: number, sequence: number) {\n    this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));\n  }\n  getInputSequence(inputIndex: number): number {\n    return this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())?.readUInt32LE(0) ?? 0xffffffff;\n  }\n  setInputTapKeySig(inputIndex: number, sig: Buffer) {\n    this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);\n  }\n  getInputTapKeySig(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());\n  }\n  setInputTapBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n    hashes: Buffer[],\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    if (pubkey.length != 32) throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n    const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);\n    this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);\n  }\n  getInputTapBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n  ): { hashes: Buffer[]; masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);\n    return this.decodeTapBip32Derivation(buf);\n  }\n  getInputKeyDatas(inputIndex: number, keyType: KeyType): Buffer[] {\n    return this.getKeyDatas(this.inputMaps[inputIndex], keyType);\n  }\n\n  setOutputRedeemScript(outputIndex: number, redeemScript: Buffer) {\n    this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);\n  }\n  getOutputRedeemScript(outputIndex: number): Buffer {\n    return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());\n  }\n  setOutputBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    this.setOutput(\n      outputIndex,\n      psbtOut.BIP_32_DERIVATION,\n      pubkey,\n      this.encodeBip32Derivation(masterFingerprint, path),\n    );\n  }\n  getOutputBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n  ): { masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);\n    return this.decodeBip32Derivation(buf);\n  }\n  setOutputAmount(outputIndex: number, amount: number) {\n    this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));\n  }\n  getOutputAmount(outputIndex: number): number {\n    const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());\n    return unsafeFrom64bitLE(buf);\n  }\n  setOutputScript(outputIndex: number, scriptPubKey: Buffer) {\n    this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);\n  }\n  getOutputScript(outputIndex: number): Buffer {\n    return this.getOutput(outputIndex, psbtOut.SCRIPT, b());\n  }\n  setOutputTapBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n    hashes: Buffer[],\n    fingerprint: Buffer,\n    path: number[],\n  ) {\n    const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);\n    this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);\n  }\n  getOutputTapBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n  ): { hashes: Buffer[]; masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);\n    return this.decodeTapBip32Derivation(buf);\n  }\n\n  deleteInputEntries(inputIndex: number, keyTypes: psbtIn[]) {\n    const map = this.inputMaps[inputIndex];\n    map.forEach((_v, k, m) => {\n      if (this.isKeyType(k, keyTypes)) {\n        m.delete(k);\n      }\n    });\n  }\n\n  copy(to: PsbtV2) {\n    this.copyMap(this.globalMap, to.globalMap);\n    this.copyMaps(this.inputMaps, to.inputMaps);\n    this.copyMaps(this.outputMaps, to.outputMaps);\n  }\n  copyMaps(from: Map<string, Buffer>[], to: Map<string, Buffer>[]) {\n    from.forEach((m, index) => {\n      const to_index = new Map();\n      this.copyMap(m, to_index);\n      to[index] = to_index;\n    });\n  }\n  copyMap(from: Map<string, Buffer>, to: Map<string, Buffer>) {\n    from.forEach((v, k) => to.set(k, Buffer.from(v)));\n  }\n  serialize(): Buffer {\n    const buf = new BufferWriter();\n    buf.writeSlice(Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]));\n    serializeMap(buf, this.globalMap);\n    this.inputMaps.forEach(map => {\n      serializeMap(buf, map);\n    });\n    this.outputMaps.forEach(map => {\n      serializeMap(buf, map);\n    });\n    return buf.buffer();\n  }\n  deserialize(psbt: Buffer) {\n    const buf = new BufferReader(psbt);\n    if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) {\n      throw new Error(\"Invalid magic bytes\");\n    }\n    while (this.readKeyPair(this.globalMap, buf));\n    for (let i = 0; i < this.getGlobalInputCount(); i++) {\n      this.inputMaps[i] = new Map();\n      while (this.readKeyPair(this.inputMaps[i], buf));\n    }\n    for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n      this.outputMaps[i] = new Map();\n      while (this.readKeyPair(this.outputMaps[i], buf));\n    }\n  }\n  private readKeyPair(map: Map<string, Buffer>, buf: BufferReader): boolean {\n    const keyLen = buf.readVarInt();\n    if (keyLen == 0) {\n      return false;\n    }\n    const keyType = buf.readUInt8();\n    const keyData = buf.readSlice(keyLen - 1);\n    const value = buf.readVarSlice();\n    set(map, keyType, keyData, value);\n    return true;\n  }\n  private getKeyDatas(map: Map<string, Buffer>, keyType: KeyType): Buffer[] {\n    const result: Buffer[] = [];\n    map.forEach((_v, k) => {\n      if (this.isKeyType(k, [keyType])) {\n        result.push(Buffer.from(k.substring(2), \"hex\"));\n      }\n    });\n    return result;\n  }\n  private isKeyType(hexKey: string, keyTypes: KeyType[]): boolean {\n    const keyType = Buffer.from(hexKey.substring(0, 2), \"hex\").readUInt8(0);\n    return keyTypes.some(k => k == keyType);\n  }\n  private setGlobal(keyType: KeyType, value: Buffer) {\n    const key = new Key(keyType, Buffer.from([]));\n    this.globalMap.set(key.toString(), value);\n  }\n  private getGlobal(keyType: KeyType): Buffer {\n    return get(this.globalMap, keyType, b(), false)!;\n  }\n  private getGlobalOptional(keyType: KeyType): Buffer | undefined {\n    return get(this.globalMap, keyType, b(), true);\n  }\n  private setInput(index: number, keyType: KeyType, keyData: Buffer, value: Buffer) {\n    set(this.getMap(index, this.inputMaps), keyType, keyData, value);\n  }\n  private getInput(index: number, keyType: KeyType, keyData: Buffer): Buffer {\n    return get(this.inputMaps[index], keyType, keyData, false)!;\n  }\n  private getInputOptional(index: number, keyType: KeyType, keyData: Buffer): Buffer | undefined {\n    return get(this.inputMaps[index], keyType, keyData, true);\n  }\n  private setOutput(index: number, keyType: KeyType, keyData: Buffer, value: Buffer) {\n    set(this.getMap(index, this.outputMaps), keyType, keyData, value);\n  }\n  private getOutput(index: number, keyType: KeyType, keyData: Buffer): Buffer {\n    return get(this.outputMaps[index], keyType, keyData, false)!;\n  }\n  private getMap(index: number, maps: Map<string, Buffer>[]): Map<string, Buffer> {\n    if (maps[index]) {\n      return maps[index];\n    }\n    return (maps[index] = new Map());\n  }\n  private encodeBip32Derivation(masterFingerprint: Buffer, path: number[]) {\n    const buf = new BufferWriter();\n    this.writeBip32Derivation(buf, masterFingerprint, path);\n    return buf.buffer();\n  }\n  private decodeBip32Derivation(buffer: Buffer): {\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const buf = new BufferReader(buffer);\n    return this.readBip32Derivation(buf);\n  }\n  private writeBip32Derivation(buf: BufferWriter, masterFingerprint: Buffer, path: number[]) {\n    buf.writeSlice(masterFingerprint);\n    path.forEach(element => {\n      buf.writeUInt32(element);\n    });\n  }\n  private readBip32Derivation(buf: BufferReader): {\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const masterFingerprint = buf.readSlice(4);\n    const path: number[] = [];\n    while (buf.offset < buf.buffer.length) {\n      path.push(buf.readUInt32());\n    }\n    return { masterFingerprint, path };\n  }\n  private encodeTapBip32Derivation(\n    hashes: Buffer[],\n    masterFingerprint: Buffer,\n    path: number[],\n  ): Buffer {\n    const buf = new BufferWriter();\n    buf.writeVarInt(hashes.length);\n    hashes.forEach(h => {\n      buf.writeSlice(h);\n    });\n    this.writeBip32Derivation(buf, masterFingerprint, path);\n    return buf.buffer();\n  }\n  private decodeTapBip32Derivation(buffer: Buffer): {\n    hashes: Buffer[];\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const buf = new BufferReader(buffer);\n    const hashCount = buf.readVarInt();\n    const hashes: Buffer[] = [];\n    for (let i = 0; i < hashCount; i++) {\n      hashes.push(buf.readSlice(32));\n    }\n    const deriv = this.readBip32Derivation(buf);\n    return { hashes, ...deriv };\n  }\n}\nfunction get(\n  map: Map<string, Buffer>,\n  keyType: KeyType,\n  keyData: Buffer,\n  acceptUndefined: boolean,\n): Buffer | undefined {\n  if (!map) throw Error(\"No such map\");\n  const key = new Key(keyType, keyData);\n  const value = map.get(key.toString());\n  if (!value) {\n    if (acceptUndefined) {\n      return undefined;\n    }\n    throw new NoSuchEntry(key.toString());\n  }\n  // Make sure to return a copy, to protect the underlying data.\n  return Buffer.from(value);\n}\ntype KeyType = number;\n\nclass Key {\n  keyType: KeyType;\n  keyData: Buffer;\n  constructor(keyType: KeyType, keyData: Buffer) {\n    this.keyType = keyType;\n    this.keyData = keyData;\n  }\n  toString(): string {\n    const buf = new BufferWriter();\n    this.toBuffer(buf);\n    return buf.buffer().toString(\"hex\");\n  }\n  serialize(buf: BufferWriter) {\n    buf.writeVarInt(1 + this.keyData.length);\n    this.toBuffer(buf);\n  }\n  private toBuffer(buf: BufferWriter) {\n    buf.writeUInt8(this.keyType);\n    buf.writeSlice(this.keyData);\n  }\n}\nclass KeyPair {\n  key: Key;\n  value: Buffer;\n  constructor(key: Key, value: Buffer) {\n    this.key = key;\n    this.value = value;\n  }\n  serialize(buf: BufferWriter) {\n    this.key.serialize(buf);\n    buf.writeVarSlice(this.value);\n  }\n}\nfunction createKey(buf: Buffer): Key {\n  return new Key(buf.readUInt8(0), buf.slice(1));\n}\nfunction serializeMap(buf: BufferWriter, map: Map<string, Buffer>) {\n  for (const k of map.keys()) {\n    const value = map.get(k)!;\n    const keyPair = new KeyPair(createKey(Buffer.from(k, \"hex\")), value);\n    keyPair.serialize(buf);\n  }\n  buf.writeUInt8(0);\n}\n\nfunction b(): Buffer {\n  return Buffer.from([]);\n}\nfunction set(map: Map<string, Buffer>, keyType: KeyType, keyData: Buffer, value: Buffer) {\n  const key = new Key(keyType, keyData);\n  map.set(key.toString(), value);\n}\nfunction uint32LE(n: number): Buffer {\n  const b = Buffer.alloc(4);\n  b.writeUInt32LE(n, 0);\n  return b;\n}\nfunction uint64LE(n: number): Buffer {\n  return unsafeTo64bitLE(n);\n}\nfunction varint(n: number): Buffer {\n  const b = new BufferWriter();\n  b.writeVarInt(n);\n  return b.buffer();\n}\nfunction fromVarint(buf: Buffer): number {\n  return new BufferReader(buf).readVarInt();\n}\n","import { BufferWriter } from \"../buffertools\";\nimport { psbtIn, PsbtV2 } from \"./psbtv2\";\n\n/**\n * This roughly implements the \"input finalizer\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki). However\n * the role is documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki).\n *\n * Verify that all inputs have a signature, and set inputFinalScriptwitness\n * and/or inputFinalScriptSig depending on the type of the spent outputs. Clean\n * fields that aren't useful anymore, partial signatures, redeem script and\n * derivation paths.\n *\n * @param psbt The psbt with all signatures added as partial sigs, either\n * through PSBT_IN_PARTIAL_SIG or PSBT_IN_TAP_KEY_SIG\n */\nexport function finalize(psbt: PsbtV2): void {\n  // First check that each input has a signature\n  const inputCount = psbt.getGlobalInputCount();\n  for (let i = 0; i < inputCount; i++) {\n    const legacyPubkeys = psbt.getInputKeyDatas(i, psbtIn.PARTIAL_SIG);\n    const taprootSig = psbt.getInputTapKeySig(i);\n    if (legacyPubkeys.length == 0 && !taprootSig) {\n      throw Error(`No signature for input ${i} present`);\n    }\n    if (legacyPubkeys.length > 0) {\n      if (legacyPubkeys.length > 1) {\n        throw Error(`Expected exactly one signature, got ${legacyPubkeys.length}`);\n      }\n      if (taprootSig) {\n        throw Error(\"Both taproot and non-taproot signatures present.\");\n      }\n\n      const isSegwitV0 = !!psbt.getInputWitnessUtxo(i);\n      const redeemScript = psbt.getInputRedeemScript(i);\n      const isWrappedSegwit = !!redeemScript;\n      const signature = psbt.getInputPartialSig(i, legacyPubkeys[0]);\n      if (!signature) throw new Error(\"Expected partial signature for input \" + i);\n      if (isSegwitV0) {\n        const witnessBuf = new BufferWriter();\n        witnessBuf.writeVarInt(2);\n        witnessBuf.writeVarInt(signature.length);\n        witnessBuf.writeSlice(signature);\n        witnessBuf.writeVarInt(legacyPubkeys[0].length);\n        witnessBuf.writeSlice(legacyPubkeys[0]);\n        psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n        if (isWrappedSegwit) {\n          if (!redeemScript || redeemScript.length == 0) {\n            throw new Error(\"Expected non-empty redeemscript. Can't finalize intput \" + i);\n          }\n          const scriptSigBuf = new BufferWriter();\n          // Push redeemScript length\n          scriptSigBuf.writeUInt8(redeemScript.length);\n          scriptSigBuf.writeSlice(redeemScript);\n          psbt.setInputFinalScriptsig(i, scriptSigBuf.buffer());\n        }\n      } else {\n        // Legacy input\n        const scriptSig = new BufferWriter();\n        writePush(scriptSig, signature);\n        writePush(scriptSig, legacyPubkeys[0]);\n        psbt.setInputFinalScriptsig(i, scriptSig.buffer());\n      }\n    } else {\n      // Taproot input\n      const signature = psbt.getInputTapKeySig(i);\n      if (!signature) {\n        throw Error(\"No taproot signature found\");\n      }\n      if (signature.length != 64 && signature.length != 65) {\n        throw Error(\"Unexpected length of schnorr signature.\");\n      }\n      const witnessBuf = new BufferWriter();\n      witnessBuf.writeVarInt(1);\n      witnessBuf.writeVarSlice(signature);\n      psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n    }\n    clearFinalizedInput(psbt, i);\n  }\n}\n\n/**\n * Deletes fields that are no longer neccesary from the psbt.\n *\n * Note, the spec doesn't say anything about removing ouput fields\n * like PSBT_OUT_BIP32_DERIVATION_PATH and others, so we keep them\n * without actually knowing why. I think we should remove them too.\n */\nfunction clearFinalizedInput(psbt: PsbtV2, inputIndex: number) {\n  const keyTypes = [\n    psbtIn.BIP32_DERIVATION,\n    psbtIn.PARTIAL_SIG,\n    psbtIn.TAP_BIP32_DERIVATION,\n    psbtIn.TAP_KEY_SIG,\n  ];\n  const witnessUtxoAvailable = !!psbt.getInputWitnessUtxo(inputIndex);\n  const nonWitnessUtxoAvailable = !!psbt.getInputNonWitnessUtxo(inputIndex);\n  if (witnessUtxoAvailable && nonWitnessUtxoAvailable) {\n    // Remove NON_WITNESS_UTXO for segwit v0 as it's only needed while signing.\n    // Segwit v1 doesn't have NON_WITNESS_UTXO set.\n    // See https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#cite_note-7\n    keyTypes.push(psbtIn.NON_WITNESS_UTXO);\n  }\n  psbt.deleteInputEntries(inputIndex, keyTypes);\n}\n\n/**\n * Writes a script push operation to buf, which looks different\n * depending on the size of the data. See\n * https://en.bitcoin.it/wiki/Script#Constants\n *\n * @param buf the BufferWriter to write to\n * @param data the Buffer to be pushed.\n */\nfunction writePush(buf: BufferWriter, data: Buffer) {\n  if (data.length <= 75) {\n    buf.writeUInt8(data.length);\n  } else if (data.length <= 256) {\n    buf.writeUInt8(76);\n    buf.writeUInt8(data.length);\n  } else if (data.length <= 256 * 256) {\n    buf.writeUInt8(77);\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(data.length, 0);\n    buf.writeSlice(b);\n  }\n  buf.writeSlice(data);\n}\n","export function getVarint(data: Buffer, offset: number): [number, number] {\n  if (data[offset] < 0xfd) {\n    return [data[offset], 1];\n  }\n\n  if (data[offset] === 0xfd) {\n    return [(data[offset + 2] << 8) + data[offset + 1], 3];\n  }\n\n  if (data[offset] === 0xfe) {\n    return [\n      (data[offset + 4] << 24) +\n        (data[offset + 3] << 16) +\n        (data[offset + 2] << 8) +\n        data[offset + 1],\n      5,\n    ];\n  }\n\n  throw new Error(\"getVarint called with unexpected parameters\");\n}\nexport function createVarint(value: number): Buffer {\n  if (value < 0xfd) {\n    const buffer = Buffer.alloc(1);\n    buffer[0] = value;\n    return buffer;\n  }\n\n  if (value <= 0xffff) {\n    const buffer = Buffer.alloc(3);\n    buffer[0] = 0xfd;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    return buffer;\n  }\n\n  const buffer = Buffer.alloc(5);\n  buffer[0] = 0xfe;\n  buffer[1] = value & 0xff;\n  buffer[2] = (value >> 8) & 0xff;\n  buffer[3] = (value >> 16) & 0xff;\n  buffer[4] = (value >> 24) & 0xff;\n  return buffer;\n}\n","import type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\n\n/**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\nexport function serializeTransactionOutputs({ outputs }: Transaction): Buffer {\n  let outputBuffer = Buffer.alloc(0);\n\n  if (typeof outputs !== \"undefined\") {\n    outputBuffer = Buffer.concat([outputBuffer, createVarint(outputs.length)]);\n    outputs.forEach(output => {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        output.amount,\n        createVarint(output.script.length),\n        output.script,\n      ]);\n    });\n  }\n\n  return outputBuffer;\n}\nexport function serializeTransaction(\n  transaction: Transaction,\n  skipWitness: boolean,\n  timestamp?: Buffer,\n  additionals: string[] = [],\n) {\n  const isDecred = additionals.includes(\"decred\");\n  const isZcash = additionals.includes(\"zcash\");\n  const isBech32 = additionals.includes(\"bech32\");\n  let inputBuffer = Buffer.alloc(0);\n  const useWitness = typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n  transaction.inputs.forEach(input => {\n    inputBuffer =\n      isDecred || isBech32\n        ? Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            Buffer.from([0x00]), //tree\n            input.sequence,\n          ])\n        : Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            createVarint(input.script.length),\n            input.script,\n            input.sequence,\n          ]);\n  });\n  let outputBuffer = serializeTransactionOutputs(transaction);\n\n  if (typeof transaction.outputs !== \"undefined\" && typeof transaction.locktime !== \"undefined\") {\n    outputBuffer = Buffer.concat([\n      outputBuffer,\n      (useWitness && transaction.witness) || Buffer.alloc(0),\n      transaction.locktime,\n      transaction.nExpiryHeight || Buffer.alloc(0),\n      transaction.extraData || Buffer.alloc(0),\n    ]);\n  }\n  // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n  if (isZcash) {\n    return Buffer.concat([\n      transaction.version,\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      Buffer.from([0xb4, 0xd0, 0xd6, 0xc2]), // Zcash Consensus Branch ID: 0xC2D6D0B4 refer to https://z.cash/upgrade/nu5/\n      transaction.locktime || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n      transaction.nExpiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n      useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n      createVarint(transaction.inputs.length),\n      inputBuffer,\n      outputBuffer,\n    ]);\n  }\n  return Buffer.concat([\n    transaction.version,\n    timestamp ? timestamp : Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n    inputBuffer,\n    outputBuffer,\n  ]);\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pointCompress } from \"tiny-secp256k1\";\nimport {\n  getXpubComponents,\n  hardenedPathOf,\n  pathArrayToString,\n  pathStringToArray,\n  pubkeyFromXpub,\n} from \"./bip32\";\nimport { BufferReader } from \"./buffertools\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport {\n  AccountType,\n  p2pkh,\n  p2tr,\n  p2wpkh,\n  p2wpkhWrapped,\n  SpendingCondition,\n} from \"./newops/accounttype\";\nimport { AppClient as Client } from \"./newops/appClient\";\nimport { createKey, DefaultDescriptorTemplate, WalletPolicy } from \"./newops/policy\";\nimport { extract } from \"./newops/psbtExtractor\";\nimport { finalize } from \"./newops/psbtFinalizer\";\nimport { psbtIn, PsbtV2 } from \"./newops/psbtv2\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport type { Transaction } from \"./types\";\n\n/**\n * @class BtcNew\n * @description This class implements the same interface as BtcOld (formerly\n * named Btc), but interacts with Bitcoin hardware app version 2.1.0+\n * which uses a totally new APDU protocol. This new\n * protocol is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n *\n * Since the interface must remain compatible with BtcOld, the methods\n * of this class are quite clunky, because it needs to adapt legacy\n * input data into the PSBT process. In the future, a new interface should\n * be developed that exposes PSBT to the outer world, which would render\n * a much cleaner implementation.\n *\n */\nexport default class BtcNew {\n  constructor(private client: Client) {}\n\n  /**\n   * This is a new method that allow users to get an xpub at a standard path.\n   * Standard paths are described at\n   * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#description\n   *\n   * This boils down to paths (N=0 for Bitcoin, N=1 for Testnet):\n   * M/44'/N'/x'/**\n   * M/48'/N'/x'/y'/**\n   * M/49'/N'/x'/**\n   * M/84'/N'/x'/**\n   * M/86'/N'/x'/**\n   *\n   * The method was added because of added security in the hardware app v2+. The\n   * new hardware app will allow export of any xpub up to and including the\n   * deepest hardened key of standard derivation paths, whereas the old app\n   * would allow export of any key.\n   *\n   * This caused an issue for callers of this class, who only had\n   * getWalletPublicKey() to call which means they have to constuct xpub\n   * themselves:\n   *\n   * Suppose a user of this class wants to create an account xpub on a standard\n   * path, M/44'/0'/Z'. The user must get the parent key fingerprint (see BIP32)\n   * by requesting the parent key M/44'/0'. The new app won't allow that, because\n   * it only allows exporting deepest level hardened path. So the options are to\n   * allow requesting M/44'/0' from the app, or to add a new function\n   * \"getWalletXpub\".\n   *\n   * We opted for adding a new function, which can greatly simplify client code.\n   */\n  async getWalletXpub({\n    path,\n    xpubVersion,\n  }: {\n    path: string;\n    xpubVersion: number;\n  }): Promise<string> {\n    const pathElements: number[] = pathStringToArray(path);\n    const xpub = await this.client.getExtendedPubkey(false, pathElements);\n    const xpubComponents = getXpubComponents(xpub);\n    if (xpubComponents.version != xpubVersion) {\n      throw new Error(\n        `Expected xpub version ${xpubVersion} doesn't match the xpub version from the device ${xpubComponents.version}`,\n      );\n    }\n    return xpub;\n  }\n\n  /**\n   * This method returns a public key, a bitcoin address, and and a chaincode\n   * for a specific derivation path.\n   *\n   * Limitation: If the path is not a leaf node of a standard path, the address\n   * will be the empty string \"\", see this.getWalletAddress() for details.\n   */\n  async getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    if (!isPathNormal(path)) {\n      throw Error(`non-standard path: ${path}`);\n    }\n    const pathElements: number[] = pathStringToArray(path);\n    const xpub = await this.client.getExtendedPubkey(false, pathElements);\n\n    const display = opts?.verify ?? false;\n\n    const address = await this.getWalletAddress(\n      pathElements,\n      descrTemplFrom(opts?.format ?? \"legacy\"),\n      display,\n    );\n    const components = getXpubComponents(xpub);\n    const uncompressedPubkey = Buffer.from(pointCompress(components.pubkey, false));\n    return {\n      publicKey: uncompressedPubkey.toString(\"hex\"),\n      bitcoinAddress: address,\n      chainCode: components.chaincode.toString(\"hex\"),\n    };\n  }\n\n  /**\n   * Get an address for the specified path.\n   *\n   * If display is true, we must get the address from the device, which would require\n   * us to determine WalletPolicy. This requires two *extra* queries to the device, one\n   * for the account xpub and one for master key fingerprint.\n   *\n   * If display is false we *could* generate the address ourselves, but chose to\n   * get it from the device to save development time. However, it shouldn't take\n   * too much time to implement local address generation.\n   *\n   * Moreover, if the path is not for a leaf, ie accountPath+/X/Y, there is no\n   * way to get the address from the device. In this case we have to create it\n   * ourselves, but we don't at this time, and instead return an empty (\"\") address.\n   */\n  private async getWalletAddress(\n    pathElements: number[],\n    descrTempl: DefaultDescriptorTemplate,\n    display: boolean,\n  ): Promise<string> {\n    const accountPath = hardenedPathOf(pathElements);\n    if (accountPath.length + 2 != pathElements.length) {\n      return \"\";\n    }\n    const accountXpub = await this.client.getExtendedPubkey(false, accountPath);\n    const masterFingerprint = await this.client.getMasterFingerprint();\n    const policy = new WalletPolicy(\n      descrTempl,\n      createKey(masterFingerprint, accountPath, accountXpub),\n    );\n    const changeAndIndex = pathElements.slice(-2, pathElements.length);\n    return this.client.getWalletAddress(\n      policy,\n      Buffer.alloc(32, 0),\n      changeAndIndex[0],\n      changeAndIndex[1],\n      display,\n    );\n  }\n\n  /**\n   * Build and sign a transaction. See Btc.createPaymentTransaction for\n   * details on how to use this method.\n   *\n   * This method will convert the legacy arguments, CreateTransactionArg, into\n   * a psbt which is finally signed and finalized, and the extracted fully signed\n   * transaction is returned.\n   */\n  async createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    const inputCount = arg.inputs.length;\n    if (inputCount == 0) {\n      throw Error(\"No inputs\");\n    }\n    const psbt = new PsbtV2();\n    // The master fingerprint is needed when adding BIP32 derivation paths on\n    // the psbt.\n    const masterFp = await this.client.getMasterFingerprint();\n\n    const accountType = accountTypeFromArg(arg, psbt, masterFp);\n\n    if (arg.lockTime != undefined) {\n      // The signer will assume locktime 0 if unset\n      psbt.setGlobalFallbackLocktime(arg.lockTime);\n    }\n    psbt.setGlobalInputCount(inputCount);\n    psbt.setGlobalPsbtVersion(2);\n    psbt.setGlobalTxVersion(2);\n\n    let notifyCount = 0;\n    const progress = () => {\n      if (!arg.onDeviceStreaming) return;\n      arg.onDeviceStreaming({\n        total: 2 * inputCount,\n        index: notifyCount,\n        progress: ++notifyCount / (2 * inputCount),\n      });\n    };\n\n    let accountXpub = \"\";\n    let accountPath: number[] = [];\n    for (let i = 0; i < inputCount; i++) {\n      progress();\n      const pathElems: number[] = pathStringToArray(arg.associatedKeysets[i]);\n      if (accountXpub == \"\") {\n        // We assume all inputs belong to the same account so we set\n        // the account xpub and path based on the first input.\n        accountPath = pathElems.slice(0, -2);\n        accountXpub = await this.client.getExtendedPubkey(false, accountPath);\n      }\n      await this.setInput(\n        psbt,\n        i,\n        arg.inputs[i],\n        pathElems,\n        accountType,\n        masterFp,\n        arg.sigHashType,\n      );\n    }\n\n    const outputsConcat = Buffer.from(arg.outputScriptHex, \"hex\");\n    const outputsBufferReader = new BufferReader(outputsConcat);\n    const outputCount = outputsBufferReader.readVarInt();\n    psbt.setGlobalOutputCount(outputCount);\n    const changeData = await this.outputScriptAt(accountPath, accountType, arg.changePath);\n    // If the caller supplied a changePath, we must make sure there actually is\n    // a change output. If no change output found, we'll throw an error.\n    let changeFound = !changeData;\n    for (let i = 0; i < outputCount; i++) {\n      const amount = Number(outputsBufferReader.readUInt64());\n      const outputScript = outputsBufferReader.readVarSlice();\n      psbt.setOutputAmount(i, amount);\n      psbt.setOutputScript(i, outputScript);\n\n      // We won't know if we're paying to ourselves, because there's no\n      // information in arg to support multiple \"change paths\". One exception is\n      // if there are multiple outputs to the change address.\n      const isChange = changeData && outputScript.equals(changeData?.cond.scriptPubKey);\n      if (isChange) {\n        changeFound = true;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const changePath = pathStringToArray(arg.changePath!);\n        const pubkey = changeData.pubkey;\n\n        accountType.setOwnOutput(i, changeData.cond, [pubkey], [changePath]);\n      }\n    }\n    if (!changeFound) {\n      throw new Error(\n        \"Change script not found among outputs! \" + changeData?.cond.scriptPubKey.toString(\"hex\"),\n      );\n    }\n\n    const key = createKey(masterFp, accountPath, accountXpub);\n    const p = new WalletPolicy(accountType.getDescriptorTemplate(), key);\n    // This is cheating, because it's not actually requested on the\n    // device yet, but it will be, soonish.\n    if (arg.onDeviceSignatureRequested) arg.onDeviceSignatureRequested();\n\n    let firstSigned = false;\n    // This callback will be called once for each signature yielded.\n    const progressCallback = () => {\n      if (!firstSigned) {\n        firstSigned = true;\n        arg.onDeviceSignatureGranted && arg.onDeviceSignatureGranted();\n      }\n      progress();\n    };\n\n    await this.signPsbt(psbt, p, progressCallback);\n    finalize(psbt);\n    const serializedTx = extract(psbt);\n    return serializedTx.toString(\"hex\");\n  }\n\n  /**\n   * Signs an arbitrary hex-formatted message with the private key at\n   * the provided derivation path according to the Bitcoin Signature format\n   * and returns v, r, s.\n   */\n  async signMessage({ path, messageHex }: { path: string; messageHex: string }): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    const pathElements: number[] = pathStringToArray(path);\n    const message = Buffer.from(messageHex, \"hex\");\n    const sig = await this.client.signMessage(message, pathElements);\n    const buf = Buffer.from(sig, \"base64\");\n\n    const v = buf.readUInt8() - 27 - 4;\n    const r = buf.slice(1, 33).toString(\"hex\");\n    const s = buf.slice(33, 65).toString(\"hex\");\n\n    return {\n      v,\n      r,\n      s,\n    };\n  }\n\n  /**\n   * Calculates an output script along with public key and possible redeemScript\n   * from a path and accountType. The accountPath must be a prefix of path.\n   *\n   * @returns an object with output script (property \"script\"), redeemScript (if\n   * wrapped p2wpkh), and pubkey at provided path. The values of these three\n   * properties depend on the accountType used.\n   */\n  private async outputScriptAt(\n    accountPath: number[],\n    accountType: AccountType,\n    path: string | undefined,\n  ): Promise<{ cond: SpendingCondition; pubkey: Buffer } | undefined> {\n    if (!path) return undefined;\n    const pathElems = pathStringToArray(path);\n    // Make sure path is in our account, otherwise something fishy is probably\n    // going on.\n    for (let i = 0; i < accountPath.length; i++) {\n      if (accountPath[i] != pathElems[i]) {\n        throw new Error(`Path ${path} not in account ${pathArrayToString(accountPath)}`);\n      }\n    }\n    const xpub = await this.client.getExtendedPubkey(false, pathElems);\n    const pubkey = pubkeyFromXpub(xpub);\n    const cond = accountType.spendingCondition([pubkey]);\n    return { cond, pubkey };\n  }\n\n  /**\n   * Adds relevant data about an input to the psbt. This includes sequence,\n   * previous txid, output index, spent UTXO, redeem script for wrapped p2wpkh,\n   * public key and its derivation path.\n   */\n  private async setInput(\n    psbt: PsbtV2,\n    i: number,\n    input: [Transaction, number, string | null | undefined, number | null | undefined],\n    pathElements: number[],\n    accountType: AccountType,\n    masterFP: Buffer,\n    sigHashType?: number,\n  ): Promise<void> {\n    const inputTx = input[0];\n    const spentOutputIndex = input[1];\n    // redeemScript will be null for wrapped p2wpkh, we need to create it\n    // ourselves. But if set, it should be used.\n    const redeemScript = input[2] ? Buffer.from(input[2], \"hex\") : undefined;\n    const sequence = input[3];\n    if (sequence != undefined) {\n      psbt.setInputSequence(i, sequence);\n    }\n    if (sigHashType != undefined) {\n      psbt.setInputSighashType(i, sigHashType);\n    }\n    const inputTxBuffer = serializeTransaction(inputTx, true);\n    const inputTxid = crypto.hash256(inputTxBuffer);\n    const xpubBase58 = await this.client.getExtendedPubkey(false, pathElements);\n\n    const pubkey = pubkeyFromXpub(xpubBase58);\n    if (!inputTx.outputs) throw Error(\"Missing outputs array in transaction to sign\");\n    const spentTxOutput = inputTx.outputs[spentOutputIndex];\n    const spendCondition: SpendingCondition = {\n      scriptPubKey: spentTxOutput.script,\n      redeemScript: redeemScript,\n    };\n    const spentOutput = { cond: spendCondition, amount: spentTxOutput.amount };\n    accountType.setInput(i, inputTxBuffer, spentOutput, [pubkey], [pathElements]);\n\n    psbt.setInputPreviousTxId(i, inputTxid);\n    psbt.setInputOutputIndex(i, spentOutputIndex);\n  }\n\n  /**\n   * This implements the \"Signer\" role of the BIP370 transaction signing\n   * process.\n   *\n   * It ssks the hardware device to sign the a psbt using the specified wallet\n   * policy. This method assumes BIP32 derived keys are used for all inputs, see\n   * comment in-line. The signatures returned from the hardware device is added\n   * to the appropriate input fields of the PSBT.\n   */\n  private async signPsbt(\n    psbt: PsbtV2,\n    walletPolicy: WalletPolicy,\n    progressCallback: () => void,\n  ): Promise<void> {\n    const sigs: Map<number, Buffer> = await this.client.signPsbt(\n      psbt,\n      walletPolicy,\n      Buffer.alloc(32, 0),\n      progressCallback,\n    );\n    sigs.forEach((v, k) => {\n      // Note: Looking at BIP32 derivation does not work in the generic case,\n      // since some inputs might not have a BIP32-derived pubkey.\n      const pubkeys = psbt.getInputKeyDatas(k, psbtIn.BIP32_DERIVATION);\n      let pubkey;\n      if (pubkeys.length != 1) {\n        // No legacy BIP32_DERIVATION, assume we're using taproot.\n        pubkey = psbt.getInputKeyDatas(k, psbtIn.TAP_BIP32_DERIVATION);\n        if (pubkey.length == 0) {\n          throw Error(`Missing pubkey derivation for input ${k}`);\n        }\n        psbt.setInputTapKeySig(k, v);\n      } else {\n        pubkey = pubkeys[0];\n        psbt.setInputPartialSig(k, pubkey, v);\n      }\n    });\n  }\n}\n\n/**\n * This function returns a descriptor template based on the address format.\n * See https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md for details of\n * the bitcoin descriptor template.\n */\nfunction descrTemplFrom(addressFormat: AddressFormat): DefaultDescriptorTemplate {\n  if (addressFormat == \"legacy\") return \"pkh(@0)\";\n  if (addressFormat == \"p2sh\") return \"sh(wpkh(@0))\";\n  if (addressFormat == \"bech32\") return \"wpkh(@0)\";\n  if (addressFormat == \"bech32m\") return \"tr(@0)\";\n  throw new Error(\"Unsupported address format \" + addressFormat);\n}\n\nfunction accountTypeFromArg(\n  arg: CreateTransactionArg,\n  psbt: PsbtV2,\n  masterFp: Buffer,\n): AccountType {\n  if (arg.additionals.includes(\"bech32m\")) return new p2tr(psbt, masterFp);\n  if (arg.additionals.includes(\"bech32\")) return new p2wpkh(psbt, masterFp);\n  if (arg.segwit) return new p2wpkhWrapped(psbt, masterFp);\n  return new p2pkh(psbt, masterFp);\n}\n\n/*\n  The new protocol only allows standard path.\n  Standard paths are (currently):\n  M/44'/(1|0|88)'/X'\n  M/49'/(1|0|88)'/X'\n  M/84'/(1|0|88)'/X'\n  M/86'/(1|0|88)'/X'\n  M/48'/(1|0|88)'/X'/Y'\n  followed by \"\", \"(0|1)\", or \"(0|1)/b\", where a and b are \n  non-hardened. For example, the following paths are standard\n  M/48'/1'/99'/7'\n  M/86'/1'/99'/0\n  M/48'/0'/99'/7'/1/17\n  The following paths are non-standard\n  M/48'/0'/99'           // Not deepest hardened path\n  M/48'/0'/99'/7'/1/17/2 // Too many non-hardened derivation steps\n  M/199'/0'/1'/0/88      // Not a known purpose 199\n  M/86'/1'/99'/2         // Change path item must be 0 or 1\n\n  Useful resource on derivation paths: https://learnmeabitcoin.com/technical/derivation-paths\n*/\n\n//path is not deepest hardened node of a standard path or deeper, use BtcOld\nconst H = 0x80000000; //HARDENED from bip32\n\nconst VALID_COIN_TYPES = [\n  0, // Bitcoin\n  1, // Bitcoin (Testnet)\n  88, // Qtum\n];\n\nconst VALID_SINGLE_SIG_PURPOSES = [\n  44, // BIP44 - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\n  49, // BIP49 - https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki\n  84, // BIP84 - https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki\n  86, // BIP86 - https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki\n];\n\nconst VALID_MULTISIG_PURPOSES = [\n  48, // BIP48 - https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki\n];\n\nconst hard = (n: number) => n >= H;\nconst soft = (n: number | undefined) => n === undefined || n < H;\nconst change = (n: number | undefined) => n === undefined || n === 0 || n === 1;\n\nconst validCoinPathPartsSet = new Set(VALID_COIN_TYPES.map(t => t + H));\nconst validSingleSigPurposePathPartsSet = new Set(VALID_SINGLE_SIG_PURPOSES.map(t => t + H));\nconst validMultiSigPurposePathPartsSet = new Set(VALID_MULTISIG_PURPOSES.map(t => t + H));\n\nexport function isPathNormal(path: string): boolean {\n  const pathElems = pathStringToArray(path);\n\n  // Single sig\n  if (\n    pathElems.length >= 3 &&\n    pathElems.length <= 5 &&\n    validSingleSigPurposePathPartsSet.has(pathElems[0]) &&\n    validCoinPathPartsSet.has(pathElems[1]) &&\n    hard(pathElems[2]) &&\n    change(pathElems[3]) &&\n    soft(pathElems[4])\n  ) {\n    return true;\n  }\n\n  // Multi sig\n  if (\n    pathElems.length >= 4 &&\n    pathElems.length <= 6 &&\n    validMultiSigPurposePathPartsSet.has(pathElems[0]) &&\n    validCoinPathPartsSet.has(pathElems[1]) &&\n    hard(pathElems[2]) &&\n    hard(pathElems[3]) &&\n    change(pathElems[4]) &&\n    soft(pathElems[5])\n  ) {\n    return true;\n  }\n  return false;\n}\n","import { BufferWriter } from \"../buffertools\";\nimport { PsbtV2 } from \"./psbtv2\";\n\n/**\n * This implements the \"Transaction Extractor\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#transaction-extractor). However\n * the role is partially documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#transaction-extractor).\n */\nexport function extract(psbt: PsbtV2): Buffer {\n  const tx = new BufferWriter();\n  tx.writeUInt32(psbt.getGlobalTxVersion());\n\n  const isSegwit = !!psbt.getInputWitnessUtxo(0);\n  if (isSegwit) {\n    tx.writeSlice(Buffer.from([0, 1]));\n  }\n  const inputCount = psbt.getGlobalInputCount();\n  tx.writeVarInt(inputCount);\n  const witnessWriter = new BufferWriter();\n  for (let i = 0; i < inputCount; i++) {\n    tx.writeSlice(psbt.getInputPreviousTxid(i));\n    tx.writeUInt32(psbt.getInputOutputIndex(i));\n    tx.writeVarSlice(psbt.getInputFinalScriptsig(i) ?? Buffer.from([]));\n    tx.writeUInt32(psbt.getInputSequence(i));\n    if (isSegwit) {\n      witnessWriter.writeSlice(psbt.getInputFinalScriptwitness(i));\n    }\n  }\n  const outputCount = psbt.getGlobalOutputCount();\n  tx.writeVarInt(outputCount);\n  for (let i = 0; i < outputCount; i++) {\n    tx.writeUInt64(psbt.getOutputAmount(i));\n    tx.writeVarSlice(psbt.getOutputScript(i));\n  }\n  tx.writeSlice(witnessWriter.buffer());\n  tx.writeUInt32(psbt.getGlobalFallbackLocktime() ?? 0);\n  return tx.buffer();\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\n\n/**\n * address format is one of legacy | p2sh | bech32 | bech32m | cashaddr\n */\nexport type AddressFormat = \"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\";\nconst addressFormatMap = {\n  legacy: 0,\n  p2sh: 1,\n  bech32: 2,\n  cashaddr: 3,\n};\nexport async function getWalletPublicKey(\n  transport: Transport,\n  options: {\n    path: string;\n    verify?: boolean;\n    format?: AddressFormat;\n  },\n): Promise<{\n  publicKey: string;\n  bitcoinAddress: string;\n  chainCode: string;\n}> {\n  const { path, verify, format } = {\n    verify: false,\n    format: \"legacy\",\n    ...options,\n  };\n\n  if (!(format in addressFormatMap)) {\n    throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n  }\n\n  const buffer = bip32asBuffer(path);\n  const p1 = verify ? 1 : 0;\n  const p2 = addressFormatMap[format];\n  const response = await transport.send(0xe0, 0x40, p1, p2, buffer);\n  const publicKeyLength = response[0];\n  const addressLength = response[1 + publicKeyLength];\n  const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n  const bitcoinAddress = response\n    .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n    .toString(\"ascii\");\n  const chainCode = response\n    .slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32)\n    .toString(\"hex\");\n  return {\n    publicKey,\n    bitcoinAddress,\n    chainCode,\n  };\n}\n","import invariant from \"invariant\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nimport { createVarint } from \"./varint\";\nexport async function getTrustedInputRaw(\n  transport: Transport,\n  transactionData: Buffer,\n  indexLookup?: number | null | undefined,\n): Promise<string> {\n  let data;\n  let firstRound = false;\n\n  if (typeof indexLookup === \"number\") {\n    firstRound = true;\n    const prefix = Buffer.alloc(4);\n    prefix.writeUInt32BE(indexLookup, 0);\n    data = Buffer.concat([prefix, transactionData], transactionData.length + 4);\n  } else {\n    data = transactionData;\n  }\n\n  const trustedInput = await transport.send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data);\n  const res = trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\");\n  return res;\n}\nexport async function getTrustedInput(\n  transport: Transport,\n  indexLookup: number,\n  transaction: Transaction,\n  additionals: Array<string> = [],\n): Promise<string> {\n  const { version, inputs, outputs, locktime, nExpiryHeight, extraData } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n  const isXST = additionals.includes(\"stealthcoin\");\n\n  const processScriptBlocks = async (script, sequence?: Buffer) => {\n    const seq = sequence || Buffer.alloc(0);\n    const scriptBlocks: Buffer[] = [];\n    let offset = 0;\n\n    while (offset !== script.length) {\n      const blockSize =\n        script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : script.length - offset;\n\n      if (offset + blockSize !== script.length) {\n        scriptBlocks.push(script.slice(offset, offset + blockSize));\n      } else {\n        scriptBlocks.push(Buffer.concat([script.slice(offset, offset + blockSize), seq]));\n      }\n\n      offset += blockSize;\n    }\n\n    // Handle case when no script length: we still want to pass the sequence\n    // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n    if (script.length === 0) {\n      scriptBlocks.push(seq);\n    }\n\n    let res;\n\n    for (const scriptBlock of scriptBlocks) {\n      res = await getTrustedInputRaw(transport, scriptBlock);\n    }\n\n    return res;\n  };\n\n  const processWholeScriptBlock = block => getTrustedInputRaw(transport, block);\n\n  await getTrustedInputRaw(\n    transport,\n    Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      createVarint(inputs.length),\n    ]),\n    indexLookup,\n  );\n\n  for (const input of inputs) {\n    const isXSTV2 = isXST && Buffer.compare(version, Buffer.from([0x02, 0x00, 0x00, 0x00])) === 0;\n    const treeField = isDecred ? input.tree || Buffer.from([0x00]) : Buffer.alloc(0);\n    const data = Buffer.concat([\n      input.prevout,\n      treeField,\n      isXSTV2 ? Buffer.from([0x00]) : createVarint(input.script.length),\n    ]);\n    await getTrustedInputRaw(transport, data);\n    // iteration (eachSeries) ended\n    // TODO notify progress\n    // deferred.notify(\"input\");\n    // Reference: https://github.com/StealthSend/Stealth/commit/5be35d6c2c500b32ed82e5d6913d66d18a4b0a7f#diff-e8db9b851adc2422aadfffca88f14c91R566\n    await (isDecred\n      ? processWholeScriptBlock(Buffer.concat([input.script, input.sequence]))\n      : isXSTV2\n        ? processWholeScriptBlock(input.sequence)\n        : processScriptBlocks(input.script, input.sequence));\n  }\n\n  await getTrustedInputRaw(transport, createVarint(outputs.length));\n\n  for (const output of outputs) {\n    const data = Buffer.concat([\n      output.amount,\n      isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n      createVarint(output.script.length),\n      output.script,\n    ]);\n    await getTrustedInputRaw(transport, data);\n  }\n\n  const endData: Buffer[] = [];\n\n  if (nExpiryHeight && nExpiryHeight.length > 0) {\n    endData.push(nExpiryHeight);\n  }\n\n  if (extraData && extraData.length > 0) {\n    endData.push(extraData);\n  }\n\n  let extraPart;\n\n  if (endData.length) {\n    const data = Buffer.concat(endData);\n    extraPart = isDecred ? data : Buffer.concat([createVarint(data.length), data]);\n  }\n\n  const res = await processScriptBlocks(Buffer.concat([locktime, extraPart || Buffer.alloc(0)]));\n  invariant(res, \"missing result in processScriptBlocks\");\n  return res;\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function startUntrustedHashTransactionInputRaw(\n  transport: Transport,\n  newTransaction: boolean,\n  firstRound: boolean,\n  transactionData: Buffer,\n  bip143 = false,\n  overwinter = false,\n  additionals: Array<string> = [],\n): Promise<Buffer> {\n  const p2 = additionals.includes(\"cashaddr\")\n    ? 0x03\n    : bip143\n      ? additionals.includes(\"sapling\")\n        ? 0x05\n        : overwinter\n          ? 0x04\n          : 0x02\n      : 0x00;\n  return transport.send(\n    0xe0,\n    0x44,\n    firstRound ? 0x00 : 0x80,\n    newTransaction ? p2 : 0x80,\n    transactionData,\n  );\n}\nexport async function startUntrustedHashTransactionInput(\n  transport: Transport,\n  newTransaction: boolean,\n  transaction: Transaction,\n  inputs: Array<{\n    trustedInput: boolean;\n    value: Buffer;\n  }>,\n  bip143 = false,\n  overwinter = false,\n  additionals: Array<string> = [],\n  useTrustedInputForSegwit = false,\n): Promise<any> {\n  let data = Buffer.concat([\n    transaction.version,\n    transaction.timestamp || Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n  ]);\n  await startUntrustedHashTransactionInputRaw(\n    transport,\n    newTransaction,\n    true,\n    data,\n    bip143,\n    overwinter,\n    additionals,\n  );\n  let i = 0;\n  const isDecred = additionals.includes(\"decred\");\n\n  for (const input of transaction.inputs) {\n    let prefix;\n    const inputValue = inputs[i].value;\n\n    if (bip143) {\n      if (useTrustedInputForSegwit && inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputValue.length]);\n      } else {\n        prefix = Buffer.from([0x02]);\n      }\n    } else {\n      if (inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputs[i].value.length]);\n      } else {\n        prefix = Buffer.from([0x00]);\n      }\n    }\n\n    data = Buffer.concat([\n      prefix,\n      inputValue,\n      isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n      createVarint(input.script.length),\n    ]);\n    await startUntrustedHashTransactionInputRaw(\n      transport,\n      newTransaction,\n      false,\n      data,\n      bip143,\n      overwinter,\n      additionals,\n    );\n    const scriptBlocks: Buffer[] = [];\n    let offset = 0;\n\n    if (input.script.length === 0) {\n      scriptBlocks.push(input.sequence);\n    } else {\n      while (offset !== input.script.length) {\n        const blockSize =\n          input.script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : input.script.length - offset;\n\n        if (offset + blockSize !== input.script.length) {\n          scriptBlocks.push(input.script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([input.script.slice(offset, offset + blockSize), input.sequence]),\n          );\n        }\n\n        offset += blockSize;\n      }\n    }\n\n    for (const scriptBlock of scriptBlocks) {\n      await startUntrustedHashTransactionInputRaw(\n        transport,\n        newTransaction,\n        false,\n        scriptBlock,\n        bip143,\n        overwinter,\n        additionals,\n      );\n    }\n\n    i++;\n  }\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport shajs from \"sha.js\";\nimport type { Transaction } from \"./types\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nexport function getTrustedInputBIP143(\n  transport: Transport,\n  indexLookup: number,\n  transaction: Transaction,\n  additionals: Array<string> = [],\n): string {\n  if (!transaction) {\n    throw new Error(\"getTrustedInputBIP143: missing tx\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n\n  if (isDecred) {\n    throw new Error(\"Decred does not implement BIP143\");\n  }\n\n  let hash = shajs(\"sha256\")\n    .update(shajs(\"sha256\").update(serializeTransaction(transaction, true)).digest())\n    .digest();\n  const data = Buffer.alloc(4);\n  data.writeUInt32LE(indexLookup, 0);\n  const { outputs, locktime } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n  }\n\n  if (!outputs[indexLookup]) {\n    throw new Error(\"getTrustedInputBIP143: wrong index\");\n  }\n\n  hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n  return hash.toString(\"hex\");\n}\n","export function compressPublicKey(publicKey: Buffer): Buffer {\n  const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n  const prefixBuffer = Buffer.alloc(1);\n  prefixBuffer[0] = prefix;\n  return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\nexport function signTransaction(\n  transport: Transport,\n  path: string,\n  lockTime: number,\n  sigHashType: number,\n  expiryHeight?: Buffer,\n  additionals: Array<string> = [],\n): Promise<Buffer> {\n  const isDecred = additionals.includes(\"decred\");\n  const pathsBuffer = bip32asBuffer(path);\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32BE(lockTime, 0);\n  let buffer = isDecred\n    ? Buffer.concat([\n        pathsBuffer,\n        lockTimeBuffer,\n        expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n        Buffer.from([sigHashType]),\n      ])\n    : Buffer.concat([pathsBuffer, Buffer.from([0x00]), lockTimeBuffer, Buffer.from([sigHashType])]);\n\n  if (expiryHeight && !isDecred) {\n    buffer = Buffer.concat([buffer, expiryHeight]);\n  }\n\n  return transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n    if (result.length > 0) {\n      result[0] = 0x30;\n      return result.slice(0, result.length - 2);\n    }\n\n    return result;\n  });\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function provideOutputFullChangePath(transport: Transport, path: string): Promise<Buffer> {\n  const buffer = bip32asBuffer(path);\n  return transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n}\nexport async function hashOutputFull(\n  transport: Transport,\n  outputScript: Buffer,\n  additionals: Array<string> = [],\n): Promise<Buffer | void> {\n  let offset = 0;\n  const p1 = Number(0x80);\n  const isDecred = additionals.includes(\"decred\");\n\n  ///WARNING: Decred works only with one call (without chunking)\n  //TODO: test without this for Decred\n  if (isDecred) {\n    return transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n  }\n\n  while (offset < outputScript.length) {\n    const blockSize =\n      offset + MAX_SCRIPT_BLOCK >= outputScript.length\n        ? outputScript.length - offset\n        : MAX_SCRIPT_BLOCK;\n    const p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n    const data = outputScript.slice(offset, offset + blockSize);\n    await transport.send(0xe0, 0x4a, p1, 0x00, data);\n    offset += blockSize;\n  }\n}\n","import invariant from \"invariant\";\nimport Transport from \"@ledgerhq/hw-transport\";\n\nexport type AppAndVersion = {\n  name: string;\n  version: string;\n  flags: number | Buffer;\n};\n\nexport const getAppAndVersion = async (transport: Transport): Promise<AppAndVersion> => {\n  const r = await transport.send(0xb0, 0x01, 0x00, 0x00);\n  let i = 0;\n  const format = r[i++];\n  invariant(format === 1, \"getAppAndVersion: format not supported\");\n  const nameLength = r[i++];\n  const name = r.slice(i, (i += nameLength)).toString(\"ascii\");\n  const versionLength = r[i++];\n  const version = r.slice(i, (i += versionLength)).toString(\"ascii\");\n  const flagLength = r[i++];\n  const flags = r.slice(i, (i += flagLength));\n  return {\n    name,\n    version,\n    flags,\n  };\n};\n\nexport const checkIsBtcLegacy = async (transport: Transport): Promise<boolean> => {\n  try {\n    // Call old btc API, it will throw an exception with new btc app. It is a workaround to differentiate new/old btc nano app\n    await transport.send(0xe0, 0xc4, 0, 0);\n  } catch (e: unknown) {\n    return false;\n  }\n  return true;\n};\n","import { log } from \"@ledgerhq/logs\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { hashPublicKey } from \"./hashPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { compressPublicKey } from \"./compressPublicKey\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull, provideOutputFullChangePath } from \"./finalizeInput\";\nimport { getAppAndVersion } from \"./getAppAndVersion\";\nimport type { TransactionOutput, Transaction } from \"./types\";\nimport {\n  DEFAULT_LOCKTIME,\n  DEFAULT_SEQUENCE,\n  SIGHASH_ALL,\n  OP_DUP,\n  OP_HASH160,\n  HASH_SIZE,\n  OP_EQUALVERIFY,\n  OP_CHECKSIG,\n} from \"./constants\";\nimport { shouldUseTrustedInputForSegwit } from \"./shouldUseTrustedInputForSegwit\";\nexport type { AddressFormat };\nconst defaultsSignTransaction = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  additionals: [],\n  onDeviceStreaming: _e => {},\n  onDeviceSignatureGranted: () => {},\n  onDeviceSignatureRequested: () => {},\n};\n\n/**\n *\n */\nexport type CreateTransactionArg = {\n  inputs: Array<[Transaction, number, string | null | undefined, number | null | undefined]>;\n  associatedKeysets: string[];\n  changePath?: string;\n  outputScriptHex: string;\n  lockTime?: number;\n  sigHashType?: number;\n  segwit?: boolean;\n  initialTimestamp?: number;\n  additionals: Array<string>;\n  expiryHeight?: Buffer;\n  useTrustedInputForSegwit?: boolean;\n  onDeviceStreaming?: (arg0: { progress: number; total: number; index: number }) => void;\n  onDeviceSignatureRequested?: () => void;\n  onDeviceSignatureGranted?: () => void;\n};\nexport async function createTransaction(\n  transport: Transport,\n  arg: CreateTransactionArg,\n): Promise<string> {\n  const signTx = { ...defaultsSignTransaction, ...arg };\n  const {\n    inputs,\n    associatedKeysets,\n    changePath,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    initialTimestamp,\n    additionals,\n    expiryHeight,\n    onDeviceStreaming,\n    onDeviceSignatureGranted,\n    onDeviceSignatureRequested,\n  } = signTx;\n  let useTrustedInputForSegwit = signTx.useTrustedInputForSegwit;\n\n  if (useTrustedInputForSegwit === undefined) {\n    try {\n      const a = await getAppAndVersion(transport);\n      useTrustedInputForSegwit = shouldUseTrustedInputForSegwit(a);\n    } catch (e: any) {\n      if (e.statusCode === 0x6d00) {\n        useTrustedInputForSegwit = false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // loop: 0 or 1 (before and after)\n  // i: index of the input being streamed\n  // i goes on 0...n, inluding n. in order for the progress value to go to 1\n  // we normalize the 2 loops to make a global percentage\n  const notify = (loop, i) => {\n    const { length } = inputs;\n    if (length < 3) return; // there is not enough significant event to worth notifying (aka just use a spinner)\n\n    const index = length * loop + i;\n    const total = 2 * length;\n    const progress = index / total;\n    onDeviceStreaming({\n      progress,\n      total,\n      index,\n    });\n  };\n\n  const isDecred = additionals.includes(\"decred\");\n  const isZcash = additionals.includes(\"zcash\");\n  const isXST = additionals.includes(\"stealthcoin\");\n  const startTime = Date.now();\n  const sapling = additionals.includes(\"sapling\");\n  const bech32 = segwit && additionals.includes(\"bech32\");\n  const useBip143 =\n    segwit ||\n    (!!additionals &&\n      (additionals.includes(\"abc\") ||\n        additionals.includes(\"gold\") ||\n        additionals.includes(\"bip143\"))) ||\n    (!!expiryHeight && !isDecred);\n  // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32LE(lockTime, 0);\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  !!expiryHeight && !isDecred\n    ? defaultVersion.writeUInt32LE(isZcash ? 0x80000005 : sapling ? 0x80000004 : 0x80000003, 0) // v5 format for zcash refer to https://zips.z.cash/zip-0225\n    : isXST\n      ? defaultVersion.writeUInt32LE(2, 0)\n      : defaultVersion.writeUInt32LE(1, 0);\n  // Default version to 2 for XST not to have timestamp\n  const trustedInputs: Array<any> = [];\n  const regularOutputs: Array<TransactionOutput> = [];\n  const signatures: Buffer[] = [];\n  const publicKeys: Buffer[] = [];\n  let firstRun = true;\n  const resuming = false;\n  const targetTransaction: Transaction = {\n    inputs: [],\n    version: defaultVersion,\n    timestamp: Buffer.alloc(0),\n  };\n  const getTrustedInputCall =\n    useBip143 && !useTrustedInputForSegwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n  notify(0, 0);\n  // first pass on inputs to get trusted inputs\n  for (const input of inputs) {\n    if (!resuming) {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0], additionals);\n      log(\"hw\", \"got trustedInput=\" + trustedInput);\n      const sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(\n        input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n        0,\n      );\n      trustedInputs.push({\n        trustedInput: true,\n        value: Buffer.from(trustedInput, \"hex\"),\n        sequence,\n      });\n    }\n\n    const { outputs } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n\n    if (expiryHeight && !isDecred) {\n      targetTransaction.nVersionGroupId = Buffer.from(\n        // nVersionGroupId is 0x26A7270A for zcash NU5 upgrade\n        // refer to https://github.com/zcash/zcash/blob/master/src/primitives/transaction.h\n        isZcash\n          ? [0x0a, 0x27, 0xa7, 0x26]\n          : sapling\n            ? [0x85, 0x20, 0x2f, 0x89]\n            : [0x70, 0x82, 0xc4, 0x03],\n      );\n      targetTransaction.nExpiryHeight = expiryHeight;\n      // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n      // Overwinter : use nJoinSplit (1)\n      targetTransaction.extraData = Buffer.from(\n        sapling ? [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] : [0x00],\n      );\n    } else if (isDecred) {\n      targetTransaction.nExpiryHeight = expiryHeight;\n    }\n  }\n\n  targetTransaction.inputs = inputs.map((input, idx) => {\n    const sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(\n      input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n      0,\n    );\n    return {\n      script: isZcash ? regularOutputs[idx].script : nullScript,\n      prevout: nullPrevout,\n      sequence,\n    };\n  });\n\n  if (!resuming) {\n    // Collect public keys\n    const result: {\n      publicKey: string;\n      bitcoinAddress: string;\n      chainCode: string;\n    }[] = [];\n\n    for (let i = 0; i < inputs.length; i++) {\n      const r = await getWalletPublicKey(transport, {\n        path: associatedKeysets[i],\n      });\n      notify(0, i + 1);\n      result.push(r);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      publicKeys.push(compressPublicKey(Buffer.from(result[i].publicKey, \"hex\")));\n    }\n  }\n\n  if (initialTimestamp !== undefined) {\n    targetTransaction.timestamp = Buffer.alloc(4);\n    targetTransaction.timestamp.writeUInt32LE(\n      Math.floor(initialTimestamp + (Date.now() - startTime) / 1000),\n      0,\n    );\n  }\n\n  onDeviceSignatureRequested();\n\n  if (useBip143) {\n    // Do the first run with all inputs\n    await startUntrustedHashTransactionInput(\n      transport,\n      true,\n      targetTransaction,\n      trustedInputs,\n      true,\n      !!expiryHeight,\n      additionals,\n      useTrustedInputForSegwit,\n    );\n\n    if (!resuming && changePath) {\n      await provideOutputFullChangePath(transport, changePath);\n    }\n\n    await hashOutputFull(transport, outputScript);\n  }\n\n  if (!!expiryHeight && !isDecred) {\n    await signTransaction(transport, \"\", lockTime, SIGHASH_ALL, expiryHeight);\n  }\n\n  // Do the second run with the individual transaction\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const script =\n      inputs[i].length >= 3 && typeof input[2] === \"string\"\n        ? Buffer.from(input[2], \"hex\")\n        : !segwit\n          ? regularOutputs[i].script\n          : Buffer.concat([\n              Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n              hashPublicKey(publicKeys[i]),\n              Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]),\n            ]);\n    const pseudoTX = Object.assign({}, targetTransaction);\n    const pseudoTrustedInputs = useBip143 ? [trustedInputs[i]] : trustedInputs;\n\n    if (useBip143) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(\n      transport,\n      !useBip143 && firstRun,\n      pseudoTX,\n      pseudoTrustedInputs,\n      useBip143,\n      !!expiryHeight && !isDecred,\n      additionals,\n      useTrustedInputForSegwit,\n    );\n\n    if (!useBip143) {\n      if (!resuming && changePath) {\n        await provideOutputFullChangePath(transport, changePath);\n      }\n\n      await hashOutputFull(transport, outputScript, additionals);\n    }\n\n    if (firstRun) {\n      onDeviceSignatureGranted();\n      notify(1, 0);\n    }\n\n    const signature = await signTransaction(\n      transport,\n      associatedKeysets[i],\n      lockTime,\n      sigHashType,\n      expiryHeight,\n      additionals,\n    );\n    notify(1, i + 1);\n    signatures.push(signature);\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  // Populate the final input scripts\n  for (let i = 0; i < inputs.length; i++) {\n    if (segwit) {\n      targetTransaction.witness = Buffer.alloc(0);\n\n      if (!bech32) {\n        targetTransaction.inputs[i].script = Buffer.concat([\n          Buffer.from(\"160014\", \"hex\"),\n          hashPublicKey(publicKeys[i]),\n        ]);\n      }\n    } else {\n      const signatureSize = Buffer.alloc(1);\n      const keySize = Buffer.alloc(1);\n      signatureSize[0] = signatures[i].length;\n      keySize[0] = publicKeys[i].length;\n      targetTransaction.inputs[i].script = Buffer.concat([\n        signatureSize,\n        signatures[i],\n        keySize,\n        publicKeys[i],\n      ]);\n    }\n\n    const offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;\n    targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 0x24);\n  }\n  targetTransaction.locktime = lockTimeBuffer;\n  let result = Buffer.concat([\n    serializeTransaction(targetTransaction, false, targetTransaction.timestamp, additionals),\n    outputScript,\n  ]);\n\n  if (segwit && !isDecred) {\n    let witness = Buffer.alloc(0);\n\n    for (let i = 0; i < inputs.length; i++) {\n      const tmpScriptData = Buffer.concat([\n        Buffer.from(\"02\", \"hex\"),\n        Buffer.from([signatures[i].length]),\n        signatures[i],\n        Buffer.from([publicKeys[i].length]),\n        publicKeys[i],\n      ]);\n      witness = Buffer.concat([witness, tmpScriptData]);\n    }\n\n    result = Buffer.concat([result, witness]);\n  }\n\n  // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n  if (!isZcash) {\n    result = Buffer.concat([result, lockTimeBuffer]);\n    if (expiryHeight) {\n      result = Buffer.concat([\n        result,\n        targetTransaction.nExpiryHeight || Buffer.alloc(0),\n        targetTransaction.extraData || Buffer.alloc(0),\n      ]);\n    }\n  }\n  if (isDecred) {\n    let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n    inputs.forEach((input, inputIndex) => {\n      decredWitness = Buffer.concat([\n        decredWitness,\n        Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n        Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n        Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n        Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n        targetTransaction.inputs[inputIndex].script,\n      ]);\n    });\n    result = Buffer.concat([result, decredWitness]);\n  }\n  if (isZcash) {\n    result = Buffer.concat([result, Buffer.from([0x00, 0x00, 0x00])]);\n  }\n  return result.toString(\"hex\");\n}\n","import semver from \"semver\";\nexport function shouldUseTrustedInputForSegwit({\n  version,\n  name,\n}: {\n  version: string;\n  name: string;\n}): boolean {\n  if (name === \"Decred\") return false;\n  if (name === \"Exchange\") return true;\n  return semver.gte(version, \"1.4.0\");\n}\n","import bs58 from \"bs58\";\nimport RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport { createTransaction } from \"./createTransaction\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport { pathArrayToString, pathStringToArray } from \"./bip32\";\nimport { signMessage } from \"./signMessage\";\nexport type { AddressFormat };\n\n/**\n * @class BtcOld\n * @description This Bitcoin old API is compatible with versions of the Bitcoin nano app that are earlier than 2.1.0\n *\n */\n\nexport default class BtcOld {\n  constructor(private transport: Transport) {}\n\n  private derivationsCache = {};\n  private async derivatePath(path: string) {\n    if (this.derivationsCache[path]) return this.derivationsCache[path];\n    const res = await getWalletPublicKey(this.transport, {\n      path,\n    });\n    this.derivationsCache[path] = res;\n    return res;\n  }\n\n  async getWalletXpub({\n    path,\n    xpubVersion,\n  }: {\n    path: string;\n    xpubVersion: number;\n  }): Promise<string> {\n    const pathElements = pathStringToArray(path);\n    const parentPath = pathElements.slice(0, -1);\n    const parentDerivation = await this.derivatePath(pathArrayToString(parentPath));\n    const accountDerivation = await this.derivatePath(path);\n    const fingerprint = makeFingerprint(\n      compressPublicKeySECP256(Buffer.from(parentDerivation.publicKey, \"hex\")),\n    );\n    const xpub = makeXpub(\n      xpubVersion,\n      pathElements.length,\n      fingerprint,\n      pathElements[pathElements.length - 1],\n      Buffer.from(accountDerivation.chainCode, \"hex\"),\n      compressPublicKeySECP256(Buffer.from(accountDerivation.publicKey, \"hex\")),\n    );\n    return xpub;\n  }\n\n  /**\n   * @param path a BIP 32 path\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) will ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 84' paths\n   *\n   * - bech32m format with 86' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    if (opts?.format === \"bech32m\") {\n      throw new Error(\"Unsupported address format bech32m\");\n    }\n    return getWalletPublicKey(this.transport, { ...opts, path });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"decred\" for decred\n   * - \"zcash\" for zcash\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n  createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    if (arguments.length > 1) {\n      throw new Error(\n        \"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\",\n      );\n    }\n    return createTransaction(this.transport, arg);\n  }\n\n  async signMessage({ path, messageHex }: { path: string; messageHex: string }): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    return signMessage(this.transport, {\n      path,\n      messageHex,\n    });\n  }\n}\n\nfunction makeFingerprint(compressedPubKey) {\n  return hash160(compressedPubKey).slice(0, 4);\n}\n\nfunction asBufferUInt32BE(n: number): Buffer {\n  const buf = Buffer.allocUnsafe(4);\n  buf.writeUInt32BE(n, 0);\n  return buf;\n}\n\nconst compressPublicKeySECP256 = (publicKey: Buffer) =>\n  Buffer.concat([Buffer.from([0x02 + (publicKey[64] & 0x01)]), publicKey.slice(1, 33)]);\n\nfunction makeXpub(\n  version: number,\n  depth: number,\n  parentFingerprint: Buffer,\n  index: number,\n  chainCode: Buffer,\n  pubKey: Buffer,\n) {\n  const indexBuffer = asBufferUInt32BE(index);\n  indexBuffer[0] |= 0x80;\n  const extendedKeyBytes = Buffer.concat([\n    asBufferUInt32BE(version),\n    Buffer.from([depth]),\n    parentFingerprint,\n    indexBuffer,\n    chainCode,\n    pubKey,\n  ]);\n  const checksum = hash256(extendedKeyBytes).slice(0, 4);\n  return bs58.encode(Buffer.concat([extendedKeyBytes, checksum]));\n}\n\nfunction sha256(buffer: Buffer | string) {\n  return sha(\"sha256\").update(buffer).digest();\n}\nfunction hash256(buffer: Buffer | string) {\n  return sha256(sha256(buffer));\n}\nfunction ripemd160(buffer: Buffer | string) {\n  return new RIPEMD160().update(buffer).digest();\n}\nfunction hash160(buffer: Buffer | string) {\n  return ripemd160(sha256(buffer));\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport bippath from \"bip32-path\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport async function signMessage(\n  transport: Transport,\n  {\n    path,\n    messageHex,\n  }: {\n    path: string;\n    messageHex: string;\n  },\n): Promise<{\n  v: number;\n  r: string;\n  s: string;\n}> {\n  const paths = bippath.fromString(path).toPathArray();\n  const message = Buffer.from(messageHex, \"hex\");\n  let offset = 0;\n\n  while (offset !== message.length) {\n    const maxChunkSize =\n      offset === 0 ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4 : MAX_SCRIPT_BLOCK;\n    const chunkSize =\n      offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n    const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);\n\n    if (offset === 0) {\n      buffer[0] = paths.length;\n      paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n      message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);\n    } else {\n      message.copy(buffer, 0, offset, offset + chunkSize);\n    }\n\n    await transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n    offset += chunkSize;\n  }\n\n  const res = await transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n  const v = res[0] - 0x30;\n  let r: Buffer | string = res.slice(4, 4 + res[3]);\n\n  if (r[0] === 0) {\n    r = r.slice(1);\n  }\n\n  r = r.toString(\"hex\");\n  offset = 4 + res[3] + 2;\n  let s: Buffer | string = res.slice(offset, offset + res[offset - 1]);\n\n  if (s[0] === 0) {\n    s = s.slice(1);\n  }\n\n  s = s.toString(\"hex\");\n  return {\n    v,\n    r,\n    s,\n  };\n}\n","import { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\n/**\n * This implements \"Merkelized Maps\", documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md#merkleized-maps\n *\n * A merkelized map consist of two merkle trees, one for the keys of\n * a map and one for the values of the same map, thus the two merkle\n * trees have the same shape. The commitment is the number elements\n * in the map followed by the keys' merkle root followed by the\n * values' merkle root.\n */\nexport class MerkleMap {\n  keys: Buffer[];\n  keysTree: Merkle;\n  values: Buffer[];\n  valuesTree: Merkle;\n  /**\n   * @param keys Sorted list of (unhashed) keys\n   * @param values values, in corresponding order as the keys, and of equal length\n   */\n  constructor(keys: Buffer[], values: Buffer[]) {\n    if (keys.length != values.length) {\n      throw new Error(\"keys and values should have the same length\");\n    }\n\n    // Sanity check: verify that keys are actually sorted and with no duplicates\n    for (let i = 0; i < keys.length - 1; i++) {\n      if (keys[i].toString(\"hex\") >= keys[i + 1].toString(\"hex\")) {\n        throw new Error(\"keys must be in strictly increasing order\");\n      }\n    }\n\n    this.keys = keys;\n    this.keysTree = new Merkle(keys.map(k => hashLeaf(k)));\n    this.values = values;\n    this.valuesTree = new Merkle(values.map(v => hashLeaf(v)));\n  }\n\n  commitment(): Buffer {\n    // returns a buffer between 65 and 73 (included) bytes long\n    return Buffer.concat([\n      createVarint(this.keys.length),\n      this.keysTree.getRoot(),\n      this.valuesTree.getRoot(),\n    ]);\n  }\n}\n","import { MerkleMap } from \"./merkleMap\";\nimport { PsbtV2 } from \"./psbtv2\";\n\n/**\n * This class merkelizes a PSBTv2, by merkelizing the different\n * maps of the psbt. This is used during the transaction signing process,\n * where the hardware app can request specific parts of the psbt from the\n * client code and be sure that the response data actually belong to the psbt.\n * The reason for this is the limited amount of memory available to the app,\n * so it can't always store the full psbt in memory.\n *\n * The signing process is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#sign_psbt\n */\nexport class MerkelizedPsbt extends PsbtV2 {\n  public globalMerkleMap: MerkleMap;\n  public inputMerkleMaps: MerkleMap[] = [];\n  public outputMerkleMaps: MerkleMap[] = [];\n  public inputMapCommitments: Buffer[];\n  public outputMapCommitments: Buffer[];\n  constructor(psbt: PsbtV2) {\n    super();\n    psbt.copy(this);\n    this.globalMerkleMap = MerkelizedPsbt.createMerkleMap(this.globalMap);\n\n    for (let i = 0; i < this.getGlobalInputCount(); i++) {\n      this.inputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));\n    }\n    this.inputMapCommitments = [...this.inputMerkleMaps.values()].map(v => v.commitment());\n\n    for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n      this.outputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));\n    }\n    this.outputMapCommitments = [...this.outputMerkleMaps.values()].map(v => v.commitment());\n  }\n  // These public functions are for MerkelizedPsbt.\n  getGlobalSize(): number {\n    return this.globalMap.size;\n  }\n  getGlobalKeysValuesRoot(): Buffer {\n    return this.globalMerkleMap.commitment();\n  }\n\n  private static createMerkleMap(map: Map<string, Buffer>): MerkleMap {\n    const sortedKeysStrings = [...map.keys()].sort();\n    const values = sortedKeysStrings.map(k => {\n      const v = map.get(k);\n      if (!v) {\n        throw new Error(\"No value for key \" + k);\n      }\n      return v;\n    });\n    const sortedKeys = sortedKeysStrings.map(k => Buffer.from(k, \"hex\"));\n\n    const merkleMap = new MerkleMap(sortedKeys, values);\n    return merkleMap;\n  }\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { BufferReader } from \"../buffertools\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\nimport { MerkleMap } from \"./merkleMap\";\n\nenum ClientCommandCode {\n  YIELD = 0x10,\n  GET_PREIMAGE = 0x40,\n  GET_MERKLE_LEAF_PROOF = 0x41,\n  GET_MERKLE_LEAF_INDEX = 0x42,\n  GET_MORE_ELEMENTS = 0xa0,\n}\n\nabstract class ClientCommand {\n  abstract code: ClientCommandCode;\n  abstract execute(request: Buffer): Buffer;\n}\n\nexport class YieldCommand extends ClientCommand {\n  private results: Buffer[];\n\n  code = ClientCommandCode.YIELD;\n\n  constructor(\n    results: Buffer[],\n    private progressCallback: () => void,\n  ) {\n    super();\n    this.results = results;\n  }\n\n  execute(request: Buffer): Buffer {\n    this.results.push(Buffer.from(request.subarray(1)));\n    this.progressCallback();\n    return Buffer.from(\"\");\n  }\n}\n\nexport class GetPreimageCommand extends ClientCommand {\n  private known_preimages: Map<string, Buffer>;\n  private queue: Buffer[];\n\n  code = ClientCommandCode.GET_PREIMAGE;\n\n  constructor(known_preimages: Map<string, Buffer>, queue: Buffer[]) {\n    super();\n    this.known_preimages = known_preimages;\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    // we expect no more data to read\n    if (req.length != 1 + 32) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    if (req[0] != 0) {\n      throw new Error(\"Unsupported request, the first byte should be 0\");\n    }\n\n    // read the hash\n    const hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      hash[i] = req[1 + i];\n    }\n    const req_hash_hex = hash.toString(\"hex\");\n\n    const known_preimage = this.known_preimages.get(req_hash_hex);\n    if (known_preimage != undefined) {\n      const preimage_len_varint = createVarint(known_preimage.length);\n\n      // We can send at most 255 - len(preimage_len_out) - 1 bytes in a single message;\n      // the rest will be stored in the queue for GET_MORE_ELEMENTS\n      const max_payload_size = 255 - preimage_len_varint.length - 1;\n\n      const payload_size = Math.min(max_payload_size, known_preimage.length);\n\n      if (payload_size < known_preimage.length) {\n        for (let i = payload_size; i < known_preimage.length; i++) {\n          this.queue.push(Buffer.from([known_preimage[i]]));\n        }\n      }\n\n      return Buffer.concat([\n        preimage_len_varint,\n        Buffer.from([payload_size]),\n        Buffer.from(known_preimage.subarray(0, payload_size)),\n      ]);\n    }\n\n    throw Error(`Requested unknown preimage for: ${req_hash_hex}`);\n  }\n}\n\nexport class GetMerkleLeafProofCommand extends ClientCommand {\n  private known_trees: Map<string, Merkle>;\n  private queue: Buffer[];\n\n  code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;\n\n  constructor(known_trees: Map<string, Merkle>, queue: Buffer[]) {\n    super();\n    this.known_trees = known_trees;\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    if (req.length < 32 + 1 + 1) {\n      throw new Error(\"Invalid request, expected at least 34 bytes\");\n    }\n\n    const reqBuf = new BufferReader(req);\n    const hash = reqBuf.readSlice(32);\n    const hash_hex = hash.toString(\"hex\");\n\n    let tree_size;\n    let leaf_index;\n    try {\n      tree_size = reqBuf.readVarInt();\n      leaf_index = reqBuf.readVarInt();\n    } catch (e: any) {\n      throw new Error(\"Invalid request, couldn't parse tree_size or leaf_index\");\n    }\n\n    const mt = this.known_trees.get(hash_hex);\n    if (!mt) {\n      throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);\n    }\n\n    if (leaf_index >= tree_size || mt.size() != tree_size) {\n      throw Error(\"Invalid index or tree size.\");\n    }\n\n    if (this.queue.length != 0) {\n      throw Error(\"This command should not execute when the queue is not empty.\");\n    }\n\n    const proof = mt.getProof(leaf_index);\n\n    const n_response_elements = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), proof.length);\n    const n_leftover_elements = proof.length - n_response_elements;\n\n    // Add to the queue any proof elements that do not fit the response\n    if (n_leftover_elements > 0) {\n      this.queue.push(...proof.slice(-n_leftover_elements));\n    }\n\n    return Buffer.concat([\n      mt.getLeafHash(leaf_index),\n      Buffer.from([proof.length]),\n      Buffer.from([n_response_elements]),\n      ...proof.slice(0, n_response_elements),\n    ]);\n  }\n}\n\nexport class GetMerkleLeafIndexCommand extends ClientCommand {\n  private known_trees: Map<string, Merkle>;\n\n  code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;\n\n  constructor(known_trees: Map<string, Merkle>) {\n    super();\n    this.known_trees = known_trees;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    if (req.length != 32 + 32) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    // read the root hash\n    const root_hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      root_hash[i] = req.readUInt8(i);\n    }\n    const root_hash_hex = root_hash.toString(\"hex\");\n\n    // read the leaf hash\n    const leef_hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      leef_hash[i] = req.readUInt8(32 + i);\n    }\n    const leef_hash_hex = leef_hash.toString(\"hex\");\n\n    const mt = this.known_trees.get(root_hash_hex);\n    if (!mt) {\n      throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);\n    }\n\n    let leaf_index = 0;\n    let found = 0;\n    for (let i = 0; i < mt.size(); i++) {\n      if (mt.getLeafHash(i).toString(\"hex\") == leef_hash_hex) {\n        found = 1;\n        leaf_index = i;\n        break;\n      }\n    }\n    return Buffer.concat([Buffer.from([found]), createVarint(leaf_index)]);\n  }\n}\n\nexport class GetMoreElementsCommand extends ClientCommand {\n  queue: Buffer[];\n\n  code = ClientCommandCode.GET_MORE_ELEMENTS;\n\n  constructor(queue: Buffer[]) {\n    super();\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    if (request.length != 1) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    if (this.queue.length === 0) {\n      throw new Error(\"No elements to get\");\n    }\n\n    // all elements should have the same length\n    const element_len = this.queue[0].length;\n    if (this.queue.some(el => el.length != element_len)) {\n      throw new Error(\n        \"The queue contains elements with different byte length, which is not expected\",\n      );\n    }\n\n    const max_elements = Math.floor(253 / element_len);\n    const n_returned_elements = Math.min(max_elements, this.queue.length);\n\n    const returned_elements = this.queue.splice(0, n_returned_elements);\n\n    return Buffer.concat([\n      Buffer.from([n_returned_elements]),\n      Buffer.from([element_len]),\n      ...returned_elements,\n    ]);\n  }\n}\n\n/**\n * This class will dispatch a client command coming from the hardware device to\n * the appropriate client command implementation. Those client commands\n * typically requests data from a merkle tree or merkelized maps.\n *\n * A ClientCommandInterpreter is prepared by adding the merkle trees and\n * merkelized maps it should be able to serve to the hardware device. This class\n * doesn't know anything about the semantics of the data it holds, it just\n * serves merkle data. It doesn't even know in what context it is being\n * executed, ie SignPsbt, getWalletAddress, etc.\n *\n * If the command yelds results to the client, as signPsbt does, the yielded\n * data will be accessible after the command completed by calling getYielded(),\n * which will return the yields in the same order as they came in.\n */\nexport class ClientCommandInterpreter {\n  private roots: Map<string, Merkle> = new Map();\n  private preimages: Map<string, Buffer> = new Map();\n\n  private yielded: Buffer[] = [];\n\n  private queue: Buffer[] = [];\n\n  private commands: Map<ClientCommandCode, ClientCommand> = new Map();\n\n  constructor(progressCallback: () => void) {\n    const commands = [\n      new YieldCommand(this.yielded, progressCallback),\n      new GetPreimageCommand(this.preimages, this.queue),\n      new GetMerkleLeafIndexCommand(this.roots),\n      new GetMerkleLeafProofCommand(this.roots, this.queue),\n      new GetMoreElementsCommand(this.queue),\n    ];\n\n    for (const cmd of commands) {\n      if (this.commands.has(cmd.code)) {\n        throw new Error(`Multiple commands with code ${cmd.code}`);\n      }\n      this.commands.set(cmd.code, cmd);\n    }\n  }\n\n  getYielded(): Buffer[] {\n    return this.yielded;\n  }\n\n  addKnownPreimage(preimage: Buffer): void {\n    this.preimages.set(crypto.sha256(preimage).toString(\"hex\"), preimage);\n  }\n\n  addKnownList(elements: Buffer[]): void {\n    for (const el of elements) {\n      const preimage = Buffer.concat([Buffer.from([0]), el]);\n      this.addKnownPreimage(preimage);\n    }\n    const mt = new Merkle(elements.map(el => hashLeaf(el)));\n    this.roots.set(mt.getRoot().toString(\"hex\"), mt);\n  }\n\n  addKnownMapping(mm: MerkleMap): void {\n    this.addKnownList(mm.keys);\n    this.addKnownList(mm.values);\n  }\n\n  execute(request: Buffer): Buffer {\n    if (request.length == 0) {\n      throw new Error(\"Unexpected empty command\");\n    }\n\n    const cmdCode = request[0];\n    const cmd = this.commands.get(cmdCode);\n    if (!cmd) {\n      throw new Error(`Unexpected command code ${cmdCode}`);\n    }\n\n    return cmd.execute(request);\n  }\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport { pathElementsToBuffer } from \"../bip32\";\nimport { PsbtV2 } from \"./psbtv2\";\nimport { MerkelizedPsbt } from \"./merkelizedPsbt\";\nimport { ClientCommandInterpreter } from \"./clientCommands\";\nimport { WalletPolicy } from \"./policy\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\nconst CLA_BTC = 0xe1;\nconst CLA_FRAMEWORK = 0xf8;\n\nenum BitcoinIns {\n  GET_PUBKEY = 0x00,\n  // GET_ADDRESS = 0x01, // Removed from app\n  REGISTER_WALLET = 0x02,\n  GET_WALLET_ADDRESS = 0x03,\n  SIGN_PSBT = 0x04,\n  GET_MASTER_FINGERPRINT = 0x05,\n  SIGN_MESSAGE = 0x10,\n}\n\nenum FrameworkIns {\n  CONTINUE_INTERRUPTED = 0x01,\n}\n\n/**\n * This class encapsulates the APDU protocol documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n */\nexport class AppClient {\n  transport: Transport;\n\n  constructor(transport: Transport) {\n    this.transport = transport;\n  }\n\n  private async makeRequest(\n    ins: BitcoinIns,\n    data: Buffer,\n    cci?: ClientCommandInterpreter,\n  ): Promise<Buffer> {\n    let response: Buffer = await this.transport.send(CLA_BTC, ins, 0, 0, data, [0x9000, 0xe000]);\n    while (response.readUInt16BE(response.length - 2) === 0xe000) {\n      if (!cci) {\n        throw new Error(\"Unexpected SW_INTERRUPTED_EXECUTION\");\n      }\n\n      const hwRequest = response.slice(0, -2);\n      const commandResponse = cci.execute(hwRequest);\n\n      response = await this.transport.send(\n        CLA_FRAMEWORK,\n        FrameworkIns.CONTINUE_INTERRUPTED,\n        0,\n        0,\n        commandResponse,\n        [0x9000, 0xe000],\n      );\n    }\n    return response.slice(0, -2); // drop the status word (can only be 0x9000 at this point)\n  }\n\n  async getExtendedPubkey(display: boolean, pathElements: number[]): Promise<string> {\n    if (pathElements.length > 6) {\n      throw new Error(\"Path too long. At most 6 levels allowed.\");\n    }\n    const response = await this.makeRequest(\n      BitcoinIns.GET_PUBKEY,\n      Buffer.concat([Buffer.from(display ? [1] : [0]), pathElementsToBuffer(pathElements)]),\n    );\n    return response.toString(\"ascii\");\n  }\n\n  async getWalletAddress(\n    walletPolicy: WalletPolicy,\n    walletHMAC: Buffer | null,\n    change: number,\n    addressIndex: number,\n    display: boolean,\n  ): Promise<string> {\n    if (change !== 0 && change !== 1) throw new Error(\"Change can only be 0 or 1\");\n    if (addressIndex < 0 || !Number.isInteger(addressIndex))\n      throw new Error(\"Invalid address index\");\n\n    if (walletHMAC != null && walletHMAC.length != 32) {\n      throw new Error(\"Invalid HMAC length\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(() => {});\n    clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n    clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n\n    const addressIndexBuffer = Buffer.alloc(4);\n    addressIndexBuffer.writeUInt32BE(addressIndex, 0);\n\n    const response = await this.makeRequest(\n      BitcoinIns.GET_WALLET_ADDRESS,\n      Buffer.concat([\n        Buffer.from(display ? [1] : [0]),\n        walletPolicy.getWalletId(),\n        walletHMAC || Buffer.alloc(32, 0),\n        Buffer.from([change]),\n        addressIndexBuffer,\n      ]),\n      clientInterpreter,\n    );\n\n    return response.toString(\"ascii\");\n  }\n\n  async signPsbt(\n    psbt: PsbtV2,\n    walletPolicy: WalletPolicy,\n    walletHMAC: Buffer | null,\n    progressCallback: () => void,\n  ): Promise<Map<number, Buffer>> {\n    const merkelizedPsbt = new MerkelizedPsbt(psbt);\n\n    if (walletHMAC != null && walletHMAC.length != 32) {\n      throw new Error(\"Invalid HMAC length\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(progressCallback);\n\n    // prepare ClientCommandInterpreter\n    clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n    clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n\n    clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);\n    for (const map of merkelizedPsbt.inputMerkleMaps) {\n      clientInterpreter.addKnownMapping(map);\n    }\n    for (const map of merkelizedPsbt.outputMerkleMaps) {\n      clientInterpreter.addKnownMapping(map);\n    }\n\n    clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);\n    const inputMapsRoot = new Merkle(\n      merkelizedPsbt.inputMapCommitments.map(m => hashLeaf(m)),\n    ).getRoot();\n    clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);\n    const outputMapsRoot = new Merkle(\n      merkelizedPsbt.outputMapCommitments.map(m => hashLeaf(m)),\n    ).getRoot();\n\n    await this.makeRequest(\n      BitcoinIns.SIGN_PSBT,\n      Buffer.concat([\n        merkelizedPsbt.getGlobalKeysValuesRoot(),\n        createVarint(merkelizedPsbt.getGlobalInputCount()),\n        inputMapsRoot,\n        createVarint(merkelizedPsbt.getGlobalOutputCount()),\n        outputMapsRoot,\n        walletPolicy.getWalletId(),\n        walletHMAC || Buffer.alloc(32, 0),\n      ]),\n      clientInterpreter,\n    );\n\n    const yielded = clientInterpreter.getYielded();\n\n    const ret: Map<number, Buffer> = new Map();\n    for (const inputAndSig of yielded) {\n      ret.set(inputAndSig[0], inputAndSig.slice(1));\n    }\n    return ret;\n  }\n\n  async getMasterFingerprint(): Promise<Buffer> {\n    return this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));\n  }\n\n  async signMessage(message: Buffer, pathElements: number[]): Promise<string> {\n    if (pathElements.length > 6) {\n      throw new Error(\"Path too long. At most 6 levels allowed.\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(() => {});\n\n    // prepare ClientCommandInterpreter\n    const nChunks = Math.ceil(message.length / 64);\n    const chunks: Buffer[] = [];\n    for (let i = 0; i < nChunks; i++) {\n      chunks.push(message.subarray(64 * i, 64 * i + 64));\n    }\n\n    clientInterpreter.addKnownList(chunks);\n    const chunksRoot = new Merkle(chunks.map(m => hashLeaf(m))).getRoot();\n\n    const response = await this.makeRequest(\n      BitcoinIns.SIGN_MESSAGE,\n      Buffer.concat([pathElementsToBuffer(pathElements), createVarint(message.length), chunksRoot]),\n      clientInterpreter,\n    );\n\n    return response.toString(\"base64\");\n  }\n}\n","import type { Transaction } from \"./types\";\nexport function formatTransactionDebug(transaction: Transaction): string {\n  let str = \"TX\";\n  str += \" version \" + transaction.version.toString(\"hex\");\n\n  if (transaction.locktime) {\n    str += \" locktime \" + transaction.locktime.toString(\"hex\");\n  }\n\n  if (transaction.witness) {\n    str += \" witness \" + transaction.witness.toString(\"hex\");\n  }\n\n  if (transaction.timestamp) {\n    str += \" timestamp \" + transaction.timestamp.toString(\"hex\");\n  }\n\n  if (transaction.nVersionGroupId) {\n    str += \" nVersionGroupId \" + transaction.nVersionGroupId.toString(\"hex\");\n  }\n\n  if (transaction.nExpiryHeight) {\n    str += \" nExpiryHeight \" + transaction.nExpiryHeight.toString(\"hex\");\n  }\n\n  if (transaction.extraData) {\n    str += \" extraData \" + transaction.extraData.toString(\"hex\");\n  }\n\n  transaction.inputs.forEach(({ prevout, script, sequence }, i) => {\n    str += `\\ninput ${i}:`;\n    str += ` prevout ${prevout.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n    str += ` sequence ${sequence.toString(\"hex\")}`;\n  });\n  (transaction.outputs || []).forEach(({ amount, script }, i) => {\n    str += `\\noutput ${i}:`;\n    str += ` amount ${amount.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n  });\n  return str;\n}\nexport function displayTransactionDebug(transaction: Transaction): void {\n  console.log(formatTransactionDebug(transaction));\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull } from \"./finalizeInput\";\nimport type { TransactionOutput, Transaction, TrustedInput } from \"./types\";\nimport { DEFAULT_LOCKTIME, DEFAULT_VERSION, DEFAULT_SEQUENCE, SIGHASH_ALL } from \"./constants\";\nconst defaultArg = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  transactionVersion: DEFAULT_VERSION,\n};\n\n/**\n *\n */\nexport type SignP2SHTransactionArg = {\n  inputs: Array<[Transaction, number, string | null | undefined, number | null | undefined]>;\n  associatedKeysets: string[];\n  outputScriptHex: string;\n  lockTime?: number;\n  sigHashType?: number;\n  segwit?: boolean;\n  transactionVersion?: number;\n};\nexport async function signP2SHTransaction(transport: Transport, arg: SignP2SHTransactionArg) {\n  const {\n    inputs,\n    associatedKeysets,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    transactionVersion,\n  } = { ...defaultArg, ...arg };\n  // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  defaultVersion.writeUInt32LE(transactionVersion, 0);\n  const trustedInputs: TrustedInput[] = [];\n  const regularOutputs: Array<TransactionOutput> = [];\n  const signatures: string[] = [];\n  let firstRun = true;\n  const resuming = false;\n  const targetTransaction: Transaction = {\n    inputs: [],\n    version: defaultVersion,\n  };\n  const getTrustedInputCall = segwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n  for (const input of inputs) {\n    if (!resuming) {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0]);\n      const sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(\n        input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n        0,\n      );\n      trustedInputs.push({\n        trustedInput: false,\n        value: segwit\n          ? Buffer.from(trustedInput, \"hex\")\n          : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n        sequence,\n      });\n    }\n\n    const { outputs } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n  }\n\n  // Pre-build the target transaction\n  for (let i = 0; i < inputs.length; i++) {\n    const sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(\n      inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n        ? (inputs[i][3] as number)\n        : DEFAULT_SEQUENCE,\n      0,\n    );\n    targetTransaction.inputs.push({\n      script: nullScript,\n      prevout: nullPrevout,\n      sequence,\n    });\n  }\n\n  if (segwit) {\n    await startUntrustedHashTransactionInput(\n      transport,\n      true,\n      targetTransaction,\n      trustedInputs,\n      true,\n    );\n    await hashOutputFull(transport, outputScript);\n  }\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const script =\n      inputs[i].length >= 3 && typeof input[2] === \"string\"\n        ? Buffer.from(input[2], \"hex\")\n        : regularOutputs[i].script;\n    const pseudoTX = Object.assign({}, targetTransaction);\n    const pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n\n    if (segwit) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(\n      transport,\n      !segwit && firstRun,\n      pseudoTX,\n      pseudoTrustedInputs,\n      segwit,\n    );\n\n    if (!segwit) {\n      await hashOutputFull(transport, outputScript);\n    }\n\n    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType);\n    signatures.push(\n      segwit ? signature.toString(\"hex\") : signature.slice(0, signature.length - 1).toString(\"hex\"),\n    );\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  return signatures;\n}\n","import semver from \"semver\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BtcNew from \"./BtcNew\";\nimport BtcOld from \"./BtcOld\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { AppClient } from \"./newops/appClient\";\nimport { serializeTransactionOutputs } from \"./serializeTransaction\";\nimport type { SignP2SHTransactionArg } from \"./signP2SHTransaction\";\nimport { splitTransaction } from \"./splitTransaction\";\nimport type { Transaction } from \"./types\";\nexport type { AddressFormat };\nimport { signP2SHTransaction } from \"./signP2SHTransaction\";\nimport { checkIsBtcLegacy, getAppAndVersion } from \"./getAppAndVersion\";\n\n/**\n * @class Btc\n * @description Bitcoin API.\n * @param transport The transport layer used for communication.\n * @param scrambleKey This parameter is deprecated and no longer needed.\n * @param currency The currency to use, defaults to \"bitcoin\".\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc({ transport, currency: \"bitcoin\" });\n */\n\nexport default class Btc {\n  // Transport instance\n  private _transport: Transport;\n  // The specific implementation used, determined by the nano app and its version.\n  // It chooses between BtcNew (new interface) and BtcOld (old interface).\n  private _impl: BtcOld | BtcNew;\n  constructor({\n    transport,\n    scrambleKey = \"BTC\",\n    currency = \"bitcoin\",\n  }: {\n    transport: Transport;\n    scrambleKey?: string;\n    currency?: string;\n  }) {\n    this._transport = transport;\n    this._transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getWalletXpub\",\n        \"getWalletPublicKey\",\n        \"signP2SHTransaction\",\n        \"signMessage\",\n        \"createPaymentTransaction\",\n        \"getTrustedInput\",\n        \"getTrustedInputBIP143\",\n      ],\n      scrambleKey,\n    );\n\n    this._impl = (() => {\n      switch (currency) {\n        case \"bitcoin\":\n        case \"bitcoin_testnet\":\n        case \"qtum\":\n          // new APDU (nano app API) for currencies using app-bitcoin-new implementation\n          return new BtcNew(new AppClient(this._transport));\n        default:\n          // old APDU (legacy API) for currencies using legacy bitcoin app implementation\n          return new BtcOld(this._transport);\n      }\n    })();\n  }\n\n  /**\n   * Get an XPUB with a ledger device\n   * @param arg derivation parameter\n   * - path: a BIP 32 path of the account level. (e.g. The derivation path `84'/0'/0'`\n   * follows the `purpose' / coin_type' / account'` standard, with purpose=84, coin_type=0, account=0)\n   * - xpubVersion: the XPUBVersion of the coin used. (refer to ledgerjs/packages/cryptoassets/src/currencies.ts\n   * for the XPUBVersion value if needed)\n   * @returns XPUB of the account\n   */\n  getWalletXpub(arg: { path: string; xpubVersion: number }): Promise<string> {\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.getWalletXpub(arg);\n    });\n  }\n\n  /**\n   * @param path a BIP 32 path (i.e. the `purpose / coin_type / account / change / address_index` standard)\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) whether ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 84' paths\n   *\n   * - bech32m format with 86' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    let options;\n    if (arguments.length > 2 || typeof opts === \"boolean\") {\n      console.warn(\n        \"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\",\n      );\n      options = {\n        verify: !!opts,\n        // eslint-disable-next-line prefer-rest-params\n        format: arguments[2] ? \"p2sh\" : \"legacy\",\n      };\n    } else {\n      options = opts || {};\n    }\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.getWalletPublicKey(path, options);\n    });\n  }\n\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessage(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n  signMessage(\n    path: string,\n    messageHex: string,\n  ): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.signMessage({\n        path,\n        messageHex,\n      });\n    });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign, including leading vararg voutCount\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not. This includes wrapped segwit.\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"bech32m\" for spending segwit v1+ outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"decred\" for decred\n   * - \"zcash\" for zcash\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions. If app version >= 1.4.0 this should be true.\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n  createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    if (arguments.length > 1) {\n      throw new Error(\n        \"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\",\n      );\n    }\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.createPaymentTransaction(arg);\n    });\n  }\n\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.signP2SHTransaction({\n  inputs: [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n  associatedKeysets: [\"0'/0/0\"],\n  outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(result => ...);\n   */\n  signP2SHTransaction(arg: SignP2SHTransactionArg): Promise<string[]> {\n    return signP2SHTransaction(this._transport, arg);\n  }\n\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @param transactionHex a raw hexadecimal serialized transaction\n   * @param isSegwitSupported is a boolean indicating if the segwit is supported\n   * @param hasTimestamp is a boolean (peercoin includes timestamp in their transactions, others don't)\n   * @param hasExtraData is a boolean (komodo, zencash and zcash include extraData in their transactions, others don't)\n   * @param additionals list of additionnal options\n   * @return the transaction object deserialized from the raw hexadecimal transaction\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n  splitTransaction(\n    transactionHex: string,\n    isSegwitSupported: boolean | null | undefined = false,\n    hasTimestamp = false,\n    hasExtraData = false,\n    additionals: Array<string> = [],\n  ): Transaction {\n    return splitTransaction(\n      transactionHex,\n      isSegwitSupported,\n      hasTimestamp,\n      hasExtraData,\n      additionals,\n    );\n  }\n\n  /**\n   * Serialize a transaction's outputs to hexadecimal\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n  const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n  serializeTransactionOutputs(t: Transaction): Buffer {\n    return serializeTransactionOutputs(t);\n  }\n\n  /**\n   * Trusted input is the hash of a UTXO that needs to be signed\n   * For Legacy transactions, the app has some APDUs flows that do the amount check for an UTXO,\n   * by parsing the transaction that created this UTXO\n   */\n  getTrustedInput(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = [],\n  ): Promise<string> {\n    return getTrustedInput(this._transport, indexLookup, transaction, additionals);\n  }\n\n  /**\n   * Trusted input is the hash of a UTXO that needs to be signed. BIP143 is used for Segwit inputs.\n   */\n  getTrustedInputBIP143(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = [],\n  ): string {\n    return getTrustedInputBIP143(this._transport, indexLookup, transaction, additionals);\n  }\n\n  async changeImplIfNecessary(): Promise<BtcOld | BtcNew> {\n    // if BtcOld was instantiated, stick with it\n    if (this._impl instanceof BtcOld) return this._impl;\n\n    const { name, version } = await getAppAndVersion(this._transport);\n\n    const isBtcLegacy = await (async () => {\n      switch (name) {\n        case \"Bitcoin\":\n        case \"Bitcoin Test\": {\n          // we use the legacy protocol for versions below 2.1.0 of the Bitcoin app.\n          return semver.lt(version, \"2.1.0\");\n        }\n        case \"Bitcoin Legacy\":\n        case \"Bitcoin Test Legacy\":\n          // the \"Bitcoin Legacy\" and \"Bitcoin Testnet Legacy\" app use the legacy protocol, regardless of the version\n          return true;\n        case \"Exchange\":\n          // We can't query the version of the Bitcoin app if we're coming from Exchange;\n          // therefore, we use a workaround to distinguish legacy and new versions.\n          // This can be removed once Ledger Live enforces minimum bitcoin version >= 2.1.0.\n          return await checkIsBtcLegacy(this._transport);\n        case \"Qtum\":\n          // we use the legacy protocol for versions below 3.0.0 of the Qtum app.\n          return semver.lt(version, \"3.0.0\");\n        default:\n          return true;\n      }\n    })();\n\n    if (isBtcLegacy) {\n      this._impl = new BtcOld(this._transport);\n    }\n    return this._impl;\n  }\n}\n","import { log } from \"@ledgerhq/logs\";\nimport type { Transaction, TransactionInput, TransactionOutput } from \"./types\";\nimport { getVarint } from \"./varint\";\nimport { formatTransactionDebug } from \"./debug\";\nexport function splitTransaction(\n  transactionHex: string,\n  isSegwitSupported: boolean | null | undefined = false,\n  hasTimestamp = false,\n  hasExtraData = false,\n  additionals: Array<string> = [],\n): Transaction {\n  const inputs: TransactionInput[] = [];\n  const outputs: TransactionOutput[] = [];\n  let witness = false;\n  let offset = 0;\n  let timestamp = Buffer.alloc(0);\n  let nExpiryHeight = Buffer.alloc(0);\n  let nVersionGroupId = Buffer.alloc(0);\n  let extraData = Buffer.alloc(0);\n  let witnessScript, locktime;\n  const isDecred = additionals.includes(\"decred\");\n  const isZencash = additionals.includes(\"zencash\");\n  const isZcash = additionals.includes(\"zcash\");\n  const transaction = Buffer.from(transactionHex, \"hex\");\n  const version = transaction.slice(offset, offset + 4);\n  const overwinter =\n    version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n    version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80])) ||\n    version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n  const isZcashv5 = isZcash && version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n  offset += 4;\n  if (\n    !hasTimestamp &&\n    isSegwitSupported &&\n    transaction[offset] === 0 &&\n    transaction[offset + 1] !== 0 &&\n    !isZencash\n  ) {\n    offset += 2;\n    witness = true;\n  }\n\n  if (hasTimestamp) {\n    timestamp = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n\n  if (overwinter) {\n    nVersionGroupId = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n  if (isZcashv5) {\n    locktime = transaction.slice(offset + 4, offset + 8);\n    nExpiryHeight = transaction.slice(offset + 8, offset + 12);\n    offset += 12;\n  }\n  let varint = getVarint(transaction, offset);\n  const numberInputs = varint[0];\n  offset += varint[1];\n\n  for (let i = 0; i < numberInputs; i++) {\n    const prevout = transaction.slice(offset, offset + 36);\n    offset += 36;\n    let script = Buffer.alloc(0);\n    let tree = Buffer.alloc(0);\n\n    //No script for decred, it has a witness\n    if (!isDecred) {\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n    } else {\n      //Tree field\n      tree = transaction.slice(offset, offset + 1);\n      offset += 1;\n    }\n\n    const sequence = transaction.slice(offset, offset + 4);\n    offset += 4;\n    inputs.push({\n      prevout,\n      script,\n      sequence,\n      tree,\n    });\n  }\n  varint = getVarint(transaction, offset);\n  const numberOutputs = varint[0];\n  offset += varint[1];\n  for (let i = 0; i < numberOutputs; i++) {\n    const amount = transaction.slice(offset, offset + 8);\n    offset += 8;\n\n    if (isDecred) {\n      //Script version\n      offset += 2;\n    }\n\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n    const script = transaction.slice(offset, offset + varint[0]);\n    offset += varint[0];\n    outputs.push({\n      amount,\n      script,\n    });\n  }\n\n  if (witness) {\n    witnessScript = transaction.slice(offset, -4);\n    locktime = transaction.slice(transaction.length - 4);\n  } else if (!isZcashv5) {\n    locktime = transaction.slice(offset, offset + 4);\n  }\n\n  offset += 4;\n\n  if ((overwinter || isDecred) && !isZcashv5) {\n    nExpiryHeight = transaction.slice(offset, offset + 4);\n    offset += 4;\n  }\n\n  if (hasExtraData) {\n    extraData = transaction.slice(offset);\n  }\n\n  //Get witnesses for Decred\n  if (isDecred) {\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n\n    if (varint[0] !== numberInputs) {\n      throw new Error(\"splitTransaction: incoherent number of witnesses\");\n    }\n\n    for (let i = 0; i < numberInputs; i++) {\n      //amount\n      offset += 8;\n      //block height\n      offset += 4;\n      //block index\n      offset += 4;\n      //Script size\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      inputs[i].script = script;\n    }\n  }\n\n  const t: Transaction = {\n    version,\n    inputs,\n    outputs,\n    locktime,\n    witness: witnessScript,\n    timestamp,\n    nVersionGroupId,\n    nExpiryHeight,\n    extraData,\n  };\n  log(\"btc\", `splitTransaction ${transactionHex}:\\n${formatTransactionDebug(t)}`);\n  return t;\n}\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require('create-hash');\nconst createHmac = require('create-hmac');\nfunction hash160(buffer) {\n    const sha256Hash = createHash('sha256')\n        .update(buffer)\n        .digest();\n    try {\n        return createHash('rmd160')\n            .update(sha256Hash)\n            .digest();\n    }\n    catch (err) {\n        return createHash('ripemd160')\n            .update(sha256Hash)\n            .digest();\n    }\n}\nexports.hash160 = hash160;\nfunction hmacSHA512(key, data) {\n    return createHmac('sha512', key)\n        .update(data)\n        .digest();\n}\nexports.hmacSHA512 = hmacSHA512;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bip32_1 = require(\"./bip32\");\nexports.fromSeed = bip32_1.fromSeed;\nexports.fromBase58 = bip32_1.fromBase58;\nexports.fromPublicKey = bip32_1.fromPublicKey;\nexports.fromPrivateKey = bip32_1.fromPrivateKey;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types = require('./types');\nconst bech32 = require('bech32');\nconst bs58check = require('bs58check');\nconst typeforce = require('typeforce');\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst script_1 = require('./script');\nconst multisig = require('./templates/multisig');\nconst nullData = require('./templates/nulldata');\nconst pubKey = require('./templates/pubkey');\nconst pubKeyHash = require('./templates/pubkeyhash');\nconst scriptHash = require('./templates/scripthash');\nconst witnessCommitment = require('./templates/witnesscommitment');\nconst witnessPubKeyHash = require('./templates/witnesspubkeyhash');\nconst witnessScriptHash = require('./templates/witnessscripthash');\nconst types = {\n  P2MS: 'multisig',\n  NONSTANDARD: 'nonstandard',\n  NULLDATA: 'nulldata',\n  P2PK: 'pubkey',\n  P2PKH: 'pubkeyhash',\n  P2SH: 'scripthash',\n  P2WPKH: 'witnesspubkeyhash',\n  P2WSH: 'witnessscripthash',\n  WITNESS_COMMITMENT: 'witnesscommitment',\n};\nexports.types = types;\nfunction classifyOutput(script) {\n  if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;\n  if (witnessScriptHash.output.check(script)) return types.P2WSH;\n  if (pubKeyHash.output.check(script)) return types.P2PKH;\n  if (scriptHash.output.check(script)) return types.P2SH;\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (multisig.output.check(chunks)) return types.P2MS;\n  if (pubKey.output.check(chunks)) return types.P2PK;\n  if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;\n  if (nullData.output.check(chunks)) return types.NULLDATA;\n  return types.NONSTANDARD;\n}\nexports.output = classifyOutput;\nfunction classifyInput(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (pubKeyHash.input.check(chunks)) return types.P2PKH;\n  if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;\n  if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;\n  if (pubKey.input.check(chunks)) return types.P2PK;\n  return types.NONSTANDARD;\n}\nexports.input = classifyInput;\nfunction classifyWitness(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;\n  if (witnessScriptHash.input.check(chunks, allowIncomplete))\n    return types.P2WSH;\n  return types.NONSTANDARD;\n}\nexports.witness = classifyWitness;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst createHash = require('create-hash');\nfunction ripemd160(buffer) {\n  try {\n    return createHash('rmd160')\n      .update(buffer)\n      .digest();\n  } catch (err) {\n    return createHash('ripemd160')\n      .update(buffer)\n      .digest();\n  }\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return createHash('sha1')\n    .update(buffer)\n    .digest();\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return createHash('sha256')\n    .update(buffer)\n    .digest();\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexports.hash256 = hash256;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst NETWORKS = require('./networks');\nconst types = require('./types');\nconst ecc = require('tiny-secp256k1');\nconst randomBytes = require('randombytes');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst isOptions = typeforce.maybe(\n  typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed =\n      options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer))\n    throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version;\n  // list of networks?\n  if (types.Array(network)) {\n    network = network\n      .filter(x => {\n        return version === x.wif;\n      })\n      .pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network,\n  });\n}\nexports.fromWIF = fromWIF;\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n  return fromPrivateKey(d, options);\n}\nexports.makeRandom = makeRandom;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip32 = require('bip32');\nexports.bip32 = bip32;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst ECPair = require('./ecpair');\nexports.ECPair = ECPair;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nexports.Block = block_1.Block;\nvar psbt_1 = require('./psbt');\nexports.Psbt = psbt_1.Psbt;\nvar script_1 = require('./script');\nexports.opcodes = script_1.OPS;\nvar transaction_1 = require('./transaction');\nexports.Transaction = transaction_1.Transaction;\nvar transaction_builder_1 = require('./transaction_builder');\nexports.TransactionBuilder = transaction_builder_1.TransactionBuilder;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.bitcoin = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// output: OP_RETURN ...\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      data: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst embed_1 = require('./embed');\nexports.embed = embed_1.p2data;\nconst p2ms_1 = require('./p2ms');\nexports.p2ms = p2ms_1.p2ms;\nconst p2pk_1 = require('./p2pk');\nexports.p2pk = p2pk_1.p2pk;\nconst p2pkh_1 = require('./p2pkh');\nexports.p2pkh = p2pkh_1.p2pkh;\nconst p2sh_1 = require('./p2sh');\nexports.p2sh = p2sh_1.p2sh;\nconst p2wpkh_1 = require('./p2wpkh');\nexports.p2wpkh = p2wpkh_1.p2wpkh;\nconst p2wsh_1 = require('./p2wsh');\nexports.p2wsh = p2wsh_1.p2wsh;\n// TODO\n// witness commitment\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst typef = require('typeforce');\nconst ecc = require('tiny-secp256k1');\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      m: typef.maybe(typef.Number),\n      n: typef.maybe(typef.Number),\n      output: typef.maybe(typef.Buffer),\n      pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),\n      signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid');\n      if (!typef.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => ecc.isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!ecc.isPoint(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bs58check = require('bs58check');\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(25)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!ecc.isPoint(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst bs58check = require('bs58check');\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(23)),\n      redeem: typef.maybe({\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        input: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    return {\n      network,\n      output: chunks[chunks.length - 1],\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      input: typef.maybe(typef.BufferN(0)),\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.BufferN(22)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    ecc.isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(32)),\n      output: typef.maybe(typef.BufferN(34)),\n      redeem: typef.maybe({\n        input: typef.maybe(typef.Buffer),\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.BufferN(0)),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty?\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Old TransactionBuilder behavior was to not confirm input values\n      // before signing. Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n      });\n    });\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nconst isP2SHScript = isPaymentFactory(payments.p2sh);\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })\n      .output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          'to trick you into paying large fees. This behavior is the same as the old ' +\n          'TransactionBuilder class when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return input.witnessUtxo.script;\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction pubkeyInScript(pubkey, script) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst ecc = require('tiny-secp256k1');\nconst pushdata = require('pushdata-bitcoin');\nconst typeforce = require('typeforce');\nexports.OPS = require('bitcoin-ops');\nconst REVERSE_OPS = require('bitcoin-ops/map');\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === exports.OPS.OP_0 ||\n      (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||\n      value === exports.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\n// tslint:disable-next-line variable-name\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst typeforce = require('typeforce');\nconst ZERO = Buffer.alloc(1, 0);\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_0 [signatures ...]\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction partialSignature(value) {\n  return (\n    value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value)\n  );\n}\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 2) return false;\n  if (chunks[0] !== script_1.OPS.OP_0) return false;\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature);\n  }\n  return chunks.slice(1).every(bscript.isCanonicalScriptSignature);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multisig input';\n};\n","'use strict';\n// m [pubKeys ...] n OP_CHECKMULTISIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 4) return false;\n  if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;\n  if (!types.Number(chunks[0])) return false;\n  if (!types.Number(chunks[chunks.length - 2])) return false;\n  const m = chunks[0] - OP_INT_BASE;\n  const n = chunks[chunks.length - 2] - OP_INT_BASE;\n  if (m <= 0) return false;\n  if (n > 16) return false;\n  if (m > n) return false;\n  if (n !== chunks.length - 3) return false;\n  if (allowIncomplete) return true;\n  const keys = chunks.slice(1, -2);\n  return keys.every(bscript.isCanonicalPubKey);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multi-sig output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// OP_RETURN {data}\nconst bscript = require('../script');\nconst OPS = bscript.OPS;\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'null data output';\n};\nconst output = { check };\nexports.output = output;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey input';\n};\n","'use strict';\n// {pubKey} OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalPubKey(chunks[0]) &&\n    chunks[1] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    bscript.isCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash input';\n};\n","'use strict';\n// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 25 &&\n    buffer[0] === script_1.OPS.OP_DUP &&\n    buffer[1] === script_1.OPS.OP_HASH160 &&\n    buffer[2] === 0x14 &&\n    buffer[23] === script_1.OPS.OP_EQUALVERIFY &&\n    buffer[24] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nconst p2wpkho = require('../witnesspubkeyhash/output');\nconst p2wsho = require('../witnessscripthash/output');\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 1) return false;\n  const lastChunk = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(lastChunk)) return false;\n  const scriptSigChunks = bscript.decompile(\n    bscript.compile(chunks.slice(0, -1)),\n  );\n  const redeemScriptChunks = bscript.decompile(lastChunk);\n  // is redeemScript a valid script?\n  if (!redeemScriptChunks) return false;\n  // is redeemScriptSig push only?\n  if (!bscript.isPushOnly(scriptSigChunks)) return false;\n  // is witness?\n  if (chunks.length === 1) {\n    return (\n      p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks)\n    );\n  }\n  // match types\n  if (\n    p2pkh.input.check(scriptSigChunks) &&\n    p2pkh.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(scriptSigChunks, allowIncomplete) &&\n    p2ms.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(scriptSigChunks) &&\n    p2pk.output.check(redeemScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash input';\n};\n","'use strict';\n// OP_HASH160 {scriptHash} OP_EQUAL\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 23 &&\n    buffer[0] === script_1.OPS.OP_HASH160 &&\n    buffer[1] === 0x14 &&\n    buffer[22] === script_1.OPS.OP_EQUAL\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_RETURN {aa21a9ed} {commitment}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst typeforce = require('typeforce');\nconst HEADER = Buffer.from('aa21a9ed', 'hex');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length > 37 &&\n    buffer[0] === script_1.OPS.OP_RETURN &&\n    buffer[1] === 0x24 &&\n    buffer.slice(2, 6).equals(HEADER)\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness commitment output';\n};\nfunction encode(commitment) {\n  typeforce(types.Hash256bit, commitment);\n  const buffer = Buffer.allocUnsafe(36);\n  HEADER.copy(buffer, 0);\n  commitment.copy(buffer, 4);\n  return bscript.compile([script_1.OPS.OP_RETURN, buffer]);\n}\nexports.encode = encode;\nfunction decode(buffer) {\n  typeforce(check, buffer);\n  return bscript.decompile(buffer)[1].slice(4, 36);\n}\nexports.decode = decode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction isCompressedCanonicalPubKey(pubKey) {\n  return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;\n}\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    isCompressedCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessPubKeyHash input';\n};\n","'use strict';\n// OP_0 {pubKeyHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 22 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x14\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst typeforce = require('typeforce');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nfunction check(chunks, allowIncomplete) {\n  typeforce(typeforce.Array, chunks);\n  if (chunks.length < 1) return false;\n  const witnessScript = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(witnessScript)) return false;\n  const witnessScriptChunks = bscript.decompile(witnessScript);\n  // is witnessScript a valid script?\n  if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;\n  const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));\n  // match types\n  if (\n    p2pkh.input.check(witnessRawScriptSig) &&\n    p2pkh.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&\n    p2ms.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(witnessRawScriptSig) &&\n    p2pk.output.check(witnessScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessScriptHash input';\n};\n","'use strict';\n// OP_0 {scriptHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 34 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x20\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_SCRIPT,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst baddress = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst classify = require('./classify');\nconst bcrypto = require('./crypto');\nconst ECPair = require('./ecpair');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([\n  // Raw\n  'p2pkh',\n  'p2pk',\n  'p2wpkh',\n  'p2ms',\n  // P2SH wrapped\n  'p2sh-p2pkh',\n  'p2sh-p2pk',\n  'p2sh-p2wpkh',\n  'p2sh-p2ms',\n  // P2WSH wrapped\n  'p2wsh-p2pkh',\n  'p2wsh-p2pk',\n  'p2wsh-p2ms',\n  // P2SH-P2WSH wrapper\n  'p2sh-p2wsh-p2pkh',\n  'p2sh-p2wsh-p2pk',\n  'p2sh-p2wsh-p2ms',\n]);\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn(\n      'Deprecation Warning: TransactionBuilder will be removed in the future. ' +\n        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +\n        'are available in the transactions-psbt.js integration test file on our ' +\n        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +\n        'files as well.',\n    );\n  }\n  static fromTransaction(transaction, network) {\n    const txb = new TransactionBuilder(network);\n    // Copy transaction fields\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime);\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n      });\n    });\n    // fix some things not possible through the public API\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i);\n    });\n    return txb;\n  }\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n    if (setting === undefined) {\n      setting = true;\n    }\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(s => s !== undefined);\n      })\n    ) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    this.__TX.locktime = locktime;\n  }\n  setVersion(version) {\n    typeforce(types.UInt32, version);\n    // XXX: this might eventually become more complex depending on what the versions represent\n    this.__TX.version = version;\n  }\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    let value;\n    // is it a hex string?\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));\n      // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value,\n    });\n  }\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 or bech32 address string\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n  build() {\n    return this.__build(false);\n  }\n  buildIncomplete() {\n    return this.__build(true);\n  }\n  sign(\n    signParams,\n    keyPair,\n    redeemScript,\n    hashType,\n    witnessValue,\n    witnessScript,\n  ) {\n    trySign(\n      getSigningData(\n        this.network,\n        this.__INPUTS,\n        this.__needsOutputs.bind(this),\n        this.__TX,\n        signParams,\n        keyPair,\n        redeemScript,\n        hashType,\n        witnessValue,\n        witnessScript,\n        this.__USE_LOW_R,\n      ),\n    );\n  }\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined)\n      throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n      input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n        prevOutType = expanded.type;\n      }\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n    const vin = this.__TX.addInput(\n      txHash,\n      vout,\n      options.sequence,\n      options.scriptSig,\n    );\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n    const tx = this.__TX.clone();\n    // create script signatures from inputs\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete)\n        throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)\n          throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n    return tx;\n  }\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n        return (\n          (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0\n        );\n      });\n    });\n  }\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    }\n    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n    return (\n      this.__TX.outs.length === 0 &&\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(signature => {\n          if (!signature) return false; // no signature, no issue\n          const hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n          return true; // SIGHASH_* does care\n        });\n      })\n    );\n  }\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n        return false;\n      });\n    });\n  }\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n}\nexports.TransactionBuilder = TransactionBuilder;\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({\n        witness: witnessStack,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({\n        input: scriptSig,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig });\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms(\n        {\n          input: scriptSig,\n          output: scriptPubKey,\n        },\n        { allowIncomplete: true },\n      );\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys,\n        signatures,\n        maxSignatures: m,\n      };\n    }\n  }\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(\n      redeem.input,\n      redeem.witness,\n      outputType,\n      redeem.output,\n    );\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(\n        bscript.compile(redeem.witness),\n        [],\n        outputType,\n        redeem.output,\n      );\n    }\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig,\n  };\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)\n    return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match;\n    // check for a signature\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature);\n      const hash = transaction.hashForSignature(\n        vin,\n        input.redeemScript,\n        parsed.hashType,\n      );\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash;\n      const pkh2 = bcrypto.hash160(ourPubKey);\n      if (!pkh1.equals(pkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash;\n      const wpkh2 = bcrypto.hash160(ourPubKey);\n      if (!wpkh1.equals(wpkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script });\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script });\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m,\n      };\n    }\n  }\n  return { type };\n}\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: witnessScript },\n    });\n    const p2wshAlt = payments.p2wsh({ output: redeemScript });\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    const p2shAlt = payments.p2sh({ redeem: p2wsh });\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash))\n      throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash))\n      throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    if (input.prevOutScript) {\n      let p2shAlt;\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n      if (!p2sh.hash.equals(p2shAlt.hash))\n        throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as redeemScript (' +\n          bscript.toASM(redeemScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = redeemScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });\n      if (!p2wsh.hash.equals(p2wshAlt.hash))\n        throw new Error('Witness script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',\n      );\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',\n      );\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported (' +\n          bscript.toASM(input.prevOutScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = input.prevOutScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined],\n  };\n}\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pk({ signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures;\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || script_1.OPS.OP_0);\n      } else {\n        signatures = signatures.filter(x => x);\n      }\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || m === signatures.length;\n      return payments.p2ms(\n        { m, pubkeys, signatures },\n        { allowIncomplete, validate },\n      );\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n  }\n}\nfunction canSign(input) {\n  return (\n    input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (input.hasWitness === false || input.value !== undefined)\n  );\n}\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\n      `Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`,\n    );\n  }\n  tfMessage(\n    typeforce.Number,\n    signParams.vin,\n    `sign must include vin parameter as Number (input index)`,\n  );\n  tfMessage(\n    types.Signer,\n    signParams.keyPair,\n    `sign must include keyPair parameter as Signer interface`,\n  );\n  tfMessage(\n    typeforce.maybe(typeforce.Number),\n    signParams.hashType,\n    `sign hashType parameter must be a number`,\n  );\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessScript`,\n      );\n      break;\n  }\n}\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR,\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error(\n        'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',\n      );\n    }\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\nfunction getSigningData(\n  network,\n  inputs,\n  needsOutputs,\n  tx,\n  signParams,\n  keyPair,\n  redeemScript,\n  hashType,\n  witnessValue,\n  witnessScript,\n  useLowR,\n) {\n  let vin;\n  if (typeof signParams === 'number') {\n    console.warn(\n      'DEPRECATED: TransactionBuilder sign method arguments ' +\n        'will change in v6, please use the TxbSignArg interface',\n    );\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript,\n    } = signParams);\n  } else {\n    throw new TypeError(\n      'TransactionBuilder sign first arg must be TxbSignArg or number',\n    );\n  }\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  }\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== network)\n    throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (\n    input.redeemScript !== undefined &&\n    redeemScript &&\n    !input.redeemScript.equals(redeemScript)\n  ) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  const ourPubKey =\n    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue)\n        throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    if (!canSign(input)) {\n      const prepared = prepareInput(\n        input,\n        ourPubKey,\n        redeemScript,\n        witnessScript,\n      );\n      // updates inline\n      Object.assign(input, prepared);\n    }\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  let signatureHash;\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n    );\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR,\n  };\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeforce = require('typeforce');\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nexports.UInt31 = UInt31;\nfunction BIP32Path(value) {\n  return typeforce.String(value) && !!value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\nexports.BIP32Path = BIP32Path;\nBIP32Path.toJSON = () => {\n  return 'BIP32 derivation path';\n};\nfunction Signer(obj) {\n  return (\n    (typeforce.Buffer(obj.publicKey) ||\n      typeof obj.getPublicKey === 'function') &&\n    typeof obj.sign === 'function'\n  );\n}\nexports.Signer = Signer;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\n// external dependent types\nexports.ECPoint = typeforce.quacksLike('Point');\n// exposed, external API\nexports.Network = typeforce.compile({\n  messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32,\n  },\n  pubKeyHash: typeforce.UInt8,\n  scriptHash: typeforce.UInt8,\n  wif: typeforce.UInt8,\n});\nexports.Buffer256bit = typeforce.BufferN(32);\nexports.Hash160bit = typeforce.BufferN(20);\nexports.Hash256bit = typeforce.BufferN(32);\nexports.Number = typeforce.Number; // tslint:disable-line variable-name\nexports.Array = typeforce.Array;\nexports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name\nexports.String = typeforce.String; // tslint:disable-line variable-name\nexports.Buffer = typeforce.Buffer;\nexports.Hex = typeforce.Hex;\nexports.maybe = typeforce.maybe;\nexports.tuple = typeforce.tuple;\nexports.UInt8 = typeforce.UInt8;\nexports.UInt32 = typeforce.UInt32;\nexports.Function = typeforce.Function;\nexports.BufferN = typeforce.BufferN;\nexports.Null = typeforce.Null;\nexports.oneOf = typeforce.oneOf;\n","var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { safeRe: re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = require('../internal/lrucache')\nconst cache = new LRU()\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (!identifier && identifierBase === false) {\n          throw new Error('invalid increment argument: identifier is empty')\n        }\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","const parse = require('./parse.js')\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // Otherwise it can be determined by checking the high version\n\n    if (highVersion.patch) {\n      // anything higher than a patch bump would result in the wrong version\n      return 'patch'\n    }\n\n    if (highVersion.minor) {\n      // anything higher than a minor bump would result in the wrong version\n      return 'minor'\n    }\n\n    // bumping major/minor/patch all have same result\n    return 'major'\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const SemVer = require('../classes/semver')\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nconst constants = require('./internal/constants')\nconst SemVer = require('./classes/semver')\nconst identifiers = require('./internal/identifiers')\nconst parse = require('./functions/parse')\nconst valid = require('./functions/valid')\nconst clean = require('./functions/clean')\nconst inc = require('./functions/inc')\nconst diff = require('./functions/diff')\nconst major = require('./functions/major')\nconst minor = require('./functions/minor')\nconst patch = require('./functions/patch')\nconst prerelease = require('./functions/prerelease')\nconst compare = require('./functions/compare')\nconst rcompare = require('./functions/rcompare')\nconst compareLoose = require('./functions/compare-loose')\nconst compareBuild = require('./functions/compare-build')\nconst sort = require('./functions/sort')\nconst rsort = require('./functions/rsort')\nconst gt = require('./functions/gt')\nconst lt = require('./functions/lt')\nconst eq = require('./functions/eq')\nconst neq = require('./functions/neq')\nconst gte = require('./functions/gte')\nconst lte = require('./functions/lte')\nconst cmp = require('./functions/cmp')\nconst coerce = require('./functions/coerce')\nconst Comparator = require('./classes/comparator')\nconst Range = require('./classes/range')\nconst satisfies = require('./functions/satisfies')\nconst toComparators = require('./ranges/to-comparators')\nconst maxSatisfying = require('./ranges/max-satisfying')\nconst minSatisfying = require('./ranges/min-satisfying')\nconst minVersion = require('./ranges/min-version')\nconst validRange = require('./ranges/valid')\nconst outside = require('./ranges/outside')\nconst gtr = require('./ranges/gtr')\nconst ltr = require('./ranges/ltr')\nconst intersects = require('./ranges/intersects')\nconst simplifyRange = require('./ranges/simplify')\nconst subset = require('./ranges/subset')\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n","class LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n","// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n","const {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n","/*\n * Bitcoin BIP32 path helpers\n * (C) 2016 Alex Beregszaszi\n */\n\nconst HARDENED = 0x80000000\n\nvar BIPPath = function (path) {\n  if (!Array.isArray(path)) {\n    throw new Error('Input must be an Array')\n  }\n  if (path.length === 0) {\n    throw new Error('Path must contain at least one level')\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (typeof path[i] !== 'number') {\n      throw new Error('Path element is not a number')\n    }\n  }\n  this.path = path\n}\n\nBIPPath.validatePathArray = function (path) {\n  try {\n    BIPPath.fromPathArray(path)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.validateString = function (text, reqRoot) {\n  try {\n    BIPPath.fromString(text, reqRoot)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.fromPathArray = function (path) {\n  return new BIPPath(path)\n}\n\nBIPPath.fromString = function (text, reqRoot) {\n  // skip the root\n  if (/^m\\//i.test(text)) {\n    text = text.slice(2)\n  } else if (reqRoot) {\n    throw new Error('Root element is required')\n  }\n\n  var path = text.split('/')\n  var ret = new Array(path.length)\n  for (var i = 0; i < path.length; i++) {\n    var tmp = /(\\d+)([hH\\']?)/.exec(path[i])\n    if (tmp === null) {\n      throw new Error('Invalid input')\n    }\n    ret[i] = parseInt(tmp[1], 10)\n\n    if (ret[i] >= HARDENED) {\n      throw new Error('Invalid child index')\n    }\n\n    if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\\'') {\n      ret[i] += HARDENED\n    } else if (tmp[2].length != 0) {\n      throw new Error('Invalid modifier')\n    }\n  }\n  return new BIPPath(ret)\n}\n\nBIPPath.prototype.toPathArray = function () {\n  return this.path\n}\n\nBIPPath.prototype.toString = function (noRoot, oldStyle) {\n  var ret = new Array(this.path.length)\n  for (var i = 0; i < this.path.length; i++) {\n    var tmp = this.path[i]\n    if (tmp & HARDENED) {\n      ret[i] = (tmp & ~HARDENED) + (oldStyle ? 'h' : '\\'')\n    } else {\n      ret[i] = tmp\n    }\n  }\n  return (noRoot ? '' : 'm/') + ret.join('/')\n}\n\nBIPPath.prototype.inspect = function () {\n  return 'BIPPath <' + this.toString() + '>'\n}\n\nmodule.exports = BIPPath\n","var OPS = require('./index.json')\n\nvar map = {}\nfor (var op in OPS) {\n  var code = OPS[op]\n  map[code] = op\n}\n\nmodule.exports = map\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var OPS = require('bitcoin-ops')\n\nfunction encodingLength (i) {\n  return i < OPS.OP_PUSHDATA1 ? 1\n  : i <= 0xff ? 2\n  : i <= 0xffff ? 3\n  : 5\n}\n\nfunction encode (buffer, number, offset) {\n  var size = encodingLength(number)\n\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(number, offset)\n\n  // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)\n    buffer.writeUInt8(number, offset + 1)\n\n  // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n\n  // 32 bit\n  } else {\n    buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n  }\n\n  return size\n}\n\nfunction decode (buffer, offset) {\n  var opcode = buffer.readUInt8(offset)\n  var number, size\n\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    number = opcode\n    size = 1\n\n  // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null\n    number = buffer.readUInt8(offset + 1)\n    size = 2\n\n  // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null\n    number = buffer.readUInt16LE(offset + 1)\n    size = 3\n\n  // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')\n\n    number = buffer.readUInt32LE(offset + 1)\n    size = 5\n  }\n\n  return {\n    opcode: opcode,\n    number: number,\n    size: size\n  }\n}\n\nmodule.exports = {\n  encodingLength: encodingLength,\n  encode: encode,\n  decode: decode\n}\n"],"names":["pathElementsToBuffer","paths","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE","bip32asBuffer","path","pathStringToArray","pathArrayToString","pathElements","bippath","toString","toPathArray","pubkeyFromXpub","xpub","xpubBuf","bs58check","slice","getXpubComponents","chaincode","pubkey","version","readUInt32BE","unsafeTo64bitLE","n","Number","MAX_SAFE_INTEGER","Error","byteArray","byte","unsafeFrom64bitLE","value","i","BufferWriter","constructor","bufs","write","fn","b","this","push","writeUInt8","writeInt32","writeInt32LE","writeUInt32","writeUInt32LE","writeUInt64","bytes","writeSlice","writeVarInt","varuint","from","writeVarSlice","concat","BufferReader","offset","available","readUInt8","result","readInt32","readInt32LE","readUInt32","readUInt32LE","readUInt64","readSlice","readVarInt","vi","readVarSlice","readVector","count","vector","MAX_SCRIPT_BLOCK","DEFAULT_SEQUENCE","hashPublicKey","RIPEMD160","update","sha","digest","BaseAccount","psbt","masterFp","SingleKeyAccount","spendingCondition","pubkeys","singleKeyCondition","setInput","inputTx","spentOutput","pathElems","setSingleKeyInput","setOwnOutput","cond","setSingleKeyOutput","p2pkh","buf","pubkeyHash","scriptPubKey","_spentOutput","setInputNonWitnessUtxo","setInputBip32Derivation","setOutputBip32Derivation","getDescriptorTemplate","p2tr","xonlyPubkey","outputKey","getTaprootOutputKey","_inputTx","xonly","setInputTapBip32Derivation","setInputWitnessUtxo","amount","setOutputTapBip32Derivation","hashTapTweak","x","h","crypto","sha256","internalPubkey","evenEcdsaPubkey","tweak","pointAddScalar","p2wpkhWrapped","redeemScript","createRedeemScript","scriptHash","userSuppliedRedeemScript","expectedRedeemScript","equals","setInputRedeemScript","setOutputRedeemScript","p2wpkh","Merkle","leaves","hasher","nodes","calculateRoot","rootNode","root","leafNodes","getRoot","hash","size","getLeaves","getLeafHash","getProof","proveNode","Node","undefined","newNode","leftCount","isPowerOf2","Math","floor","log2","highestPowerOf2LessThan","leftBranch","rightBranch","leftChild","rightChild","hashNode","node","parent","left","right","hashLeaf","hashFunction","bufA","bufB","hashConcat","isLeaf","WalletPolicy","descriptorTemplate","key","keys","getWalletId","serialize","keyBuffers","map","k","m","createKey","masterFingerprint","accountPath","substring","psbtGlobal","psbtIn","psbtOut","PSBT_MAGIC_BYTES","NoSuchEntry","PsbtV2","globalMap","Map","inputMaps","outputMaps","setGlobalTxVersion","setGlobal","TX_VERSION","uint32LE","getGlobalTxVersion","getGlobal","setGlobalFallbackLocktime","locktime","FALLBACK_LOCKTIME","getGlobalFallbackLocktime","_a","getGlobalOptional","setGlobalInputCount","inputCount","INPUT_COUNT","varint","getGlobalInputCount","fromVarint","setGlobalOutputCount","outputCount","OUTPUT_COUNT","getGlobalOutputCount","setGlobalTxModifiable","TX_MODIFIABLE","getGlobalTxModifiable","setGlobalPsbtVersion","psbtVersion","VERSION","getGlobalPsbtVersion","inputIndex","transaction","NON_WITNESS_UTXO","getInputNonWitnessUtxo","getInputOptional","WITNESS_UTXO","getInputWitnessUtxo","utxo","setInputPartialSig","signature","PARTIAL_SIG","getInputPartialSig","setInputSighashType","sigHashtype","SIGHASH_TYPE","getInputSighashType","REDEEM_SCRIPT","getInputRedeemScript","BIP32_DERIVATION","encodeBip32Derivation","getInputBip32Derivation","decodeBip32Derivation","setInputFinalScriptsig","scriptSig","FINAL_SCRIPTSIG","getInputFinalScriptsig","setInputFinalScriptwitness","scriptWitness","FINAL_SCRIPTWITNESS","getInputFinalScriptwitness","getInput","setInputPreviousTxId","txid","PREVIOUS_TXID","getInputPreviousTxid","setInputOutputIndex","outputIndex","OUTPUT_INDEX","getInputOutputIndex","setInputSequence","sequence","SEQUENCE","getInputSequence","_b","setInputTapKeySig","sig","TAP_KEY_SIG","getInputTapKeySig","hashes","encodeTapBip32Derivation","TAP_BIP32_DERIVATION","getInputTapBip32Derivation","decodeTapBip32Derivation","getInputKeyDatas","keyType","getKeyDatas","setOutput","getOutputRedeemScript","getOutput","BIP_32_DERIVATION","getOutputBip32Derivation","setOutputAmount","AMOUNT","getOutputAmount","setOutputScript","SCRIPT","getOutputScript","fingerprint","getOutputTapBip32Derivation","deleteInputEntries","keyTypes","_v","isKeyType","delete","copy","to","copyMap","copyMaps","to_index","v","set","serializeMap","deserialize","readKeyPair","keyLen","hexKey","some","Key","get","keyData","getMap","maps","writeBip32Derivation","readBip32Derivation","hashCount","deriv","Object","assign","acceptUndefined","toBuffer","KeyPair","clearFinalizedInput","witnessUtxoAvailable","nonWitnessUtxoAvailable","writePush","data","writeUInt16LE","getVarint","createVarint","serializeTransactionOutputs","outputs","outputBuffer","output","script","serializeTransaction","skipWitness","timestamp","additionals","isDecred","includes","isZcash","isBech32","inputBuffer","useWitness","inputs","input","prevout","witness","nExpiryHeight","extraData","nVersionGroupId","BtcNew","client","getWalletXpub","xpubVersion","getExtendedPubkey","xpubComponents","getWalletPublicKey","opts","validSingleSigPurposePathPartsSet","has","validCoinPathPartsSet","hard","change","soft","validMultiSigPurposePathPartsSet","isPathNormal","display","verify","address","getWalletAddress","addressFormat","descrTemplFrom","format","components","publicKey","pointCompress","bitcoinAddress","chainCode","descrTempl","hardenedPathOf","accountXpub","getMasterFingerprint","policy","changeAndIndex","createPaymentTransaction","arg","accountType","segwit","accountTypeFromArg","lockTime","notifyCount","progress","onDeviceStreaming","total","associatedKeysets","sigHashType","outputsConcat","outputScriptHex","outputsBufferReader","changeData","outputScriptAt","changePath","changeFound","outputScript","p","onDeviceSignatureRequested","firstSigned","signPsbt","progressCallback","onDeviceSignatureGranted","legacyPubkeys","taprootSig","isSegwitV0","isWrappedSegwit","witnessBuf","scriptSigBuf","finalize","serializedTx","tx","isSegwit","witnessWriter","extract","signMessage","messageHex","message","r","s","masterFP","spentOutputIndex","inputTxBuffer","inputTxid","hash256","spentTxOutput","walletPolicy","H","Set","t","addressFormatMap","legacy","p2sh","bech32","cashaddr","transport","options","p1","p2","response","send","publicKeyLength","addressLength","getTrustedInputRaw","transactionData","indexLookup","firstRound","prefix","trustedInput","getTrustedInput","transport_1","indexLookup_1","transaction_1","isXST","processScriptBlocks","__awaiter","seq","scriptBlocks","res","blockSize","scriptBlock","processWholeScriptBlock","block","isXSTV2","compare","treeField","tree","endData","extraPart","invariant","startUntrustedHashTransactionInputRaw","newTransaction","bip143","overwinter","startUntrustedHashTransactionInput","newTransaction_1","inputs_1","useTrustedInputForSegwit","inputValue","getTrustedInputBIP143","shajs","compressPublicKey","prefixBuffer","signTransaction","expiryHeight","pathsBuffer","lockTimeBuffer","then","provideOutputFullChangePath","hashOutputFull","outputScript_1","getAppAndVersion","nameLength","name","versionLength","flagLength","flags","defaultsSignTransaction","_e","createTransaction","signTx","initialTimestamp","semver","shouldUseTrustedInputForSegwit","e","statusCode","notify","loop","startTime","Date","now","sapling","useBip143","nullScript","nullPrevout","defaultVersion","trustedInputs","regularOutputs","signatures","publicKeys","firstRun","targetTransaction","getTrustedInputCall","log","idx","pseudoTX","pseudoTrustedInputs","signatureSize","keySize","tmpScriptData","decredWitness","BtcOld","derivationsCache","derivatePath","parentPath","parentDerivation","accountDerivation","compressedPubKey","ripemd160","makeFingerprint","compressPublicKeySECP256","depth","parentFingerprint","pubKey","indexBuffer","asBufferUInt32BE","extendedKeyBytes","checksum","bs58","makeXpub","arguments","maxChunkSize","chunkSize","writeUInt16BE","allocUnsafe","MerkleMap","values","keysTree","valuesTree","commitment","MerkelizedPsbt","super","inputMerkleMaps","outputMerkleMaps","globalMerkleMap","createMerkleMap","inputMapCommitments","outputMapCommitments","getGlobalSize","getGlobalKeysValuesRoot","sortedKeysStrings","sort","sortedKeys","ClientCommandCode","ClientCommand","YieldCommand","results","code","YIELD","execute","request","subarray","GetPreimageCommand","known_preimages","queue","GET_PREIMAGE","req","req_hash_hex","known_preimage","preimage_len_varint","max_payload_size","payload_size","min","GetMerkleLeafProofCommand","known_trees","GET_MERKLE_LEAF_PROOF","reqBuf","hash_hex","tree_size","leaf_index","mt","proof","n_response_elements","n_leftover_elements","GetMerkleLeafIndexCommand","GET_MERKLE_LEAF_INDEX","root_hash","root_hash_hex","leef_hash","leef_hash_hex","found","GetMoreElementsCommand","GET_MORE_ELEMENTS","element_len","el","max_elements","n_returned_elements","returned_elements","splice","ClientCommandInterpreter","roots","preimages","yielded","commands","cmd","getYielded","addKnownPreimage","preimage","addKnownList","elements","addKnownMapping","mm","cmdCode","BitcoinIns","FrameworkIns","AppClient","makeRequest","ins","cci","readUInt16BE","hwRequest","commandResponse","CONTINUE_INTERRUPTED","GET_PUBKEY","walletHMAC","addressIndex","isInteger","clientInterpreter","addressIndexBuffer","GET_WALLET_ADDRESS","merkelizedPsbt","inputMapsRoot","outputMapsRoot","SIGN_PSBT","ret","inputAndSig","GET_MASTER_FINGERPRINT","nChunks","ceil","chunks","chunksRoot","SIGN_MESSAGE","formatTransactionDebug","str","defaultArg","transactionVersion","Btc","scrambleKey","currency","_transport","decorateAppAPIMethods","_impl","changeImplIfNecessary","impl","console","warn","signP2SHTransaction","splitTransaction","transactionHex","isSegwitSupported","hasTimestamp","hasExtraData","witnessScript","isZencash","isZcashv5","numberInputs","numberOutputs","ALPHABET","ALPHABET_MAP","z","charAt","TypeError","polymodStep","pre","prefixChk","chk","c","charCodeAt","__decode","LIMIT","lowered","toLowerCase","uppered","toUpperCase","split","lastIndexOf","wordChars","words","convert","inBits","outBits","pad","bits","maxV","module","exports","decodeUnsafe","apply","decode","encode","toWordsUnsafe","Array","isArray","toWords","fromWordsUnsafe","fromWords","defineProperty","require","ecc","typeforce","wif","UINT256_TYPE","BufferN","NETWORK_TYPE","compile","UInt8","bip32","public","UInt32","private","BITCOIN","messagePrefix","pubKeyHash","HIGHEST_BIT","UINT31_MAX","pow","BIP32Path","String","match","UInt31","BIP32","__D","__Q","network","__DEPTH","__INDEX","__PARENT_FINGERPRINT","lowR","pointFromScalar","privateKey","identifier","hash160","compressed","isNeutered","neutered","fromPublicKeyLocal","toBase58","toWIF","derive","isHardened","I","hmacSHA512","IL","IR","isPrivate","hd","Ki","ki","privateAdd","fromPrivateKeyLocal","deriveHardened","derivePath","splitPath","reduce","prevHd","indexStr","parseInt","sign","counter","writeUIntLE","signWithEntropy","fromPrivateKey","isPoint","fromBase58","inString","fromPublicKey","fromSeed","seed","createHash","createHmac","sha256Hash","err","bip32_1","networks","payments","bscript","types","fromBase58Check","payload","fromBech32","toBase58Check","tuple","Hash160bit","toBech32","unshift","fromOutputScript","bitcoin","p2wsh","toASM","toOutputScript","decodeBase58","decodeBech32","bufferutils_1","bcrypto","fastMerkleRoot","errorMerkleNoTxes","errorWitnessNotSegwit","Block","prevHash","merkleRoot","witnessCommit","nonce","transactions","fromBuffer","bufferReader","readTransaction","Transaction","byteLength","nTransactions","getWitnessCommit","fromHex","hex","calculateTarget","exponent","mantissa","target","writeUIntBE","calculateMerkleRoot","forWitness","getHash","Function","txesHaveWitnessCommit","rootHash","witnessCommits","outs","filter","out","hasWitnessCommit","hasWitness","weight","headersOnly","allowWitness","encodingLength","a","getId","reverseBuffer","getUTCDate","date","setUTCSeconds","bufferWriter","txSize","toHex","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","actualMerkleRoot","actualWitnessCommit","verifuint","max","readUInt64LE","writeUInt64LE","j","tmp","cloneBuffer","clone","writeVector","script_1","multisig","nullData","witnessCommitment","witnessPubKeyHash","witnessScriptHash","P2MS","NONSTANDARD","NULLDATA","P2PK","P2PKH","P2SH","P2WPKH","P2WSH","WITNESS_COMMITMENT","check","decompile","allowIncomplete","sha1","NETWORKS","randomBytes","isOptions","maybe","Boolean","Network","ECPair","Buffer256bit","fromWIF","wifString","decoded","pop","makeRandom","rng","d","Psbt","OPS","TransactionBuilder","regtest","testnet","networks_1","lazy","typef","p2data","validate","arrayOf","o","prop","OP_RETURN","every","stacksEqual","embed_1","embed","p2ms_1","p2ms","p2pk_1","p2pk","p2pkh_1","p2sh_1","p2wpkh_1","p2wsh_1","object","f","configurable","enumerable","_value","call","writable","OP_INT_BASE","OP_RESERVED","isAcceptableSignature","isCanonicalScriptSignature","OP_0","OP_CHECKMULTISIG","_chunks","OP_CHECKSIG","_address","OP_DUP","OP_HASH160","OP_EQUALVERIFY","hash2","pkh","redeem","_redeem","OP_EQUAL","nameParts","join","checkRedeem","hasInput","richunks","isPushOnly","isBuffer","EMPTY_BUFFER","shift","chunkHasUncompressedPubkey","chunk","_rchunks","stack","toStack","wScript","bip174_1","utils_1","address_1","crypto_1","ecpair_1","DEFAULT_OPTS","maximumFeeRate","PsbtTransaction","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","unsignedTx","__UNSAFE_SIGN_NONSEGWIT","setVersion","dpew","obj","attr","fromBase64","psbtBase","transactionFromBuffer","cache","checkTxInputCache","setLocktime","txInputs","txOutputs","_","combine","those","JSON","parse","stringify","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","__EXTRACTED_TX","addInputs","inputDatas","inputData","addInput","checkInvalidP2WSH","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","outputData","addOutput","extractTransaction","disableFeeCheck","isFinalized","feeRate","getFeeRate","vsize","virtualSize","satoshis","toFixed","checkFees","inputFinalizeGetAmts","getTxCacheValue","getFee","finalizeAllInputs","checkForInput","range","finalizeInput","finalScriptsFunc","getFinalScripts","isP2SH","isP2WSH","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutIndex","witnessUtxo","isP2WPKH","getScriptFromInput","sighashType","partialSig","pSig","hashType","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","getInputType","getMeaningfulScript","getScriptFromUtxo","finalScript","decomp","lastItem","isPubkeyLike","redeemFromFinalScriptSig","scriptWitnessToWitnessStack","redeemFromFinalWitnessScript","type","classifyScript","meaningfulScript","inputHasPubkey","pubkeyInScript","pubkeyInInput","inputHasHDKey","derivationIsMine","bip32DerivationIsMine","bip32Derivation","outputHasPubkey","pubkeyInOutput","checkForOutput","outputHasHDKey","validateSignaturesOfAllInputs","validateSignaturesOfInput","final","mySigs","hashCache","scriptCache","sighashCache","getHashForSig","checkScriptForPubkey","keypair","signAllInputsHD","hdKeyPair","sighashTypes","SIGHASH_ALL","signInputHD","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","all","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","entries","getHashAndSighashType","checkCache","toBase64","updateGlobal","updateData","updateOutput","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","hasSigs","neededSigs","sigs","pkey","find","isPaymentFactory","payment","isP2MS","isP2PK","isP2PKH","isP2WSHScript","isP2SHScript","num","action","throws","pSigs","scriptItems","witnessItems","item","getPsigsFromInputFinalScripts","whitelist","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","indexOf","scriptCheckerFactory","paymentScriptName","ioType","redeemScriptOutput","checkRedeemScript","checkWitnessScript","mustFinalize","scriptType","canFinalize","pk","ps","getSortedSigs","getPayment","witnessStackToScriptWitness","prepareFinalScripts","forValidate","text","sighashTypeToString","prevoutHash","utxoHash","hashForWitnessV0","signingScript","hashForSignature","myDerivations","bipDv","currentLen","varintLen","self","selfIndex","txCache","newBuf","inputAmount","nwTx","vout","outputAmount","fee","isCanonicalPubKey","isP2SHP2WSH","decompiled","scriptNumber","scriptSignature","bip66","pushdata","REVERSE_OPS","isPushOnlyChunk","OP_1","OP_16","OP_1NEGATE","isOPInt","asMinimalOP","chunksIsBuffer","singleChunkIsBuffer","bufferSize","accum","opcode","OP_PUSHDATA4","number","op","isDefinedHashType","hashTypeMod","fromASM","asm","chunkStr","Hex","maxLength","minimal","_number","abs","negative","ZERO","toDER","fromDER","bstart","hashTypeBuffer","partialSignature","toJSON","p2wpkho","p2wsho","lastChunk","scriptSigChunks","redeemScriptChunks","HEADER","Hash256bit","witnessScriptChunks","witnessRawScriptSig","varSliceSize","someScript","EMPTY_SCRIPT","EMPTY_WITNESS","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","valueBuffer","_NO_STRICT","marker","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","vinLen","voutLen","isCoinbaseHash","isCoinbase","Null","Satoshi","_ALLOW_WITNESS","sum","someVector","vectorSize","newTx","txIn","txOut","inIndex","prevOutScript","ourScript","OP_CODESEPARATOR","txTmp","y","__toBuffer","tbuffer","hashOutputs","hashPrevouts","hashSequence","txOutsSize","initialOffset","setInputScript","setWitness","baddress","classify","SCRIPT_TYPES","PREVOUT_TYPES","tfMessage","__PREV_TX_SET","__INPUTS","__USE_LOW_R","fromTransaction","txb","setLockTime","__addInputUnsafe","vin","redeemScriptType","unmatched","parsed","fixMultisigOrder","setLowR","setting","txHash","__canModifyInputs","txIsTransaction","__canModifyOutputs","build","__build","buildIncomplete","signParams","witnessValue","ourPubKey","signatureHash","useLowR","signed","trySign","needsOutputs","prevOutScriptType","Signer","prevOutType","posType","checkSignArgs","getPublicKey","canSign","prepared","p2wshAlt","p2shAlt","expanded","expandOutput","signScript","witnessScriptType","signType","maxSignatures","prepareInput","getSigningData","__needsOutputs","bind","prevTxOut","expandInput","__overMaximumFees","signatureHashType","signingHashType","nInputs","nOutputs","witnessStack","ssType","wsType","outputType","pkh1","pkh2","wpkh1","wpkh2","UInt53","ECPoint","quacksLike","oneOf","basex","base58","checksumFn","decodeRaw","newChecksum","string","bs58checkBase","ANY","Symbol","Comparator","comp","parseOptions","loose","trim","debug","operator","re","COMPARATORLOOSE","COMPARATOR","SemVer","test","er","cmp","intersects","Range","includePrerelease","startsWith","safeRe","SPACE_CHARACTERS","raw","formatted","replace","parseRange","first","isNullSet","isAny","comps","memoKey","FLAG_INCLUDE_PRERELEASE","FLAG_LOOSE","cached","hr","HYPHENRANGELOOSE","HYPHENRANGE","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","rangeList","parseComparator","replaceGTE0","rangeMap","comparators","thisComparators","isSatisfiable","rangeComparators","thisComparator","rangeComparator","testSet","remainingComparators","testComparator","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","id","replaceTilde","TILDELOOSE","TILDE","M","pr","replaceCaret","CARETLOOSE","CARET","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","prerelease","allowed","major","minor","patch","MAX_LENGTH","compareIdentifiers","LOOSE","FULL","other","compareMain","comparePre","compareBuild","inc","release","identifierBase","base","isNaN","clean","eq","neq","gt","gte","lt","lte","coerce","rtl","coerceRtlRegex","COERCERTLFULL","COERCERTL","next","exec","lastIndex","COERCEFULL","COERCE","versionA","versionB","compareLoose","diff","version1","version2","v1","v2","comparison","v1Higher","highVersion","lowVersion","highHasPre","throwErrors","rcompare","rsort","list","satisfies","valid","internalRe","constants","identifiers","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","src","tokens","SEMVER_SPEC_VERSION","RELEASE_TYPES","rcompareIdentifiers","MAX_SAFE_COMPONENT_LENGTH","MAX_SAFE_BUILD_LENGTH","process","NODE_DEBUG","args","error","numeric","anum","bnum","firstKey","looseOption","freeze","emptyOpts","R","LETTERDASHNUMBER","safeRegexReplacements","createToken","isGlobal","safe","token","makeSafeRegex","RegExp","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCEPLAIN","LONETILDE","LONECARET","r1","r2","versions","maxSV","rangeObj","minSV","minver","setMin","comparator","compver","hilo","gtfn","ltefn","ltfn","ecomp","high","low","prev","ranges","simplified","original","minimumVersionWithPreRelease","minimumVersion","simpleSubset","sub","dom","eqSet","gtltComp","higher","lower","hasDomLT","hasDomGT","higherGT","lowerLT","add","needDomLTPre","needDomGTPre","sawNonNull","OUTER","simpleSub","simpleDom","isSub","subscribers","dispatch","LocalTracer","context","trace","getContext","setContext","updateContext","contextToAdd","getType","setType","withType","withContext","withUpdatedContext","listen","cb","window","__ledgerLogsListen","HARDENED","BIPPath","validatePathArray","fromPathArray","validateString","reqRoot","fromString","prototype","noRoot","oldStyle","inspect","condition","argIndex","framesToPop","OP_PUSHDATA1","OP_PUSHDATA2","readUInt16LE"],"sourceRoot":""}