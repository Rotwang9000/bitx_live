{"version":3,"file":"static/js/266.a01c9998.chunk.js","mappings":"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","sources":["components/wallets/secureKeystore/sol-toolbox.ts"],"sourcesContent":["import { mnemonicToSeedSync } from \"@scure/bip39\";\nimport {\n\tTOKEN_PROGRAM_ID,\n\tcreateAssociatedTokenAccountInstruction,\n\tcreateTransferCheckedInstruction,\n\tgetAccount,\n\tgetAssociatedTokenAddress,\n} from \"@solana/spl-token\";\nimport { type TokenInfo, TokenListProvider } from \"@solana/spl-token-registry\";\nimport {\n\tConnection,\n\tKeypair,\n\tPublicKey,\n\tSystemProgram,\n\tTransaction,\n\tsendAndConfirmTransaction,\n} from \"@solana/web3.js\";\nimport {\n\tAssetValue,\n\tChain,\n\tDerivationPath,\n\tRPCUrl,\n\tSwapKitError,\n\tSwapKitNumber,\n\ttype WalletTxParams,\n} from \"@swapkit/helpers\";\nimport { HDKey } from \"micro-key-producer/slip10.js\";\n\nexport function validateAddress(address: string) {\n\ttry {\n\t\tconst pubkey = new PublicKey(address);\n\t\treturn true;//PublicKey.isOnCurve(pubkey.toBytes());\n\t} catch (_) {\n\t\treturn false;\n\t}\n}\n\nfunction createKeysForPath({\n\tphrase,\n\tderivationPath = DerivationPath.SOL,\n}: {\n\tphrase: string;\n\tderivationPath?: string;\n}) {\n\tconst seed = mnemonicToSeedSync(phrase);\n\tconst hdKey = HDKey.fromMasterSeed(seed);\n\n\treturn Keypair.fromSeed(hdKey.derive(derivationPath, true).privateKey);\n}\n\nfunction getAddressFromKeys(keypair: Keypair) {\n\treturn keypair.publicKey.toString();\n}\n\nasync function getTokenBalances({\n\tconnection,\n\taddress,\n}: {\n\tconnection: Connection;\n\taddress: string;\n}) {\n\tconst tokenAccounts = await connection.getParsedTokenAccountsByOwner(new PublicKey(address), {\n\t\tprogramId: TOKEN_PROGRAM_ID,\n\t});\n\tconst tokenListProvider = new TokenListProvider();\n\tconst tokenListContainer = await tokenListProvider.resolve();\n\tconst tokenList = tokenListContainer.filterByChainId(101).getList();\n\n\tconst tokenBalances: AssetValue[] = [];\n\n\tfor await (const tokenAccountInfo of tokenAccounts.value) {\n\t\tconst accountInfo = tokenAccountInfo.account.data.parsed.info;\n\t\tconst tokenAmount = accountInfo.tokenAmount.uiAmount;\n\t\tconst mintAddress = accountInfo.mint;\n\t\tconst decimal = accountInfo.tokenAmount.decimals;\n\n\t\t// Find the token info from the token list\n\t\tconst tokenInfo = tokenList.find((token: TokenInfo) => token.address === mintAddress);\n\n\t\tconst tokenSymbol = tokenInfo ? tokenInfo.symbol : \"UNKNOWN\";\n\n\t\tif (tokenAmount > BigInt(0)) {\n\t\t\ttokenBalances.push(\n\t\t\t\tnew AssetValue({\n\t\t\t\t\tvalue: SwapKitNumber.fromBigInt(accountInfo.tokenAmount.amount, decimal),\n\t\t\t\t\tdecimal,\n\t\t\t\t\tidentifier: `${Chain.Solana}.${tokenSymbol}-${address.toString()}`,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn tokenBalances;\n}\n\nfunction getBalance(connection: Connection) {\n\treturn async (address: string) => {\n\t\tconst SOLBalance = await connection.getBalance(new PublicKey(address));\n\t\tconst tokenBalances = await getTokenBalances({ connection, address });\n\n\t\treturn [AssetValue.from({ chain: Chain.Solana, value: BigInt(SOLBalance) }), ...tokenBalances];\n\t};\n}\n\nexport async function createSolanaTokenTransaction({\n\ttokenAddress,\n\trecipient,\n\tfrom,\n\tconnection,\n\tamount,\n\tdecimals,\n}: {\n\ttokenAddress: string;\n\trecipient: string;\n\tfrom: PublicKey;\n\tconnection: Connection;\n\tamount: number;\n\tdecimals: number;\n}) {\n\tconst transaction = new Transaction();\n\tconst tokenPublicKey = new PublicKey(tokenAddress);\n\tconst fromSPLAddress = await getAssociatedTokenAddress(tokenPublicKey, from);\n\n\tconst recipientPublicKey = new PublicKey(recipient);\n\tconst recipientSPLAddress = await getAssociatedTokenAddress(tokenPublicKey, recipientPublicKey);\n\n\ttry {\n\t\tawait getAccount(connection, recipientSPLAddress);\n\t\treturn transaction.add(\n\t\t\tcreateTransferCheckedInstruction(\n\t\t\t\tfromSPLAddress,\n\t\t\t\ttokenPublicKey,\n\t\t\t\trecipientSPLAddress,\n\t\t\t\tfrom,\n\t\t\t\tamount,\n\t\t\t\tdecimals,\n\t\t\t),\n\t\t);\n\t} catch (_) {\n\t\treturn transaction.add(\n\t\t\tcreateAssociatedTokenAccountInstruction(\n\t\t\t\tfrom,\n\t\t\t\trecipientSPLAddress,\n\t\t\t\trecipientPublicKey,\n\t\t\t\ttokenPublicKey,\n\t\t\t),\n\t\t);\n\t}\n}\n\nfunction transfer(connection: Connection) {\n\treturn async ({\n\t\trecipient,\n\t\tassetValue,\n\t\tfromKeypair,\n\t}: WalletTxParams & {\n\t\tassetValue: AssetValue;\n\t\tfromKeypair: Keypair;\n\t}) => {\n\t\tif (!validateAddress(recipient)) {\n\t\t\tthrow new SwapKitError(\"core_transaction_invalid_recipient_address\");\n\t\t}\n\n\t\tconst transaction = assetValue.isGasAsset\n\t\t\t? new Transaction().add(\n\t\t\t\tSystemProgram.transfer({\n\t\t\t\t\tfromPubkey: fromKeypair.publicKey,\n\t\t\t\t\tlamports: assetValue.getValue(\"bigint\"),\n\t\t\t\t\ttoPubkey: new PublicKey(recipient),\n\t\t\t\t}),\n\t\t\t)\n\t\t\t: assetValue.address\n\t\t\t\t? await createSolanaTokenTransaction({\n\t\t\t\t\tamount: assetValue.getValue(\"number\"),\n\t\t\t\t\tconnection,\n\t\t\t\t\tdecimals: assetValue.decimal as number,\n\t\t\t\t\tfrom: fromKeypair.publicKey,\n\t\t\t\t\trecipient,\n\t\t\t\t\ttokenAddress: assetValue.address,\n\t\t\t\t})\n\t\t\t\t: undefined;\n\n\t\tif (!transaction) {\n\t\t\tthrow new SwapKitError(\"core_transaction_invalid_sender_address\");\n\t\t}\n\n\t\tconst blockHash = await connection.getLatestBlockhash();\n\t\ttransaction.recentBlockhash = blockHash.blockhash;\n\t\ttransaction.feePayer = fromKeypair.publicKey;\n\n\t\treturn sendAndConfirmTransaction(connection, transaction, [fromKeypair]);\n\t};\n}\n\nexport const SOLToolbox = ({ rpcUrl = RPCUrl.Solana }: { rpcUrl?: string } = {}) => {\n\tconst connection = new Connection(rpcUrl, \"confirmed\");\n\n\treturn {\n\t\tconnection,\n\t\tcreateKeysForPath,\n\t\tgetAddressFromKeys,\n\t\tgetBalance: getBalance(connection),\n\t\ttransfer: transfer(connection),\n\t\tvalidateAddress,\n\t};\n};"],"names":["validateAddress","address","PublicKey","_","createKeysForPath","phrase","derivationPath","DerivationPath","SOL","seed","mnemonicToSeedSync","hdKey","HDKey","fromMasterSeed","Keypair","fromSeed","derive","privateKey","getAddressFromKeys","keypair","publicKey","toString","getBalance","connection","async","SOLBalance","tokenBalances","tokenAccounts","getParsedTokenAccountsByOwner","programId","TOKEN_PROGRAM_ID","tokenListProvider","TokenListProvider","tokenList","resolve","filterByChainId","getList","tokenAccountInfo","value","accountInfo","account","data","parsed","info","tokenAmount","uiAmount","mintAddress","mint","decimal","decimals","tokenInfo","find","token","tokenSymbol","symbol","BigInt","push","AssetValue","SwapKitNumber","fromBigInt","amount","identifier","Chain","Solana","getTokenBalances","from","chain","transfer","recipient","assetValue","fromKeypair","SwapKitError","transaction","isGasAsset","Transaction","add","SystemProgram","fromPubkey","lamports","getValue","toPubkey","tokenAddress","tokenPublicKey","fromSPLAddress","getAssociatedTokenAddress","recipientPublicKey","recipientSPLAddress","getAccount","createTransferCheckedInstruction","createAssociatedTokenAccountInstruction","createSolanaTokenTransaction","undefined","blockHash","getLatestBlockhash","recentBlockhash","blockhash","feePayer","sendAndConfirmTransaction","SOLToolbox","rpcUrl","RPCUrl","Connection"],"sourceRoot":""}