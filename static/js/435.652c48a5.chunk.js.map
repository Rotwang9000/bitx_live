{"version":3,"file":"static/js/435.652c48a5.chunk.js","mappings":"8OAaM,SAAUA,EAAqBC,GACnC,MAAMC,EAASC,EAAOC,MAAM,EAAmB,EAAfH,EAAMI,QAKtC,OAJAH,EAAO,GAAKD,EAAMI,OAClBJ,EAAMK,SAAQ,CAACC,EAASC,KACtBN,EAAOO,cAAcF,EAAS,EAAI,EAAIC,EAAM,IAEvCN,CACT,CAEM,SAAUQ,EAAcC,GAE5B,OAAOX,EADeW,EAAYC,EAAkBD,GAAvB,GAE/B,CAEM,SAAUE,EAAkBC,GAIhC,OAAOC,IAAAA,cAAsBD,GAAcE,UAC7C,CAEM,SAAUJ,EAAkBD,GAChC,OAAOI,IAAAA,WAAmBJ,GAAMM,aAClC,CAEM,SAAUC,EAAeC,GAC7B,MAAMC,EAAUC,IAAAA,OAAiBF,GACjC,OAAOC,EAAQE,MAAMF,EAAQf,OAAS,GACxC,CAEM,SAAUkB,EAAkBJ,GAKhC,MAAMC,EAAkBC,IAAAA,OAAiBF,GACzC,MAAO,CACLK,UAAWJ,EAAQE,MAAM,GAAI,IAC7BG,OAAQL,EAAQE,MAAMF,EAAQf,OAAS,IACvCqB,QAASN,EAAQO,aAAa,GAElC,C,0CCpDM,SAAUC,EAAgBC,GAE9B,GAAIA,EAAIC,OAAOC,iBACb,MAAM,IAAIC,MAAM,wCAElB,MAAMC,EAAY9B,EAAOC,MAAM,EAAG,GAClC,IAAK,IAAII,EAAQ,EAAGA,EAAQyB,EAAU5B,OAAQG,IAAS,CACrD,MAAM0B,EAAW,IAAJL,EACbI,EAAUzB,GAAS0B,EACnBL,GAAKA,EAAIK,GAAQ,GACnB,CACA,OAAOD,CACT,CAEM,SAAUE,EAAkBF,GAChC,IAAIG,EAAQ,EACZ,GAAwB,GAApBH,EAAU5B,OACZ,MAAM,IAAI2B,MAAM,gCAElB,GAAoB,GAAhBC,EAAU,GACZ,MAAM,IAAID,MAAM,uCAElB,GAAIC,EAAU,GAAK,GACjB,MAAM,IAAID,MAAM,uCAElB,IAAK,IAAIK,EAAIJ,EAAU5B,OAAS,EAAGgC,GAAK,EAAGA,IACzCD,EAAgB,IAARA,EAAcH,EAAUI,GAElC,OAAOD,CACT,CAEM,MAAOE,EAAbC,WAAAA,GACU,KAAAC,KAAiB,EAyC3B,CAvCEC,KAAAA,CAAMrC,EAAesC,GACnB,MAAMC,EAAIxC,EAAOC,MAAMA,GACvBsC,EAAGC,GACHC,KAAKJ,KAAKK,KAAKF,EACjB,CAEAG,UAAAA,CAAWT,GACTO,KAAKH,MAAM,GAAGE,GAAKA,EAAEG,WAAWT,EAAG,IACrC,CAEAU,UAAAA,CAAWV,GACTO,KAAKH,MAAM,GAAGE,GAAKA,EAAEK,aAAaX,EAAG,IACvC,CAEAY,WAAAA,CAAYZ,GACVO,KAAKH,MAAM,GAAGE,GAAKA,EAAEO,cAAcb,EAAG,IACxC,CAEAc,WAAAA,CAAYd,GACV,MAAMe,EAAQxB,EAAgBS,GAC9BO,KAAKS,WAAWD,EAClB,CAEAE,WAAAA,CAAYjB,GACVO,KAAKJ,KAAKK,KAAKU,IAAAA,OAAelB,GAChC,CAEAgB,UAAAA,CAAW/B,GACTsB,KAAKJ,KAAKK,KAAK1C,EAAOqD,KAAKlC,GAC7B,CAEAmC,aAAAA,CAAcnC,GACZsB,KAAKU,YAAYhC,EAAMjB,QACvBuC,KAAKS,WAAW/B,EAClB,CAEApB,MAAAA,GACE,OAAOC,EAAOuD,OAAOd,KAAKJ,KAC5B,EAGI,MAAOmB,EACXpB,WAAAA,CACSrC,EACA0D,EAAiB,GADjB,KAAA1D,OAAAA,EACA,KAAA0D,OAAAA,CACN,CAEHC,SAAAA,GACE,OAAOjB,KAAK1C,OAAOG,OAASuC,KAAKgB,MACnC,CAEAE,SAAAA,GACE,MAAMC,EAASnB,KAAK1C,OAAO4D,UAAUlB,KAAKgB,QAE1C,OADAhB,KAAKgB,SACEG,CACT,CAEAC,SAAAA,GACE,MAAMD,EAASnB,KAAK1C,OAAO+D,YAAYrB,KAAKgB,QAE5C,OADAhB,KAAKgB,QAAU,EACRG,CACT,CAEAG,UAAAA,GACE,MAAMH,EAASnB,KAAK1C,OAAOiE,aAAavB,KAAKgB,QAE7C,OADAhB,KAAKgB,QAAU,EACRG,CACT,CAEAK,UAAAA,GAGE,OADUjC,EADES,KAAKyB,UAAU,GAG7B,CAEAC,UAAAA,GACE,MAAMC,EAAKhB,IAAAA,OAAeX,KAAK1C,OAAQ0C,KAAKgB,QAE5C,OADAhB,KAAKgB,QAAUL,IAAAA,OAAeH,MACvBmB,CACT,CAEAF,SAAAA,CAAUxC,GACR,GAAIe,KAAK1C,OAAOG,OAASuC,KAAKgB,OAAS/B,EACrC,MAAM,IAAIG,MAAM,mCAElB,MAAM+B,EAASnB,KAAK1C,OAAOoB,MAAMsB,KAAKgB,OAAQhB,KAAKgB,OAAS/B,GAE5D,OADAe,KAAKgB,QAAU/B,EACRkC,CACT,CAEAS,YAAAA,GACE,OAAO5B,KAAKyB,UAAUzB,KAAK0B,aAC7B,CAEAG,UAAAA,GACE,MAAMC,EAAQ9B,KAAK0B,aACbK,EAAmB,GACzB,IAAK,IAAItC,EAAI,EAAGA,EAAIqC,EAAOrC,IAAKsC,EAAO9B,KAAKD,KAAK4B,gBACjD,OAAOG,CACT,ECrIK,MAAMC,EAAmB,GAInBC,EAAmB,W,4CCJ1B,SAAUC,EAAc5E,GAC5B,OAAO,IAAI6E,MAAYC,OAAOC,IAAI,UAAUD,OAAO9E,GAAQgF,UAAUA,QACvE,C,sBCoEA,MAAeC,EACb5C,WAAAA,CACY6C,EACAC,GADA,KAAAD,KAAAA,EACA,KAAAC,SAAAA,CACT,EAQL,MAAeC,UAAyBH,EACtCI,iBAAAA,CAAkBC,GAChB,GAAsB,GAAlBA,EAAQnF,OACV,MAAM,IAAI2B,MAAM,4BAA8BwD,EAAQnF,QAExD,OAAOuC,KAAK6C,mBAAmBD,EAAQ,GACzC,CAGAE,QAAAA,CACErD,EACAsD,EACAC,EACAJ,EACAK,GAEA,GAAsB,GAAlBL,EAAQnF,OACV,MAAM,IAAI2B,MAAM,4BAA8BwD,EAAQnF,QAExD,GAAwB,GAApBwF,EAAUxF,OACZ,MAAM,IAAI2B,MAAM,6BAA+B6D,EAAUxF,QAE3DuC,KAAKkD,kBAAkBzD,EAAGsD,EAASC,EAAaJ,EAAQ,GAAIK,EAAU,GACxE,CASAE,YAAAA,CAAa1D,EAAW2D,EAAyBR,EAAmBvF,GAClE,GAAsB,GAAlBuF,EAAQnF,OACV,MAAM,IAAI2B,MAAM,4BAA8BwD,EAAQnF,QAExD,GAAoB,GAAhBJ,EAAMI,OACR,MAAM,IAAI2B,MAAM,6BAA+B/B,EAAMI,QAEvDuC,KAAKqD,mBAAmB5D,EAAG2D,EAAMR,EAAQ,GAAIvF,EAAM,GACrD,EASI,MAAOiG,UAAcZ,EACzBG,kBAAAA,CAAmBhE,GACjB,MAAM0E,EAAM,IAAI7D,EACV8D,EAAatB,EAAcrD,GAIjC,OAHA0E,EAAI9C,WAAWlD,EAAOqD,KAAK,CF9HT,IACI,IACD,ME6HrB2C,EAAI9C,WAAW+C,GACfD,EAAI9C,WAAWlD,EAAOqD,KAAK,CF5HD,IACH,OE4HhB,CAAE6C,aAAcF,EAAIjG,SAC7B,CAEA4F,iBAAAA,CACEzD,EACAsD,EACAW,EACA7E,EACAd,GAEA,IAAKgF,EACH,MAAM,IAAI3D,MAAM,wCAElBY,KAAKwC,KAAKmB,uBAAuBlE,EAAGsD,GACpC/C,KAAKwC,KAAKoB,wBAAwBnE,EAAGZ,EAAQmB,KAAKyC,SAAU1E,EAC9D,CAEAsF,kBAAAA,CAAmB5D,EAAW2D,EAAyBvE,EAAgBd,GACrEiC,KAAKwC,KAAKqB,yBAAyBpE,EAAGZ,EAAQmB,KAAKyC,SAAU1E,EAC/D,CAEA+F,qBAAAA,GACE,MAAO,SACT,EAGI,MAAOC,UAAarB,EACxBG,kBAAAA,CAAmBhE,GACjB,MAAMmF,EAAcnF,EAAOH,MAAM,GAC3B6E,EAAM,IAAI7D,EACVuE,EAAYjE,KAAKkE,oBAAoBF,GAG3C,OAFAT,EAAI9C,WAAWlD,EAAOqD,KAAK,CAAC,GAAM,MAClC2C,EAAI9C,WAAWwD,GACR,CAAER,aAAcF,EAAIjG,SAC7B,CAEA4F,iBAAAA,CACEzD,EACA0E,EACAnB,EACAnE,EACAd,GAEA,MAAMqG,EAAQvF,EAAOH,MAAM,GAC3BsB,KAAKwC,KAAK6B,2BAA2B5E,EAAG2E,EAAO,GAAIpE,KAAKyC,SAAU1E,GAClEiC,KAAKwC,KAAK8B,oBAAoB7E,EAAGuD,EAAYuB,OAAQvB,EAAYI,KAAKK,aACxE,CAEAJ,kBAAAA,CAAmB5D,EAAW2D,EAAyBvE,EAAgBd,GACrE,MAAMqG,EAAQvF,EAAOH,MAAM,GAC3BsB,KAAKwC,KAAKgC,4BAA4B/E,EAAG2E,EAAO,GAAIpE,KAAKyC,SAAU1E,EACrE,CAEA+F,qBAAAA,GACE,MAAO,QACT,CAMQW,YAAAA,CAAaC,GAGnB,MAAMC,EAAIC,EAAAA,GAAOC,OAAOtH,EAAOqD,KAAK,WAAY,UAChD,OAAOgE,EAAAA,GAAOC,OAAOtH,EAAOuD,OAAO,CAAC6D,EAAGA,EAAGD,IAC5C,CAWAR,mBAAAA,CAAoBY,GAClB,GAA6B,IAAzBA,EAAerH,OACjB,MAAM,IAAI2B,MAAM,gCAAkC0F,EAAerH,QAMnE,MAAMsH,EAAkBxH,EAAOuD,OAAO,CAACvD,EAAOqD,KAAK,CAAC,IAAQkE,IACtDE,EAAQhF,KAAKyE,aAAaK,GAOhC,OAJuBvH,EAAOqD,MAAKqE,EAAAA,EAAAA,gBAAeF,EAAiBC,IAE3BtG,MAAM,EAGhD,EAGI,MAAOwG,UAAsBxC,EACjCG,kBAAAA,CAAmBhE,GACjB,MAAM0E,EAAM,IAAI7D,EACVyF,EAAenF,KAAKoF,mBAAmBvG,GACvCwG,EAAanD,EAAciD,GAIjC,OAHA5B,EAAI9C,WAAWlD,EAAOqD,KAAK,CFtOL,IACD,MEsOrB2C,EAAI9C,WAAW4E,GACf9B,EAAIrD,WFtOgB,KEuOb,CAAEuD,aAAcF,EAAIjG,SAAU6H,aAAcA,EACrD,CAEAjC,iBAAAA,CACEzD,EACAsD,EACAC,EACAnE,EACAd,GAEA,IAAKgF,EACH,MAAM,IAAI3D,MAAM,wCAElBY,KAAKwC,KAAKmB,uBAAuBlE,EAAGsD,GACpC/C,KAAKwC,KAAKoB,wBAAwBnE,EAAGZ,EAAQmB,KAAKyC,SAAU1E,GAE5D,MAAMuH,EAA2BtC,EAAYI,KAAK+B,aAC5CI,EAAuBvF,KAAKoF,mBAAmBvG,GACrD,GAAIyG,IAA6BC,EAAqBC,OAAOF,GAE3D,MAAM,IAAIlG,MAAM,8BAA8BkG,EAAyBlH,SACrE,yCAEgBmH,EAAqBnH,SAAS,oBAAoBqB,KAEtEO,KAAKwC,KAAKiD,qBAAqBhG,EAAG8F,GAClCvF,KAAKwC,KAAK8B,oBAAoB7E,EAAGuD,EAAYuB,OAAQvB,EAAYI,KAAKK,aACxE,CAEAJ,kBAAAA,CAAmB5D,EAAW2D,EAAyBvE,EAAgBd,GACrEiC,KAAKwC,KAAKkD,sBAAsBjG,EAAG2D,EAAK+B,cACxCnF,KAAKwC,KAAKqB,yBAAyBpE,EAAGZ,EAAQmB,KAAKyC,SAAU1E,EAC/D,CAEA+F,qBAAAA,GACE,MAAO,cACT,CAEQsB,kBAAAA,CAAmBvG,GACzB,MAAM2E,EAAatB,EAAcrD,GACjC,OAAOtB,EAAOuD,OAAO,CAACvD,EAAOqD,KAAK,OAAQ,OAAQ4C,GACpD,EAGI,MAAOmC,UAAejD,EAC1BG,kBAAAA,CAAmBhE,GACjB,MAAM0E,EAAM,IAAI7D,EACV8D,EAAatB,EAAcrD,GAGjC,OAFA0E,EAAI9C,WAAWlD,EAAOqD,KAAK,CAAC,EFxRP,MEyRrB2C,EAAI9C,WAAW+C,GACR,CAAEC,aAAcF,EAAIjG,SAC7B,CAEA4F,iBAAAA,CACEzD,EACAsD,EACAC,EACAnE,EACAd,GAEA,IAAKgF,EACH,MAAM,IAAI3D,MAAM,wCAElBY,KAAKwC,KAAKmB,uBAAuBlE,EAAGsD,GACpC/C,KAAKwC,KAAKoB,wBAAwBnE,EAAGZ,EAAQmB,KAAKyC,SAAU1E,GAC5DiC,KAAKwC,KAAK8B,oBAAoB7E,EAAGuD,EAAYuB,OAAQvB,EAAYI,KAAKK,aACxE,CAEAJ,kBAAAA,CAAmB5D,EAAW2D,EAAyBvE,EAAgBd,GACrEiC,KAAKwC,KAAKqB,yBAAyBpE,EAAGZ,EAAQmB,KAAKyC,SAAU1E,EAC/D,CAEA+F,qBAAAA,GACE,MAAO,UACT,E,sBCxTI,MAAO8B,EAKXjG,WAAAA,CAAYkG,EAAkBC,EAAkClB,EAAAA,GAAOC,QACrE7E,KAAK6F,OAASA,EACd7F,KAAK2E,EAAImB,EACT,MAAMC,EAAQ/F,KAAKgG,cAAcH,GACjC7F,KAAKiG,SAAWF,EAAMG,KACtBlG,KAAKmG,UAAYJ,EAAMF,MACzB,CACAO,OAAAA,GACE,OAAOpG,KAAKiG,SAASI,IACvB,CACAC,IAAAA,GACE,OAAOtG,KAAK6F,OAAOpI,MACrB,CACA8I,SAAAA,GACE,OAAOvG,KAAK6F,MACd,CACAW,WAAAA,CAAY5I,GACV,OAAOoC,KAAKmG,UAAUvI,GAAOyI,IAC/B,CACAI,QAAAA,CAAS7I,GACP,GAAIA,GAASoC,KAAK6F,OAAOpI,OAAQ,MAAM2B,MAAM,uBAC7C,OAAOsH,EAAU1G,KAAKmG,UAAUvI,GAClC,CAEAoI,aAAAA,CAAcH,GACZ,MAAM5G,EAAI4G,EAAOpI,OACjB,GAAS,GAALwB,EACF,MAAO,CACLiH,KAAM,IAAIS,OAAKC,OAAWA,EAAWrJ,EAAOC,MAAM,GAAI,IACtDqI,OAAQ,IAGZ,GAAS,GAAL5G,EAAQ,CACV,MAAM4H,EAAU,IAAIF,OAAKC,OAAWA,EAAWf,EAAO,IACtD,MAAO,CAAEK,KAAMW,EAAShB,OAAQ,CAACgB,GACnC,CACA,MAAMC,EA4DV,SAAiC7H,GAC/B,GAAIA,EAAI,EACN,MAAMG,MAAM,mBAEd,GAMF,SAAoBH,GAClB,OAAwB,IAAhBA,EAAKA,EAAI,EACnB,CARM8H,CAAW9H,GACb,OAAOA,EAAI,EAEb,OAAO,GAAK+H,KAAKC,MAAMD,KAAKE,KAAKjI,GACnC,CApEsBkI,CAAwBlI,GACpCmI,EAAapH,KAAKgG,cAAcH,EAAOnH,MAAM,EAAGoI,IAChDO,EAAcrH,KAAKgG,cAAcH,EAAOnH,MAAMoI,IAC9CQ,EAAYF,EAAWlB,KACvBqB,EAAaF,EAAYnB,KACzBG,EAAOrG,KAAKwH,SAASF,EAAUjB,KAAMkB,EAAWlB,MAChDoB,EAAO,IAAId,EAAKW,EAAWC,EAAYlB,GAG7C,OAFAiB,EAAUI,OAASD,EACnBF,EAAWG,OAASD,EACb,CAAEvB,KAAMuB,EAAM5B,OAAQuB,EAAWvB,OAAO/E,OAAOuG,EAAYxB,QACpE,CAEA2B,QAAAA,CAASG,EAAcC,GACrB,OAAO5H,KAAK2E,EAAEpH,EAAOuD,OAAO,CAACvD,EAAOqD,KAAK,CAAC,IAAK+G,EAAMC,IACvD,EAGI,SAAUC,EACdtE,EACAuE,EAAwClD,EAAAA,GAAOC,QAE/C,OAGF,SAAoBkD,EAAcC,EAAcF,GAC9C,OAAOA,EAAavK,EAAOuD,OAAO,CAACiH,EAAMC,IAC3C,CALSC,CAAW1K,EAAOqD,KAAK,CAAC,IAAK2C,EAAKuE,EAC3C,CAMA,MAAMnB,EAKJhH,WAAAA,CAAYgI,EAAwBC,EAAyBvB,GAC3DrG,KAAKsH,UAAYK,EACjB3H,KAAKuH,WAAaK,EAClB5H,KAAKqG,KAAOA,CACd,CACA6B,MAAAA,GACE,YAAyBtB,GAAlB5G,KAAKsH,SACd,EAGF,SAASZ,EAAUe,GACjB,IAAKA,EAAKC,OACR,MAAO,GAET,GAAID,EAAKC,OAAOJ,WAAaG,EAAM,CACjC,IAAKA,EAAKC,OAAOH,WACf,MAAM,IAAInI,MAAM,iCAElB,MAAO,CAACqI,EAAKC,OAAOH,WAAWlB,QAASK,EAAUe,EAAKC,QACzD,CACE,IAAKD,EAAKC,OAAOJ,UACf,MAAM,IAAIlI,MAAM,gCAElB,MAAO,CAACqI,EAAKC,OAAOJ,UAAUjB,QAASK,EAAUe,EAAKC,QAE1D,C,sBC3FM,MAAOS,EAMXxI,WAAAA,CAAYyI,EAA+CC,GACzDrI,KAAKoI,mBAAqBA,EAC1BpI,KAAKsI,KAAO,CAACD,EACf,CAEAE,WAAAA,GAEE,OAAO3D,EAAAA,GAAOC,OAAO7E,KAAKwI,YAC5B,CAEAA,SAAAA,GACE,MAAMC,EAAazI,KAAKsI,KAAKI,KAAIC,GACxBpL,EAAOqD,KAAK+H,EAAG,WAElBC,EAAI,IAAIhD,EAAO6C,EAAWC,KAAIC,GAAKd,EAASc,MAE5CpF,EAAM,IAAI7D,EAKhB,OAJA6D,EAAIrD,WAAW,GACfqD,EAAIrD,WAAW,GACfqD,EAAI1C,cAActD,EAAOqD,KAAKZ,KAAKoI,mBAAoB,UACvD7E,EAAI7C,YAAYV,KAAKsI,KAAK7K,QAAS8F,EAAI9C,WAAWmI,EAAExC,WAC7C7C,EAAIjG,QACb,EAGI,SAAUuL,EAAUC,EAA2B/K,EAAgBQ,GACnE,MAAMwK,EAAc9K,EAAkBF,GACtC,MAAO,IAAI+K,EAAkB1K,SAAS,SAAS2K,EAAYC,UAAU,MAAMzK,MAC7E,C,0BC7CY0K,EAQAC,EAeAC,E,mBAvBZ,SAAYF,GACVA,EAAAA,EAAA,2BACAA,EAAAA,EAAA,yCACAA,EAAAA,EAAA,6BACAA,EAAAA,EAAA,+BACAA,EAAAA,EAAA,iCACAA,EAAAA,EAAA,sBACD,CAPD,CAAYA,IAAAA,EAAU,KAQtB,SAAYC,GACVA,EAAAA,EAAA,uCACAA,EAAAA,EAAA,+BACAA,EAAAA,EAAA,6BACAA,EAAAA,EAAA,+BACAA,EAAAA,EAAA,iCACAA,EAAAA,EAAA,uCACAA,EAAAA,EAAA,qCACAA,EAAAA,EAAA,6CACAA,EAAAA,EAAA,kCACAA,EAAAA,EAAA,gCACAA,EAAAA,EAAA,wBACAA,EAAAA,EAAA,8BACAA,EAAAA,EAAA,+CACD,CAdD,CAAYA,IAAAA,EAAM,KAelB,SAAYC,GACVA,EAAAA,EAAA,iCACAA,EAAAA,EAAA,yCACAA,EAAAA,EAAA,mBACAA,EAAAA,EAAA,mBACAA,EAAAA,EAAA,8CACD,CAND,CAAYA,IAAAA,EAAO,KAQnB,MAAMC,EAAmB7L,EAAOqD,KAAK,CAAC,IAAM,IAAM,GAAM,IAAM,MAExD,MAAOyI,UAAoBjK,OAoB3B,MAAOkK,GAAb3J,WAAAA,GACY,KAAA4J,UAAiC,IAAIC,IACrC,KAAAC,UAAmC,GACnC,KAAAC,WAAoC,EAwXhD,CAtXEC,kBAAAA,CAAmB7K,GACjBkB,KAAK4J,UAAUX,EAAWY,WAAYC,GAAShL,GACjD,CACAiL,kBAAAA,GACE,OAAO/J,KAAKgK,UAAUf,EAAWY,YAAYtI,aAAa,EAC5D,CACA0I,yBAAAA,CAA0BC,GACxBlK,KAAK4J,UAAUX,EAAWkB,kBAAmBL,GAASI,GACxD,CACAE,yBAAAA,G,MACE,OAA2D,QAApDC,EAAArK,KAAKsK,kBAAkBrB,EAAWkB,0BAAkB,IAAAE,OAAA,EAAAA,EAAE9I,aAAa,EAC5E,CACAgJ,mBAAAA,CAAoBC,GAClBxK,KAAK4J,UAAUX,EAAWwB,YAAaC,GAAOF,GAChD,CACAG,mBAAAA,GACE,OAAOC,GAAW5K,KAAKgK,UAAUf,EAAWwB,aAC9C,CACAI,oBAAAA,CAAqBC,GACnB9K,KAAK4J,UAAUX,EAAW8B,aAAcL,GAAOI,GACjD,CACAE,oBAAAA,GACE,OAAOJ,GAAW5K,KAAKgK,UAAUf,EAAW8B,cAC9C,CACAE,qBAAAA,CAAsB3L,GACpBU,KAAK4J,UAAUX,EAAWiC,cAAe5L,EAC3C,CACA6L,qBAAAA,GACE,OAAOnL,KAAKsK,kBAAkBrB,EAAWiC,cAC3C,CACAE,oBAAAA,CAAqBC,GACnBrL,KAAK4J,UAAUX,EAAWqC,QAASxB,GAASuB,GAC9C,CACAE,oBAAAA,GACE,OAAOvL,KAAKgK,UAAUf,EAAWqC,SAAS/J,aAAa,EACzD,CAEAoC,sBAAAA,CAAuB6H,EAAoBC,GACzCzL,KAAK8C,SAAS0I,EAAYtC,EAAOwC,iBAAkB3L,KAAK0L,EAC1D,CACAE,sBAAAA,CAAuBH,GACrB,OAAOxL,KAAK4L,iBAAiBJ,EAAYtC,EAAOwC,iBAAkB3L,KACpE,CACAuE,mBAAAA,CAAoBkH,EAAoBjH,EAAgBd,GACtD,MAAMF,EAAM,IAAI7D,EAChB6D,EAAI9C,WAAW8D,GACfhB,EAAI1C,cAAc4C,GAClBzD,KAAK8C,SAAS0I,EAAYtC,EAAO2C,aAAc9L,KAAKwD,EAAIjG,SAC1D,CACAwO,mBAAAA,CAAoBN,GAClB,MAAMO,EAAO/L,KAAK4L,iBAAiBJ,EAAYtC,EAAO2C,aAAc9L,MACpE,IAAKgM,EAAM,OACX,MAAMxI,EAAM,IAAIxC,EAAagL,GAC7B,MAAO,CAAExH,OAAQhB,EAAI9B,UAAU,GAAIgC,aAAcF,EAAI3B,eACvD,CACAoK,kBAAAA,CAAmBR,EAAoB3M,EAAgBoN,GACrDjM,KAAK8C,SAAS0I,EAAYtC,EAAOgD,YAAarN,EAAQoN,EACxD,CACAE,kBAAAA,CAAmBX,EAAoB3M,GACrC,OAAOmB,KAAK4L,iBAAiBJ,EAAYtC,EAAOgD,YAAarN,EAC/D,CACAuN,mBAAAA,CAAoBZ,EAAoBa,GACtCrM,KAAK8C,SAAS0I,EAAYtC,EAAOoD,aAAcvM,KAAK+J,GAASuC,GAC/D,CACAE,mBAAAA,CAAoBf,GAClB,MAAMrK,EAASnB,KAAK4L,iBAAiBJ,EAAYtC,EAAOoD,aAAcvM,MACtE,GAAKoB,EACL,OAAOA,EAAOI,aAAa,EAC7B,CACAkE,oBAAAA,CAAqB+F,EAAoBrG,GACvCnF,KAAK8C,SAAS0I,EAAYtC,EAAOsD,cAAezM,KAAKoF,EACvD,CACAsH,oBAAAA,CAAqBjB,GACnB,OAAOxL,KAAK4L,iBAAiBJ,EAAYtC,EAAOsD,cAAezM,KACjE,CACA6D,uBAAAA,CACE4H,EACA3M,EACAiK,EACA/K,GAEA,GAAqB,IAAjBc,EAAOpB,OAAc,MAAM,IAAI2B,MAAM,0BAA4BP,EAAOpB,QAC5EuC,KAAK8C,SACH0I,EACAtC,EAAOwD,iBACP7N,EACAmB,KAAK2M,sBAAsB7D,EAAmB/K,GAElD,CACA6O,uBAAAA,CACEpB,EACA3M,GAEA,MAAM0E,EAAMvD,KAAK4L,iBAAiBJ,EAAYtC,EAAOwD,iBAAkB7N,GACvE,GAAK0E,EACL,OAAOvD,KAAK6M,sBAAsBtJ,EACpC,CACAuJ,sBAAAA,CAAuBtB,EAAoBuB,GACzC/M,KAAK8C,SAAS0I,EAAYtC,EAAO8D,gBAAiBjN,KAAKgN,EACzD,CACAE,sBAAAA,CAAuBzB,GACrB,OAAOxL,KAAK4L,iBAAiBJ,EAAYtC,EAAO8D,gBAAiBjN,KACnE,CACAmN,0BAAAA,CAA2B1B,EAAoB2B,GAC7CnN,KAAK8C,SAAS0I,EAAYtC,EAAOkE,oBAAqBrN,KAAKoN,EAC7D,CACAE,0BAAAA,CAA2B7B,GACzB,OAAOxL,KAAKsN,SAAS9B,EAAYtC,EAAOkE,oBAAqBrN,KAC/D,CACAwN,oBAAAA,CAAqB/B,EAAoBgC,GACvCxN,KAAK8C,SAAS0I,EAAYtC,EAAOuE,cAAe1N,KAAKyN,EACvD,CACAE,oBAAAA,CAAqBlC,GACnB,OAAOxL,KAAKsN,SAAS9B,EAAYtC,EAAOuE,cAAe1N,KACzD,CACA4N,mBAAAA,CAAoBnC,EAAoBoC,GACtC5N,KAAK8C,SAAS0I,EAAYtC,EAAO2E,aAAc9N,KAAK+J,GAAS8D,GAC/D,CACAE,mBAAAA,CAAoBtC,GAClB,OAAOxL,KAAKsN,SAAS9B,EAAYtC,EAAO2E,aAAc9N,MAAKwB,aAAa,EAC1E,CACAwM,gBAAAA,CAAiBvC,EAAoBwC,GACnChO,KAAK8C,SAAS0I,EAAYtC,EAAO+E,SAAUlO,KAAK+J,GAASkE,GAC3D,CACAE,gBAAAA,CAAiB1C,G,QACf,OAA+E,QAAxE2C,EAAuD,QAAvD9D,EAAArK,KAAK4L,iBAAiBJ,EAAYtC,EAAO+E,SAAUlO,aAAI,IAAAsK,OAAA,EAAAA,EAAE9I,aAAa,UAAE,IAAA4M,EAAAA,EAAI,UACrF,CACAC,iBAAAA,CAAkB5C,EAAoB6C,GACpCrO,KAAK8C,SAAS0I,EAAYtC,EAAOoF,YAAavO,KAAKsO,EACrD,CACAE,iBAAAA,CAAkB/C,GAChB,OAAOxL,KAAK4L,iBAAiBJ,EAAYtC,EAAOoF,YAAavO,KAC/D,CACAsE,0BAAAA,CACEmH,EACA3M,EACA2P,EACA1F,EACA/K,GAEA,GAAqB,IAAjBc,EAAOpB,OAAc,MAAM,IAAI2B,MAAM,0BAA4BP,EAAOpB,QAC5E,MAAM8F,EAAMvD,KAAKyO,yBAAyBD,EAAQ1F,EAAmB/K,GACrEiC,KAAK8C,SAAS0I,EAAYtC,EAAOwF,qBAAsB7P,EAAQ0E,EACjE,CACAoL,0BAAAA,CACEnD,EACA3M,GAEA,MAAM0E,EAAMvD,KAAKsN,SAAS9B,EAAYtC,EAAOwF,qBAAsB7P,GACnE,OAAOmB,KAAK4O,yBAAyBrL,EACvC,CACAsL,gBAAAA,CAAiBrD,EAAoBsD,GACnC,OAAO9O,KAAK+O,YAAY/O,KAAKyJ,UAAU+B,GAAasD,EACtD,CAEApJ,qBAAAA,CAAsBkI,EAAqBzI,GACzCnF,KAAKgP,UAAUpB,EAAazE,EAAQqD,cAAezM,KAAKoF,EAC1D,CACA8J,qBAAAA,CAAsBrB,GACpB,OAAO5N,KAAKkP,UAAUtB,EAAazE,EAAQqD,cAAezM,KAC5D,CACA8D,wBAAAA,CACE+J,EACA/O,EACAiK,EACA/K,GAEAiC,KAAKgP,UACHpB,EACAzE,EAAQgG,kBACRtQ,EACAmB,KAAK2M,sBAAsB7D,EAAmB/K,GAElD,CACAqR,wBAAAA,CACExB,EACA/O,GAEA,MAAM0E,EAAMvD,KAAKkP,UAAUtB,EAAazE,EAAQgG,kBAAmBtQ,GACnE,OAAOmB,KAAK6M,sBAAsBtJ,EACpC,CACA8L,eAAAA,CAAgBzB,EAAqBrJ,GACnCvE,KAAKgP,UAAUpB,EAAazE,EAAQmG,OAAQvP,KA+QvCf,EA/QqDuF,GAC5D,CACAgL,eAAAA,CAAgB3B,GAEd,OAAOrO,EADKS,KAAKkP,UAAUtB,EAAazE,EAAQmG,OAAQvP,MAE1D,CACAyP,eAAAA,CAAgB5B,EAAqBnK,GACnCzD,KAAKgP,UAAUpB,EAAazE,EAAQsG,OAAQ1P,KAAK0D,EACnD,CACAiM,eAAAA,CAAgB9B,GACd,OAAO5N,KAAKkP,UAAUtB,EAAazE,EAAQsG,OAAQ1P,KACrD,CACAyE,2BAAAA,CACEoJ,EACA/O,EACA2P,EACAmB,EACA5R,GAEA,MAAMwF,EAAMvD,KAAKyO,yBAAyBD,EAAQmB,EAAa5R,GAC/DiC,KAAKgP,UAAUpB,EAAazE,EAAQuF,qBAAsB7P,EAAQ0E,EACpE,CACAqM,2BAAAA,CACEhC,EACA/O,GAEA,MAAM0E,EAAMvD,KAAKkP,UAAUtB,EAAazE,EAAQuF,qBAAsB7P,GACtE,OAAOmB,KAAK4O,yBAAyBrL,EACvC,CAEAsM,kBAAAA,CAAmBrE,EAAoBsE,GACzB9P,KAAKyJ,UAAU+B,GACvB9N,SAAQ,CAACqS,EAAIpH,EAAGC,KACd5I,KAAKgQ,UAAUrH,EAAGmH,IACpBlH,EAAEqH,OAAOtH,EACX,GAEJ,CAEAuH,IAAAA,CAAKC,GACHnQ,KAAKoQ,QAAQpQ,KAAKuJ,UAAW4G,EAAG5G,WAChCvJ,KAAKqQ,SAASrQ,KAAKyJ,UAAW0G,EAAG1G,WACjCzJ,KAAKqQ,SAASrQ,KAAK0J,WAAYyG,EAAGzG,WACpC,CACA2G,QAAAA,CAASzP,EAA6BuP,GACpCvP,EAAKlD,SAAQ,CAACkL,EAAGhL,KACf,MAAM0S,EAAW,IAAI9G,IACrBxJ,KAAKoQ,QAAQxH,EAAG0H,GAChBH,EAAGvS,GAAS0S,CAAQ,GAExB,CACAF,OAAAA,CAAQxP,EAA2BuP,GACjCvP,EAAKlD,SAAQ,CAAC6S,EAAG5H,IAAMwH,EAAGK,IAAI7H,EAAGpL,EAAOqD,KAAK2P,KAC/C,CACA/H,SAAAA,GACE,MAAMjF,EAAM,IAAI7D,EAShB,OARA6D,EAAI9C,WAAWlD,EAAOqD,KAAK,CAAC,IAAM,IAAM,GAAM,IAAM,OACpD6P,GAAalN,EAAKvD,KAAKuJ,WACvBvJ,KAAKyJ,UAAU/L,SAAQgL,IACrB+H,GAAalN,EAAKmF,EAAI,IAExB1I,KAAK0J,WAAWhM,SAAQgL,IACtB+H,GAAalN,EAAKmF,EAAI,IAEjBnF,EAAIjG,QACb,CACAoT,WAAAA,CAAYlO,GACV,MAAMe,EAAM,IAAIxC,EAAayB,GAC7B,IAAKe,EAAI9B,UAAU,GAAG+D,OAAO4D,GAC3B,MAAM,IAAIhK,MAAM,uBAElB,KAAOY,KAAK2Q,YAAY3Q,KAAKuJ,UAAWhG,KACxC,IAAK,IAAI9D,EAAI,EAAGA,EAAIO,KAAK2K,sBAAuBlL,IAE9C,IADAO,KAAKyJ,UAAUhK,GAAK,IAAI+J,IACjBxJ,KAAK2Q,YAAY3Q,KAAKyJ,UAAUhK,GAAI8D,KAE7C,IAAK,IAAI9D,EAAI,EAAGA,EAAIO,KAAKgL,uBAAwBvL,IAE/C,IADAO,KAAK0J,WAAWjK,GAAK,IAAI+J,IAClBxJ,KAAK2Q,YAAY3Q,KAAK0J,WAAWjK,GAAI8D,KAEhD,CACQoN,WAAAA,CAAYjI,EAA0BnF,GAC5C,MAAMqN,EAASrN,EAAI7B,aACnB,GAAc,GAAVkP,EACF,OAAO,EAMT,OADAJ,GAAI9H,EAHYnF,EAAIrC,YACJqC,EAAI9B,UAAUmP,EAAS,GACzBrN,EAAI3B,iBAEX,CACT,CACQmN,WAAAA,CAAYrG,EAA0BoG,GAC5C,MAAM3N,EAAmB,GAMzB,OALAuH,EAAIhL,SAAQ,CAACqS,EAAIpH,KACX3I,KAAKgQ,UAAUrH,EAAG,CAACmG,KACrB3N,EAAOlB,KAAK1C,EAAOqD,KAAK+H,EAAEK,UAAU,GAAI,OAC1C,IAEK7H,CACT,CACQ6O,SAAAA,CAAUa,EAAgBf,GAChC,MAAMhB,EAAUvR,EAAOqD,KAAKiQ,EAAO7H,UAAU,EAAG,GAAI,OAAO9H,UAAU,GACrE,OAAO4O,EAASgB,MAAKnI,GAAKA,GAAKmG,GACjC,CACQlF,SAAAA,CAAUkF,EAAkBtP,GAClC,MAAM6I,EAAM,IAAI0I,GAAIjC,EAASvR,EAAOqD,KAAK,KACzCZ,KAAKuJ,UAAUiH,IAAInI,EAAIjK,WAAYoB,EACrC,CACQwK,SAAAA,CAAU8E,GAChB,OAAOkC,GAAIhR,KAAKuJ,UAAWuF,EAAS/O,MAAK,EAC3C,CACQuK,iBAAAA,CAAkBwE,GACxB,OAAOkC,GAAIhR,KAAKuJ,UAAWuF,EAAS/O,MAAK,EAC3C,CACQ+C,QAAAA,CAASlF,EAAekR,EAAkBmC,EAAiBzR,GACjEgR,GAAIxQ,KAAKkR,OAAOtT,EAAOoC,KAAKyJ,WAAYqF,EAASmC,EAASzR,EAC5D,CACQ8N,QAAAA,CAAS1P,EAAekR,EAAkBmC,GAChD,OAAOD,GAAIhR,KAAKyJ,UAAU7L,GAAQkR,EAASmC,GAAS,EACtD,CACQrF,gBAAAA,CAAiBhO,EAAekR,EAAkBmC,GACxD,OAAOD,GAAIhR,KAAKyJ,UAAU7L,GAAQkR,EAASmC,GAAS,EACtD,CACQjC,SAAAA,CAAUpR,EAAekR,EAAkBmC,EAAiBzR,GAClEgR,GAAIxQ,KAAKkR,OAAOtT,EAAOoC,KAAK0J,YAAaoF,EAASmC,EAASzR,EAC7D,CACQ0P,SAAAA,CAAUtR,EAAekR,EAAkBmC,GACjD,OAAOD,GAAIhR,KAAK0J,WAAW9L,GAAQkR,EAASmC,GAAS,EACvD,CACQC,MAAAA,CAAOtT,EAAeuT,GAC5B,OAAIA,EAAKvT,GACAuT,EAAKvT,GAENuT,EAAKvT,GAAS,IAAI4L,GAC5B,CACQmD,qBAAAA,CAAsB7D,EAA2B/K,GACvD,MAAMwF,EAAM,IAAI7D,EAEhB,OADAM,KAAKoR,qBAAqB7N,EAAKuF,EAAmB/K,GAC3CwF,EAAIjG,QACb,CACQuP,qBAAAA,CAAsBvP,GAI5B,MAAMiG,EAAM,IAAIxC,EAAazD,GAC7B,OAAO0C,KAAKqR,oBAAoB9N,EAClC,CACQ6N,oBAAAA,CAAqB7N,EAAmBuF,EAA2B/K,GACzEwF,EAAI9C,WAAWqI,GACf/K,EAAKL,SAAQC,IACX4F,EAAIlD,YAAY1C,EAAQ,GAE5B,CACQ0T,mBAAAA,CAAoB9N,GAI1B,MAAMuF,EAAoBvF,EAAI9B,UAAU,GAClC1D,EAAiB,GACvB,KAAOwF,EAAIvC,OAASuC,EAAIjG,OAAOG,QAC7BM,EAAKkC,KAAKsD,EAAIjC,cAEhB,MAAO,CAAEwH,oBAAmB/K,OAC9B,CACQ0Q,wBAAAA,CACND,EACA1F,EACA/K,GAEA,MAAMwF,EAAM,IAAI7D,EAMhB,OALA6D,EAAI7C,YAAY8N,EAAO/Q,QACvB+Q,EAAO9Q,SAAQiH,IACbpB,EAAI9C,WAAWkE,EAAE,IAEnB3E,KAAKoR,qBAAqB7N,EAAKuF,EAAmB/K,GAC3CwF,EAAIjG,QACb,CACQsR,wBAAAA,CAAyBtR,GAK/B,MAAMiG,EAAM,IAAIxC,EAAazD,GACvBgU,EAAY/N,EAAI7B,aAChB8M,EAAmB,GACzB,IAAK,IAAI/O,EAAI,EAAGA,EAAI6R,EAAW7R,IAC7B+O,EAAOvO,KAAKsD,EAAI9B,UAAU,KAE5B,MAAM8P,EAAQvR,KAAKqR,oBAAoB9N,GACvC,OAAAiO,OAAAC,OAAA,CAASjD,UAAW+C,EACtB,EAEF,SAASP,GACPtI,EACAoG,EACAmC,EACAS,GAEA,IAAKhJ,EAAK,MAAMtJ,MAAM,eACtB,MAAMiJ,EAAM,IAAI0I,GAAIjC,EAASmC,GACvBzR,EAAQkJ,EAAIsI,IAAI3I,EAAIjK,YAC1B,IAAKoB,EAAO,CACV,GAAIkS,EACF,OAEF,MAAM,IAAIrI,EAAYhB,EAAIjK,WAC5B,CAEA,OAAOb,EAAOqD,KAAKpB,EACrB,CAGA,MAAMuR,GAGJpR,WAAAA,CAAYmP,EAAkBmC,GAC5BjR,KAAK8O,QAAUA,EACf9O,KAAKiR,QAAUA,CACjB,CACA7S,QAAAA,GACE,MAAMmF,EAAM,IAAI7D,EAEhB,OADAM,KAAK2R,SAASpO,GACPA,EAAIjG,SAASc,SAAS,MAC/B,CACAoK,SAAAA,CAAUjF,GACRA,EAAI7C,YAAY,EAAIV,KAAKiR,QAAQxT,QACjCuC,KAAK2R,SAASpO,EAChB,CACQoO,QAAAA,CAASpO,GACfA,EAAIrD,WAAWF,KAAK8O,SACpBvL,EAAI9C,WAAWT,KAAKiR,QACtB,EAEF,MAAMW,GAGJjS,WAAAA,CAAY0I,EAAU7I,GACpBQ,KAAKqI,IAAMA,EACXrI,KAAKR,MAAQA,CACf,CACAgJ,SAAAA,CAAUjF,GACRvD,KAAKqI,IAAIG,UAAUjF,GACnBA,EAAI1C,cAAcb,KAAKR,MACzB,EAEF,SAASqJ,GAAUtF,GACjB,OAAO,IAAIwN,GAAIxN,EAAIrC,UAAU,GAAIqC,EAAI7E,MAAM,GAC7C,CACA,SAAS+R,GAAalN,EAAmBmF,GACvC,IAAK,MAAMC,KAAKD,EAAIJ,OAAQ,CAC1B,MAAM9I,EAAQkJ,EAAIsI,IAAIrI,GACN,IAAIiJ,GAAQ/I,GAAUtL,EAAOqD,KAAK+H,EAAG,QAASnJ,GACtDgJ,UAAUjF,EACpB,CACAA,EAAIrD,WAAW,EACjB,CAEA,SAASH,KACP,OAAOxC,EAAOqD,KAAK,GACrB,CACA,SAAS4P,GAAI9H,EAA0BoG,EAAkBmC,EAAiBzR,GACxE,MAAM6I,EAAM,IAAI0I,GAAIjC,EAASmC,GAC7BvI,EAAI8H,IAAInI,EAAIjK,WAAYoB,EAC1B,CACA,SAASsK,GAAS7K,GAChB,MAAMc,EAAIxC,EAAOC,MAAM,GAEvB,OADAuC,EAAEO,cAAcrB,EAAG,GACZc,CACT,CAIA,SAAS2K,GAAOzL,GACd,MAAMc,EAAI,IAAIL,EAEd,OADAK,EAAEW,YAAYzB,GACPc,EAAEzC,QACX,CACA,SAASsN,GAAWrH,GAClB,OAAO,IAAIxC,EAAawC,GAAK7B,YAC/B,C,uBCnbA,SAASmQ,GAAoBrP,EAAcgJ,GACzC,MAAMsE,EAAW,CACf5G,EAAOwD,iBACPxD,EAAOgD,YACPhD,EAAOwF,qBACPxF,EAAOoF,aAEHwD,IAAyBtP,EAAKsJ,oBAAoBN,GAClDuG,IAA4BvP,EAAKmJ,uBAAuBH,GAC1DsG,GAAwBC,GAI1BjC,EAAS7P,KAAKiJ,EAAOwC,kBAEvBlJ,EAAKqN,mBAAmBrE,EAAYsE,EACtC,CAUA,SAASkC,GAAUzO,EAAmB0O,GACpC,GAAIA,EAAKxU,QAAU,GACjB8F,EAAIrD,WAAW+R,EAAKxU,aACf,GAAIwU,EAAKxU,QAAU,IACxB8F,EAAIrD,WAAW,IACfqD,EAAIrD,WAAW+R,EAAKxU,aACf,GAAIwU,EAAKxU,QAAU,MAAW,CACnC8F,EAAIrD,WAAW,IACf,MAAMH,EAAIxC,GAAOC,MAAM,GACvBuC,EAAEmS,cAAcD,EAAKxU,OAAQ,GAC7B8F,EAAI9C,WAAWV,EACjB,CACAwD,EAAI9C,WAAWwR,EACjB,C,uBChIM,SAAUE,GAAUF,EAAcjR,GACtC,GAAIiR,EAAKjR,GAAU,IACjB,MAAO,CAACiR,EAAKjR,GAAS,GAGxB,GAAqB,MAAjBiR,EAAKjR,GACP,MAAO,EAAEiR,EAAKjR,EAAS,IAAM,GAAKiR,EAAKjR,EAAS,GAAI,GAGtD,GAAqB,MAAjBiR,EAAKjR,GACP,MAAO,EACJiR,EAAKjR,EAAS,IAAM,KAClBiR,EAAKjR,EAAS,IAAM,KACpBiR,EAAKjR,EAAS,IAAM,GACrBiR,EAAKjR,EAAS,GAChB,GAIJ,MAAM,IAAI5B,MAAM,8CAClB,CACM,SAAUgT,GAAa5S,GAC3B,GAAIA,EAAQ,IAAM,CAChB,MAAMlC,EAASC,GAAOC,MAAM,GAE5B,OADAF,EAAO,GAAKkC,EACLlC,CACT,CAEA,GAAIkC,GAAS,MAAQ,CACnB,MAAMlC,EAASC,GAAOC,MAAM,GAI5B,OAHAF,EAAO,GAAK,IACZA,EAAO,GAAa,IAARkC,EACZlC,EAAO,GAAMkC,GAAS,EAAK,IACpBlC,CACT,CAEA,MAAMA,EAASC,GAAOC,MAAM,GAM5B,OALAF,EAAO,GAAK,IACZA,EAAO,GAAa,IAARkC,EACZlC,EAAO,GAAMkC,GAAS,EAAK,IAC3BlC,EAAO,GAAMkC,GAAS,GAAM,IAC5BlC,EAAO,GAAMkC,GAAS,GAAM,IACrBlC,CACT,C,uBCnCM,SAAU+U,IAA4B,QAAEC,IAC5C,IAAIC,EAAehV,GAAOC,MAAM,GAchC,MAZuB,qBAAZ8U,IACTC,EAAehV,GAAOuD,OAAO,CAACyR,EAAcH,GAAaE,EAAQ7U,UACjE6U,EAAQ5U,SAAQ8U,IACdD,EAAehV,GAAOuD,OAAO,CAC3ByR,EACAC,EAAOjO,OACP6N,GAAaI,EAAOC,OAAOhV,QAC3B+U,EAAOC,QACP,KAICF,CACT,CACM,SAAUG,GACdjH,EACAkH,EACAC,EACAC,EAAwB,IAExB,MAAMC,EAAWD,EAAYE,SAAS,UAChCC,EAAUH,EAAYE,SAAS,SAC/BE,EAAWJ,EAAYE,SAAS,UACtC,IAAIG,EAAc3V,GAAOC,MAAM,GAC/B,MAAM2V,EAA8C,oBAA1B1H,EAAqB,UAAqBkH,EACpElH,EAAY2H,OAAO1V,SAAQ2V,IACzBH,EACEJ,GAAYG,EACR1V,GAAOuD,OAAO,CACZoS,EACAG,EAAMC,QACN/V,GAAOqD,KAAK,CAAC,IACbyS,EAAMrF,WAERzQ,GAAOuD,OAAO,CACZoS,EACAG,EAAMC,QACNlB,GAAaiB,EAAMZ,OAAOhV,QAC1B4V,EAAMZ,OACNY,EAAMrF,UACN,IAEV,IAAIuE,EAAeF,GAA4B5G,GAY/C,MAVmC,qBAAxBA,EAAY6G,SAA2D,qBAAzB7G,EAAYvB,WACnEqI,EAAehV,GAAOuD,OAAO,CAC3ByR,EACCY,GAAc1H,EAAY8H,SAAYhW,GAAOC,MAAM,GACpDiO,EAAYvB,SACZuB,EAAY+H,eAAiBjW,GAAOC,MAAM,GAC1CiO,EAAYgI,WAAalW,GAAOC,MAAM,MAItCwV,EACKzV,GAAOuD,OAAO,CACnB2K,EAAY3M,QACZ2M,EAAYiI,iBAAmBnW,GAAOC,MAAM,GAC5CD,GAAOqD,KAAK,CAAC,IAAM,IAAM,IAAM,MAC/B6K,EAAYvB,UAAY3M,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,IACvD6K,EAAY+H,eAAiBjW,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,IAC5DuS,EAAa5V,GAAOqD,KAAK,OAAQ,OAASrD,GAAOC,MAAM,GACvD4U,GAAa3G,EAAY2H,OAAO3V,QAChCyV,EACAX,IAGGhV,GAAOuD,OAAO,CACnB2K,EAAY3M,QACZ8T,GAAwBrV,GAAOC,MAAM,GACrCiO,EAAYiI,iBAAmBnW,GAAOC,MAAM,GAC5C2V,EAAa5V,GAAOqD,KAAK,OAAQ,OAASrD,GAAOC,MAAM,GACvD4U,GAAa3G,EAAY2H,OAAO3V,QAChCyV,EACAX,GAEJ,C,8TC5Cc,MAAOoB,GACnBhU,WAAAA,CAAoBiU,GAAA,KAAAA,OAAAA,CAAiB,CAgC/BC,aAAAA,CAAaxJ,G,4CAAC,KAClBtM,EAAI,YACJ+V,IAKA,MAAM5V,EAAyBF,EAAkBD,GAC3CQ,QAAayB,KAAK4T,OAAOG,mBAAkB,EAAO7V,GAClD8V,EAAiBrV,EAAkBJ,GACzC,GAAIyV,EAAelV,SAAWgV,EAC5B,MAAM,IAAI1U,MACR,yBAAyB0U,oDAA8DE,EAAelV,WAG1G,OAAOP,CACT,G,CASM0V,kBAAAA,CACJlW,EACAmW,G,kDASA,IAqYE,SAAuBnW,GAC3B,MAAMkF,EAAYjF,EAAkBD,GAGpC,GACEkF,EAAUxF,QAAU,GACpBwF,EAAUxF,QAAU,GACpB0W,GAAkCC,IAAInR,EAAU,KAChDoR,GAAsBD,IAAInR,EAAU,KACpCqR,GAAKrR,EAAU,KACfsR,GAAOtR,EAAU,KACjBuR,GAAKvR,EAAU,IAEf,OAAO,EAIT,GACEA,EAAUxF,QAAU,GACpBwF,EAAUxF,QAAU,GACpBgX,GAAiCL,IAAInR,EAAU,KAC/CoR,GAAsBD,IAAInR,EAAU,KACpCqR,GAAKrR,EAAU,KACfqR,GAAKrR,EAAU,KACfsR,GAAOtR,EAAU,KACjBuR,GAAKvR,EAAU,IAEf,OAAO,EAET,OAAO,CACT,CAnaSyR,CAAa3W,GAChB,MAAMqB,MAAM,sBAAsBrB,KAEpC,MAAMG,EAAyBF,EAAkBD,GAC3CQ,QAAayB,KAAK4T,OAAOG,mBAAkB,EAAO7V,GAElDyW,EAAsB,QAAZtK,EAAI,OAAJ6J,QAAI,IAAJA,OAAI,EAAJA,EAAMU,cAAM,IAAAvK,GAAAA,EAEtBwK,QAAgB7U,KAAK8U,iBACzB5W,EAuTN,SAAwB6W,GACtB,GAAqB,UAAjBA,EAA2B,MAAO,UACtC,GAAqB,QAAjBA,EAAyB,MAAO,eACpC,GAAqB,UAAjBA,EAA2B,MAAO,WACtC,GAAqB,WAAjBA,EAA4B,MAAO,SACvC,MAAM,IAAI3V,MAAM,8BAAgC2V,EAClD,CA5TMC,CAA2B,QAAZ7G,EAAI,OAAJ+F,QAAI,IAAJA,OAAI,EAAJA,EAAMe,cAAM,IAAA9G,EAAAA,EAAI,UAC/BwG,GAEIO,EAAavW,EAAkBJ,GAErC,MAAO,CACL4W,UAFyB5X,GAAOqD,MAAKwU,EAAAA,EAAAA,eAAcF,EAAWrW,QAAQ,IAExCT,SAAS,OACvCiX,eAAgBR,EAChBS,UAAWJ,EAAWtW,UAAUR,SAAS,OAE7C,G,CAiBc0W,gBAAAA,CACZ5W,EACAqX,EACAZ,G,0CAEA,MAAM5L,EXlGJ,SAAyB7K,GAC7B,IAAK,IAAIuB,EAAIvB,EAAaT,OAAS,EAAGgC,GAAK,EAAGA,IAC5C,GAAIvB,EAAauB,IAAM,WACrB,OAAOvB,EAAaQ,MAAM,EAAGe,EAAI,GAGrC,MAAO,EACT,CW2FwB+V,CAAetX,GACnC,GAAI6K,EAAYtL,OAAS,GAAKS,EAAaT,OACzC,MAAO,GAET,MAAMgY,QAAoBzV,KAAK4T,OAAOG,mBAAkB,EAAOhL,GACzDD,QAA0B9I,KAAK4T,OAAO8B,uBACtCC,EAAS,IAAIxN,EACjBoN,EACA1M,EAAUC,EAAmBC,EAAa0M,IAEtCG,EAAiB1X,EAAaQ,OAAO,EAAGR,EAAaT,QAC3D,OAAOuC,KAAK4T,OAAOkB,iBACjBa,EACApY,GAAOC,MAAM,GAAI,GACjBoY,EAAe,GACfA,EAAe,GACfjB,EAEJ,G,CAUMkB,wBAAAA,CAAyBC,G,0CAC7B,MAAMtL,EAAasL,EAAI1C,OAAO3V,OAC9B,GAAkB,GAAd+M,EACF,MAAMpL,MAAM,aAEd,MAAMoD,EAAO,IAAI8G,GAGX7G,QAAiBzC,KAAK4T,OAAO8B,uBAE7BK,EAwPV,SACED,EACAtT,EACAC,GAEA,OAAIqT,EAAIjD,YAAYE,SAAS,WAAmB,IAAIhP,EAAKvB,EAAMC,GAC3DqT,EAAIjD,YAAYE,SAAS,UAAkB,IAAIpN,EAAOnD,EAAMC,GAC5DqT,EAAIE,OAAe,IAAI9Q,EAAc1C,EAAMC,GACxC,IAAIa,EAAMd,EAAMC,EACzB,CAjQwBwT,CAAmBH,EAAKtT,EAAMC,QAE9BmE,GAAhBkP,EAAII,UAEN1T,EAAKyH,0BAA0B6L,EAAII,UAErC1T,EAAK+H,oBAAoBC,GACzBhI,EAAK4I,qBAAqB,GAC1B5I,EAAKmH,mBAAmB,GAExB,IAAIwM,EAAc,EAClB,MAAMC,EAAWA,KACVN,EAAIO,mBACTP,EAAIO,kBAAkB,CACpBC,MAAO,EAAI9L,EACX5M,MAAOuY,EACPC,WAAYD,GAAe,EAAI3L,IAC/B,EAGJ,IAAIiL,EAAc,GACd1M,EAAwB,GAC5B,IAAK,IAAItJ,EAAI,EAAGA,EAAI+K,EAAY/K,IAAK,CACnC2W,IACA,MAAMnT,EAAsBjF,EAAkB8X,EAAIS,kBAAkB9W,IACjD,IAAfgW,IAGF1M,EAAc9F,EAAUvE,MAAM,GAAI,GAClC+W,QAAoBzV,KAAK4T,OAAOG,mBAAkB,EAAOhL,UAErD/I,KAAK8C,SACTN,EACA/C,EACAqW,EAAI1C,OAAO3T,GACXwD,EACA8S,EACAtT,EACAqT,EAAIU,YAER,CAEA,MAAMC,EAAgBlZ,GAAOqD,KAAKkV,EAAIY,gBAAiB,OACjDC,EAAsB,IAAI5V,EAAa0V,GACvC3L,EAAc6L,EAAoBjV,aACxCc,EAAKqI,qBAAqBC,GAC1B,MAAM8L,QAAmB5W,KAAK6W,eAAe9N,EAAagN,EAAaD,EAAIgB,YAG3E,IAAIC,GAAeH,EACnB,IAAK,IAAInX,EAAI,EAAGA,EAAIqL,EAAarL,IAAK,CACpC,MAAM8E,EAASrF,OAAOyX,EAAoBnV,cACpCwV,EAAeL,EAAoB/U,eACzCY,EAAK6M,gBAAgB5P,EAAG8E,GACxB/B,EAAKgN,gBAAgB/P,EAAGuX,GAMxB,GADiBJ,GAAcI,EAAaxR,OAAiB,OAAVoR,QAAU,IAAVA,OAAU,EAAVA,EAAYxT,KAAKK,cACtD,CACZsT,GAAc,EAEd,MAAMD,EAAa9Y,EAAkB8X,EAAIgB,YACnCjY,EAAS+X,EAAW/X,OAE1BkX,EAAY5S,aAAa1D,EAAGmX,EAAWxT,KAAM,CAACvE,GAAS,CAACiY,GAC1D,CACF,CACA,IAAKC,EACH,MAAM,IAAI3X,MACR,2CAAsD,OAAVwX,QAAU,IAAVA,OAAU,EAAVA,EAAYxT,KAAKK,aAAarF,SAAS,SAIvF,MAAMiK,EAAMQ,EAAUpG,EAAUsG,EAAa0M,GACvCwB,EAAI,IAAI9O,EAAa4N,EAAYjS,wBAAyBuE,GAG5DyN,EAAIoB,4BAA4BpB,EAAIoB,6BAExC,IAAIC,GAAc,QAUZnX,KAAKoX,SAAS5U,EAAMyU,GARDI,KAClBF,IACHA,GAAc,EACdrB,EAAIwB,0BAA4BxB,EAAIwB,4BAEtClB,GAAU,IHvQV,SAAmB5T,GAEvB,MAAMgI,EAAahI,EAAKmI,sBACxB,IAAK,IAAIlL,EAAI,EAAGA,EAAI+K,EAAY/K,IAAK,CACnC,MAAM8X,EAAgB/U,EAAKqM,iBAAiBpP,EAAGyJ,EAAOgD,aAChDsL,EAAahV,EAAK+L,kBAAkB9O,GAC1C,GAA4B,GAAxB8X,EAAc9Z,SAAgB+Z,EAChC,MAAMpY,MAAM,0BAA0BK,aAExC,GAAI8X,EAAc9Z,OAAS,EAAG,CAC5B,GAAI8Z,EAAc9Z,OAAS,EACzB,MAAM2B,MAAM,uCAAuCmY,EAAc9Z,UAEnE,GAAI+Z,EACF,MAAMpY,MAAM,oDAGd,MAAMqY,IAAejV,EAAKsJ,oBAAoBrM,GACxC0F,EAAe3C,EAAKiK,qBAAqBhN,GACzCiY,IAAoBvS,EACpB8G,EAAYzJ,EAAK2J,mBAAmB1M,EAAG8X,EAAc,IAC3D,IAAKtL,EAAW,MAAM,IAAI7M,MAAM,wCAA0CK,GAC1E,GAAIgY,EAAY,CACd,MAAME,EAAa,IAAIjY,EAOvB,GANAiY,EAAWjX,YAAY,GACvBiX,EAAWjX,YAAYuL,EAAUxO,QACjCka,EAAWlX,WAAWwL,GACtB0L,EAAWjX,YAAY6W,EAAc,GAAG9Z,QACxCka,EAAWlX,WAAW8W,EAAc,IACpC/U,EAAK0K,2BAA2BzN,EAAGkY,EAAWra,UAC1Coa,EAAiB,CACnB,IAAKvS,GAAuC,GAAvBA,EAAa1H,OAChC,MAAM,IAAI2B,MAAM,0DAA4DK,GAE9E,MAAMmY,EAAe,IAAIlY,EAEzBkY,EAAa1X,WAAWiF,EAAa1H,QACrCma,EAAanX,WAAW0E,GACxB3C,EAAKsK,uBAAuBrN,EAAGmY,EAAata,SAC9C,CACF,KAAO,CAEL,MAAMyP,EAAY,IAAIrN,EACtBsS,GAAUjF,EAAWd,GACrB+F,GAAUjF,EAAWwK,EAAc,IACnC/U,EAAKsK,uBAAuBrN,EAAGsN,EAAUzP,SAC3C,CACF,KAAO,CAEL,MAAM2O,EAAYzJ,EAAK+L,kBAAkB9O,GACzC,IAAKwM,EACH,MAAM7M,MAAM,8BAEd,GAAwB,IAApB6M,EAAUxO,QAAoC,IAApBwO,EAAUxO,OACtC,MAAM2B,MAAM,2CAEd,MAAMuY,EAAa,IAAIjY,EACvBiY,EAAWjX,YAAY,GACvBiX,EAAW9W,cAAcoL,GACzBzJ,EAAK0K,2BAA2BzN,EAAGkY,EAAWra,SAChD,CACAuU,GAAoBrP,EAAM/C,EAC5B,CACF,CG4MIoY,CAASrV,GACT,MAAMsV,ECpRJ,SAAkBtV,G,QACtB,MAAMuV,EAAK,IAAIrY,EACfqY,EAAG1X,YAAYmC,EAAKuH,sBAEpB,MAAMiO,IAAaxV,EAAKsJ,oBAAoB,GACxCkM,GACFD,EAAGtX,WAAWlD,EAAOqD,KAAK,CAAC,EAAG,KAEhC,MAAM4J,EAAahI,EAAKmI,sBACxBoN,EAAGrX,YAAY8J,GACf,MAAMyN,EAAgB,IAAIvY,EAC1B,IAAK,IAAID,EAAI,EAAGA,EAAI+K,EAAY/K,IAC9BsY,EAAGtX,WAAW+B,EAAKkL,qBAAqBjO,IACxCsY,EAAG1X,YAAYmC,EAAKsL,oBAAoBrO,IACxCsY,EAAGlX,cAA4C,QAA9BwJ,EAAA7H,EAAKyK,uBAAuBxN,UAAE,IAAA4K,EAAAA,EAAI9M,EAAOqD,KAAK,KAC/DmX,EAAG1X,YAAYmC,EAAK0L,iBAAiBzO,IACjCuY,GACFC,EAAcxX,WAAW+B,EAAK6K,2BAA2B5N,IAG7D,MAAMqL,EAActI,EAAKwI,uBACzB+M,EAAGrX,YAAYoK,GACf,IAAK,IAAIrL,EAAI,EAAGA,EAAIqL,EAAarL,IAC/BsY,EAAGxX,YAAYiC,EAAK+M,gBAAgB9P,IACpCsY,EAAGlX,cAAc2B,EAAKkN,gBAAgBjQ,IAIxC,OAFAsY,EAAGtX,WAAWwX,EAAc3a,UAC5Bya,EAAG1X,YAA4C,QAAhC8N,EAAA3L,EAAK4H,mCAA2B,IAAA+D,EAAAA,EAAI,GAC5C4J,EAAGza,QACZ,CDuPyB4a,CAAQ1V,GAC7B,OAAOsV,EAAa1Z,SAAS,MAC/B,G,CAOM+Z,WAAAA,CAAW9N,G,4CAAC,KAAEtM,EAAI,WAAEqa,IAKxB,MAAMla,EAAyBF,EAAkBD,GAC3Csa,EAAU9a,GAAOqD,KAAKwX,EAAY,OAClC/J,QAAYrO,KAAK4T,OAAOuE,YAAYE,EAASna,GAC7CqF,EAAMhG,GAAOqD,KAAKyN,EAAK,UAM7B,MAAO,CACLkC,EALQhN,EAAIrC,YAAc,GAAK,EAM/BoX,EALQ/U,EAAI7E,MAAM,EAAG,IAAIN,SAAS,OAMlCma,EALQhV,EAAI7E,MAAM,GAAI,IAAIN,SAAS,OAOvC,G,CAUcyY,cAAAA,CACZ9N,EACAgN,EACAhY,G,0CAEA,IAAKA,EAAM,OACX,MAAMkF,EAAYjF,EAAkBD,GAGpC,IAAK,IAAI0B,EAAI,EAAGA,EAAIsJ,EAAYtL,OAAQgC,IACtC,GAAIsJ,EAAYtJ,IAAMwD,EAAUxD,GAC9B,MAAM,IAAIL,MAAM,QAAQrB,oBAAuBE,EAAkB8K,MAGrE,MACMlK,EAASP,QADI0B,KAAK4T,OAAOG,mBAAkB,EAAO9Q,IAGxD,MAAO,CAAEG,KADI2S,EAAYpT,kBAAkB,CAAC9D,IAC7BA,SACjB,G,CAOciE,QAAAA,CACZN,EACA/C,EACA4T,EACAnV,EACA6X,EACAyC,EACAhC,G,0CAEA,MAAMzT,EAAUsQ,EAAM,GAChBoF,EAAmBpF,EAAM,GAGzBlO,EAAekO,EAAM,GAAK9V,GAAOqD,KAAKyS,EAAM,GAAI,YAASzM,EACzDoH,EAAWqF,EAAM,QACPzM,GAAZoH,GACFxL,EAAKuL,iBAAiBtO,EAAGuO,QAERpH,GAAf4P,GACFhU,EAAK4J,oBAAoB3M,EAAG+W,GAE9B,MAAMkC,EAAgBhG,GAAqB3P,GAAS,GAC9C4V,EAAY/T,EAAAA,GAAOgU,QAAQF,GAG3B7Z,EAASP,QAFU0B,KAAK4T,OAAOG,mBAAkB,EAAO7V,IAG9D,IAAK6E,EAAQuP,QAAS,MAAMlT,MAAM,gDAClC,MAAMyZ,EAAgB9V,EAAQuP,QAAQmG,GAKhCzV,EAAc,CAAEI,KAJoB,CACxCK,aAAcoV,EAAcpG,OAC5BtN,aAAcA,GAE4BZ,OAAQsU,EAActU,QAClEwR,EAAYjT,SAASrD,EAAGiZ,EAAe1V,EAAa,CAACnE,GAAS,CAACX,IAE/DsE,EAAK+K,qBAAqB9N,EAAGkZ,GAC7BnW,EAAKmL,oBAAoBlO,EAAGgZ,EAC9B,G,CAWcrB,QAAAA,CACZ5U,EACAsW,EACAzB,G,iDAEwCrX,KAAK4T,OAAOwD,SAClD5U,EACAsW,EACAvb,GAAOC,MAAM,GAAI,GACjB6Z,IAEG3Z,SAAQ,CAAC6S,EAAG5H,KAGf,MAAM/F,EAAUJ,EAAKqM,iBAAiBlG,EAAGO,EAAOwD,kBAChD,IAAI7N,EACJ,GAAsB,GAAlB+D,EAAQnF,OAAa,CAGvB,GADAoB,EAAS2D,EAAKqM,iBAAiBlG,EAAGO,EAAOwF,sBACpB,GAAjB7P,EAAOpB,OACT,MAAM2B,MAAM,uCAAuCuJ,KAErDnG,EAAK4L,kBAAkBzF,EAAG4H,EAC5B,MACE1R,EAAS+D,EAAQ,GACjBJ,EAAKwJ,mBAAmBrD,EAAG9J,EAAQ0R,EACrC,GAEJ,G,EAkDF,MAAMwI,GAAI,WAmBJzE,GAAQrV,GAAcA,GAAK8Z,GAC3BvE,GAAQvV,QAAgC2H,IAAN3H,GAAmBA,EAAI8Z,GACzDxE,GAAUtV,QAAgC2H,IAAN3H,GAAyB,IAANA,GAAiB,IAANA,EAElEoV,GAAwB,IAAI2E,IArBT,CACvB,EACA,EACA,IAkBqDtQ,KAAIuQ,GAAKA,EAAIF,MAC9D5E,GAAoC,IAAI6E,IAhBZ,CAChC,GACA,GACA,GACA,IAY0EtQ,KAAIuQ,GAAKA,EAAIF,MACnFtE,GAAmC,IAAIuE,IAVb,CAC9B,IASuEtQ,KAAIuQ,GAAKA,EAAIF,M,8UE5etF,MAAMG,GAAmB,CACvBC,OAAQ,EACRC,KAAM,EACNC,OAAQ,EACRC,SAAU,GAEN,SAAgBrF,GACpBsF,EACAC,G,0CAUA,MAAM,KAAEzb,EAAI,OAAE6W,EAAM,OAAEK,GAAQzD,OAAAC,OAAA,CAC5BmD,QAAQ,EACRK,OAAQ,UACLuE,GAGL,KAAMvE,KAAUiE,IACd,MAAM,IAAI9Z,MAAM,yCAA2C6V,GAG7D,MAAM3X,EAASQ,EAAcC,GACvB0b,EAAK7E,EAAS,EAAI,EAClB8E,EAAKR,GAAiBjE,GACtB0E,QAAiBJ,EAAUK,KAAK,IAAM,GAAMH,EAAIC,EAAIpc,GACpDuc,EAAkBF,EAAS,GAC3BG,EAAgBH,EAAS,EAAIE,GAQnC,MAAO,CACL1E,UARgBwE,EAASjb,MAAM,EAAG,EAAImb,GAAiBzb,SAAS,OAShEiX,eARqBsE,EACpBjb,MAAM,EAAImb,EAAkB,EAAG,EAAIA,EAAkB,EAAIC,GACzD1b,SAAS,SAOVkX,UANgBqE,EACfjb,MAAM,EAAImb,EAAkB,EAAIC,EAAe,EAAID,EAAkB,EAAIC,EAAgB,IACzF1b,SAAS,OAMd,G,sVChDM,SAAgB2b,GACpBR,EACAS,EACAC,G,0CAEA,IAAIhI,EACAiI,GAAa,EAEjB,GAA2B,kBAAhBD,EAA0B,CACnCC,GAAa,EACb,MAAMC,EAAS5c,GAAOC,MAAM,GAC5B2c,EAAOtc,cAAcoc,EAAa,GAClChI,EAAO1U,GAAOuD,OAAO,CAACqZ,EAAQH,GAAkBA,EAAgBvc,OAAS,EAC3E,MACEwU,EAAO+H,EAGT,MAAMI,QAAqBb,EAAUK,KAAK,IAAM,GAAMM,EAAa,EAAO,IAAM,EAAMjI,GAEtF,OADYmI,EAAa1b,MAAM,EAAG0b,EAAa3c,OAAS,GAAGW,SAAS,MAEtE,G,CACM,SAAgBic,GAAeC,EAAAC,EAAAC,G,2CACnCjB,EACAU,EACAxO,EACAoH,EAA6B,IAE7B,MAAM,QAAE/T,EAAO,OAAEsU,EAAM,QAAEd,EAAO,SAAEpI,EAAQ,cAAEsJ,EAAa,UAAEC,GAAchI,EAEzE,IAAK6G,IAAYpI,EACf,MAAM,IAAI9K,MAAM,mDAGlB,MAAM0T,EAAWD,EAAYE,SAAS,UAChC0H,EAAQ5H,EAAYE,SAAS,eAE7B2H,EAAsBA,CAAOjI,EAAQzE,IAAqB2M,GAAA,gCAC9D,MAAMC,EAAM5M,GAAYzQ,GAAOC,MAAM,GAC/Bqd,EAAyB,GAC/B,IAqBIC,EArBA9Z,EAAS,EAEb,KAAOA,IAAWyR,EAAOhV,QAAQ,CAC/B,MAAMsd,EACJtI,EAAOhV,OAASuD,EAASgB,EAAmBA,EAAmByQ,EAAOhV,OAASuD,EAE7EA,EAAS+Z,IAActI,EAAOhV,OAChCod,EAAa5a,KAAKwS,EAAO/T,MAAMsC,EAAQA,EAAS+Z,IAEhDF,EAAa5a,KAAK1C,GAAOuD,OAAO,CAAC2R,EAAO/T,MAAMsC,EAAQA,EAAS+Z,GAAYH,KAG7E5Z,GAAU+Z,CACZ,CAIsB,IAAlBtI,EAAOhV,QACTod,EAAa5a,KAAK2a,GAKpB,IAAK,MAAMI,KAAeH,EACxBC,QAAYf,GAAmBR,EAAWyB,GAG5C,OAAOF,CACT,IAEMG,EAA0BC,GAASnB,GAAmBR,EAAW2B,SAEjEnB,GACJR,EACAhc,GAAOuD,OAAO,CACZ2K,EAAY3M,QACZ2M,EAAYmH,WAAarV,GAAOC,MAAM,GACtCiO,EAAYiI,iBAAmBnW,GAAOC,MAAM,GAC5C4U,GAAagB,EAAO3V,UAEtBwc,GAGF,IAAK,MAAM5G,KAASD,EAAQ,CAC1B,MAAM+H,EAAUV,GAA4E,IAAnEld,GAAO6d,QAAQtc,EAASvB,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,KAC1Eya,EAAYvI,EAAWO,EAAMiI,MAAQ/d,GAAOqD,KAAK,CAAC,IAASrD,GAAOC,MAAM,GACxEyU,EAAO1U,GAAOuD,OAAO,CACzBuS,EAAMC,QACN+H,EACAF,EAAU5d,GAAOqD,KAAK,CAAC,IAASwR,GAAaiB,EAAMZ,OAAOhV,gBAEtDsc,GAAmBR,EAAWtH,SAK7Ba,EACHmI,EAAwB1d,GAAOuD,OAAO,CAACuS,EAAMZ,OAAQY,EAAMrF,YAC3DmN,EACEF,EAAwB5H,EAAMrF,UAC9B0M,EAAoBrH,EAAMZ,OAAQY,EAAMrF,SAChD,OAEM+L,GAAmBR,EAAWnH,GAAaE,EAAQ7U,SAEzD,IAAK,MAAM+U,KAAUF,EAAS,CAC5B,MAAML,EAAO1U,GAAOuD,OAAO,CACzB0R,EAAOjO,OACPuO,EAAWvV,GAAOqD,KAAK,CAAC,EAAM,IAASrD,GAAOC,MAAM,GACpD4U,GAAaI,EAAOC,OAAOhV,QAC3B+U,EAAOC,eAEHsH,GAAmBR,EAAWtH,EACtC,CAEA,MAAMsJ,EAAoB,GAU1B,IAAIC,EAEJ,GAVIhI,GAAiBA,EAAc/V,OAAS,GAC1C8d,EAAQtb,KAAKuT,GAGXC,GAAaA,EAAUhW,OAAS,GAClC8d,EAAQtb,KAAKwT,GAKX8H,EAAQ9d,OAAQ,CAClB,MAAMwU,EAAO1U,GAAOuD,OAAOya,GAC3BC,EAAY1I,EAAWb,EAAO1U,GAAOuD,OAAO,CAACsR,GAAaH,EAAKxU,QAASwU,GAC1E,CAEA,MAAM6I,QAAYJ,EAAoBnd,GAAOuD,OAAO,CAACoJ,EAAUsR,GAAaje,GAAOC,MAAM,MAEzF,OADAie,KAAUX,EAAK,yCACRA,CACT,G,+TCvIM,SAAUY,GACdnC,EACAoC,EACAzB,EACAF,EACA4B,GAAS,EACTC,GAAa,EACbhJ,EAA6B,IAE7B,MAAM6G,EAAK7G,EAAYE,SAAS,YAC5B,EACA6I,EACE/I,EAAYE,SAAS,WACnB,EACA8I,EACE,EACA,EACJ,EACN,OAAOtC,EAAUK,KACf,IACA,GACAM,EAAa,EAAO,IACpByB,EAAiBjC,EAAK,IACtBM,EAEJ,CACM,SAAgB8B,GAAkCxB,EAAAyB,EAAAvB,EAAAwB,G,2CACtDzC,EACAoC,EACAlQ,EACA2H,EAIAwI,GAAS,EACTC,GAAa,EACbhJ,EAA6B,GAC7BoJ,GAA2B,GAE3B,IAAIhK,EAAO1U,GAAOuD,OAAO,CACvB2K,EAAY3M,QACZ2M,EAAYmH,WAAarV,GAAOC,MAAM,GACtCiO,EAAYiI,iBAAmBnW,GAAOC,MAAM,GAC5C4U,GAAa3G,EAAY2H,OAAO3V,gBAE5Bie,GACJnC,EACAoC,GACA,EACA1J,EACA2J,EACAC,EACAhJ,GAEF,IAAIpT,EAAI,EACR,MAAMqT,EAAWD,EAAYE,SAAS,UAEtC,IAAK,MAAMM,KAAS5H,EAAY2H,OAAQ,CACtC,IAAI+G,EACJ,MAAM+B,EAAa9I,EAAO3T,GAAGD,MAIzB2a,EAFAyB,EACEK,GAA4B7I,EAAO3T,GAAG2a,aAC/B7c,GAAOqD,KAAK,CAAC,EAAMsb,EAAWze,SAE9BF,GAAOqD,KAAK,CAAC,IAGpBwS,EAAO3T,GAAG2a,aACH7c,GAAOqD,KAAK,CAAC,EAAMwS,EAAO3T,GAAGD,MAAM/B,SAEnCF,GAAOqD,KAAK,CAAC,IAI1BqR,EAAO1U,GAAOuD,OAAO,CACnBqZ,EACA+B,EACApJ,EAAWvV,GAAOqD,KAAK,CAAC,IAASrD,GAAOC,MAAM,GAC9C4U,GAAaiB,EAAMZ,OAAOhV,gBAEtBie,GACJnC,EACAoC,GACA,EACA1J,EACA2J,EACAC,EACAhJ,GAEF,MAAMgI,EAAyB,GAC/B,IAAI7Z,EAAS,EAEb,GAA4B,IAAxBqS,EAAMZ,OAAOhV,OACfod,EAAa5a,KAAKoT,EAAMrF,eAExB,KAAOhN,IAAWqS,EAAMZ,OAAOhV,QAAQ,CACrC,MAAMsd,EACJ1H,EAAMZ,OAAOhV,OAASuD,EAASgB,EAC3BA,EACAqR,EAAMZ,OAAOhV,OAASuD,EAExBA,EAAS+Z,IAAc1H,EAAMZ,OAAOhV,OACtCod,EAAa5a,KAAKoT,EAAMZ,OAAO/T,MAAMsC,EAAQA,EAAS+Z,IAEtDF,EAAa5a,KACX1C,GAAOuD,OAAO,CAACuS,EAAMZ,OAAO/T,MAAMsC,EAAQA,EAAS+Z,GAAY1H,EAAMrF,YAIzEhN,GAAU+Z,CACZ,CAGF,IAAK,MAAMC,KAAeH,QAClBa,GACJnC,EACAoC,GACA,EACAX,EACAY,EACAC,EACAhJ,GAIJpT,GACF,CACF,G,wBChIM,SAAU0c,GACd5C,EACAU,EACAxO,EACAoH,EAA6B,IAE7B,IAAKpH,EACH,MAAM,IAAIrM,MAAM,qCAKlB,GAFiByT,EAAYE,SAAS,UAGpC,MAAM,IAAI3T,MAAM,oCAGlB,IAAIiH,EAAO+V,IAAM,UACdha,OAAOga,IAAM,UAAUha,OAAOsQ,GAAqBjH,GAAa,IAAOnJ,UACvEA,SACH,MAAM2P,EAAO1U,GAAOC,MAAM,GAC1ByU,EAAK3R,cAAc2Z,EAAa,GAChC,MAAM,QAAE3H,EAAO,SAAEpI,GAAauB,EAE9B,IAAK6G,IAAYpI,EACf,MAAM,IAAI9K,MAAM,yDAGlB,IAAKkT,EAAQ2H,GACX,MAAM,IAAI7a,MAAM,sCAIlB,OADAiH,EAAO9I,GAAOuD,OAAO,CAACuF,EAAM4L,EAAMK,EAAQ2H,GAAa1V,SAChD8B,EAAKjI,SAAS,MACvB,C,uBCrCM,SAAUie,GAAkBlH,GAChC,MAAMgF,EAAiC,KAAP,EAAhBhF,EAAU,KAAiB,EAAO,EAC5CmH,EAAe/e,GAAOC,MAAM,GAElC,OADA8e,EAAa,GAAKnC,EACX5c,GAAOuD,OAAO,CAACwb,EAAcnH,EAAUzW,MAAM,EAAG,KACzD,C,uBCHM,SAAU6d,GACdhD,EACAxb,EACAmY,EACAM,EACAgG,EACA3J,EAA6B,IAE7B,MAAMC,EAAWD,EAAYE,SAAS,UAChC0J,EAAc3e,EAAcC,GAC5B2e,EAAiBnf,GAAOC,MAAM,GACpCkf,EAAe7e,cAAcqY,EAAU,GACvC,IAAI5Y,EAASwV,EACTvV,GAAOuD,OAAO,CACZ2b,EACAC,EACAF,GAAgBjf,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,IAC/CrD,GAAOqD,KAAK,CAAC4V,MAEfjZ,GAAOuD,OAAO,CAAC2b,EAAalf,GAAOqD,KAAK,CAAC,IAAQ8b,EAAgBnf,GAAOqD,KAAK,CAAC4V,MAMlF,OAJIgG,IAAiB1J,IACnBxV,EAASC,GAAOuD,OAAO,CAACxD,EAAQkf,KAG3BjD,EAAUK,KAAK,IAAM,GAAM,EAAM,EAAMtc,GAAQqf,MAAKxb,GACrDA,EAAO1D,OAAS,GAClB0D,EAAO,GAAK,GACLA,EAAOzC,MAAM,EAAGyC,EAAO1D,OAAS,IAGlC0D,GAEX,C,2SChCM,SAAUyb,GAA4BrD,EAAsBxb,GAChE,MAAMT,EAASQ,EAAcC,GAC7B,OAAOwb,EAAUK,KAAK,IAAM,GAAM,IAAM,EAAMtc,EAChD,CACM,SAAgBuf,GAAcvC,EAAAwC,G,2CAClCvD,EACAvC,EACAnE,EAA6B,IAE7B,IAAI7R,EAAS,EACb,MAAMyY,EAAKva,OAAO,KAKlB,GAJiB2T,EAAYE,SAAS,UAKpC,OAAOwG,EAAUK,KAAK,IAAM,GAAMH,EAAI,EAAMzC,GAG9C,KAAOhW,EAASgW,EAAavZ,QAAQ,CACnC,MAAMsd,EACJ/Z,EAASgB,GAAoBgV,EAAavZ,OACtCuZ,EAAavZ,OAASuD,EACtBgB,EACAyX,EAAKzY,EAAS+Z,IAAc/D,EAAavZ,OAAS,IAAO,EACzDwU,EAAO+E,EAAatY,MAAMsC,EAAQA,EAAS+Z,SAC3CxB,EAAUK,KAAK,IAAM,GAAMH,EAAI,EAAMxH,GAC3CjR,GAAU+Z,CACZ,CACF,G,4SCvBO,MAAMgC,GAA0BxD,GAAgDoB,QAAA,6BACrF,MAAMrC,QAAUiB,EAAUK,KAAK,IAAM,EAAM,EAAM,GACjD,IAAIna,EAAI,EACR,MAAMwV,EAASqD,EAAE7Y,KACjBgc,KAAqB,IAAXxG,EAAc,0CACxB,MAAM+H,EAAa1E,EAAE7Y,KACfwd,EAAO3E,EAAE5Z,MAAMe,EAAIA,GAAKud,GAAa5e,SAAS,SAC9C8e,EAAgB5E,EAAE7Y,KAClBX,EAAUwZ,EAAE5Z,MAAMe,EAAIA,GAAKyd,GAAgB9e,SAAS,SACpD+e,EAAa7E,EAAE7Y,KAErB,MAAO,CACLwd,OACAne,UACAse,MAJY9E,EAAE5Z,MAAMe,EAAIA,GAAK0d,GAMjC,I,8TCCA,MAAME,GAA0B,CAC9BnH,SnBvB8B,EmBwB9BM,YnBnByB,EmBoBzBR,QAAQ,EACRnD,YAAa,GACbwD,kBAAmBiH,MACnBhG,yBAA0BA,OAC1BJ,2BAA4BA,QAsBxB,SAAgBqG,GACpBhE,EACAzD,G,0CAEA,MAAM0H,EAAMhM,OAAAC,OAAAD,OAAAC,OAAA,GAAQ4L,IAA4BvH,IAC1C,OACJ1C,EAAM,kBACNmD,EAAiB,WACjBO,EAAU,gBACVJ,EAAe,SACfR,EAAQ,YACRM,EAAW,OACXR,EAAM,iBACNyH,EAAgB,YAChB5K,EAAW,aACX2J,EAAY,kBACZnG,EAAiB,yBACjBiB,EAAwB,2BACxBJ,GACEsG,EACJ,IAAIvB,EAA2BuB,EAAOvB,yBAEtC,QAAiCrV,IAA7BqV,EACF,IAEEA,EC/EA,UAAyC,QAC7Cnd,EAAO,KACPme,IAKA,MAAa,WAATA,IACS,aAATA,GACGS,IAAAA,IAAW5e,EAAS,SAC7B,CDqEiC6e,OADXZ,GAAiBxD,GAEnC,CAAE,MAAOqE,GACP,GAAqB,QAAjBA,EAAEC,WAGJ,MAAMD,EAFN3B,GAA2B,CAI/B,CAOF,MAAM6B,EAASA,CAACC,EAAMte,KACpB,MAAM,OAAEhC,GAAW2V,EACnB,GAAI3V,EAAS,EAAG,OAEhB,MAAMG,EAAQH,EAASsgB,EAAOte,EACxB6W,EAAQ,EAAI7Y,EAElB4Y,EAAkB,CAChBD,SAFexY,EAAQ0Y,EAGvBA,QACA1Y,SACA,EAGEkV,EAAWD,EAAYE,SAAS,UAChCC,EAAUH,EAAYE,SAAS,SAC/B0H,EAAQ5H,EAAYE,SAAS,eAC7BiL,EAAYC,KAAKC,MACjBC,EAAUtL,EAAYE,SAAS,WAC/BsG,EAASrD,GAAUnD,EAAYE,SAAS,UACxCqL,EACJpI,KACGnD,IACAA,EAAYE,SAAS,QACpBF,EAAYE,SAAS,SACrBF,EAAYE,SAAS,cACtByJ,IAAiB1J,EAGhB4J,EAAiBnf,GAAOC,MAAM,GACpCkf,EAAepc,cAAc4V,EAAU,GACvC,MAAMmI,EAAa9gB,GAAOC,MAAM,GAC1B8gB,EAAc/gB,GAAOC,MAAM,GAC3B+gB,EAAiBhhB,GAAOC,MAAM,GAClCgf,IAAiB1J,EACfyL,EAAeje,cAAc0S,EAAU,WAAamL,EAAU,WAAa,WAAY,GACvF1D,EACE8D,EAAeje,cAAc,EAAG,GAChCie,EAAeje,cAAc,EAAG,GAEtC,MAAMke,EAA4B,GAC5BC,EAA2C,GAC3CC,EAAuB,GACvBC,EAAuB,GAC7B,IAAIC,GAAW,EACf,MACMC,EAAiC,CACrCzL,OAAQ,GACRtU,QAASyf,EACT3L,UAAWrV,GAAOC,MAAM,IAEpBshB,EACJV,IAAcnC,EAA2BE,GAAwB9B,GAC7DrD,EAAezZ,GAAOqD,KAAK8V,EAAiB,OAClDoH,EAAO,EAAG,GAEV,IAAK,MAAMzK,KAASD,EAAQ,CACX,CACb,MAAMgH,QAAqB0E,EAAoBvF,EAAWlG,EAAM,GAAIA,EAAM,GAAIR,IAC9EkM,EAAAA,GAAAA,IAAI,KAAM,oBAAsB3E,GAChC,MAAMpM,EAAWzQ,GAAOC,MAAM,GAC9BwQ,EAAS1N,cACP+S,EAAM5V,QAAU,GAAyB,kBAAb4V,EAAM,GAAkBA,EAAM,GAAKpR,EAC/D,GAEFuc,EAAcve,KAAK,CACjBma,cAAc,EACd5a,MAAOjC,GAAOqD,KAAKwZ,EAAc,OACjCpM,YAEJ,CAEA,MAAM,QAAEsE,GAAYe,EAAM,GACpBzV,EAAQyV,EAAM,GAEhBf,GAAW1U,GAAS0U,EAAQ7U,OAAS,GACvCghB,EAAexe,KAAKqS,EAAQ1U,IAG1B4e,IAAiB1J,GACnB+L,EAAkBnL,gBAAkBnW,GAAOqD,KAGzCoS,EACI,CAAC,GAAM,GAAM,IAAM,IACnBmL,EACE,CAAC,IAAM,GAAM,GAAM,KACnB,CAAC,IAAM,IAAM,IAAM,IAE3BU,EAAkBrL,cAAgBgJ,EAGlCqC,EAAkBpL,UAAYlW,GAAOqD,KACnCud,EAAU,CAAC,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,GAAQ,CAAC,KAEzErL,IACT+L,EAAkBrL,cAAgBgJ,EAEtC,CAEAqC,EAAkBzL,OAASA,EAAO1K,KAAI,CAAC2K,EAAO2L,KAC5C,MAAMhR,EAAWzQ,GAAOC,MAAM,GAK9B,OAJAwQ,EAAS1N,cACP+S,EAAM5V,QAAU,GAAyB,kBAAb4V,EAAM,GAAkBA,EAAM,GAAKpR,EAC/D,GAEK,CACLwQ,OAAQO,EAAUyL,EAAeO,GAAKvM,OAAS4L,EAC/C/K,QAASgL,EACTtQ,WACD,IAGY,CAEb,MAAM7M,EAIA,GAEN,IAAK,IAAI1B,EAAI,EAAGA,EAAI2T,EAAO3V,OAAQgC,IAAK,CACtC,MAAM6Y,QAAUrE,GAAmBsF,EAAW,CAC5Cxb,KAAMwY,EAAkB9W,KAE1Bqe,EAAO,EAAGre,EAAI,GACd0B,EAAOlB,KAAKqY,EACd,CAEA,IAAK,IAAI7Y,EAAI,EAAGA,EAAI0B,EAAO1D,OAAQgC,IACjCkf,EAAW1e,KAAKoc,GAAkB9e,GAAOqD,KAAKO,EAAO1B,GAAG0V,UAAW,QAEvE,MAEyBvO,IAArB6W,IACFoB,EAAkBjM,UAAYrV,GAAOC,MAAM,GAC3CqhB,EAAkBjM,UAAUtS,cAC1B0G,KAAKC,MAAMwW,GAAoBQ,KAAKC,MAAQF,GAAa,KACzD,IAIJ9G,IAEIkH,UAEItC,GACJvC,GACA,EACAsF,EACAL,GACA,IACEhC,EACF3J,EACAoJ,GAGenF,UACT8F,GAA4BrD,EAAWzC,UAGzC+F,GAAetD,EAAWvC,IAG5BwF,IAAiB1J,UACfyJ,GAAgBhD,EAAW,GAAIrD,EnB1Pd,EmB0PqCsG,IAI9D,IAAK,IAAI/c,EAAI,EAAGA,EAAI2T,EAAO3V,OAAQgC,IAAK,CACtC,MAAM4T,EAAQD,EAAO3T,GACfgT,EACJW,EAAO3T,GAAGhC,QAAU,GAAyB,kBAAb4V,EAAM,GAClC9V,GAAOqD,KAAKyS,EAAM,GAAI,OACrB2C,EAECzY,GAAOuD,OAAO,CACZvD,GAAOqD,KAAK,CnBpQJ,IACI,IACD,KmBmQXsB,EAAcyc,EAAWlf,IACzBlC,GAAOqD,KAAK,CnBlQI,IACH,QmB6Pf6d,EAAehf,GAAGgT,OAMpBwM,EAAWzN,OAAOC,OAAO,CAAC,EAAGoN,GAC7BK,EAAsBd,EAAY,CAACI,EAAc/e,IAAM+e,EAEzDJ,EACFa,EAAS7L,OAAS,CAAA5B,OAAAC,OAAAD,OAAAC,OAAA,GAAMwN,EAAS7L,OAAO3T,IAAE,CAAEgT,YAE5CwM,EAAS7L,OAAO3T,GAAGgT,OAASA,QAGxBqJ,GACJvC,GACC6E,GAAaQ,EACdK,EACAC,EACAd,IACE5B,IAAiB1J,EACnBD,EACAoJ,GAGGmC,IACctH,UACT8F,GAA4BrD,EAAWzC,UAGzC+F,GAAetD,EAAWvC,EAAcnE,IAG5C+L,IACFtH,IACAwG,EAAO,EAAG,IAGZ,MAAM7R,QAAkBsQ,GACtBhD,EACAhD,EAAkB9W,GAClByW,EACAM,EACAgG,EACA3J,GAEFiL,EAAO,EAAGre,EAAI,GACdif,EAAWze,KAAKgM,GAChB4S,EAAkBzL,OAAO3T,GAAGgT,OAAS4L,EAEjCO,IACFA,GAAW,EAEf,CAGA,IAAK,IAAInf,EAAI,EAAGA,EAAI2T,EAAO3V,OAAQgC,IAAK,CACtC,GAAIuW,EACF6I,EAAkBtL,QAAUhW,GAAOC,MAAM,GAEpC6b,IACHwF,EAAkBzL,OAAO3T,GAAGgT,OAASlV,GAAOuD,OAAO,CACjDvD,GAAOqD,KAAK,SAAU,OACtBsB,EAAcyc,EAAWlf,WAGxB,CACL,MAAM0f,EAAgB5hB,GAAOC,MAAM,GAC7B4hB,EAAU7hB,GAAOC,MAAM,GAC7B2hB,EAAc,GAAKT,EAAWjf,GAAGhC,OACjC2hB,EAAQ,GAAKT,EAAWlf,GAAGhC,OAC3BohB,EAAkBzL,OAAO3T,GAAGgT,OAASlV,GAAOuD,OAAO,CACjDqe,EACAT,EAAWjf,GACX2f,EACAT,EAAWlf,IAEf,CAEA,MAAMuB,EAASod,IAAcnC,EAA2B,EAAI,EAC5D4C,EAAkBzL,OAAO3T,GAAG6T,QAAUkL,EAAc/e,GAAGD,MAAMd,MAAMsC,EAAQA,EAAS,GACtF,CACA6d,EAAkB3U,SAAWwS,EAC7B,IAAIvb,EAAS5D,GAAOuD,OAAO,CACzB4R,GAAqBmM,GAAmB,EAAOA,EAAkBjM,UAAWC,GAC5EmE,IAGF,GAAIhB,IAAWlD,EAAU,CACvB,IAAIS,EAAUhW,GAAOC,MAAM,GAE3B,IAAK,IAAIiC,EAAI,EAAGA,EAAI2T,EAAO3V,OAAQgC,IAAK,CACtC,MAAM4f,EAAgB9hB,GAAOuD,OAAO,CAClCvD,GAAOqD,KAAK,KAAM,OAClBrD,GAAOqD,KAAK,CAAC8d,EAAWjf,GAAGhC,SAC3BihB,EAAWjf,GACXlC,GAAOqD,KAAK,CAAC+d,EAAWlf,GAAGhC,SAC3BkhB,EAAWlf,KAEb8T,EAAUhW,GAAOuD,OAAO,CAACyS,EAAS8L,GACpC,CAEAle,EAAS5D,GAAOuD,OAAO,CAACK,EAAQoS,GAClC,CAaA,GAVKP,IACH7R,EAAS5D,GAAOuD,OAAO,CAACK,EAAQub,IAC5BF,IACFrb,EAAS5D,GAAOuD,OAAO,CACrBK,EACA0d,EAAkBrL,eAAiBjW,GAAOC,MAAM,GAChDqhB,EAAkBpL,WAAalW,GAAOC,MAAM,OAI9CsV,EAAU,CACZ,IAAIwM,EAAgB/hB,GAAOqD,KAAK,CAACie,EAAkBzL,OAAO3V,SAC1D2V,EAAO1V,SAAQ,CAAC2V,EAAO7H,KACrB8T,EAAgB/hB,GAAOuD,OAAO,CAC5Bwe,EACA/hB,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,EAAM,IACvDrD,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,IAC/BrD,GAAOqD,KAAK,CAAC,IAAM,IAAM,IAAM,MAC/BrD,GAAOqD,KAAK,CAACie,EAAkBzL,OAAO5H,GAAYiH,OAAOhV,SACzDohB,EAAkBzL,OAAO5H,GAAYiH,QACrC,IAEJtR,EAAS5D,GAAOuD,OAAO,CAACK,EAAQme,GAClC,CAIA,OAHItM,IACF7R,EAAS5D,GAAOuD,OAAO,CAACK,EAAQ5D,GAAOqD,KAAK,CAAC,EAAM,EAAM,OAEpDO,EAAO/C,SAAS,MACzB,G,6nBElYc,MAAOmhB,GACnB5f,WAAAA,CAAoB4Z,GAAA,KAAAA,UAAAA,EAEZ,KAAAiG,iBAAmB,CAAC,CAFe,CAG7BC,YAAAA,CAAa1hB,G,0CACzB,GAAIiC,KAAKwf,iBAAiBzhB,GAAO,OAAOiC,KAAKwf,iBAAiBzhB,GAC9D,MAAM+c,QAAY7G,GAAmBjU,KAAKuZ,UAAW,CACnDxb,SAGF,OADAiC,KAAKwf,iBAAiBzhB,GAAQ+c,EACvBA,CACT,G,CAEMjH,aAAAA,CAAaxJ,G,4CAAC,KAClBtM,EAAI,YACJ+V,IAKA,MAAM5V,EAAeF,EAAkBD,GACjC2hB,EAAaxhB,EAAaQ,MAAM,GAAI,GACpCihB,QAAyB3f,KAAKyf,aAAaxhB,EAAkByhB,IAC7DE,QAA0B5f,KAAKyf,aAAa1hB,GAC5C4R,EA8GV,SAAyBkQ,GACvB,OA2CeviB,EA3CAuiB,EAwCjB,SAAmBviB,GACjB,OAAO,IAAI6E,MAAYC,OAAO9E,GAAQgF,QACxC,CAESwd,CAAUjb,GAAOvH,KA5CSoB,MAAM,EAAG,GA2C5C,IAAiBpB,CA1CjB,CAhHwByiB,CAClBC,GAAyBziB,GAAOqD,KAAK+e,EAAiBxK,UAAW,SAUnE,OAgHJ,SACErW,EACAmhB,EACAC,EACAtiB,EACA0X,EACA6K,GAEA,MAAMC,EAAcC,GAAiBziB,GACrCwiB,EAAY,IAAM,IAClB,MAAME,EAAmB/iB,GAAOuD,OAAO,CACrCuf,GAAiBvhB,GACjBvB,GAAOqD,KAAK,CAACqf,IACbC,EACAE,EACA9K,EACA6K,IAEII,GAOSjjB,EAPUgjB,EAQlBzb,GAAOA,GAAOvH,KARsBoB,MAAM,EAAG,GAOtD,IAAiBpB,EANf,OAAOkjB,KAAAA,OAAYjjB,GAAOuD,OAAO,CAACwf,EAAkBC,IACtD,CA5IiBE,CACX3M,EACA5V,EAAaT,OACbkS,EACAzR,EAAaA,EAAaT,OAAS,GACnCF,GAAOqD,KAAKgf,EAAkBtK,UAAW,OACzC0K,GAAyBziB,GAAOqD,KAAKgf,EAAkBzK,UAAW,QAGtE,G,CA0BAlB,kBAAAA,CACElW,EACAmW,GASA,GAAqB,aAAb,OAAJA,QAAI,IAAJA,OAAI,EAAJA,EAAMe,QACR,MAAM,IAAI7V,MAAM,sCAElB,OAAO6U,GAAmBjU,KAAKuZ,UAAS/H,OAAAC,OAAAD,OAAAC,OAAA,GAAOyC,GAAI,CAAEnW,SACvD,CAoCA8X,wBAAAA,CAAyBC,GACvB,GAAI4K,UAAUjjB,OAAS,EACrB,MAAM,IAAI2B,MACR,6HAGJ,OAAOme,GAAkBvd,KAAKuZ,UAAWzD,EAC3C,CAEMqC,WAAAA,CAAW9N,G,4CAAC,KAAEtM,EAAI,WAAEqa,IAKxB,OC9IE,SAA2BkC,EAAAjQ,G,2CAC/BkP,GACA,KACExb,EAAI,WACJqa,IAUF,MAAM/a,EAAQc,IAAAA,WAAmBJ,GAAMM,cACjCga,EAAU9a,GAAOqD,KAAKwX,EAAY,OACxC,IAAIpX,EAAS,EAEb,KAAOA,IAAWqX,EAAQ5a,QAAQ,CAChC,MAAMkjB,EACO,IAAX3f,EAAegB,EAAmB,EAAmB,EAAf3E,EAAMI,OAAa,EAAIuE,EACzD4e,EACJ5f,EAAS2f,EAAetI,EAAQ5a,OAAS4a,EAAQ5a,OAASuD,EAAS2f,EAC/DrjB,EAASC,GAAOC,MAAiB,IAAXwD,EAAe,EAAmB,EAAf3D,EAAMI,OAAa,EAAImjB,EAAYA,GAEnE,IAAX5f,GACF1D,EAAO,GAAKD,EAAMI,OAClBJ,EAAMK,SAAQ,CAACC,EAASC,KACtBN,EAAOO,cAAcF,EAAS,EAAI,EAAIC,EAAM,IAE9CN,EAAOujB,cAAcxI,EAAQ5a,OAAQ,EAAI,EAAIJ,EAAMI,QACnD4a,EAAQnI,KAAK5S,EAAQ,EAAI,EAAID,EAAMI,OAAS,EAAGuD,EAAQA,EAAS4f,IAEhEvI,EAAQnI,KAAK5S,EAAQ,EAAG0D,EAAQA,EAAS4f,SAGrCrH,EAAUK,KAAK,IAAM,GAAM,EAAiB,IAAX5Y,EAAe,EAAO,IAAM1D,GACnE0D,GAAU4f,CACZ,CAEA,MAAM9F,QAAYvB,EAAUK,KAAK,IAAM,GAAM,IAAM,EAAMrc,GAAOqD,KAAK,CAAC,KAChE2P,EAAIuK,EAAI,GAAK,GACnB,IAAIxC,EAAqBwC,EAAIpc,MAAM,EAAG,EAAIoc,EAAI,IAEjC,IAATxC,EAAE,KACJA,EAAIA,EAAE5Z,MAAM,IAGd4Z,EAAIA,EAAEla,SAAS,OACf4C,EAAS,EAAI8Z,EAAI,GAAK,EACtB,IAAIvC,EAAqBuC,EAAIpc,MAAMsC,EAAQA,EAAS8Z,EAAI9Z,EAAS,IAOjE,OALa,IAATuX,EAAE,KACJA,EAAIA,EAAE7Z,MAAM,IAGd6Z,EAAIA,EAAEna,SAAS,OACR,CACLmS,IACA+H,IACAC,IAEJ,G,CDgFWJ,CAAYnY,KAAKuZ,UAAW,CACjCxb,OACAqa,cAEJ,G,EAOF,SAASiI,GAAiBphB,GACxB,MAAMsE,EAAMhG,GAAOujB,YAAY,GAE/B,OADAvd,EAAI1F,cAAcoB,EAAG,GACdsE,CACT,CAEA,MAAMyc,GAA4B7K,GAChC5X,GAAOuD,OAAO,CAACvD,GAAOqD,KAAK,CAAC,GAAwB,EAAhBuU,EAAU,OAAeA,EAAUzW,MAAM,EAAG,MAwBlF,SAASmG,GAAOvH,GACd,OAAO+E,IAAI,UAAUD,OAAO9E,GAAQgF,QACtC,C,uBEhLM,MAAOye,GASXphB,WAAAA,CAAY2I,EAAgB0Y,GAC1B,GAAI1Y,EAAK7K,QAAUujB,EAAOvjB,OACxB,MAAM,IAAI2B,MAAM,+CAIlB,IAAK,IAAIK,EAAI,EAAGA,EAAI6I,EAAK7K,OAAS,EAAGgC,IACnC,GAAI6I,EAAK7I,GAAGrB,SAAS,QAAUkK,EAAK7I,EAAI,GAAGrB,SAAS,OAClD,MAAM,IAAIgB,MAAM,6CAIpBY,KAAKsI,KAAOA,EACZtI,KAAKihB,SAAW,IAAIrb,EAAO0C,EAAKI,KAAIC,GAAKd,EAASc,MAClD3I,KAAKghB,OAASA,EACdhhB,KAAKkhB,WAAa,IAAItb,EAAOob,EAAOtY,KAAI6H,GAAK1I,EAAS0I,KACxD,CAEA4Q,UAAAA,GAEE,OAAO5jB,GAAOuD,OAAO,CACnBsR,GAAapS,KAAKsI,KAAK7K,QACvBuC,KAAKihB,SAAS7a,UACdpG,KAAKkhB,WAAW9a,WAEpB,E,uBCjCI,MAAOgb,WAAuB9X,GAMlC3J,WAAAA,CAAY6C,GACV6e,QALK,KAAAC,gBAA+B,GAC/B,KAAAC,iBAAgC,GAKrC/e,EAAK0N,KAAKlQ,MACVA,KAAKwhB,gBAAkBJ,GAAeK,gBAAgBzhB,KAAKuJ,WAE3D,IAAK,IAAI9J,EAAI,EAAGA,EAAIO,KAAK2K,sBAAuBlL,IAC9CO,KAAKshB,gBAAgBrhB,KAAKmhB,GAAeK,gBAAgBzhB,KAAKyJ,UAAUhK,KAE1EO,KAAK0hB,oBAAsB,IAAI1hB,KAAKshB,gBAAgBN,UAAUtY,KAAI6H,GAAKA,EAAE4Q,eAEzE,IAAK,IAAI1hB,EAAI,EAAGA,EAAIO,KAAKgL,uBAAwBvL,IAC/CO,KAAKuhB,iBAAiBthB,KAAKmhB,GAAeK,gBAAgBzhB,KAAK0J,WAAWjK,KAE5EO,KAAK2hB,qBAAuB,IAAI3hB,KAAKuhB,iBAAiBP,UAAUtY,KAAI6H,GAAKA,EAAE4Q,cAC7E,CAEAS,aAAAA,GACE,OAAO5hB,KAAKuJ,UAAUjD,IACxB,CACAub,uBAAAA,GACE,OAAO7hB,KAAKwhB,gBAAgBL,YAC9B,CAEQ,sBAAOM,CAAgB/Y,GAC7B,MAAMoZ,EAAoB,IAAIpZ,EAAIJ,QAAQyZ,OACpCf,EAASc,EAAkBpZ,KAAIC,IACnC,MAAM4H,EAAI7H,EAAIsI,IAAIrI,GAClB,IAAK4H,EACH,MAAM,IAAInR,MAAM,oBAAsBuJ,GAExC,OAAO4H,CAAC,IAEJyR,EAAaF,EAAkBpZ,KAAIC,GAAKpL,GAAOqD,KAAK+H,EAAG,SAG7D,OADkB,IAAIoY,GAAUiB,EAAYhB,EAE9C,E,IClDGiB,G,oBAAL,SAAKA,GACHA,EAAAA,EAAA,kBACAA,EAAAA,EAAA,gCACAA,EAAAA,EAAA,kDACAA,EAAAA,EAAA,kDACAA,EAAAA,EAAA,0CACD,CAND,CAAKA,KAAAA,GAAiB,KAQtB,MAAeC,IAKT,MAAOC,WAAqBD,GAKhCviB,WAAAA,CACEyiB,EACQ/K,GAERgK,QAFQ,KAAAhK,iBAAAA,EAJV,KAAAgL,KAAOJ,GAAkBK,MAOvBtiB,KAAKoiB,QAAUA,CACjB,CAEAG,OAAAA,CAAQC,GAGN,OAFAxiB,KAAKoiB,QAAQniB,KAAK1C,GAAOqD,KAAK4hB,EAAQC,SAAS,KAC/CziB,KAAKqX,mBACE9Z,GAAOqD,KAAK,GACrB,EAGI,MAAO8hB,WAA2BR,GAMtCviB,WAAAA,CAAYgjB,EAAsCC,GAChDvB,QAHF,KAAAgB,KAAOJ,GAAkBY,aAIvB7iB,KAAK2iB,gBAAkBA,EACvB3iB,KAAK4iB,MAAQA,CACf,CAEAL,OAAAA,CAAQC,GACN,MAAMM,EAAMvlB,GAAOqD,KAAK4hB,EAAQC,SAAS,IAGzC,GAAkB,IAAdK,EAAIrlB,OACN,MAAM,IAAI2B,MAAM,6CAGlB,GAAc,GAAV0jB,EAAI,GACN,MAAM,IAAI1jB,MAAM,mDAIlB,MAAMiH,EAAO9I,GAAOC,MAAM,IAC1B,IAAK,IAAIiC,EAAI,EAAGA,EAAI,GAAIA,IACtB4G,EAAK5G,GAAKqjB,EAAI,EAAIrjB,GAEpB,MAAMsjB,EAAe1c,EAAKjI,SAAS,OAE7B4kB,EAAiBhjB,KAAK2iB,gBAAgB3R,IAAI+R,GAChD,QAAsBnc,GAAlBoc,EAA6B,CAC/B,MAAMC,EAAsB7Q,GAAa4Q,EAAevlB,QAIlDylB,EAAmB,IAAMD,EAAoBxlB,OAAS,EAEtD0lB,EAAenc,KAAKoc,IAAIF,EAAkBF,EAAevlB,QAE/D,GAAI0lB,EAAeH,EAAevlB,OAChC,IAAK,IAAIgC,EAAI0jB,EAAc1jB,EAAIujB,EAAevlB,OAAQgC,IACpDO,KAAK4iB,MAAM3iB,KAAK1C,GAAOqD,KAAK,CAACoiB,EAAevjB,MAIhD,OAAOlC,GAAOuD,OAAO,CACnBmiB,EACA1lB,GAAOqD,KAAK,CAACuiB,IACb5lB,GAAOqD,KAAKoiB,EAAeP,SAAS,EAAGU,KAE3C,CAEA,MAAM/jB,MAAM,mCAAmC2jB,IACjD,EAGI,MAAOM,WAAkCnB,GAM7CviB,WAAAA,CAAY2jB,EAAkCV,GAC5CvB,QAHF,KAAAgB,KAAOJ,GAAkBsB,sBAIvBvjB,KAAKsjB,YAAcA,EACnBtjB,KAAK4iB,MAAQA,CACf,CAEAL,OAAAA,CAAQC,GACN,MAAMM,EAAMvlB,GAAOqD,KAAK4hB,EAAQC,SAAS,IAEzC,GAAIK,EAAIrlB,OAAS,GACf,MAAM,IAAI2B,MAAM,+CAGlB,MAAMokB,EAAS,IAAIziB,EAAa+hB,GAE1BW,EADOD,EAAO/hB,UAAU,IACRrD,SAAS,OAE/B,IAAIslB,EACAC,EACJ,IACED,EAAYF,EAAO9hB,aACnBiiB,EAAaH,EAAO9hB,YACtB,CAAE,MAAOkc,GACP,MAAM,IAAIxe,MAAM,0DAClB,CAEA,MAAMwkB,EAAK5jB,KAAKsjB,YAAYtS,IAAIyS,GAChC,IAAKG,EACH,MAAMxkB,MAAM,iDAAiDqkB,KAG/D,GAAIE,GAAcD,GAAaE,EAAGtd,QAAUod,EAC1C,MAAMtkB,MAAM,+BAGd,GAAyB,GAArBY,KAAK4iB,MAAMnlB,OACb,MAAM2B,MAAM,gEAGd,MAAMykB,EAAQD,EAAGnd,SAASkd,GAEpBG,EAAsB9c,KAAKoc,IAAIpc,KAAKC,MAAM,IAAqB,IAAK4c,EAAMpmB,QAC1EsmB,EAAsBF,EAAMpmB,OAASqmB,EAO3C,OAJIC,EAAsB,GACxB/jB,KAAK4iB,MAAM3iB,QAAQ4jB,EAAMnlB,OAAOqlB,IAG3BxmB,GAAOuD,OAAO,CACnB8iB,EAAGpd,YAAYmd,GACfpmB,GAAOqD,KAAK,CAACijB,EAAMpmB,SACnBF,GAAOqD,KAAK,CAACkjB,OACVD,EAAMnlB,MAAM,EAAGolB,IAEtB,EAGI,MAAOE,WAAkC9B,GAK7CviB,WAAAA,CAAY2jB,GACVjC,QAHF,KAAAgB,KAAOJ,GAAkBgC,sBAIvBjkB,KAAKsjB,YAAcA,CACrB,CAEAf,OAAAA,CAAQC,GACN,MAAMM,EAAMvlB,GAAOqD,KAAK4hB,EAAQC,SAAS,IAEzC,GAAkB,IAAdK,EAAIrlB,OACN,MAAM,IAAI2B,MAAM,6CAIlB,MAAM8kB,EAAY3mB,GAAOC,MAAM,IAC/B,IAAK,IAAIiC,EAAI,EAAGA,EAAI,GAAIA,IACtBykB,EAAUzkB,GAAKqjB,EAAI5hB,UAAUzB,GAE/B,MAAM0kB,EAAgBD,EAAU9lB,SAAS,OAGnCgmB,EAAY7mB,GAAOC,MAAM,IAC/B,IAAK,IAAIiC,EAAI,EAAGA,EAAI,GAAIA,IACtB2kB,EAAU3kB,GAAKqjB,EAAI5hB,UAAU,GAAKzB,GAEpC,MAAM4kB,EAAgBD,EAAUhmB,SAAS,OAEnCwlB,EAAK5jB,KAAKsjB,YAAYtS,IAAImT,GAChC,IAAKP,EACH,MAAMxkB,MAAM,iDAAiD+kB,KAG/D,IAAIR,EAAa,EACbW,EAAQ,EACZ,IAAK,IAAI7kB,EAAI,EAAGA,EAAImkB,EAAGtd,OAAQ7G,IAC7B,GAAImkB,EAAGpd,YAAY/G,GAAGrB,SAAS,QAAUimB,EAAe,CACtDC,EAAQ,EACRX,EAAalkB,EACb,KACF,CAEF,OAAOlC,GAAOuD,OAAO,CAACvD,GAAOqD,KAAK,CAAC0jB,IAASlS,GAAauR,IAC3D,EAGI,MAAOY,WAA+BrC,GAK1CviB,WAAAA,CAAYijB,GACVvB,QAHF,KAAAgB,KAAOJ,GAAkBuC,kBAIvBxkB,KAAK4iB,MAAQA,CACf,CAEAL,OAAAA,CAAQC,GACN,GAAsB,GAAlBA,EAAQ/kB,OACV,MAAM,IAAI2B,MAAM,6CAGlB,GAA0B,IAAtBY,KAAK4iB,MAAMnlB,OACb,MAAM,IAAI2B,MAAM,sBAIlB,MAAMqlB,EAAczkB,KAAK4iB,MAAM,GAAGnlB,OAClC,GAAIuC,KAAK4iB,MAAM9R,MAAK4T,GAAMA,EAAGjnB,QAAUgnB,IACrC,MAAM,IAAIrlB,MACR,iFAIJ,MAAMulB,EAAe3d,KAAKC,MAAM,IAAMwd,GAChCG,EAAsB5d,KAAKoc,IAAIuB,EAAc3kB,KAAK4iB,MAAMnlB,QAExDonB,EAAoB7kB,KAAK4iB,MAAMkC,OAAO,EAAGF,GAE/C,OAAOrnB,GAAOuD,OAAO,CACnBvD,GAAOqD,KAAK,CAACgkB,IACbrnB,GAAOqD,KAAK,CAAC6jB,OACVI,GAEP,EAkBI,MAAOE,GAUXplB,WAAAA,CAAY0X,GATJ,KAAA2N,MAA6B,IAAIxb,IACjC,KAAAyb,UAAiC,IAAIzb,IAErC,KAAA0b,QAAoB,GAEpB,KAAAtC,MAAkB,GAElB,KAAAuC,SAAkD,IAAI3b,IAG5D,MAAM2b,EAAW,CACf,IAAIhD,GAAaniB,KAAKklB,QAAS7N,GAC/B,IAAIqL,GAAmB1iB,KAAKilB,UAAWjlB,KAAK4iB,OAC5C,IAAIoB,GAA0BhkB,KAAKglB,OACnC,IAAI3B,GAA0BrjB,KAAKglB,MAAOhlB,KAAK4iB,OAC/C,IAAI2B,GAAuBvkB,KAAK4iB,QAGlC,IAAK,MAAMwC,KAAOD,EAAU,CAC1B,GAAInlB,KAAKmlB,SAAS/Q,IAAIgR,EAAI/C,MACxB,MAAM,IAAIjjB,MAAM,+BAA+BgmB,EAAI/C,QAErDriB,KAAKmlB,SAAS3U,IAAI4U,EAAI/C,KAAM+C,EAC9B,CACF,CAEAC,UAAAA,GACE,OAAOrlB,KAAKklB,OACd,CAEAI,gBAAAA,CAAiBC,GACfvlB,KAAKilB,UAAUzU,IAAI5L,EAAAA,GAAOC,OAAO0gB,GAAUnnB,SAAS,OAAQmnB,EAC9D,CAEAC,YAAAA,CAAaC,GACX,IAAK,MAAMf,KAAMe,EAAU,CACzB,MAAMF,EAAWhoB,GAAOuD,OAAO,CAACvD,GAAOqD,KAAK,CAAC,IAAK8jB,IAClD1kB,KAAKslB,iBAAiBC,EACxB,CACA,MAAM3B,EAAK,IAAIhe,EAAO6f,EAAS/c,KAAIgc,GAAM7c,EAAS6c,MAClD1kB,KAAKglB,MAAMxU,IAAIoT,EAAGxd,UAAUhI,SAAS,OAAQwlB,EAC/C,CAEA8B,eAAAA,CAAgBC,GACd3lB,KAAKwlB,aAAaG,EAAGrd,MACrBtI,KAAKwlB,aAAaG,EAAG3E,OACvB,CAEAuB,OAAAA,CAAQC,GACN,GAAsB,GAAlBA,EAAQ/kB,OACV,MAAM,IAAI2B,MAAM,4BAGlB,MAAMwmB,EAAUpD,EAAQ,GAClB4C,EAAMplB,KAAKmlB,SAASnU,IAAI4U,GAC9B,IAAKR,EACH,MAAM,IAAIhmB,MAAM,2BAA2BwmB,KAG7C,OAAOR,EAAI7C,QAAQC,EACrB,E,8TC1TF,IAAKqD,GAUAC,IAVL,SAAKD,GACHA,EAAAA,EAAA,2BAEAA,EAAAA,EAAA,qCACAA,EAAAA,EAAA,2CACAA,EAAAA,EAAA,yBACAA,EAAAA,EAAA,mDACAA,EAAAA,EAAA,+BACD,CARD,CAAKA,KAAAA,GAAU,KAUf,SAAKC,GACHA,EAAAA,EAAA,8CACD,CAFD,CAAKA,KAAAA,GAAY,KAQX,MAAOC,GAGXpmB,WAAAA,CAAY4Z,GACVvZ,KAAKuZ,UAAYA,CACnB,CAEcyM,WAAAA,CACZC,EACAhU,EACAiU,G,0CAEA,IAAIvM,QAAyB3Z,KAAKuZ,UAAUK,KAjChC,IAiC8CqM,EAAK,EAAG,EAAGhU,EAAM,CAAC,MAAQ,QACpF,KAAsD,QAA/C0H,EAASwM,aAAaxM,EAASlc,OAAS,IAAe,CAC5D,IAAKyoB,EACH,MAAM,IAAI9mB,MAAM,uCAGlB,MAAMgnB,EAAYzM,EAASjb,MAAM,GAAI,GAC/B2nB,EAAkBH,EAAI3D,QAAQ6D,GAEpCzM,QAAiB3Z,KAAKuZ,UAAUK,KAzChB,IA2CdkM,GAAaQ,qBACb,EACA,EACAD,EACA,CAAC,MAAQ,OAEb,CACA,OAAO1M,EAASjb,MAAM,GAAI,EAC5B,G,CAEMqV,iBAAAA,CAAkBY,EAAkBzW,G,0CACxC,GAAIA,EAAaT,OAAS,EACxB,MAAM,IAAI2B,MAAM,4CAMlB,aAJuBY,KAAKgmB,YAC1BH,GAAWU,WACXhpB,GAAOuD,OAAO,CAACvD,GAAOqD,KAAK+T,EAAU,CAAC,GAAK,CAAC,IAAKvX,EAAqBc,OAExDE,SAAS,QAC3B,G,CAEM0W,gBAAAA,CACJgE,EACA0N,EACAjS,EACAkS,EACA9R,G,0CAEA,GAAe,IAAXJ,GAA2B,IAAXA,EAAc,MAAM,IAAInV,MAAM,6BAClD,GAAIqnB,EAAe,IAAMvnB,OAAOwnB,UAAUD,GACxC,MAAM,IAAIrnB,MAAM,yBAElB,GAAkB,MAAdonB,GAA2C,IAArBA,EAAW/oB,OACnC,MAAM,IAAI2B,MAAM,uBAGlB,MAAMunB,EAAoB,IAAI5B,IAAyB,SACvD4B,EAAkBnB,aAAa1M,EAAaxQ,KAAKI,KAAIC,GAAKpL,GAAOqD,KAAK+H,EAAG,YACzEge,EAAkBrB,iBAAiBxM,EAAatQ,aAEhD,MAAMoe,EAAqBrpB,GAAOC,MAAM,GACxCopB,EAAmB/oB,cAAc4oB,EAAc,GAc/C,aAZuBzmB,KAAKgmB,YAC1BH,GAAWgB,mBACXtpB,GAAOuD,OAAO,CACZvD,GAAOqD,KAAK+T,EAAU,CAAC,GAAK,CAAC,IAC7BmE,EAAavQ,cACbie,GAAcjpB,GAAOC,MAAM,GAAI,GAC/BD,GAAOqD,KAAK,CAAC2T,IACbqS,IAEFD,IAGcvoB,SAAS,QAC3B,G,CAEMgZ,QAAAA,CACJ5U,EACAsW,EACA0N,EACAnP,G,0CAEA,MAAMyP,EAAiB,IAAI1F,GAAe5e,GAE1C,GAAkB,MAAdgkB,GAA2C,IAArBA,EAAW/oB,OACnC,MAAM,IAAI2B,MAAM,uBAGlB,MAAMunB,EAAoB,IAAI5B,GAAyB1N,GAGvDsP,EAAkBnB,aAAa1M,EAAaxQ,KAAKI,KAAIC,GAAKpL,GAAOqD,KAAK+H,EAAG,YACzEge,EAAkBrB,iBAAiBxM,EAAatQ,aAEhDme,EAAkBjB,gBAAgBoB,EAAetF,iBACjD,IAAK,MAAM9Y,KAAOoe,EAAexF,gBAC/BqF,EAAkBjB,gBAAgBhd,GAEpC,IAAK,MAAMA,KAAOoe,EAAevF,iBAC/BoF,EAAkBjB,gBAAgBhd,GAGpCie,EAAkBnB,aAAasB,EAAepF,qBAC9C,MAAMqF,EAAgB,IAAInhB,EACxBkhB,EAAepF,oBAAoBhZ,KAAIE,GAAKf,EAASe,MACrDxC,UACFugB,EAAkBnB,aAAasB,EAAenF,sBAC9C,MAAMqF,EAAiB,IAAIphB,EACzBkhB,EAAenF,qBAAqBjZ,KAAIE,GAAKf,EAASe,MACtDxC,gBAEIpG,KAAKgmB,YACTH,GAAWoB,UACX1pB,GAAOuD,OAAO,CACZgmB,EAAejF,0BACfzP,GAAa0U,EAAenc,uBAC5Boc,EACA3U,GAAa0U,EAAe9b,wBAC5Bgc,EACAlO,EAAavQ,cACbie,GAAcjpB,GAAOC,MAAM,GAAI,KAEjCmpB,GAGF,MAAMzB,EAAUyB,EAAkBtB,aAE5B6B,EAA2B,IAAI1d,IACrC,IAAK,MAAM2d,KAAejC,EACxBgC,EAAI1W,IAAI2W,EAAY,GAAIA,EAAYzoB,MAAM,IAE5C,OAAOwoB,CACT,G,CAEMxR,oBAAAA,G,0CACJ,OAAO1V,KAAKgmB,YAAYH,GAAWuB,uBAAwB7pB,GAAOqD,KAAK,IACzE,G,CAEMuX,WAAAA,CAAYE,EAAiBna,G,0CACjC,GAAIA,EAAaT,OAAS,EACxB,MAAM,IAAI2B,MAAM,4CAGlB,MAAMunB,EAAoB,IAAI5B,IAAyB,SAGjDsC,EAAUrgB,KAAKsgB,KAAKjP,EAAQ5a,OAAS,IACrC8pB,EAAmB,GACzB,IAAK,IAAI9nB,EAAI,EAAGA,EAAI4nB,EAAS5nB,IAC3B8nB,EAAOtnB,KAAKoY,EAAQoK,SAAS,GAAKhjB,EAAG,GAAKA,EAAI,KAGhDknB,EAAkBnB,aAAa+B,GAC/B,MAAMC,EAAa,IAAI5hB,EAAO2hB,EAAO7e,KAAIE,GAAKf,EAASe,MAAKxC,UAQ5D,aANuBpG,KAAKgmB,YAC1BH,GAAW4B,aACXlqB,GAAOuD,OAAO,CAAC1D,EAAqBc,GAAekU,GAAaiG,EAAQ5a,QAAS+pB,IACjFb,IAGcvoB,SAAS,SAC3B,G,ECpMI,SAAUspB,GAAuBjc,GACrC,IAAIkc,EAAM,KAsCV,OArCAA,GAAO,YAAclc,EAAY3M,QAAQV,SAAS,OAE9CqN,EAAYvB,WACdyd,GAAO,aAAelc,EAAYvB,SAAS9L,SAAS,QAGlDqN,EAAY8H,UACdoU,GAAO,YAAclc,EAAY8H,QAAQnV,SAAS,QAGhDqN,EAAYmH,YACd+U,GAAO,cAAgBlc,EAAYmH,UAAUxU,SAAS,QAGpDqN,EAAYiI,kBACdiU,GAAO,oBAAsBlc,EAAYiI,gBAAgBtV,SAAS,QAGhEqN,EAAY+H,gBACdmU,GAAO,kBAAoBlc,EAAY+H,cAAcpV,SAAS,QAG5DqN,EAAYgI,YACdkU,GAAO,cAAgBlc,EAAYgI,UAAUrV,SAAS,QAGxDqN,EAAY2H,OAAO1V,SAAQ,EAAG4V,UAASb,SAAQzE,YAAYvO,KACzDkoB,GAAO,WAAWloB,KAClBkoB,GAAO,YAAYrU,EAAQlV,SAAS,SACpCupB,GAAO,WAAWlV,EAAOrU,SAAS,SAClCupB,GAAO,aAAa3Z,EAAS5P,SAAS,QAAQ,KAE/CqN,EAAY6G,SAAW,IAAI5U,SAAQ,EAAG6G,SAAQkO,UAAUhT,KACvDkoB,GAAO,YAAYloB,KACnBkoB,GAAO,WAAWpjB,EAAOnG,SAAS,SAClCupB,GAAO,WAAWlV,EAAOrU,SAAS,QAAQ,IAErCupB,CACT,C,qVCjCA,MAAMC,GAAa,CACjB1R,S5BL8B,E4BM9BM,Y5BDyB,E4BEzBR,QAAQ,EACR6R,mB5BT6B,G,2S6ByBjB,MAAOC,GAMnBnoB,WAAAA,EAAY,UACV4Z,EAAS,YACTwO,EAAc,MAAK,SACnBC,EAAW,YAMXhoB,KAAKioB,WAAa1O,EAClBvZ,KAAKioB,WAAWC,sBACdloB,KACA,CACE,gBACA,qBACA,sBACA,cACA,2BACA,kBACA,yBAEF+nB,GAGF/nB,KAAKmoB,MAAQ,MACX,OAAQH,GACN,IAAK,UACL,IAAK,kBACL,IAAK,OAEH,OAAO,IAAIrU,GAAO,IAAIoS,GAAU/lB,KAAKioB,aACvC,QAEE,OAAO,IAAI1I,GAAOvf,KAAKioB,YAE5B,EAXY,EAYf,CAWApU,aAAAA,CAAciC,GACZ,OAAO9V,KAAKooB,wBAAwBzL,MAAK0L,GAChCA,EAAKxU,cAAciC,IAE9B,CA0BA7B,kBAAAA,CACElW,EACAmW,GASA,IAAIsF,EAaJ,OAZIkH,UAAUjjB,OAAS,GAAqB,mBAATyW,GACjCoU,QAAQC,KACN,mHAEF/O,EAAU,CACR5E,SAAUV,EAEVe,OAAQyL,UAAU,GAAK,OAAS,WAGlClH,EAAUtF,GAAQ,CAAC,EAEdlU,KAAKooB,wBAAwBzL,MAAK0L,GAChCA,EAAKpU,mBAAmBlW,EAAMyb,IAEzC,CAWArB,WAAAA,CACEpa,EACAqa,GAMA,OAAOpY,KAAKooB,wBAAwBzL,MAAK0L,GAChCA,EAAKlQ,YAAY,CACtBpa,OACAqa,gBAGN,CAqCAvC,wBAAAA,CAAyBC,GACvB,GAAI4K,UAAUjjB,OAAS,EACrB,MAAM,IAAI2B,MACR,6HAGJ,OAAOY,KAAKooB,wBAAwBzL,MAAK0L,GAChCA,EAAKxS,yBAAyBC,IAEzC,CAqBA0S,mBAAAA,CAAoB1S,GAClB,OD5ME,SAAoCyD,EAAsBzD,G,0CAC9D,MAAM,OACJ1C,EAAM,kBACNmD,EAAiB,gBACjBG,EAAe,SACfR,EAAQ,YACRM,EAAW,OACXR,EAAM,mBACN6R,GACDrW,OAAAC,OAAAD,OAAAC,OAAA,GAAQmW,IAAe9R,GAGlBuI,EAAa9gB,GAAOC,MAAM,GAC1B8gB,EAAc/gB,GAAOC,MAAM,GAC3B+gB,EAAiBhhB,GAAOC,MAAM,GACpC+gB,EAAeje,cAAcunB,EAAoB,GACjD,MAAMrJ,EAAgC,GAChCC,EAA2C,GAC3CC,EAAuB,GAC7B,IAAIE,GAAW,EACf,MACMC,EAAiC,CACrCzL,OAAQ,GACRtU,QAASyf,GAELO,EAAsB9I,EAASmG,GAAwB9B,GACvDrD,EAAezZ,GAAOqD,KAAK8V,EAAiB,OAElD,IAAK,MAAMrD,KAASD,EAAQ,CACX,CACb,MAAMgH,QAAqB0E,EAAoBvF,EAAWlG,EAAM,GAAIA,EAAM,IACpErF,EAAWzQ,GAAOC,MAAM,GAC9BwQ,EAAS1N,cACP+S,EAAM5V,QAAU,GAAyB,kBAAb4V,EAAM,GAAkBA,EAAM,GAAKpR,EAC/D,GAEFuc,EAAcve,KAAK,CACjBma,cAAc,EACd5a,MAAOwW,EACHzY,GAAOqD,KAAKwZ,EAAc,OAC1B7c,GAAOqD,KAAKwZ,EAAc,OAAO1b,MAAM,EAAG,IAC9CsP,YAEJ,CAEA,MAAM,QAAEsE,GAAYe,EAAM,GACpBzV,EAAQyV,EAAM,GAEhBf,GAAW1U,GAAS0U,EAAQ7U,OAAS,GACvCghB,EAAexe,KAAKqS,EAAQ1U,GAEhC,CAGA,IAAK,IAAI6B,EAAI,EAAGA,EAAI2T,EAAO3V,OAAQgC,IAAK,CACtC,MAAMuO,EAAWzQ,GAAOC,MAAM,GAC9BwQ,EAAS1N,cACP8S,EAAO3T,GAAGhC,QAAU,GAA6B,kBAAjB2V,EAAO3T,GAAG,GACrC2T,EAAO3T,GAAG,GACXwC,EACJ,GAEF4c,EAAkBzL,OAAOnT,KAAK,CAC5BwS,OAAQ4L,EACR/K,QAASgL,EACTtQ,YAEJ,CAEIgI,UACI8F,GACJvC,GACA,EACAsF,EACAL,GACA,SAEI3B,GAAetD,EAAWvC,IAGlC,IAAK,IAAIvX,EAAI,EAAGA,EAAI2T,EAAO3V,OAAQgC,IAAK,CACtC,MAAM4T,EAAQD,EAAO3T,GACfgT,EACJW,EAAO3T,GAAGhC,QAAU,GAAyB,kBAAb4V,EAAM,GAClC9V,GAAOqD,KAAKyS,EAAM,GAAI,OACtBoL,EAAehf,GAAGgT,OAClBwM,EAAWzN,OAAOC,OAAO,CAAC,EAAGoN,GAC7BK,EAAsBlJ,EAAS,CAACwI,EAAc/e,IAAM+e,EAEtDxI,EACFiJ,EAAS7L,OAAS,CAAA5B,OAAAC,OAAAD,OAAAC,OAAA,GAAMwN,EAAS7L,OAAO3T,IAAE,CAAEgT,YAE5CwM,EAAS7L,OAAO3T,GAAGgT,OAASA,QAGxBqJ,GACJvC,GACCvD,GAAU4I,EACXK,EACAC,EACAlJ,GAGGA,UACG6G,GAAetD,EAAWvC,IAGlC,MAAM/K,QAAkBsQ,GAAgBhD,EAAWhD,EAAkB9W,GAAIyW,EAAUM,GACnFkI,EAAWze,KACT+V,EAAS/J,EAAU7N,SAAS,OAAS6N,EAAUvN,MAAM,EAAGuN,EAAUxO,OAAS,GAAGW,SAAS,QAEzFygB,EAAkBzL,OAAO3T,GAAGgT,OAAS4L,EAEjCO,IACFA,GAAW,EAEf,CAEA,OAAOF,CACT,G,CCqFW8J,CAAoBxoB,KAAKioB,WAAYnS,EAC9C,CAaA2S,gBAAAA,CACEC,EACAC,GAAgD,EAChDC,GAAe,EACfC,GAAe,EACfhW,EAA6B,IAE7B,OCxPE,SACJ6V,EACAC,GAAgD,EAChDC,GAAe,EACfC,GAAe,EACfhW,EAA6B,IAE7B,MAAMO,EAA6B,GAC7Bd,EAA+B,GACrC,IAMIwW,EAAe5e,EANfqJ,GAAU,EACVvS,EAAS,EACT4R,EAAYrV,GAAOC,MAAM,GACzBgW,EAAgBjW,GAAOC,MAAM,GAC7BkW,EAAkBnW,GAAOC,MAAM,GAC/BiW,EAAYlW,GAAOC,MAAM,GAE7B,MAAMsV,EAAWD,EAAYE,SAAS,UAChCgW,EAAYlW,EAAYE,SAAS,WACjCC,EAAUH,EAAYE,SAAS,SAC/BtH,EAAclO,GAAOqD,KAAK8nB,EAAgB,OAC1C5pB,EAAU2M,EAAY/M,MAAMsC,EAAQA,EAAS,GAC7C6a,EACJ/c,EAAQ0G,OAAOjI,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,QAC9C9B,EAAQ0G,OAAOjI,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,QAC9C9B,EAAQ0G,OAAOjI,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,OAC1CooB,EAAYhW,GAAWlU,EAAQ0G,OAAOjI,GAAOqD,KAAK,CAAC,EAAM,EAAM,EAAM,OAC3EI,GAAU,EAEP4nB,IACDD,GACwB,IAAxBld,EAAYzK,IACgB,IAA5ByK,EAAYzK,EAAS,IACpB+nB,IAED/nB,GAAU,EACVuS,GAAU,GAGRqV,IACFhW,EAAYnH,EAAY/M,MAAMsC,EAAQ,EAAIA,GAC1CA,GAAU,GAGR6a,IACFnI,EAAkBjI,EAAY/M,MAAMsC,EAAQ,EAAIA,GAChDA,GAAU,GAERgoB,IACF9e,EAAWuB,EAAY/M,MAAMsC,EAAS,EAAGA,EAAS,GAClDwS,EAAgB/H,EAAY/M,MAAMsC,EAAS,EAAGA,EAAS,IACvDA,GAAU,IAEZ,IAAI0J,EAASyH,GAAU1G,EAAazK,GACpC,MAAMioB,EAAeve,EAAO,GAC5B1J,GAAU0J,EAAO,GAEjB,IAAK,IAAIjL,EAAI,EAAGA,EAAIwpB,EAAcxpB,IAAK,CACrC,MAAM6T,EAAU7H,EAAY/M,MAAMsC,EAAQA,EAAS,IACnDA,GAAU,GACV,IAAIyR,EAASlV,GAAOC,MAAM,GACtB8d,EAAO/d,GAAOC,MAAM,GAGnBsV,GAOHwI,EAAO7P,EAAY/M,MAAMsC,EAAQA,EAAS,GAC1CA,GAAU,IAPV0J,EAASyH,GAAU1G,EAAazK,GAChCA,GAAU0J,EAAO,GACjB+H,EAAShH,EAAY/M,MAAMsC,EAAQA,EAAS0J,EAAO,IACnD1J,GAAU0J,EAAO,IAOnB,MAAMsD,EAAWvC,EAAY/M,MAAMsC,EAAQA,EAAS,GACpDA,GAAU,EACVoS,EAAOnT,KAAK,CACVqT,UACAb,SACAzE,WACAsN,QAEJ,CACA5Q,EAASyH,GAAU1G,EAAazK,GAChC,MAAMkoB,EAAgBxe,EAAO,GAC7B1J,GAAU0J,EAAO,GACjB,IAAK,IAAIjL,EAAI,EAAGA,EAAIypB,EAAezpB,IAAK,CACtC,MAAM8E,EAASkH,EAAY/M,MAAMsC,EAAQA,EAAS,GAClDA,GAAU,EAEN8R,IAEF9R,GAAU,GAGZ0J,EAASyH,GAAU1G,EAAazK,GAChCA,GAAU0J,EAAO,GACjB,MAAM+H,EAAShH,EAAY/M,MAAMsC,EAAQA,EAAS0J,EAAO,IACzD1J,GAAU0J,EAAO,GACjB4H,EAAQrS,KAAK,CACXsE,SACAkO,UAEJ,CAqBA,GAnBIc,GACFuV,EAAgBrd,EAAY/M,MAAMsC,GAAS,GAC3CkJ,EAAWuB,EAAY/M,MAAM+M,EAAYhO,OAAS,IACxCurB,IACV9e,EAAWuB,EAAY/M,MAAMsC,EAAQA,EAAS,IAGhDA,GAAU,GAEL6a,IAAc/I,GAAckW,IAC/BxV,EAAgB/H,EAAY/M,MAAMsC,EAAQA,EAAS,GACnDA,GAAU,GAGR6nB,IACFpV,EAAYhI,EAAY/M,MAAMsC,IAI5B8R,EAAU,CAIZ,GAHApI,EAASyH,GAAU1G,EAAazK,GAChCA,GAAU0J,EAAO,GAEbA,EAAO,KAAOue,EAChB,MAAM,IAAI7pB,MAAM,oDAGlB,IAAK,IAAIK,EAAI,EAAGA,EAAIwpB,EAAcxpB,IAAK,CAErCuB,GAAU,EAEVA,GAAU,EAEVA,GAAU,EAEV0J,EAASyH,GAAU1G,EAAazK,GAChCA,GAAU0J,EAAO,GACjB,MAAM+H,EAAShH,EAAY/M,MAAMsC,EAAQA,EAAS0J,EAAO,IACzD1J,GAAU0J,EAAO,GACjB0I,EAAO3T,GAAGgT,OAASA,CACrB,CACF,CAEA,MAAMwG,EAAiB,CACrBna,UACAsU,SACAd,UACApI,WACAqJ,QAASuV,EACTlW,YACAc,kBACAF,gBACAC,aAGF,OADAsL,EAAAA,GAAAA,IAAI,MAAO,oBAAoB2J,OAAoBhB,GAAuBzO,MACnEA,CACT,CDuFWwP,CACLC,EACAC,EACAC,EACAC,EACAhW,EAEJ,CAQAR,2BAAAA,CAA4B4G,GAC1B,OAAO5G,GAA4B4G,EACrC,CAOAoB,eAAAA,CACEJ,EACAxO,EACAoH,EAA6B,IAE7B,OAAOwH,GAAgBra,KAAKioB,WAAYhO,EAAaxO,EAAaoH,EACpE,CAKAsJ,qBAAAA,CACElC,EACAxO,EACAoH,EAA6B,IAE7B,OAAOsJ,GAAsBnc,KAAKioB,WAAYhO,EAAaxO,EAAaoH,EAC1E,CAEMuV,qBAAAA,G,0CAEJ,GAAIpoB,KAAKmoB,iBAAiB5I,GAAQ,OAAOvf,KAAKmoB,MAE9C,MAAM,KAAElL,EAAI,QAAEne,SAAkBie,GAAiB/c,KAAKioB,YA6BtD,YA3B0B,KAAYtN,GAAA,gCACpC,OAAQsC,GACN,IAAK,UACL,IAAK,eAEH,OAAOS,IAAAA,GAAU5e,EAAS,SAE5B,IAAK,iBACL,IAAK,sBAWL,QACE,OAAO,EATT,IAAK,WAIH,aXjS6Bya,EWiSCvZ,KAAKioB,WXjSoCtN,QAAA,6BAC/E,UAEQpB,EAAUK,KAAK,IAAM,IAAM,EAAG,EACtC,CAAE,MAAOgE,GACP,OAAO,CACT,CACA,OAAO,CACT,KW0RQ,IAAK,OAEH,OAAOF,IAAAA,GAAU5e,EAAS,SXpSGya,KWwSnC,IAtB0B,MAyBxBvZ,KAAKmoB,MAAQ,IAAI5I,GAAOvf,KAAKioB,aAExBjoB,KAAKmoB,KACd,G,2BEpUF,IAJA,IAAIgB,EAAW,mCAGXC,EAAe,CAAC,EACXC,EAAI,EAAGA,EAAIF,GAAiBE,IAAK,CACxC,IAAI3kB,EAAIykB,EAASG,OAAOD,GAExB,QAAwBziB,IAApBwiB,EAAa1kB,GAAkB,MAAM,IAAI6kB,UAAU7kB,EAAI,iBAC3D0kB,EAAa1kB,GAAK2kB,CACpB,CAEA,SAASG,EAAaC,GACpB,IAAI1pB,EAAI0pB,GAAO,GACf,OAAe,SAANA,IAAoB,EACR,YAAL,EAAV1pB,GACe,YAAfA,GAAK,EAAK,GACK,YAAfA,GAAK,EAAK,GACK,aAAfA,GAAK,EAAK,GACK,YAAfA,GAAK,EAAK,EAClB,CAEA,SAAS2pB,EAAWvP,GAElB,IADA,IAAIwP,EAAM,EACDlqB,EAAI,EAAGA,EAAI0a,EAAO1c,SAAUgC,EAAG,CACtC,IAAImqB,EAAIzP,EAAO0P,WAAWpqB,GAC1B,GAAImqB,EAAI,IAAMA,EAAI,IAAK,MAAO,mBAAqBzP,EAAS,IAE5DwP,EAAMH,EAAYG,GAAQC,GAAK,CACjC,CAGA,IAFAD,EAAMH,EAAYG,GAEblqB,EAAI,EAAGA,EAAI0a,EAAO1c,SAAUgC,EAAG,CAClC,IAAI8Q,EAAI4J,EAAO0P,WAAWpqB,GAC1BkqB,EAAMH,EAAYG,GAAY,GAAJpZ,CAC5B,CACA,OAAOoZ,CACT,CAkCA,SAASG,EAAUnC,EAAKoC,GAEtB,GADAA,EAAQA,GAAS,GACbpC,EAAIlqB,OAAS,EAAG,OAAOkqB,EAAM,aACjC,GAAIA,EAAIlqB,OAASssB,EAAO,MAAO,uBAG/B,IAAIC,EAAUrC,EAAIsC,cACdC,EAAUvC,EAAIwC,cAClB,GAAIxC,IAAQqC,GAAWrC,IAAQuC,EAAS,MAAO,qBAAuBvC,EAGtE,IAAIyC,GAFJzC,EAAMqC,GAEUK,YAAY,KAC5B,IAAe,IAAXD,EAAc,MAAO,8BAAgCzC,EACzD,GAAc,IAAVyC,EAAa,MAAO,sBAAwBzC,EAEhD,IAAIxN,EAASwN,EAAIjpB,MAAM,EAAG0rB,GACtBE,EAAY3C,EAAIjpB,MAAM0rB,EAAQ,GAClC,GAAIE,EAAU7sB,OAAS,EAAG,MAAO,iBAEjC,IAAIksB,EAAMD,EAAUvP,GACpB,GAAmB,kBAARwP,EAAkB,OAAOA,EAGpC,IADA,IAAIY,EAAQ,GACH9qB,EAAI,EAAGA,EAAI6qB,EAAU7sB,SAAUgC,EAAG,CACzC,IAAImqB,EAAIU,EAAUhB,OAAO7pB,GACrB8Q,EAAI6Y,EAAaQ,GACrB,QAAUhjB,IAAN2J,EAAiB,MAAO,qBAAuBqZ,EACnDD,EAAMH,EAAYG,GAAOpZ,EAGrB9Q,EAAI,GAAK6qB,EAAU7sB,QACvB8sB,EAAMtqB,KAAKsQ,EACb,CAEA,OAAY,IAARoZ,EAAkB,wBAA0BhC,EACzC,CAAExN,OAAQA,EAAQoQ,MAAOA,EAClC,CAcA,SAASC,EAASvY,EAAMwY,EAAQC,EAASC,GAMvC,IALA,IAAInrB,EAAQ,EACRorB,EAAO,EACPC,GAAQ,GAAKH,GAAW,EAExBvpB,EAAS,GACJ1B,EAAI,EAAGA,EAAIwS,EAAKxU,SAAUgC,EAIjC,IAHAD,EAASA,GAASirB,EAAUxY,EAAKxS,GACjCmrB,GAAQH,EAEDG,GAAQF,GACbE,GAAQF,EACRvpB,EAAOlB,KAAMT,GAASorB,EAAQC,GAIlC,GAAIF,EACEC,EAAO,GACTzpB,EAAOlB,KAAMT,GAAUkrB,EAAUE,EAASC,OAEvC,CACL,GAAID,GAAQH,EAAQ,MAAO,iBAC3B,GAAKjrB,GAAUkrB,EAAUE,EAASC,EAAM,MAAO,kBACjD,CAEA,OAAO1pB,CACT,CA0BA2pB,EAAOC,QAAU,CACfC,aAjEF,WACE,IAAIlQ,EAAMgP,EAASmB,MAAM,KAAMvK,WAC/B,GAAmB,kBAAR5F,EAAkB,OAAOA,CACtC,EA+DEoQ,OA7DF,SAAiBvD,GACf,IAAI7M,EAAMgP,EAASmB,MAAM,KAAMvK,WAC/B,GAAmB,kBAAR5F,EAAkB,OAAOA,EAEpC,MAAM,IAAI1b,MAAM0b,EAClB,EAyDEqQ,OAzIF,SAAiBhR,EAAQoQ,EAAOR,GAE9B,GADAA,EAAQA,GAAS,GACZ5P,EAAO1c,OAAS,EAAI8sB,EAAM9sB,OAAUssB,EAAO,MAAM,IAAIR,UAAU,wBAKpE,IAAII,EAAMD,EAHVvP,EAASA,EAAO8P,eAIhB,GAAmB,kBAARN,EAAkB,MAAM,IAAIvqB,MAAMuqB,GAG7C,IADA,IAAIxoB,EAASgZ,EAAS,IACb1a,EAAI,EAAGA,EAAI8qB,EAAM9sB,SAAUgC,EAAG,CACrC,IAAIiF,EAAI6lB,EAAM9qB,GACd,GAAKiF,GAAK,IAAO,EAAG,MAAM,IAAItF,MAAM,kBAEpCuqB,EAAMH,EAAYG,GAAOjlB,EACzBvD,GAAUgoB,EAASG,OAAO5kB,EAC5B,CAEA,IAAKjF,EAAI,EAAGA,EAAI,IAAKA,EACnBkqB,EAAMH,EAAYG,GAIpB,IAFAA,GAAO,EAEFlqB,EAAI,EAAGA,EAAI,IAAKA,EAAG,CAEtB0B,GAAUgoB,EAASG,OADVK,GAAkB,GAAT,EAAIlqB,GAAW,GAEnC,CAEA,OAAO0B,CACT,EA4GEiqB,cA5BF,SAAwB5qB,GACtB,IAAIsa,EAAM0P,EAAQhqB,EAAO,EAAG,GAAG,GAC/B,GAAI6qB,MAAMC,QAAQxQ,GAAM,OAAOA,CACjC,EA0BEyQ,QAxBF,SAAkB/qB,GAChB,IAAIsa,EAAM0P,EAAQhqB,EAAO,EAAG,GAAG,GAC/B,GAAI6qB,MAAMC,QAAQxQ,GAAM,OAAOA,EAE/B,MAAM,IAAI1b,MAAM0b,EAClB,EAoBE0Q,gBAlBF,SAA0BjB,GACxB,IAAIzP,EAAM0P,EAAQD,EAAO,EAAG,GAAG,GAC/B,GAAIc,MAAMC,QAAQxQ,GAAM,OAAOA,CACjC,EAgBE2Q,UAdF,SAAoBlB,GAClB,IAAIzP,EAAM0P,EAAQD,EAAO,EAAG,GAAG,GAC/B,GAAIc,MAAMC,QAAQxQ,GAAM,OAAOA,EAE/B,MAAM,IAAI1b,MAAM0b,EAClB,E,qDC1KAtJ,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMmsB,EAAWC,EAAQ,OACnBC,EAAWD,EAAQ,OACnBE,EAAUF,EAAQ,OAClBG,EAAQH,EAAQ,OAChBvS,EAASuS,EAAQ,OACjBntB,EAAYmtB,EAAQ,MACpBI,EAAYJ,EAAQ,MAC1B,SAASK,EAAgBpX,GACvB,MAAMqX,EAAUztB,EAAUysB,OAAOrW,GAEjC,GAAIqX,EAAQzuB,OAAS,GAAI,MAAM,IAAI8rB,UAAU1U,EAAU,iBACvD,GAAIqX,EAAQzuB,OAAS,GAAI,MAAM,IAAI8rB,UAAU1U,EAAU,gBAGvD,MAAO,CAAE/V,QAFOotB,EAAQhrB,UAAU,GAEhBmF,KADL6lB,EAAQxtB,MAAM,GAE7B,CAEA,SAASytB,EAAWtX,GAClB,MAAM1T,EAASkY,EAAO6R,OAAOrW,GACvB5C,EAAOoH,EAAOoS,UAAUtqB,EAAOopB,MAAM7rB,MAAM,IACjD,MAAO,CACLI,QAASqC,EAAOopB,MAAM,GACtBpQ,OAAQhZ,EAAOgZ,OACflI,KAAM1U,EAAOqD,KAAKqR,GAEtB,CATA8Y,EAAQkB,gBAAkBA,EAU1BlB,EAAQoB,WAAaA,EAQrBpB,EAAQqB,cAPR,SAAuB/lB,EAAMvH,GAC3BktB,EAAUD,EAAMM,MAAMN,EAAMO,WAAYP,EAAMQ,OAAQ7L,WACtD,MAAMwL,EAAU3uB,EAAOujB,YAAY,IAGnC,OAFAoL,EAAQhsB,WAAWpB,EAAS,GAC5BuH,EAAK6J,KAAKgc,EAAS,GACZztB,EAAU0sB,OAAOe,EAC1B,EAOAnB,EAAQyB,SALR,SAAkBva,EAAMnT,EAASqb,GAC/B,MAAMoQ,EAAQlR,EAAOkS,QAAQtZ,GAE7B,OADAsY,EAAMkC,QAAQ3tB,GACPua,EAAO8R,OAAOhR,EAAQoQ,EAC/B,EAmBAQ,EAAQ2B,iBAjBR,SAA0Bla,EAAQma,GAEhCA,EAAUA,GAAWhB,EAASiB,QAC9B,IACE,OAAOf,EAASvoB,MAAM,CAAEkP,SAAQma,YAAW9X,OAC7C,CAAE,MAAO+I,GAAI,CACb,IACE,OAAOiO,EAASzS,KAAK,CAAE5G,SAAQma,YAAW9X,OAC5C,CAAE,MAAO+I,GAAI,CACb,IACE,OAAOiO,EAASlmB,OAAO,CAAE6M,SAAQma,YAAW9X,OAC9C,CAAE,MAAO+I,GAAI,CACb,IACE,OAAOiO,EAASgB,MAAM,CAAEra,SAAQma,YAAW9X,OAC7C,CAAE,MAAO+I,GAAI,CACb,MAAM,IAAIxe,MAAM0sB,EAAQgB,MAAMta,GAAU,2BAC1C,EA+BAuY,EAAQgC,eA7BR,SAAwBlY,EAAS8X,GAE/B,IAAIK,EACAC,EAFJN,EAAUA,GAAWhB,EAASiB,QAG9B,IACEI,EAAef,EAAgBpX,EACjC,CAAE,MAAO+I,GAAI,CACb,GAAIoP,EAAc,CAChB,GAAIA,EAAaluB,UAAY6tB,EAAQO,WACnC,OAAOrB,EAASvoB,MAAM,CAAE+C,KAAM2mB,EAAa3mB,OAAQmM,OACrD,GAAIwa,EAAaluB,UAAY6tB,EAAQtnB,WACnC,OAAOwmB,EAASzS,KAAK,CAAE/S,KAAM2mB,EAAa3mB,OAAQmM,MACtD,KAAO,CACL,IACEya,EAAed,EAAWtX,EAC5B,CAAE,MAAO+I,GAAI,CACb,GAAIqP,EAAc,CAChB,GAAIA,EAAa9S,SAAWwS,EAAQtT,OAClC,MAAM,IAAIja,MAAMyV,EAAU,0BAC5B,GAA6B,IAAzBoY,EAAanuB,QAAe,CAC9B,GAAiC,KAA7BmuB,EAAahb,KAAKxU,OACpB,OAAOouB,EAASlmB,OAAO,CAAEU,KAAM4mB,EAAahb,OAAQO,OACtD,GAAiC,KAA7Bya,EAAahb,KAAKxU,OACpB,OAAOouB,EAASgB,MAAM,CAAExmB,KAAM4mB,EAAahb,OAAQO,MACvD,CACF,CACF,CACA,MAAM,IAAIpT,MAAMyV,EAAU,0BAC5B,C,qDCxFArD,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM2tB,EAAgBvB,EAAQ,MACxBwB,EAAUxB,EAAQ,MAClBpR,EAAgBoR,EAAQ,OACxBG,EAAQH,EAAQ,OAChByB,EAAiBzB,EAAQ,OACzBI,EAAYJ,EAAQ,MACpBjrB,EAAUirB,EAAQ,OAClB0B,EAAoB,IAAI/D,UAC5B,oDAEIgE,EAAwB,IAAIhE,UAChC,sDAEF,MAAMiE,EACJ7tB,WAAAA,GACEK,KAAKlB,QAAU,EACfkB,KAAKytB,cAAW7mB,EAChB5G,KAAK0tB,gBAAa9mB,EAClB5G,KAAK4S,UAAY,EACjB5S,KAAK2tB,mBAAgB/mB,EACrB5G,KAAK4qB,KAAO,EACZ5qB,KAAK4tB,MAAQ,EACb5tB,KAAK6tB,kBAAejnB,CACtB,CACA,iBAAOknB,CAAWxwB,GAChB,GAAIA,EAAOG,OAAS,GAAI,MAAM,IAAI2B,MAAM,iCACxC,MAAM2uB,EAAe,IAAIZ,EAAcpsB,aAAazD,GAC9C4d,EAAQ,IAAIsS,EAOlB,GANAtS,EAAMpc,QAAUivB,EAAa3sB,YAC7B8Z,EAAMuS,SAAWM,EAAatsB,UAAU,IACxCyZ,EAAMwS,WAAaK,EAAatsB,UAAU,IAC1CyZ,EAAMtI,UAAYmb,EAAazsB,aAC/B4Z,EAAM0P,KAAOmD,EAAazsB,aAC1B4Z,EAAM0S,MAAQG,EAAazsB,aACL,KAAlBhE,EAAOG,OAAe,OAAOyd,EACjC,MAAM8S,EAAkBA,KACtB,MAAMjW,EAAKyC,EAAcyT,YAAYH,WACnCC,EAAazwB,OAAOoB,MAAMqvB,EAAa/sB,SACvC,GAGF,OADA+sB,EAAa/sB,QAAU+W,EAAGmW,aACnBnW,CAAE,EAELoW,EAAgBJ,EAAarsB,aACnCwZ,EAAM2S,aAAe,GACrB,IAAK,IAAIpuB,EAAI,EAAGA,EAAI0uB,IAAiB1uB,EAAG,CACtC,MAAMsY,EAAKiW,IACX9S,EAAM2S,aAAa5tB,KAAK8X,EAC1B,CACA,MAAM4V,EAAgBzS,EAAMkT,mBAG5B,OADIT,IAAezS,EAAMyS,cAAgBA,GAClCzS,CACT,CACA,cAAOmT,CAAQC,GACb,OAAOd,EAAMM,WAAWvwB,EAAOqD,KAAK0tB,EAAK,OAC3C,CACA,sBAAOC,CAAgB3D,GACrB,MAAM4D,IAAoB,WAAP5D,IAAsB,IAAM,EACzC6D,EAAkB,QAAP7D,EACX8D,EAASnxB,EAAOC,MAAM,GAAI,GAEhC,OADAkxB,EAAOC,YAAYF,EAAU,GAAKD,EAAU,GACrCE,CACT,CACA,0BAAOE,CAAoBf,EAAcgB,GAEvC,GADA7C,EAAU,CAAC,CAAE8C,QAAS/C,EAAMgD,WAAalB,GACb,IAAxBA,EAAapwB,OAAc,MAAM6vB,EACrC,GAAIuB,IAAeG,EAAsBnB,GACvC,MAAMN,EACR,MAAM/e,EAASqf,EAAanlB,KAAI+C,GAC9BA,EAAYqjB,QAAQD,KAEhBI,EAAW5B,EAAe7e,EAAQ4e,EAAQxU,SAChD,OAAOiW,EACHzB,EAAQxU,QACNrb,EAAOuD,OAAO,CAACmuB,EAAUpB,EAAa,GAAG5H,IAAI,GAAG1S,QAAQ,MAE1D0b,CACN,CACAb,gBAAAA,GACE,IAAKY,EAAsBhvB,KAAK6tB,cAAe,OAAO,KAKtD,MAAMqB,EAAiBlvB,KAAK6tB,aAAa,GAAGsB,KACzCC,QAAOC,GACNA,EAAI5c,OAAO/T,MAAM,EAAG,GAAG8G,OAAOjI,EAAOqD,KAAK,eAAgB,UAE3D8H,KAAI2mB,GAAOA,EAAI5c,OAAO/T,MAAM,EAAG,MAClC,GAA8B,IAA1BwwB,EAAezxB,OAAc,OAAO,KAExC,MAAM0D,EAAS+tB,EAAeA,EAAezxB,OAAS,GACtD,OAAM0D,aAAkB5D,GAA4B,KAAlB4D,EAAO1D,OAClC0D,EADyD,IAElE,CACAmuB,gBAAAA,GACE,OACEtvB,KAAK2tB,yBAAyBpwB,GACA,KAA9ByC,KAAK2tB,cAAclwB,QAGW,OAA5BuC,KAAKouB,kBAEX,CACAmB,UAAAA,GACE,OA4FqB1B,EA5FE7tB,KAAK6tB,wBA8FJxC,OACxBwC,EAAa/c,MACXiH,GACgB,kBAAPA,GACPA,EAAGkO,eAAeoF,OAClBtT,EAAGkO,IAAInV,MACLuC,GACmB,kBAAVA,GACPA,EAAME,mBAAmB8X,OACzBhY,EAAME,QAAQ9V,OAAS,MAXnC,IAAyBowB,CA3FvB,CACA2B,MAAAA,GAGE,OAAc,EAFDxvB,KAAKkuB,YAAW,GAAO,GACtBluB,KAAKkuB,YAAW,GAAO,EAEvC,CACAA,UAAAA,CAAWuB,EAAaC,GAAe,GACrC,OAAID,IAAgBzvB,KAAK6tB,aAAqB,GAE5C,GACAltB,EAAQgvB,eAAe3vB,KAAK6tB,aAAapwB,QACzCuC,KAAK6tB,aAAa+B,QAAO,CAACC,EAAGnrB,IAAMmrB,EAAInrB,EAAEwpB,WAAWwB,IAAe,EAEvE,CACAZ,OAAAA,GACE,OAAO1B,EAAQxU,QAAQ5Y,KAAK2R,UAAS,GACvC,CACAme,KAAAA,GACE,OAAO3C,EAAc4C,cAAc/vB,KAAK8uB,WAAW1wB,SAAS,MAC9D,CACA4xB,UAAAA,GACE,MAAMC,EAAO,IAAIhS,KAAK,GAEtB,OADAgS,EAAKC,cAAclwB,KAAK4S,WACjBqd,CACT,CAEAte,QAAAA,CAAS8d,GACP,MAAMnyB,EAASC,EAAOujB,YAAY9gB,KAAKkuB,WAAWuB,IAC5CU,EAAe,IAAIhD,EAAcztB,aAAapC,GAOpD,OANA6yB,EAAahwB,WAAWH,KAAKlB,SAC7BqxB,EAAa1vB,WAAWT,KAAKytB,UAC7B0C,EAAa1vB,WAAWT,KAAK0tB,YAC7ByC,EAAa9vB,YAAYL,KAAK4S,WAC9Bud,EAAa9vB,YAAYL,KAAK4qB,MAC9BuF,EAAa9vB,YAAYL,KAAK4tB,OAC1B6B,IAAgBzvB,KAAK6tB,eACzBltB,EAAQwqB,OAAOnrB,KAAK6tB,aAAapwB,OAAQH,EAAQ6yB,EAAanvB,QAC9DmvB,EAAanvB,QAAUL,EAAQwqB,OAAO3qB,MACtCR,KAAK6tB,aAAanwB,SAAQqa,IACxB,MAAMqY,EAASrY,EAAGmW,aAClBnW,EAAGpG,SAASrU,EAAQ6yB,EAAanvB,QACjCmvB,EAAanvB,QAAUovB,CAAM,KANe9yB,CAShD,CACA+yB,KAAAA,CAAMZ,GACJ,OAAOzvB,KAAK2R,SAAS8d,GAAarxB,SAAS,MAC7C,CACAkyB,YAAAA,GAGE,MAAMhB,EAAmBtvB,KAAKsvB,mBAC9B,SAAKA,GAAoBtvB,KAAKuvB,gBAE5BvvB,KAAKuwB,uBACJjB,GAAmBtvB,KAAKwwB,wBAE7B,CACAC,gBAAAA,GACE,MAAMpqB,EAAO8mB,EAAc4C,cAAc/vB,KAAK8uB,WACxCJ,EAASlB,EAAMe,gBAAgBvuB,KAAK4qB,MAC1C,OAAOvkB,EAAK+U,QAAQsT,IAAW,CACjC,CACA6B,iBAAAA,GACE,IAAKvwB,KAAK6tB,aAAc,MAAMP,EAC9B,MAAMoD,EAAmBlD,EAAMoB,oBAAoB5uB,KAAK6tB,cACxD,OAAqD,IAA9C7tB,KAAK0tB,WAAWtS,QAAQsV,EACjC,CACAF,oBAAAA,GACE,IAAKxwB,KAAK6tB,aAAc,MAAMP,EAC9B,IAAKttB,KAAKsvB,mBAAoB,MAAM/B,EACpC,MAAMoD,EAAsBnD,EAAMoB,oBAChC5uB,KAAK6tB,cACL,GAEF,OAA2D,IAApD7tB,KAAK2tB,cAAcvS,QAAQuV,EACpC,EAGF,SAAS3B,EAAsBnB,GAC7B,OACEA,aAAwBxC,OACxBwC,EAAa,IACbA,EAAa,GAAG5H,KAChB4H,EAAa,GAAG5H,eAAeoF,OAC/BwC,EAAa,GAAG5H,IAAI,IACpB4H,EAAa,GAAG5H,IAAI,GAAG1S,SACvBsa,EAAa,GAAG5H,IAAI,GAAG1S,mBAAmB8X,OAC1CwC,EAAa,GAAG5H,IAAI,GAAG1S,QAAQ9V,OAAS,CAE5C,CAZAstB,EAAQyC,MAAQA,C,oDC1LhBhc,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMusB,EAAQH,EAAQ,OAChBI,EAAYJ,EAAQ,MACpBjrB,EAAUirB,EAAQ,OAExB,SAASgF,EAAUpxB,EAAOqxB,GACxB,GAAqB,kBAAVrxB,EACT,MAAM,IAAIJ,MAAM,yCAClB,GAAII,EAAQ,EACV,MAAM,IAAIJ,MAAM,4DAClB,GAAII,EAAQqxB,EAAK,MAAM,IAAIzxB,MAAM,kCACjC,GAAI4H,KAAKC,MAAMzH,KAAWA,EACxB,MAAM,IAAIJ,MAAM,mCACpB,CACA,SAAS0xB,EAAaxzB,EAAQ0D,GAC5B,MAAM6uB,EAAIvyB,EAAOiE,aAAaP,GAC9B,IAAIjB,EAAIzC,EAAOiE,aAAaP,EAAS,GAGrC,OAFAjB,GAAK,WACL6wB,EAAU7wB,EAAI8vB,EAAG,kBACV9vB,EAAI8vB,CACb,CAEA,SAASkB,EAAczzB,EAAQkC,EAAOwB,GAIpC,OAHA4vB,EAAUpxB,EAAO,kBACjBlC,EAAO8C,cAAsB,EAATZ,EAAYwB,GAChC1D,EAAOgD,cAAc0G,KAAKC,MAAMzH,EAAQ,YAAcwB,EAAS,GACxDA,EAAS,CAClB,CANA+pB,EAAQ+F,aAAeA,EAOvB/F,EAAQgG,cAAgBA,EAaxBhG,EAAQgF,cAZR,SAAuBzyB,GACrB,GAAIA,EAAOG,OAAS,EAAG,OAAOH,EAC9B,IAAI0zB,EAAI1zB,EAAOG,OAAS,EACpBwzB,EAAM,EACV,IAAK,IAAIxxB,EAAI,EAAGA,EAAInC,EAAOG,OAAS,EAAGgC,IACrCwxB,EAAM3zB,EAAOmC,GACbnC,EAAOmC,GAAKnC,EAAO0zB,GACnB1zB,EAAO0zB,GAAKC,EACZD,IAEF,OAAO1zB,CACT,EAOAytB,EAAQmG,YALR,SAAqB5zB,GACnB,MAAM6zB,EAAQ5zB,EAAOujB,YAAYxjB,EAAOG,QAExC,OADAH,EAAO4S,KAAKihB,GACLA,CACT,EA0CApG,EAAQrrB,aArCR,MACEC,WAAAA,CAAYrC,EAAQ0D,EAAS,GAC3BhB,KAAK1C,OAASA,EACd0C,KAAKgB,OAASA,EACdgrB,EAAUD,EAAMM,MAAMN,EAAMxuB,OAAQwuB,EAAMqF,QAAS,CAAC9zB,EAAQ0D,GAC9D,CACAd,UAAAA,CAAWT,GACTO,KAAKgB,OAAShB,KAAK1C,OAAO4C,WAAWT,EAAGO,KAAKgB,OAC/C,CACAb,UAAAA,CAAWV,GACTO,KAAKgB,OAAShB,KAAK1C,OAAO8C,aAAaX,EAAGO,KAAKgB,OACjD,CACAX,WAAAA,CAAYZ,GACVO,KAAKgB,OAAShB,KAAK1C,OAAOgD,cAAcb,EAAGO,KAAKgB,OAClD,CACAT,WAAAA,CAAYd,GACVO,KAAKgB,OAAS+vB,EAAc/wB,KAAK1C,OAAQmC,EAAGO,KAAKgB,OACnD,CACAN,WAAAA,CAAYjB,GACVkB,EAAQwqB,OAAO1rB,EAAGO,KAAK1C,OAAQ0C,KAAKgB,QACpChB,KAAKgB,QAAUL,EAAQwqB,OAAO3qB,KAChC,CACAC,UAAAA,CAAW/B,GACT,GAAIsB,KAAK1C,OAAOG,OAASuC,KAAKgB,OAAStC,EAAMjB,OAC3C,MAAM,IAAI2B,MAAM,oCAElBY,KAAKgB,QAAUtC,EAAMwR,KAAKlQ,KAAK1C,OAAQ0C,KAAKgB,OAC9C,CACAH,aAAAA,CAAcnC,GACZsB,KAAKU,YAAYhC,EAAMjB,QACvBuC,KAAKS,WAAW/B,EAClB,CACA2yB,WAAAA,CAAYtvB,GACV/B,KAAKU,YAAYqB,EAAOtE,QACxBsE,EAAOrE,SAAQ6F,GAAOvD,KAAKa,cAAc0C,IAC3C,GAuDFwnB,EAAQhqB,aAjDR,MACEpB,WAAAA,CAAYrC,EAAQ0D,EAAS,GAC3BhB,KAAK1C,OAASA,EACd0C,KAAKgB,OAASA,EACdgrB,EAAUD,EAAMM,MAAMN,EAAMxuB,OAAQwuB,EAAMqF,QAAS,CAAC9zB,EAAQ0D,GAC9D,CACAE,SAAAA,GACE,MAAMC,EAASnB,KAAK1C,OAAO4D,UAAUlB,KAAKgB,QAE1C,OADAhB,KAAKgB,SACEG,CACT,CACAC,SAAAA,GACE,MAAMD,EAASnB,KAAK1C,OAAO+D,YAAYrB,KAAKgB,QAE5C,OADAhB,KAAKgB,QAAU,EACRG,CACT,CACAG,UAAAA,GACE,MAAMH,EAASnB,KAAK1C,OAAOiE,aAAavB,KAAKgB,QAE7C,OADAhB,KAAKgB,QAAU,EACRG,CACT,CACAK,UAAAA,GACE,MAAML,EAAS2vB,EAAa9wB,KAAK1C,OAAQ0C,KAAKgB,QAE9C,OADAhB,KAAKgB,QAAU,EACRG,CACT,CACAO,UAAAA,GACE,MAAMC,EAAKhB,EAAQuqB,OAAOlrB,KAAK1C,OAAQ0C,KAAKgB,QAE5C,OADAhB,KAAKgB,QAAUL,EAAQuqB,OAAO1qB,MACvBmB,CACT,CACAF,SAAAA,CAAUxC,GACR,GAAIe,KAAK1C,OAAOG,OAASuC,KAAKgB,OAAS/B,EACrC,MAAM,IAAIG,MAAM,mCAElB,MAAM+B,EAASnB,KAAK1C,OAAOoB,MAAMsB,KAAKgB,OAAQhB,KAAKgB,OAAS/B,GAE5D,OADAe,KAAKgB,QAAU/B,EACRkC,CACT,CACAS,YAAAA,GACE,OAAO5B,KAAKyB,UAAUzB,KAAK0B,aAC7B,CACAG,UAAAA,GACE,MAAMC,EAAQ9B,KAAK0B,aACbK,EAAS,GACf,IAAK,IAAItC,EAAI,EAAGA,EAAIqC,EAAOrC,IAAKsC,EAAO9B,KAAKD,KAAK4B,gBACjD,OAAOG,CACT,E,+BC3IFyP,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM8xB,EAAW1F,EAAQ,OACnB2F,EAAW3F,EAAQ,OACnB4F,EAAW5F,EAAQ,MACnBzL,EAASyL,EAAQ,OACjBsB,EAAatB,EAAQ,OACrBvmB,EAAaumB,EAAQ,OACrB6F,EAAoB7F,EAAQ,OAC5B8F,EAAoB9F,EAAQ,MAC5B+F,EAAoB/F,EAAQ,MAC5BG,EAAQ,CACZ6F,KAAM,WACNC,YAAa,cACbC,SAAU,WACVC,KAAM,SACNC,MAAO,aACPC,KAAM,aACNC,OAAQ,oBACRC,MAAO,oBACPC,mBAAoB,qBAEtBrH,EAAQgB,MAAQA,EAehBhB,EAAQvY,OAdR,SAAwBC,GACtB,GAAIif,EAAkBlf,OAAO6f,MAAM5f,GAAS,OAAOsZ,EAAMmG,OACzD,GAAIP,EAAkBnf,OAAO6f,MAAM5f,GAAS,OAAOsZ,EAAMoG,MACzD,GAAIjF,EAAW1a,OAAO6f,MAAM5f,GAAS,OAAOsZ,EAAMiG,MAClD,GAAI3sB,EAAWmN,OAAO6f,MAAM5f,GAAS,OAAOsZ,EAAMkG,KAElD,MAAM1K,EAAS+J,EAASgB,UAAU7f,GAClC,IAAK8U,EAAQ,MAAM,IAAIgC,UAAU,kBACjC,OAAIgI,EAAS/e,OAAO6f,MAAM9K,GAAgBwE,EAAM6F,KAC5CzR,EAAO3N,OAAO6f,MAAM9K,GAAgBwE,EAAMgG,KAC1CN,EAAkBjf,OAAO6f,MAAM9K,GAAgBwE,EAAMqG,mBACrDZ,EAAShf,OAAO6f,MAAM9K,GAAgBwE,EAAM+F,SACzC/F,EAAM8F,WACf,EAYA9G,EAAQ1X,MAVR,SAAuBZ,EAAQ8f,GAE7B,MAAMhL,EAAS+J,EAASgB,UAAU7f,GAClC,IAAK8U,EAAQ,MAAM,IAAIgC,UAAU,kBACjC,OAAI2D,EAAW7Z,MAAMgf,MAAM9K,GAAgBwE,EAAMiG,MAC7C3sB,EAAWgO,MAAMgf,MAAM9K,EAAQgL,GAAyBxG,EAAMkG,KAC9DV,EAASle,MAAMgf,MAAM9K,EAAQgL,GAAyBxG,EAAM6F,KAC5DzR,EAAO9M,MAAMgf,MAAM9K,GAAgBwE,EAAMgG,KACtChG,EAAM8F,WACf,EAWA9G,EAAQxX,QATR,SAAyBd,EAAQ8f,GAE/B,MAAMhL,EAAS+J,EAASgB,UAAU7f,GAClC,IAAK8U,EAAQ,MAAM,IAAIgC,UAAU,kBACjC,OAAImI,EAAkBre,MAAMgf,MAAM9K,GAAgBwE,EAAMmG,OACpDP,EAAkBte,MAAMgf,MAAM9K,EAAQgL,GACjCxG,EAAMoG,MACRpG,EAAM8F,WACf,C,8BCxDArgB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMgzB,EAAa5G,EAAQ,OAC3B,SAAS9L,EAAUxiB,GACjB,IACE,OAAOk1B,EAAW,UACfpwB,OAAO9E,GACPgF,QACL,CAAE,MAAOmwB,GACP,OAAOD,EAAW,aACfpwB,OAAO9E,GACPgF,QACL,CACF,CAQA,SAASuC,EAAOvH,GACd,OAAOk1B,EAAW,UACfpwB,OAAO9E,GACPgF,QACL,CAXAyoB,EAAQjL,UAAYA,EAMpBiL,EAAQ2H,KALR,SAAcp1B,GACZ,OAAOk1B,EAAW,QACfpwB,OAAO9E,GACPgF,QACL,EAOAyoB,EAAQlmB,OAASA,EAIjBkmB,EAAQ4H,QAHR,SAAiBr1B,GACf,OAAOwiB,EAAUjb,EAAOvH,GAC1B,EAKAytB,EAAQnS,QAHR,SAAiBtb,GACf,OAAOuH,EAAOA,EAAOvH,GACvB,C,oDChCAkU,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMozB,EAAWhH,EAAQ,OACnBG,EAAQH,EAAQ,OAChBiH,EAAMjH,EAAQ,OACdkH,EAAclH,EAAQ,OACtBI,EAAYJ,EAAQ,MACpBmH,EAAMnH,EAAQ,MACdoH,EAAYhH,EAAUiH,MAC1BjH,EAAUkH,QAAQ,CAChBC,WAAYpH,EAAMkH,MAAMlH,EAAMqH,SAC9BzG,QAASZ,EAAMkH,MAAMlH,EAAMsH,YAG/B,MAAMC,EACJ3zB,WAAAA,CAAY4zB,EAAKC,EAAKha,GACpBxZ,KAAKuzB,IAAMA,EACXvzB,KAAKwzB,IAAMA,EACXxzB,KAAKyzB,MAAO,OACI7sB,IAAZ4S,IAAuBA,EAAU,CAAC,GACtCxZ,KAAKmzB,gBACoBvsB,IAAvB4S,EAAQ2Z,YAAkC3Z,EAAQ2Z,WACpDnzB,KAAK2sB,QAAUnT,EAAQmT,SAAWiG,EAAShG,aAC/BhmB,IAAR4sB,IAAmBxzB,KAAKwzB,IAAMX,EAAIzd,cAAcoe,EAAKxzB,KAAKmzB,YAChE,CACA,cAAIO,GACF,OAAO1zB,KAAKuzB,GACd,CACA,aAAIpe,GAEF,OADKnV,KAAKwzB,MAAKxzB,KAAKwzB,IAAMX,EAAIc,gBAAgB3zB,KAAKuzB,IAAKvzB,KAAKmzB,aACtDnzB,KAAKwzB,GACd,CACAI,KAAAA,GACE,IAAK5zB,KAAKuzB,IAAK,MAAM,IAAIn0B,MAAM,uBAC/B,OAAO2zB,EAAI5H,OAAOnrB,KAAK2sB,QAAQoG,IAAK/yB,KAAKuzB,IAAKvzB,KAAKmzB,WACrD,CACAU,IAAAA,CAAKxtB,EAAMotB,GACT,IAAKzzB,KAAKuzB,IAAK,MAAM,IAAIn0B,MAAM,uBAE/B,QADawH,IAAT6sB,IAAoBA,EAAOzzB,KAAKyzB,OACvB,IAATA,EACF,OAAOZ,EAAIgB,KAAKxtB,EAAMrG,KAAKuzB,KACtB,CACL,IAAIllB,EAAMwkB,EAAIgB,KAAKxtB,EAAMrG,KAAKuzB,KAC9B,MAAM9f,EAAYlW,EAAOC,MAAM,GAAI,GACnC,IAAIs2B,EAAU,EAGd,KAAOzlB,EAAI,GAAK,KACdylB,IACArgB,EAAUsgB,YAAYD,EAAS,EAAG,GAClCzlB,EAAMwkB,EAAImB,gBAAgB3tB,EAAMrG,KAAKuzB,IAAK9f,GAE5C,OAAOpF,CACT,CACF,CACAuG,MAAAA,CAAOvO,EAAM4F,GACX,OAAO4mB,EAAIje,OAAOvO,EAAMrG,KAAKmV,UAAWlJ,EAC1C,EAEF,SAASgoB,EAAe32B,EAAQkc,GAE9B,GADAwS,EAAUD,EAAMmI,aAAc52B,IACzBu1B,EAAIsB,UAAU72B,GACjB,MAAM,IAAIisB,UAAU,mCAEtB,OADAyC,EAAUgH,EAAWxZ,GACd,IAAI8Z,EAAOh2B,OAAQsJ,EAAW4S,EACvC,CACAuR,EAAQkJ,eAAiBA,EAMzBlJ,EAAQqJ,cALR,SAAuB92B,EAAQkc,GAG7B,OAFAwS,EAAU6G,EAAIwB,QAAS/2B,GACvB0uB,EAAUgH,EAAWxZ,GACd,IAAI8Z,OAAO1sB,EAAWtJ,EAAQkc,EACvC,EAuBAuR,EAAQuJ,QArBR,SAAiBC,EAAW5H,GAC1B,MAAM6H,EAAUzB,EAAI7H,OAAOqJ,GACrBz1B,EAAU01B,EAAQ11B,QAExB,GAAIitB,EAAMV,MAAMsB,IAMd,KALAA,EAAUA,EACPyC,QAAO1qB,GACC5F,IAAY4F,EAAEquB,MAEtB0B,OACW,MAAM,IAAIr1B,MAAM,gCAI9B,GADAutB,EAAUA,GAAWiG,EAAShG,QAC1B9tB,IAAY6tB,EAAQoG,IAAK,MAAM,IAAI3zB,MAAM,2BAE/C,OAAO60B,EAAeO,EAAQd,WAAY,CACxCP,WAAYqB,EAAQrB,WACpBxG,QAASA,GAEb,EAaA5B,EAAQ2J,WAXR,SAAoBlb,GAClBwS,EAAUgH,EAAWxZ,QACL5S,IAAZ4S,IAAuBA,EAAU,CAAC,GACtC,MAAMmb,EAAMnb,EAAQmb,KAAO7B,EAC3B,IAAI8B,EACJ,GACEA,EAAID,EAAI,IACR3I,EAAUD,EAAMmI,aAAcU,UACtB/B,EAAIsB,UAAUS,IACxB,OAAOX,EAAeW,EAAGpb,EAC3B,C,+BCvGcoS,EAAQ,OAENA,EAAQ,OAExB,MAAMhnB,EAASgnB,EAAQ,MACvBb,EAAQ,GAASnmB,EACFgnB,EAAQ,MAENA,EAAQ,OAERA,EAAQ,OAEVA,EAAQ,OAETA,EAAQ,OACE4B,MACX5B,EAAQ,OACCiJ,KACPjJ,EAAQ,OACIkJ,IACPlJ,EAAQ,OACQqC,YACRrC,EAAQ,OACemJ,kB,6BCxBnDvjB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtDurB,EAAQ6B,QAAU,CAChBoI,cAAe,gCACf3b,OAAQ,KACR4b,MAAO,CACLC,OAAQ,SACRC,QAAS,UAEXjI,WAAY,EACZ7nB,WAAY,EACZ0tB,IAAK,KAEPhI,EAAQqK,QAAU,CAChBJ,cAAe,gCACf3b,OAAQ,OACR4b,MAAO,CACLC,OAAQ,SACRC,QAAS,UAEXjI,WAAY,IACZ7nB,WAAY,IACZ0tB,IAAK,KAEPhI,EAAQsK,QAAU,CAChBL,cAAe,gCACf3b,OAAQ,KACR4b,MAAO,CACLC,OAAQ,SACRC,QAAS,UAEXjI,WAAY,IACZ7nB,WAAY,IACZ0tB,IAAK,I,+BChCPvhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM81B,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACf4J,EAAQ5J,EAAQ,MAChBkJ,EAAMhJ,EAAQgJ,IA0CpB/J,EAAQ0K,OAlCR,SAAgB5F,EAAG3b,GACjB,IAAK2b,EAAE5d,OAAS4d,EAAErd,OAAQ,MAAM,IAAI+W,UAAU,mBAC9CrV,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAClDshB,EACE,CACE7I,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BgB,OAAQgjB,EAAMvC,MAAMuC,EAAMj4B,QAC1B0U,KAAMujB,EAAMvC,MAAMuC,EAAMG,QAAQH,EAAMj4B,UAExCsyB,GAEF,MACM+F,EAAI,CAAE3Y,KAAM,QAAS0P,QADXkD,EAAElD,SAAW2I,EAAW1I,SAWxC,GATA2I,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAE5d,KACP,OAAO6Z,EAAQoH,QAAQ,CAAC4B,EAAIgB,WAAWh1B,OAAO+uB,EAAE5d,MAAM,IAExDsjB,EAAKM,KAAKD,EAAG,QAAQ,KACnB,GAAK/F,EAAErd,OACP,OAAOsZ,EAAQwG,UAAUzC,EAAErd,QAAQ9T,MAAM,EAAE,IAGzCwV,EAAKwhB,UACH7F,EAAErd,OAAQ,CACZ,MAAM+U,EAASuE,EAAQwG,UAAUzC,EAAErd,QACnC,GAAI+U,EAAO,KAAOuN,EAAIgB,UAAW,MAAM,IAAIvM,UAAU,qBACrD,IAAKhC,EAAO7oB,MAAM,GAAGq3B,MAAMP,EAAMj4B,QAC/B,MAAM,IAAIgsB,UAAU,qBACtB,GAAIsG,EAAE5d,OAnCZ,SAAqB4d,EAAG9vB,GACtB,OAAI8vB,EAAEpyB,SAAWsC,EAAEtC,QACZoyB,EAAEkG,OAAM,CAACrxB,EAAGjF,IACViF,EAAEc,OAAOzF,EAAEN,KAEtB,CA8BqBu2B,CAAYnG,EAAE5d,KAAM2jB,EAAE3jB,MACnC,MAAM,IAAIsX,UAAU,gBACxB,CAEF,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,+BC9CAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMy2B,EAAUrK,EAAQ,OACxBb,EAAQmL,MAAQD,EAAQR,OACxB,MAAMU,EAASvK,EAAQ,OACvBb,EAAQqL,KAAOD,EAAOC,KACtB,MAAMC,EAASzK,EAAQ,OACvBb,EAAQuL,KAAOD,EAAOC,KACtB,MAAMC,EAAU3K,EAAQ,OACxBb,EAAQznB,MAAQizB,EAAQjzB,MACxB,MAAMkzB,EAAS5K,EAAQ,OACvBb,EAAQ3R,KAAOod,EAAOpd,KACtB,MAAMqd,EAAW7K,EAAQ,OACzBb,EAAQplB,OAAS8wB,EAAS9wB,OAC1B,MAAM+wB,EAAU9K,EAAQ,OACxBb,EAAQ8B,MAAQ6J,EAAQ7J,K,6BCdxBrb,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IAoBtDurB,EAAQ8K,KAnBR,SAAcc,EAAQ1Z,EAAM2Z,GAC1BplB,OAAOka,eAAeiL,EAAQ1Z,EAAM,CAClC4Z,cAAc,EACdC,YAAY,EACZ9lB,GAAAA,GACE,MAAM+lB,EAASH,EAAEI,KAAKh3B,MAEtB,OADAA,KAAKid,GAAQ8Z,EACNA,CACT,EACAvmB,GAAAA,CAAIumB,GACFvlB,OAAOka,eAAe1rB,KAAMid,EAAM,CAChC4Z,cAAc,EACdC,YAAY,EACZt3B,MAAOu3B,EACPE,UAAU,GAEd,GAEJ,EAUAlM,EAAQvrB,MARR,SAAeo3B,GACb,IAAIG,EACJ,MAAO,UACUnwB,IAAXmwB,IACJA,EAASH,KADwBG,EAIrC,C,+BC5BAvlB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM81B,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACfkJ,EAAMhJ,EAAQgJ,IACdU,EAAQ5J,EAAQ,MAChBiH,EAAMjH,EAAQ,OACdsL,EAAcpC,EAAIqC,YACxB,SAASnB,EAAYnG,EAAG9vB,GACtB,OAAI8vB,EAAEpyB,SAAWsC,EAAEtC,QACZoyB,EAAEkG,OAAM,CAACrxB,EAAGjF,IACViF,EAAEc,OAAOzF,EAAEN,KAEtB,CAkIAsrB,EAAQqL,KA/HR,SAAcvG,EAAG3b,GACf,IACG2b,EAAExc,QACFwc,EAAErd,UACDqd,EAAEjtB,cAAmBgE,IAARipB,EAAEjnB,KAChBinB,EAAEnR,WAEH,MAAM,IAAI6K,UAAU,mBAEtB,SAAS6N,EAAsB1yB,GAC7B,OACEonB,EAAQuL,2BAA2B3yB,SACUkC,KAA5CsN,EAAKqe,iBAAmB7tB,IAAMowB,EAAIwC,KAEvC,CANApjB,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAOlDshB,EACE,CACE7I,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3B5I,EAAG4sB,EAAMvC,MAAMuC,EAAMt2B,QACrBD,EAAGu2B,EAAMvC,MAAMuC,EAAMt2B,QACrBsT,OAAQgjB,EAAMvC,MAAMuC,EAAMj4B,QAC1BqF,QAAS4yB,EAAMvC,MAAMuC,EAAMG,QAAQ9C,EAAIwB,UACvC3V,WAAY8W,EAAMvC,MAAMuC,EAAMG,QAAQyB,IACtC/jB,MAAOmiB,EAAMvC,MAAMuC,EAAMj4B,SAE3BsyB,GAEF,MACM+F,EAAI,CAAEjJ,QADIkD,EAAElD,SAAW2I,EAAW1I,SAExC,IAAIrF,EAAS,GACTiN,GAAU,EACd,SAAStJ,EAAO1Y,GACVgiB,IACJA,GAAU,EACVjN,EAASuE,EAAQwG,UAAU9f,GAC3BojB,EAAEhtB,EAAI2e,EAAO,GAAK2P,EAClBtB,EAAE32B,EAAIsoB,EAAOA,EAAO9pB,OAAS,GAAKy5B,EAClCtB,EAAEhzB,QAAU2kB,EAAO7oB,MAAM,GAAI,GAC/B,CA6CA,GA5CA62B,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAEjnB,GACFgtB,EAAE32B,GACF4wB,EAAEjtB,QACP,OAAOkpB,EAAQoH,QACb,GAAGpyB,OACDo2B,EAAcrH,EAAEjnB,EAChBinB,EAAEjtB,QACFs0B,EAActB,EAAE32B,EAChB61B,EAAIyC,kBAEP,IAEHhC,EAAKM,KAAKD,EAAG,KAAK,KAChB,GAAKA,EAAEpjB,OAEP,OADA0Y,EAAO0K,EAAEpjB,QACFojB,EAAEhtB,CAAC,IAEZ2sB,EAAKM,KAAKD,EAAG,KAAK,KAChB,GAAKA,EAAEhzB,QACP,OAAOgzB,EAAEhzB,QAAQnF,MAAM,IAEzB83B,EAAKM,KAAKD,EAAG,WAAW,KACtB,GAAK/F,EAAErd,OAEP,OADA0Y,EAAO2E,EAAErd,QACFojB,EAAEhzB,OAAO,IAElB2yB,EAAKM,KAAKD,EAAG,cAAc,KACzB,GAAK/F,EAAExc,MACP,OAAOyY,EAAQwG,UAAUzC,EAAExc,OAAO3U,MAAM,EAAE,IAE5C62B,EAAKM,KAAKD,EAAG,SAAS,KACpB,GAAK/F,EAAEnR,WACP,OAAOoN,EAAQoH,QAAQ,CAAC4B,EAAIwC,MAAMx2B,OAAO+uB,EAAEnR,YAAY,IAEzD6W,EAAKM,KAAKD,EAAG,WAAW,KACtB,GAAKA,EAAEviB,MACP,MAAO,EAAE,IAEXkiB,EAAKM,KAAKD,EAAG,QAAQ,KACnB,GAAKA,EAAEhtB,GAAMgtB,EAAE32B,EACf,MAAO,QAAQ22B,EAAEhtB,QAAQgtB,EAAE32B,IAAI,IAG7BiV,EAAKwhB,SAAU,CACjB,GAAI7F,EAAErd,OAAQ,CAEZ,GADA0Y,EAAO2E,EAAErd,SACJgjB,EAAMt2B,OAAOqoB,EAAO,IAAK,MAAM,IAAIgC,UAAU,qBAClD,IAAKiM,EAAMt2B,OAAOqoB,EAAOA,EAAO9pB,OAAS,IACvC,MAAM,IAAI8rB,UAAU,qBACtB,GAAIhC,EAAOA,EAAO9pB,OAAS,KAAOq3B,EAAIyC,iBACpC,MAAM,IAAIhO,UAAU,qBACtB,GAAIqM,EAAEhtB,GAAK,GAAKgtB,EAAE32B,EAAI,IAAM22B,EAAEhtB,EAAIgtB,EAAE32B,GAAK22B,EAAE32B,IAAMsoB,EAAO9pB,OAAS,EAC/D,MAAM,IAAI8rB,UAAU,qBACtB,IAAKqM,EAAEhzB,QAAQmzB,OAAMrxB,GAAKmuB,EAAIwB,QAAQ3vB,KACpC,MAAM,IAAI6kB,UAAU,qBACtB,QAAY3iB,IAARipB,EAAEjnB,GAAmBinB,EAAEjnB,IAAMgtB,EAAEhtB,EAAG,MAAM,IAAI2gB,UAAU,cAC1D,QAAY3iB,IAARipB,EAAE5wB,GAAmB4wB,EAAE5wB,IAAM22B,EAAE32B,EAAG,MAAM,IAAIsqB,UAAU,cAC1D,GAAIsG,EAAEjtB,UAAYozB,EAAYnG,EAAEjtB,QAASgzB,EAAEhzB,SACzC,MAAM,IAAI2mB,UAAU,mBACxB,CACA,GAAIsG,EAAEjtB,QAAS,CACb,QAAYgE,IAARipB,EAAE5wB,GAAmB4wB,EAAE5wB,IAAM4wB,EAAEjtB,QAAQnF,OACzC,MAAM,IAAI8rB,UAAU,yBAEtB,GADAqM,EAAE32B,EAAI4wB,EAAEjtB,QAAQnF,OACZm4B,EAAE32B,EAAI22B,EAAEhtB,EAAG,MAAM,IAAI2gB,UAAU,qCACrC,CACA,GAAIsG,EAAEnR,WAAY,CAChB,GAAImR,EAAEnR,WAAWjhB,OAASm4B,EAAEhtB,EAC1B,MAAM,IAAI2gB,UAAU,kCACtB,GAAIsG,EAAEnR,WAAWjhB,OAASm4B,EAAEhtB,EAC1B,MAAM,IAAI2gB,UAAU,+BACxB,CACA,GAAIsG,EAAExc,MAAO,CACX,GAAIwc,EAAExc,MAAM,KAAOyhB,EAAIwC,KAAM,MAAM,IAAI/N,UAAU,oBACjD,GAC0B,IAAxBqM,EAAElX,WAAWjhB,SACZm4B,EAAElX,WAAWqX,MAAMqB,GAEpB,MAAM,IAAI7N,UAAU,kCACtB,GAAIsG,EAAEnR,aAAesX,EAAYnG,EAAEnR,WAAYkX,EAAElX,YAC/C,MAAM,IAAI6K,UAAU,sBACtB,QAAY3iB,IAARipB,EAAEjnB,GAAmBinB,EAAEjnB,IAAMinB,EAAEnR,WAAWjhB,OAC5C,MAAM,IAAI8rB,UAAU,2BACxB,CACF,CACA,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,+BC9IAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM81B,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACf4J,EAAQ5J,EAAQ,MAChBkJ,EAAMhJ,EAAQgJ,IACdjC,EAAMjH,EAAQ,OAgEpBb,EAAQuL,KA7DR,SAAczG,EAAG3b,GACf,IAAK2b,EAAExc,QAAUwc,EAAErd,SAAWqd,EAAEhxB,SAAWgxB,EAAExc,QAAUwc,EAAE5jB,UACvD,MAAM,IAAIsd,UAAU,mBACtBrV,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAClDshB,EACE,CACE7I,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BgB,OAAQgjB,EAAMvC,MAAMuC,EAAMj4B,QAC1BsB,OAAQ22B,EAAMvC,MAAMJ,EAAIwB,SACxBpoB,UAAWupB,EAAMvC,MAAMnH,EAAQuL,4BAC/BhkB,MAAOmiB,EAAMvC,MAAMuC,EAAMj4B,SAE3BsyB,GAEF,MAAM2H,EAAUjC,EAAK/1B,OAAM,IAClBssB,EAAQwG,UAAUzC,EAAExc,SAGvBuiB,EAAI,CAAE3Y,KAAM,OAAQ0P,QADVkD,EAAElD,SAAW2I,EAAW1I,SAuBxC,GArBA2I,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAEhxB,OACP,OAAOitB,EAAQoH,QAAQ,CAACrD,EAAEhxB,OAAQi2B,EAAI2C,aAAa,IAErDlC,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAErd,OACP,OAAOqd,EAAErd,OAAO9T,MAAM,GAAI,EAAE,IAE9B62B,EAAKM,KAAKD,EAAG,aAAa,KACxB,GAAK/F,EAAExc,MACP,OAAOmkB,IAAU,EAAE,IAErBjC,EAAKM,KAAKD,EAAG,SAAS,KACpB,GAAK/F,EAAE5jB,UACP,OAAO6f,EAAQoH,QAAQ,CAACrD,EAAE5jB,WAAW,IAEvCspB,EAAKM,KAAKD,EAAG,WAAW,KACtB,GAAKA,EAAEviB,MACP,MAAO,EAAE,IAGPa,EAAKwhB,SAAU,CACjB,GAAI7F,EAAErd,OAAQ,CACZ,GAAIqd,EAAErd,OAAOqd,EAAErd,OAAO/U,OAAS,KAAOq3B,EAAI2C,YACxC,MAAM,IAAIlO,UAAU,qBACtB,IAAKsJ,EAAIwB,QAAQuB,EAAE/2B,QACjB,MAAM,IAAI0qB,UAAU,4BACtB,GAAIsG,EAAEhxB,SAAWgxB,EAAEhxB,OAAO2G,OAAOowB,EAAE/2B,QACjC,MAAM,IAAI0qB,UAAU,kBACxB,CACA,GAAIsG,EAAE5jB,WACA4jB,EAAExc,QAAUwc,EAAExc,MAAM7N,OAAOowB,EAAEviB,OAC/B,MAAM,IAAIkW,UAAU,sBAExB,GAAIsG,EAAExc,MAAO,CACX,GAAyB,IAArBmkB,IAAU/5B,OAAc,MAAM,IAAI8rB,UAAU,oBAChD,IAAKuC,EAAQuL,2BAA2BzB,EAAE3pB,WACxC,MAAM,IAAIsd,UAAU,8BACxB,CACF,CACA,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,qDCrEAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM4tB,EAAUxB,EAAQ,MAClB0J,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACf4J,EAAQ5J,EAAQ,MAChBkJ,EAAMhJ,EAAQgJ,IACdjC,EAAMjH,EAAQ,OACdntB,EAAYmtB,EAAQ,MA0H1Bb,EAAQznB,MAvHR,SAAeusB,EAAG3b,GAChB,IAAK2b,EAAEhb,UAAYgb,EAAExpB,OAASwpB,EAAErd,SAAWqd,EAAEhxB,SAAWgxB,EAAExc,MACxD,MAAM,IAAIkW,UAAU,mBACtBrV,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAClDshB,EACE,CACE7I,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BqD,QAAS2gB,EAAMvC,MAAMuC,EAAMkC,QAC3BrxB,KAAMmvB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAChCnlB,OAAQgjB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAClC94B,OAAQ22B,EAAMvC,MAAMJ,EAAIwB,SACxBpoB,UAAWupB,EAAMvC,MAAMnH,EAAQuL,4BAC/BhkB,MAAOmiB,EAAMvC,MAAMuC,EAAMj4B,SAE3BsyB,GAEF,MAAM+H,EAAWrC,EAAK/1B,OAAM,KAC1B,MAAM0sB,EAAUztB,EAAUysB,OAAO2E,EAAEhb,SAGnC,MAAO,CAAE/V,QAFOotB,EAAQhrB,UAAU,GAEhBmF,KADL6lB,EAAQxtB,MAAM,GACH,IAEpB84B,EAAUjC,EAAK/1B,OAAM,IAClBssB,EAAQwG,UAAUzC,EAAExc,SAEvBsZ,EAAUkD,EAAElD,SAAW2I,EAAW1I,QAClCgJ,EAAI,CAAE3Y,KAAM,QAAS0P,WAyC3B,GAxCA4I,EAAKM,KAAKD,EAAG,WAAW,KACtB,IAAKA,EAAEvvB,KAAM,OACb,MAAM6lB,EAAU3uB,EAAOujB,YAAY,IAGnC,OAFAoL,EAAQhsB,WAAWysB,EAAQO,WAAY,GACvC0I,EAAEvvB,KAAK6J,KAAKgc,EAAS,GACdztB,EAAU0sB,OAAOe,EAAQ,IAElCqJ,EAAKM,KAAKD,EAAG,QAAQ,IACf/F,EAAErd,OAAeqd,EAAErd,OAAO9T,MAAM,EAAG,IACnCmxB,EAAEhb,QAAgB+iB,IAAWvxB,KAC7BwpB,EAAEhxB,QAAU+2B,EAAE/2B,OAAeuuB,EAAQuF,QAAQ9C,EAAEhxB,QAAU+2B,EAAE/2B,aAA/D,IAEF02B,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAKA,EAAEvvB,KACP,OAAOylB,EAAQoH,QAAQ,CACrB4B,EAAI+C,OACJ/C,EAAIgD,WACJlC,EAAEvvB,KACFyuB,EAAIiD,eACJjD,EAAI2C,aACJ,IAEJlC,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAExc,MACP,OAAOmkB,IAAU,EAAE,IAErBjC,EAAKM,KAAKD,EAAG,aAAa,KACxB,GAAK/F,EAAExc,MACP,OAAOmkB,IAAU,EAAE,IAErBjC,EAAKM,KAAKD,EAAG,SAAS,KACpB,GAAK/F,EAAEhxB,QACFgxB,EAAE5jB,UACP,OAAO6f,EAAQoH,QAAQ,CAACrD,EAAE5jB,UAAW4jB,EAAEhxB,QAAQ,IAEjD02B,EAAKM,KAAKD,EAAG,WAAW,KACtB,GAAKA,EAAEviB,MACP,MAAO,EAAE,IAGPa,EAAKwhB,SAAU,CACjB,IAAIrvB,EAAO9I,EAAOqD,KAAK,IACvB,GAAIivB,EAAEhb,QAAS,CACb,GAAI+iB,IAAW94B,UAAY6tB,EAAQO,WACjC,MAAM,IAAI3D,UAAU,uCACtB,GAA+B,KAA3BqO,IAAWvxB,KAAK5I,OAAe,MAAM,IAAI8rB,UAAU,mBACvDljB,EAAOuxB,IAAWvxB,IACpB,CACA,GAAIwpB,EAAExpB,KAAM,CACV,GAAIA,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOqqB,EAAExpB,MACpC,MAAM,IAAIkjB,UAAU,iBACjBljB,EAAOwpB,EAAExpB,IAChB,CACA,GAAIwpB,EAAErd,OAAQ,CACZ,GACsB,KAApBqd,EAAErd,OAAO/U,QACToyB,EAAErd,OAAO,KAAOsiB,EAAI+C,QACpBhI,EAAErd,OAAO,KAAOsiB,EAAIgD,YACJ,KAAhBjI,EAAErd,OAAO,IACTqd,EAAErd,OAAO,MAAQsiB,EAAIiD,gBACrBlI,EAAErd,OAAO,MAAQsiB,EAAI2C,YAErB,MAAM,IAAIlO,UAAU,qBACtB,MAAMyO,EAAQnI,EAAErd,OAAO9T,MAAM,EAAG,IAChC,GAAI2H,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOwyB,GAClC,MAAM,IAAIzO,UAAU,iBACjBljB,EAAO2xB,CACd,CACA,GAAInI,EAAEhxB,OAAQ,CACZ,MAAMo5B,EAAM7K,EAAQuF,QAAQ9C,EAAEhxB,QAC9B,GAAIwH,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOyyB,GAClC,MAAM,IAAI1O,UAAU,iBACjBljB,EAAO4xB,CACd,CACA,GAAIpI,EAAExc,MAAO,CACX,MAAMkU,EAASiQ,IACf,GAAsB,IAAlBjQ,EAAO9pB,OAAc,MAAM,IAAI8rB,UAAU,oBAC7C,IAAKuC,EAAQuL,2BAA2B9P,EAAO,IAC7C,MAAM,IAAIgC,UAAU,+BACtB,IAAKsJ,EAAIwB,QAAQ9M,EAAO,IACtB,MAAM,IAAIgC,UAAU,4BACtB,GAAIsG,EAAE5jB,YAAc4jB,EAAE5jB,UAAUzG,OAAO+hB,EAAO,IAC5C,MAAM,IAAIgC,UAAU,sBACtB,GAAIsG,EAAEhxB,SAAWgxB,EAAEhxB,OAAO2G,OAAO+hB,EAAO,IACtC,MAAM,IAAIgC,UAAU,mBACtB,MAAM0O,EAAM7K,EAAQuF,QAAQpL,EAAO,IACnC,GAAIlhB,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOyyB,GAClC,MAAM,IAAI1O,UAAU,gBACxB,CACF,CACA,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,qDCjIAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM4tB,EAAUxB,EAAQ,MAClB0J,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACf4J,EAAQ5J,EAAQ,MAChBkJ,EAAMhJ,EAAQgJ,IACdr2B,EAAYmtB,EAAQ,MA8K1Bb,EAAQ3R,KApKR,SAAcyW,EAAG3b,GACf,IAAK2b,EAAEhb,UAAYgb,EAAExpB,OAASwpB,EAAErd,SAAWqd,EAAEqI,SAAWrI,EAAExc,MACxD,MAAM,IAAIkW,UAAU,mBACtBrV,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAClDshB,EACE,CACE7I,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BqD,QAAS2gB,EAAMvC,MAAMuC,EAAMkC,QAC3BrxB,KAAMmvB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAChCnlB,OAAQgjB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAClCO,OAAQ1C,EAAMvC,MAAM,CAClBtG,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BgB,OAAQgjB,EAAMvC,MAAMuC,EAAMj4B,QAC1B8V,MAAOmiB,EAAMvC,MAAMuC,EAAMj4B,QACzBgW,QAASiiB,EAAMvC,MAAMuC,EAAMG,QAAQH,EAAMj4B,WAE3C8V,MAAOmiB,EAAMvC,MAAMuC,EAAMj4B,QACzBgW,QAASiiB,EAAMvC,MAAMuC,EAAMG,QAAQH,EAAMj4B,UAE3CsyB,GAEF,IAAIlD,EAAUkD,EAAElD,QACXA,IACHA,EAAWkD,EAAEqI,QAAUrI,EAAEqI,OAAOvL,SAAY2I,EAAW1I,SAEzD,MAAMgJ,EAAI,CAAEjJ,WACNiL,EAAWrC,EAAK/1B,OAAM,KAC1B,MAAM0sB,EAAUztB,EAAUysB,OAAO2E,EAAEhb,SAGnC,MAAO,CAAE/V,QAFOotB,EAAQhrB,UAAU,GAEhBmF,KADL6lB,EAAQxtB,MAAM,GACH,IAEpB84B,EAAUjC,EAAK/1B,OAAM,IAClBssB,EAAQwG,UAAUzC,EAAExc,SAEvB8kB,EAAU5C,EAAK/1B,OAAM,KACzB,MAAM+nB,EAASiQ,IACf,MAAO,CACL7K,UACAna,OAAQ+U,EAAOA,EAAO9pB,OAAS,GAC/B4V,MAAOyY,EAAQoH,QAAQ3L,EAAO7oB,MAAM,GAAI,IACxC6U,QAASsc,EAAEtc,SAAW,GACvB,IAwCH,GArCAgiB,EAAKM,KAAKD,EAAG,WAAW,KACtB,IAAKA,EAAEvvB,KAAM,OACb,MAAM6lB,EAAU3uB,EAAOujB,YAAY,IAGnC,OAFAoL,EAAQhsB,WAAW01B,EAAEjJ,QAAQtnB,WAAY,GACzCuwB,EAAEvvB,KAAK6J,KAAKgc,EAAS,GACdztB,EAAU0sB,OAAOe,EAAQ,IAElCqJ,EAAKM,KAAKD,EAAG,QAAQ,IAEf/F,EAAErd,OAAeqd,EAAErd,OAAO9T,MAAM,EAAG,IACnCmxB,EAAEhb,QAAgB+iB,IAAWvxB,KAC7BuvB,EAAEsC,QAAUtC,EAAEsC,OAAO1lB,OAAe4a,EAAQuF,QAAQiD,EAAEsC,OAAO1lB,aAAjE,IAEF+iB,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAKA,EAAEvvB,KACP,OAAOylB,EAAQoH,QAAQ,CAAC4B,EAAIgD,WAAYlC,EAAEvvB,KAAMyuB,EAAIsD,UAAU,IAGhE7C,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAExc,MACP,OAAO8kB,GAAS,IAElB5C,EAAKM,KAAKD,EAAG,SAAS,KACpB,GAAK/F,EAAEqI,QAAWrI,EAAEqI,OAAO7kB,OAAUwc,EAAEqI,OAAO1lB,OAC9C,OAAOsZ,EAAQoH,QACb,GAAGpyB,OAAOgrB,EAAQwG,UAAUzC,EAAEqI,OAAO7kB,OAAQwc,EAAEqI,OAAO1lB,QACvD,IAEH+iB,EAAKM,KAAKD,EAAG,WAAW,IAClBA,EAAEsC,QAAUtC,EAAEsC,OAAO3kB,QAAgBqiB,EAAEsC,OAAO3kB,QAC9CqiB,EAAEviB,MAAc,QAApB,IAEFkiB,EAAKM,KAAKD,EAAG,QAAQ,KACnB,MAAMyC,EAAY,CAAC,QAEnB,YADiBzxB,IAAbgvB,EAAEsC,QAAsBG,EAAUp4B,KAAK21B,EAAEsC,OAAOjb,MAC7Cob,EAAUC,KAAK,IAAI,IAExBpkB,EAAKwhB,SAAU,CACjB,IAAIrvB,EAAO9I,EAAOqD,KAAK,IACvB,GAAIivB,EAAEhb,QAAS,CACb,GAAI+iB,IAAW94B,UAAY6tB,EAAQtnB,WACjC,MAAM,IAAIkkB,UAAU,uCACtB,GAA+B,KAA3BqO,IAAWvxB,KAAK5I,OAAe,MAAM,IAAI8rB,UAAU,mBACvDljB,EAAOuxB,IAAWvxB,IACpB,CACA,GAAIwpB,EAAExpB,KAAM,CACV,GAAIA,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOqqB,EAAExpB,MACpC,MAAM,IAAIkjB,UAAU,iBACjBljB,EAAOwpB,EAAExpB,IAChB,CACA,GAAIwpB,EAAErd,OAAQ,CACZ,GACsB,KAApBqd,EAAErd,OAAO/U,QACToyB,EAAErd,OAAO,KAAOsiB,EAAIgD,YACJ,KAAhBjI,EAAErd,OAAO,IACTqd,EAAErd,OAAO,MAAQsiB,EAAIsD,SAErB,MAAM,IAAI7O,UAAU,qBACtB,MAAMyO,EAAQnI,EAAErd,OAAO9T,MAAM,EAAG,IAChC,GAAI2H,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOwyB,GAClC,MAAM,IAAIzO,UAAU,iBACjBljB,EAAO2xB,CACd,CAEA,MAAMO,EAAcL,IAElB,GAAIA,EAAO1lB,OAAQ,CACjB,MAAM8f,EAAYxG,EAAQwG,UAAU4F,EAAO1lB,QAC3C,IAAK8f,GAAaA,EAAU70B,OAAS,EACnC,MAAM,IAAI8rB,UAAU,2BAEtB,MAAMyO,EAAQ5K,EAAQuF,QAAQuF,EAAO1lB,QACrC,GAAInM,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOwyB,GAClC,MAAM,IAAIzO,UAAU,iBACjBljB,EAAO2xB,CACd,CACA,GAAIE,EAAO7kB,MAAO,CAChB,MAAMmlB,EAAWN,EAAO7kB,MAAM5V,OAAS,EACjC8xB,EAAa2I,EAAO3kB,SAAW2kB,EAAO3kB,QAAQ9V,OAAS,EAC7D,IAAK+6B,IAAajJ,EAAY,MAAM,IAAIhG,UAAU,eAClD,GAAIiP,GAAYjJ,EACd,MAAM,IAAIhG,UAAU,8BACtB,GAAIiP,EAAU,CACZ,MAAMC,EAAW3M,EAAQwG,UAAU4F,EAAO7kB,OAC1C,IAAKyY,EAAQ4M,WAAWD,GACtB,MAAM,IAAIlP,UAAU,0BACxB,CACF,GAEF,GAAIsG,EAAExc,MAAO,CACX,MAAMkU,EAASiQ,IACf,IAAKjQ,GAAUA,EAAO9pB,OAAS,EAAG,MAAM,IAAI8rB,UAAU,mBACtD,IAAKhsB,EAAOo7B,SAASR,IAAU3lB,QAC7B,MAAM,IAAI+W,UAAU,oBACtBgP,EAAYJ,IACd,CACA,GAAItI,EAAEqI,OAAQ,CACZ,GAAIrI,EAAEqI,OAAOvL,SAAWkD,EAAEqI,OAAOvL,UAAYA,EAC3C,MAAM,IAAIpD,UAAU,oBACtB,GAAIsG,EAAExc,MAAO,CACX,MAAM6kB,EAASC,IACf,GAAItI,EAAEqI,OAAO1lB,SAAWqd,EAAEqI,OAAO1lB,OAAOhN,OAAO0yB,EAAO1lB,QACpD,MAAM,IAAI+W,UAAU,0BACtB,GAAIsG,EAAEqI,OAAO7kB,QAAUwc,EAAEqI,OAAO7kB,MAAM7N,OAAO0yB,EAAO7kB,OAClD,MAAM,IAAIkW,UAAU,wBACxB,CACAgP,EAAY1I,EAAEqI,OAChB,CACA,GAAIrI,EAAEtc,SAEFsc,EAAEqI,QACFrI,EAAEqI,OAAO3kB,UArKjB,SAAqBsc,EAAG9vB,GACtB,OAAI8vB,EAAEpyB,SAAWsC,EAAEtC,QACZoyB,EAAEkG,OAAM,CAACrxB,EAAGjF,IACViF,EAAEc,OAAOzF,EAAEN,KAEtB,CAiKSu2B,CAAYnG,EAAEqI,OAAO3kB,QAASsc,EAAEtc,SAEjC,MAAM,IAAIgW,UAAU,sCAE1B,CACA,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,qDCpLAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM4tB,EAAUxB,EAAQ,MAClB0J,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACf4J,EAAQ5J,EAAQ,MAChBkJ,EAAMhJ,EAAQgJ,IACdjC,EAAMjH,EAAQ,OACdvS,EAASuS,EAAQ,OACjBgN,EAAer7B,EAAOC,MAAM,GAuHlCutB,EAAQplB,OAnHR,SAAgBkqB,EAAG3b,GACjB,IAAK2b,EAAEhb,UAAYgb,EAAExpB,OAASwpB,EAAErd,SAAWqd,EAAEhxB,SAAWgxB,EAAEtc,QACxD,MAAM,IAAIgW,UAAU,mBACtBrV,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAClDshB,EACE,CACE3gB,QAAS2gB,EAAMvC,MAAMuC,EAAMkC,QAC3BrxB,KAAMmvB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAChCtkB,MAAOmiB,EAAMvC,MAAMuC,EAAMmC,QAAQ,IACjChL,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BgB,OAAQgjB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAClC94B,OAAQ22B,EAAMvC,MAAMJ,EAAIwB,SACxBpoB,UAAWupB,EAAMvC,MAAMnH,EAAQuL,4BAC/B9jB,QAASiiB,EAAMvC,MAAMuC,EAAMG,QAAQH,EAAMj4B,UAE3CsyB,GAEF,MAAM+H,EAAWrC,EAAK/1B,OAAM,KAC1B,MAAM2B,EAASkY,EAAO6R,OAAO2E,EAAEhb,SACzB/V,EAAUqC,EAAOopB,MAAMsO,QACvB5mB,EAAOoH,EAAOoS,UAAUtqB,EAAOopB,OACrC,MAAO,CACLzrB,UACAqb,OAAQhZ,EAAOgZ,OACflI,KAAM1U,EAAOqD,KAAKqR,GACnB,IAEG0a,EAAUkD,EAAElD,SAAW2I,EAAW1I,QAClCgJ,EAAI,CAAE3Y,KAAM,SAAU0P,WAmC5B,GAlCA4I,EAAKM,KAAKD,EAAG,WAAW,KACtB,IAAKA,EAAEvvB,KAAM,OACb,MAAMkkB,EAAQlR,EAAOkS,QAAQqK,EAAEvvB,MAE/B,OADAkkB,EAAMkC,QAAQ,GACPpT,EAAO8R,OAAOwB,EAAQtT,OAAQkR,EAAM,IAE7CgL,EAAKM,KAAKD,EAAG,QAAQ,IACf/F,EAAErd,OAAeqd,EAAErd,OAAO9T,MAAM,EAAG,IACnCmxB,EAAEhb,QAAgB+iB,IAAW3lB,KAC7B4d,EAAEhxB,QAAU+2B,EAAE/2B,OAAeuuB,EAAQuF,QAAQ9C,EAAEhxB,QAAU+2B,EAAE/2B,aAA/D,IAEF02B,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAKA,EAAEvvB,KACP,OAAOylB,EAAQoH,QAAQ,CAAC4B,EAAIwC,KAAM1B,EAAEvvB,MAAM,IAE5CkvB,EAAKM,KAAKD,EAAG,UAAU,IACjB/F,EAAEhxB,OAAegxB,EAAEhxB,OAClBgxB,EAAEtc,QACAsc,EAAEtc,QAAQ,QADjB,IAGFgiB,EAAKM,KAAKD,EAAG,aAAa,KACxB,GAAK/F,EAAEtc,QACP,OAAOsc,EAAEtc,QAAQ,EAAE,IAErBgiB,EAAKM,KAAKD,EAAG,SAAS,KACpB,GAAKA,EAAEriB,QACP,OAAOqlB,CAAY,IAErBrD,EAAKM,KAAKD,EAAG,WAAW,KACtB,GAAK/F,EAAEhxB,QACFgxB,EAAE5jB,UACP,MAAO,CAAC4jB,EAAE5jB,UAAW4jB,EAAEhxB,OAAO,IAG5BqV,EAAKwhB,SAAU,CACjB,IAAIrvB,EAAO9I,EAAOqD,KAAK,IACvB,GAAIivB,EAAEhb,QAAS,CACb,GAAI8X,GAAWA,EAAQtT,SAAWue,IAAWzd,OAC3C,MAAM,IAAIoP,UAAU,sCACtB,GAA2B,IAAvBqO,IAAW94B,QACb,MAAM,IAAIyqB,UAAU,2BACtB,GAA+B,KAA3BqO,IAAW3lB,KAAKxU,OAClB,MAAM,IAAI8rB,UAAU,wBACtBljB,EAAOuxB,IAAW3lB,IACpB,CACA,GAAI4d,EAAExpB,KAAM,CACV,GAAIA,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOqqB,EAAExpB,MACpC,MAAM,IAAIkjB,UAAU,iBACjBljB,EAAOwpB,EAAExpB,IAChB,CACA,GAAIwpB,EAAErd,OAAQ,CACZ,GACsB,KAApBqd,EAAErd,OAAO/U,QACToyB,EAAErd,OAAO,KAAOsiB,EAAIwC,MACJ,KAAhBzH,EAAErd,OAAO,GAET,MAAM,IAAI+W,UAAU,qBACtB,GAAIljB,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOqqB,EAAErd,OAAO9T,MAAM,IACjD,MAAM,IAAI6qB,UAAU,iBACjBljB,EAAOwpB,EAAErd,OAAO9T,MAAM,EAC7B,CACA,GAAImxB,EAAEhxB,OAAQ,CACZ,MAAMo5B,EAAM7K,EAAQuF,QAAQ9C,EAAEhxB,QAC9B,GAAIwH,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOyyB,GAClC,MAAM,IAAI1O,UAAU,iBAEtB,GADKljB,EAAO4xB,GACPpF,EAAIwB,QAAQxE,EAAEhxB,SAA+B,KAApBgxB,EAAEhxB,OAAOpB,OACrC,MAAM,IAAI8rB,UAAU,4BACxB,CACA,GAAIsG,EAAEtc,QAAS,CACb,GAAyB,IAArBsc,EAAEtc,QAAQ9V,OAAc,MAAM,IAAI8rB,UAAU,sBAChD,IAAKuC,EAAQuL,2BAA2BxH,EAAEtc,QAAQ,IAChD,MAAM,IAAIgW,UAAU,iCACtB,IAAKsJ,EAAIwB,QAAQxE,EAAEtc,QAAQ,KAA+B,KAAxBsc,EAAEtc,QAAQ,GAAG9V,OAC7C,MAAM,IAAI8rB,UAAU,8BACtB,GAAIsG,EAAE5jB,YAAc4jB,EAAE5jB,UAAUzG,OAAOqqB,EAAEtc,QAAQ,IAC/C,MAAM,IAAIgW,UAAU,sBACtB,GAAIsG,EAAEhxB,SAAWgxB,EAAEhxB,OAAO2G,OAAOqqB,EAAEtc,QAAQ,IACzC,MAAM,IAAIgW,UAAU,mBACtB,MAAM0O,EAAM7K,EAAQuF,QAAQ9C,EAAEtc,QAAQ,IACtC,GAAIlN,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOyyB,GAClC,MAAM,IAAI1O,UAAU,gBACxB,CACF,CACA,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,qDC/HAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM4tB,EAAUxB,EAAQ,MAClB0J,EAAa1J,EAAQ,OACrBE,EAAUF,EAAQ,OAClB2J,EAAO3J,EAAQ,OACf4J,EAAQ5J,EAAQ,MAChBkJ,EAAMhJ,EAAQgJ,IACdjC,EAAMjH,EAAQ,OACdvS,EAASuS,EAAQ,OACjBgN,EAAer7B,EAAOC,MAAM,GAOlC,SAASs7B,EAA2BC,GAClC,SACEx7B,EAAOo7B,SAASI,IACC,KAAjBA,EAAMt7B,QACO,IAAbs7B,EAAM,KACNlG,EAAIwB,QAAQ0E,GAMhB,CAkLAhO,EAAQ8B,MA9KR,SAAegD,EAAG3b,GAChB,IAAK2b,EAAEhb,UAAYgb,EAAExpB,OAASwpB,EAAErd,SAAWqd,EAAEqI,SAAWrI,EAAEtc,QACxD,MAAM,IAAIgW,UAAU,mBACtBrV,EAAO1C,OAAOC,OAAO,CAAEikB,UAAU,GAAQxhB,GAAQ,CAAC,GAClDshB,EACE,CACE7I,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BqD,QAAS2gB,EAAMvC,MAAMuC,EAAMkC,QAC3BrxB,KAAMmvB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAChCnlB,OAAQgjB,EAAMvC,MAAMuC,EAAMmC,QAAQ,KAClCO,OAAQ1C,EAAMvC,MAAM,CAClB5f,MAAOmiB,EAAMvC,MAAMuC,EAAMj4B,QACzBovB,QAAS6I,EAAMvC,MAAMuC,EAAMhkB,QAC3BgB,OAAQgjB,EAAMvC,MAAMuC,EAAMj4B,QAC1BgW,QAASiiB,EAAMvC,MAAMuC,EAAMG,QAAQH,EAAMj4B,WAE3C8V,MAAOmiB,EAAMvC,MAAMuC,EAAMmC,QAAQ,IACjCpkB,QAASiiB,EAAMvC,MAAMuC,EAAMG,QAAQH,EAAMj4B,UAE3CsyB,GAEF,MAAM+H,EAAWrC,EAAK/1B,OAAM,KAC1B,MAAM2B,EAASkY,EAAO6R,OAAO2E,EAAEhb,SACzB/V,EAAUqC,EAAOopB,MAAMsO,QACvB5mB,EAAOoH,EAAOoS,UAAUtqB,EAAOopB,OACrC,MAAO,CACLzrB,UACAqb,OAAQhZ,EAAOgZ,OACflI,KAAM1U,EAAOqD,KAAKqR,GACnB,IAEG+mB,EAAWzD,EAAK/1B,OAAM,IACnBssB,EAAQwG,UAAUzC,EAAEqI,OAAO7kB,SAEpC,IAAIsZ,EAAUkD,EAAElD,QACXA,IACHA,EAAWkD,EAAEqI,QAAUrI,EAAEqI,OAAOvL,SAAY2I,EAAW1I,SAEzD,MAAMgJ,EAAI,CAAEjJ,WAsDZ,GArDA4I,EAAKM,KAAKD,EAAG,WAAW,KACtB,IAAKA,EAAEvvB,KAAM,OACb,MAAMkkB,EAAQlR,EAAOkS,QAAQqK,EAAEvvB,MAE/B,OADAkkB,EAAMkC,QAAQ,GACPpT,EAAO8R,OAAOwB,EAAQtT,OAAQkR,EAAM,IAE7CgL,EAAKM,KAAKD,EAAG,QAAQ,IACf/F,EAAErd,OAAeqd,EAAErd,OAAO9T,MAAM,GAChCmxB,EAAEhb,QAAgB+iB,IAAW3lB,KAC7B2jB,EAAEsC,QAAUtC,EAAEsC,OAAO1lB,OAAe4a,EAAQvoB,OAAO+wB,EAAEsC,OAAO1lB,aAAhE,IAEF+iB,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAKA,EAAEvvB,KACP,OAAOylB,EAAQoH,QAAQ,CAAC4B,EAAIwC,KAAM1B,EAAEvvB,MAAM,IAE5CkvB,EAAKM,KAAKD,EAAG,UAAU,KACrB,GAAK/F,EAAEtc,QACP,MAAO,CACLf,OAAQqd,EAAEtc,QAAQsc,EAAEtc,QAAQ9V,OAAS,GACrC4V,MAAOulB,EACPrlB,QAASsc,EAAEtc,QAAQ7U,MAAM,GAAI,GAC9B,IAEH62B,EAAKM,KAAKD,EAAG,SAAS,KACpB,GAAKA,EAAEriB,QACP,OAAOqlB,CAAY,IAErBrD,EAAKM,KAAKD,EAAG,WAAW,KAEtB,GACE/F,EAAEqI,QACFrI,EAAEqI,OAAO7kB,OACTwc,EAAEqI,OAAO7kB,MAAM5V,OAAS,GACxBoyB,EAAEqI,OAAO1lB,QACTqd,EAAEqI,OAAO1lB,OAAO/U,OAAS,EACzB,CACA,MAAMw7B,EAAQnN,EAAQoN,QAAQF,KAI9B,OAFApD,EAAEsC,OAAS1mB,OAAOC,OAAO,CAAE8B,QAAS0lB,GAASpJ,EAAEqI,QAC/CtC,EAAEsC,OAAO7kB,MAAQulB,EACV,GAAG93B,OAAOm4B,EAAOpJ,EAAEqI,OAAO1lB,OACnC,CACA,GAAKqd,EAAEqI,QACFrI,EAAEqI,OAAO1lB,QACTqd,EAAEqI,OAAO3kB,QACd,MAAO,GAAGzS,OAAO+uB,EAAEqI,OAAO3kB,QAASsc,EAAEqI,OAAO1lB,OAAO,IAErD+iB,EAAKM,KAAKD,EAAG,QAAQ,KACnB,MAAMyC,EAAY,CAAC,SAEnB,YADiBzxB,IAAbgvB,EAAEsC,QAAsBG,EAAUp4B,KAAK21B,EAAEsC,OAAOjb,MAC7Cob,EAAUC,KAAK,IAAI,IAGxBpkB,EAAKwhB,SAAU,CACjB,IAAIrvB,EAAO9I,EAAOqD,KAAK,IACvB,GAAIivB,EAAEhb,QAAS,CACb,GAAI+iB,IAAWzd,SAAWwS,EAAQtT,OAChC,MAAM,IAAIkQ,UAAU,sCACtB,GAA2B,IAAvBqO,IAAW94B,QACb,MAAM,IAAIyqB,UAAU,2BACtB,GAA+B,KAA3BqO,IAAW3lB,KAAKxU,OAClB,MAAM,IAAI8rB,UAAU,wBACtBljB,EAAOuxB,IAAW3lB,IACpB,CACA,GAAI4d,EAAExpB,KAAM,CACV,GAAIA,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOqqB,EAAExpB,MACpC,MAAM,IAAIkjB,UAAU,iBACjBljB,EAAOwpB,EAAExpB,IAChB,CACA,GAAIwpB,EAAErd,OAAQ,CACZ,GACsB,KAApBqd,EAAErd,OAAO/U,QACToyB,EAAErd,OAAO,KAAOsiB,EAAIwC,MACJ,KAAhBzH,EAAErd,OAAO,GAET,MAAM,IAAI+W,UAAU,qBACtB,MAAMyO,EAAQnI,EAAErd,OAAO9T,MAAM,GAC7B,GAAI2H,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOwyB,GAClC,MAAM,IAAIzO,UAAU,iBACjBljB,EAAO2xB,CACd,CACA,GAAInI,EAAEqI,OAAQ,CACZ,GAAIrI,EAAEqI,OAAOvL,SAAWkD,EAAEqI,OAAOvL,UAAYA,EAC3C,MAAM,IAAIpD,UAAU,oBAEtB,GACEsG,EAAEqI,OAAO7kB,OACTwc,EAAEqI,OAAO7kB,MAAM5V,OAAS,GACxBoyB,EAAEqI,OAAO3kB,SACTsc,EAAEqI,OAAO3kB,QAAQ9V,OAAS,EAE1B,MAAM,IAAI8rB,UAAU,4BAEtB,GAAIsG,EAAEqI,OAAO1lB,OAAQ,CACnB,GAAkD,IAA9CsZ,EAAQwG,UAAUzC,EAAEqI,OAAO1lB,QAAQ/U,OACrC,MAAM,IAAI8rB,UAAU,4BAEtB,MAAMyO,EAAQ5K,EAAQvoB,OAAOgrB,EAAEqI,OAAO1lB,QACtC,GAAInM,EAAK5I,OAAS,IAAM4I,EAAKb,OAAOwyB,GAClC,MAAM,IAAIzO,UAAU,iBACjBljB,EAAO2xB,CACd,CACA,GAAInI,EAAEqI,OAAO7kB,QAAUyY,EAAQ4M,WAAWM,KACxC,MAAM,IAAIzP,UAAU,2BACtB,GACEsG,EAAEtc,SACFsc,EAAEqI,OAAO3kB,UAtKjB,SAAqBsc,EAAG9vB,GACtB,OAAI8vB,EAAEpyB,SAAWsC,EAAEtC,QACZoyB,EAAEkG,OAAM,CAACrxB,EAAGjF,IACViF,EAAEc,OAAOzF,EAAEN,KAEtB,CAkKSu2B,CAAYnG,EAAEtc,QAASsc,EAAEqI,OAAO3kB,SAEjC,MAAM,IAAIgW,UAAU,uCACtB,GACGsG,EAAEqI,OAAO7kB,OAAS2lB,IAAWloB,KAAKgoB,IAClCjJ,EAAEqI,OAAO1lB,SACPsZ,EAAQwG,UAAUzC,EAAEqI,OAAO1lB,SAAW,IAAI1B,KACzCgoB,GAGJ,MAAM,IAAIvP,UACR,6DAGN,CACA,GAAIsG,EAAEtc,SAAWsc,EAAEtc,QAAQ9V,OAAS,EAAG,CACrC,MAAM07B,EAAUtJ,EAAEtc,QAAQsc,EAAEtc,QAAQ9V,OAAS,GAC7C,GAAIoyB,EAAEqI,QAAUrI,EAAEqI,OAAO1lB,SAAWqd,EAAEqI,OAAO1lB,OAAOhN,OAAO2zB,GACzD,MAAM,IAAI5P,UAAU,sCACtB,GACEsG,EAAEtc,QAAQzC,KAAKgoB,KACdhN,EAAQwG,UAAU6G,IAAY,IAAIroB,KAAKgoB,GAExC,MAAM,IAAIvP,UAAU,uCACxB,CACF,CACA,OAAO/X,OAAOC,OAAOmkB,EAAG/F,EAC1B,C,qDC5MAre,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM45B,EAAWxN,EAAQ,OACnBjrB,EAAUirB,EAAQ,OAClByN,EAAUzN,EAAQ,OAClB0N,EAAY1N,EAAQ,OACpBuB,EAAgBvB,EAAQ,MACxB2N,EAAW3N,EAAQ,MACnB4N,EAAW5N,EAAQ,MACnB0J,EAAa1J,EAAQ,OACrBC,EAAWD,EAAQ,OACnBE,EAAUF,EAAQ,OAClBpR,EAAgBoR,EAAQ,OAIxB6N,EAAe,CAKnB9M,QAAS2I,EAAW1I,QAMpB8M,eAAgB,KAkClB,MAAM7E,EACJl1B,WAAAA,CAAYuU,EAAO,CAAC,EAAGjC,EAAO,IAAImnB,EAASvE,KAAK,IAAI8E,IAClD35B,KAAKiS,KAAOA,EAEZjS,KAAKkU,KAAO1C,OAAOC,OAAO,CAAC,EAAGgoB,EAAcvlB,GAC5ClU,KAAK45B,QAAU,CACbC,4BAA6B,GAC7BC,6BAA8B,GAC9BC,cAAe,CAAC,EAChBC,KAAMh6B,KAAKiS,KAAK1I,UAAU0wB,WAAWliB,GAQrCmiB,yBAAyB,GAEK,IAA5Bl6B,KAAKiS,KAAKmB,OAAO3V,QAAcuC,KAAKm6B,WAAW,GAEnD,MAAMC,EAAOA,CAACC,EAAKC,EAAMxD,EAAYG,IACnCzlB,OAAOka,eAAe2O,EAAKC,EAAM,CAC/BxD,aACAG,aAEJmD,EAAKp6B,KAAM,WAAW,GAAO,GAC7Bo6B,EAAKp6B,KAAM,QAAQ,GAAO,EAC5B,CACA,iBAAOu6B,CAAWtoB,EAAMiC,EAAO,CAAC,GAC9B,MAAM5W,EAASC,EAAOqD,KAAKqR,EAAM,UACjC,OAAOjS,KAAK8tB,WAAWxwB,EAAQ4W,EACjC,CACA,cAAOma,CAAQpc,EAAMiC,EAAO,CAAC,GAC3B,MAAM5W,EAASC,EAAOqD,KAAKqR,EAAM,OACjC,OAAOjS,KAAK8tB,WAAWxwB,EAAQ4W,EACjC,CACA,iBAAO4Z,CAAWxwB,EAAQ4W,EAAO,CAAC,GAChC,MAAMsmB,EAAWpB,EAASvE,KAAK/G,WAAWxwB,EAAQm9B,GAC5Cj4B,EAAO,IAAIqyB,EAAK3gB,EAAMsmB,GAwsBhC,IAA2BziB,EAAI2iB,EAtsB3B,OAssBuB3iB,EAvsBLvV,EAAKo3B,QAAQI,KAusBJU,EAvsBUl4B,EAAKo3B,QAwsB5C7hB,EAAGkO,IAAIvoB,SAAQ2V,IACbsnB,EAAkBD,EAAOrnB,EAAM,IAxsBxB7Q,CACT,CACA,cAAIgI,GACF,OAAOxK,KAAKiS,KAAKmB,OAAO3V,MAC1B,CACA,WAAIqB,GACF,OAAOkB,KAAK45B,QAAQI,KAAKl7B,OAC3B,CACA,WAAIA,CAAQA,GACVkB,KAAKm6B,WAAWr7B,EAClB,CACA,YAAIoL,GACF,OAAOlK,KAAK45B,QAAQI,KAAK9vB,QAC3B,CACA,YAAIA,CAASA,GACXlK,KAAK46B,YAAY1wB,EACnB,CACA,YAAI2wB,GACF,OAAO76B,KAAK45B,QAAQI,KAAK/T,IAAIvd,KAAI2K,IAAS,CACxChN,KAAM8mB,EAAc+D,YAAY7d,EAAMhN,MACtCzI,MAAOyV,EAAMzV,MACboQ,SAAUqF,EAAMrF,YAEpB,CACA,aAAI8sB,GACF,OAAO96B,KAAK45B,QAAQI,KAAK7K,KAAKzmB,KAAI8J,IAChC,IAAIqC,EACJ,IACEA,EAAUykB,EAAU5M,iBAAiBla,EAAOC,OAAQzS,KAAKkU,KAAKyY,QAChE,CAAE,MAAOoO,GAAI,CACb,MAAO,CACLtoB,OAAQ0a,EAAc+D,YAAY1e,EAAOC,QACzCjT,MAAOgT,EAAOhT,MACdqV,UACD,GAEL,CACAmmB,OAAAA,IAAWC,GAET,OADAj7B,KAAKiS,KAAK+oB,WAAWC,EAAMvyB,KAAIktB,GAAKA,EAAE3jB,QAC/BjS,IACT,CACAmxB,KAAAA,GAEE,MAAMrW,EAAM+Z,EAAK/G,WAAW9tB,KAAKiS,KAAKN,YAEtC,OADAmJ,EAAI5G,KAAOgnB,KAAKC,MAAMD,KAAKE,UAAUp7B,KAAKkU,OACnC4G,CACT,CACAugB,iBAAAA,CAAkBC,GAChBC,EAAWD,GACXt7B,KAAKkU,KAAKwlB,eAAiB4B,CAC7B,CACAnB,UAAAA,CAAWr7B,GACTy8B,EAAWz8B,GACX08B,EAAyBx7B,KAAKiS,KAAKmB,OAAQ,cAC3C,MAAMwW,EAAI5pB,KAAK45B,QAGf,OAFAhQ,EAAEoQ,KAAKl7B,QAAUA,EACjB8qB,EAAE6R,oBAAiB70B,EACZ5G,IACT,CACA46B,WAAAA,CAAY1wB,GACVqxB,EAAWrxB,GACXsxB,EAAyBx7B,KAAKiS,KAAKmB,OAAQ,eAC3C,MAAMwW,EAAI5pB,KAAK45B,QAGf,OAFAhQ,EAAEoQ,KAAK9vB,SAAWA,EAClB0f,EAAE6R,oBAAiB70B,EACZ5G,IACT,CACA+N,gBAAAA,CAAiBvC,EAAYwC,GAC3ButB,EAAWvtB,GACXwtB,EAAyBx7B,KAAKiS,KAAKmB,OAAQ,oBAC3C,MAAMwW,EAAI5pB,KAAK45B,QACf,GAAIhQ,EAAEoQ,KAAK/T,IAAIxoB,QAAU+N,EACvB,MAAM,IAAIpM,MAAM,wBAIlB,OAFAwqB,EAAEoQ,KAAK/T,IAAIza,GAAYwC,SAAWA,EAClC4b,EAAE6R,oBAAiB70B,EACZ5G,IACT,CACA07B,SAAAA,CAAUC,GAER,OADAA,EAAWj+B,SAAQk+B,GAAa57B,KAAK67B,SAASD,KACvC57B,IACT,CACA67B,QAAAA,CAASD,GACP,GACElb,UAAUjjB,OAAS,IAClBm+B,QACkBh1B,IAAnBg1B,EAAUv1B,WACUO,IAApBg1B,EAAUh+B,MAEV,MAAM,IAAIwB,MACR,gGAIJo8B,EAAyBx7B,KAAKiS,KAAKmB,OAAQ,YACvCwoB,EAAU9S,eAAegT,EAAkBF,EAAU9S,eACzD,MAAMc,EAAI5pB,KAAK45B,QACf55B,KAAKiS,KAAK4pB,SAASD,GAEnBjB,EAAkB/Q,EADLA,EAAEoQ,KAAK/T,IAAI2D,EAAEoQ,KAAK/T,IAAIxoB,OAAS,IAE5C,MAAM+N,EAAaxL,KAAKiS,KAAKmB,OAAO3V,OAAS,EACvC4V,EAAQrT,KAAKiS,KAAKmB,OAAO5H,GAO/B,OANI6H,EAAM0oB,gBACRC,EAAqBh8B,KAAK45B,QAASvmB,EAAO7H,GAE5Coe,EAAEqS,WAAQr1B,EACVgjB,EAAEsS,gBAAat1B,EACfgjB,EAAE6R,oBAAiB70B,EACZ5G,IACT,CACAm8B,UAAAA,CAAWC,GAET,OADAA,EAAY1+B,SAAQ2+B,GAAcr8B,KAAKs8B,UAAUD,KAC1Cr8B,IACT,CACAs8B,SAAAA,CAAUD,GACR,GACE3b,UAAUjjB,OAAS,IAClB4+B,QACoBz1B,IAArBy1B,EAAW78B,YACaoH,IAAvBy1B,EAAWxnB,cAA+CjO,IAAtBy1B,EAAW5pB,OAEhD,MAAM,IAAIrT,MACR,8GAIJo8B,EAAyBx7B,KAAKiS,KAAKmB,OAAQ,aAC3C,MAAM,QAAEyB,GAAYwnB,EACpB,GAAuB,kBAAZxnB,EAAsB,CAC/B,MAAM,QAAE8X,GAAY3sB,KAAKkU,KACnBzB,EAAS6mB,EAAUvM,eAAelY,EAAS8X,GACjD0P,EAAa7qB,OAAOC,OAAO4qB,EAAY,CAAE5pB,UAC3C,CACA,MAAMmX,EAAI5pB,KAAK45B,QAKf,OAJA55B,KAAKiS,KAAKqqB,UAAUD,GACpBzS,EAAEqS,WAAQr1B,EACVgjB,EAAEsS,gBAAat1B,EACfgjB,EAAE6R,oBAAiB70B,EACZ5G,IACT,CACAu8B,kBAAAA,CAAmBC,GACjB,IAAKx8B,KAAKiS,KAAKmB,OAAO2iB,MAAM0G,GAAc,MAAM,IAAIr9B,MAAM,iBAC1D,MAAMwqB,EAAI5pB,KAAK45B,QAIf,GAHK4C,GAyeT,SAAmBh6B,EAAMk4B,EAAOxmB,GAC9B,MAAMwoB,EAAUhC,EAAMwB,YAAc15B,EAAKm6B,aACnCC,EAAQlC,EAAMe,eAAeoB,cAC7BC,EAAWJ,EAAUE,EAC3B,GAAIF,GAAWxoB,EAAKwlB,eAClB,MAAM,IAAIt6B,MACR,mCAAmC09B,EAAW,KAAKC,QAAQ,wBACvCL,wDACCE,6JAK3B,CArfMI,CAAUh9B,KAAM4pB,EAAG5pB,KAAKkU,MAEtB0V,EAAE6R,eAAgB,OAAO7R,EAAE6R,eAC/B,MAAM1jB,EAAK6R,EAAEoQ,KAAK7I,QAElB,OADA8L,EAAqBj9B,KAAKiS,KAAKmB,OAAQ2E,EAAI6R,GAAG,GACvC7R,CACT,CACA4kB,UAAAA,GACE,OAAOO,EACL,aACA,WACAl9B,KAAKiS,KAAKmB,OACVpT,KAAK45B,QAET,CACAuD,MAAAA,GACE,OAAOD,EAAgB,QAAS,MAAOl9B,KAAKiS,KAAKmB,OAAQpT,KAAK45B,QAChE,CACAwD,iBAAAA,GAGE,OAFA/D,EAAQgE,cAAcr9B,KAAKiS,KAAKmB,OAAQ,GACxCkqB,EAAMt9B,KAAKiS,KAAKmB,OAAO3V,QAAQC,SAAQshB,GAAOhf,KAAKu9B,cAAcve,KAC1Dhf,IACT,CACAu9B,aAAAA,CAAc/xB,EAAYgyB,EAAmBC,GAC3C,MAAMpqB,EAAQgmB,EAAQgE,cAAcr9B,KAAKiS,KAAKmB,OAAQ5H,IAChD,OAAEiH,EAAM,OAAEirB,EAAM,QAAEC,EAAO,SAAE3lB,GA0xBrC,SAA4BxM,EAAY6H,EAAOqnB,GAC7C,MAAMT,EAAaS,EAAMV,KACnBlf,EAAM,CACVrI,OAAQ,KACRuF,UAAU,EACV0lB,QAAQ,EACRC,SAAS,GAIX,GAFA7iB,EAAI4iB,SAAWrqB,EAAMlO,aACrB2V,EAAI6iB,UAAYtqB,EAAMyV,cAClBzV,EAAMyV,cACRhO,EAAIrI,OAASY,EAAMyV,mBACd,GAAIzV,EAAMlO,aACf2V,EAAIrI,OAASY,EAAMlO,kBAEnB,GAAIkO,EAAM0oB,eAAgB,CACxB,MAAM6B,EAAmBC,EACvBnD,EACArnB,EACA7H,GAEIsyB,EAAe7D,EAAWhU,IAAIza,GAAY5N,MAChDkd,EAAIrI,OAASmrB,EAAiBzO,KAAK2O,GAAcrrB,MACnD,MAAWY,EAAM0qB,cACfjjB,EAAIrI,OAASY,EAAM0qB,YAAYtrB,SAG/BY,EAAMyV,eAAiBkV,EAASljB,EAAIrI,WACtCqI,EAAI9C,UAAW,GAEjB,OAAO8C,CACT,CAzzBkDmjB,CAC5CzyB,EACA6H,EACArT,KAAK45B,SAEP,IAAKnnB,EAAQ,MAAM,IAAIrT,MAAM,8BAA8BoM,MA2f/D,SAAkC6H,GAChC,IAAKA,EAAM6qB,cAAgB7qB,EAAM8qB,WAAY,OAC7C,MAAM,WAAEA,EAAU,YAAED,GAAgB7qB,EACpC8qB,EAAWzgC,SAAQ0gC,IACjB,MAAM,SAAEC,GAAavS,EAAQ7f,UAAUif,OAAOkT,EAAKnyB,WACnD,GAAIiyB,IAAgBG,EAClB,MAAM,IAAIj/B,MAAM,sDAClB,GAEJ,CAngBIk/B,CAAyBjrB,GACzB,MAAM,eAAEkrB,EAAc,mBAAEC,GAAuBhB,EAC7ChyB,EACA6H,EACAZ,EACAuF,EACA0lB,EACAC,GAKF,GAHIY,GAAgBv+B,KAAKiS,KAAKwsB,YAAYjzB,EAAY,CAAE+yB,mBACpDC,GACFx+B,KAAKiS,KAAKwsB,YAAYjzB,EAAY,CAAEgzB,wBACjCD,IAAmBC,EACtB,MAAM,IAAIp/B,MAAM,mCAAmCoM,KAErD,OADAxL,KAAKiS,KAAKJ,oBAAoBrG,GACvBxL,IACT,CACA0+B,YAAAA,CAAalzB,GACX,MAAM6H,EAAQgmB,EAAQgE,cAAcr9B,KAAKiS,KAAKmB,OAAQ5H,GAEhDrK,EAASw9B,EADAC,EAAkBpzB,EAAY6H,EAAOrT,KAAK45B,SAGvDpuB,EACA,QACA6H,EAAMlO,cAw+BZ,SAAkC05B,GAChC,IAAKA,EAAa,OAClB,MAAMC,EAAShT,EAAQwG,UAAUuM,GACjC,IAAKC,EAAQ,OACb,MAAMC,EAAWD,EAAOA,EAAOrhC,OAAS,GACxC,IACGF,EAAOo7B,SAASoG,IACjBC,EAAaD,KAoBEx7B,EAnBLw7B,EAoBLjT,EAAQuL,2BAA2B9zB,IAlBxC,OAiBJ,IAAmBA,EAfjB,IADgBuoB,EAAQwG,UAAUyM,GACpB,OACd,OAAOA,CACT,CAt/B4BE,CAAyB5rB,EAAMkrB,gBACrDlrB,EAAMyV,eAs/BZ,SAAsC+V,GACpC,IAAKA,EAAa,OAClB,MAAMC,EAASI,EAA4BL,GACrCE,EAAWD,EAAOA,EAAOrhC,OAAS,GACxC,GAAIuhC,EAAaD,GAAW,OAE5B,IADgBjT,EAAQwG,UAAUyM,GACpB,OACd,OAAOA,CACT,CA7/BQI,CAA6B9rB,EAAMmrB,qBAIvC,OAF6B,QAAhBr9B,EAAOi+B,KAAiB,GAAKj+B,EAAOi+B,KAAO,KACvCC,EAAel+B,EAAOm+B,iBAEzC,CACAC,cAAAA,CAAe/zB,EAAY3M,GAEzB,OAw8BJ,SAAuBA,EAAQwU,EAAO7H,EAAYkvB,GAChD,MAAMjoB,EAASmsB,EAAkBpzB,EAAY6H,EAAOqnB,IAC9C,iBAAE4E,GAAqBX,EAC3BlsB,EACAjH,EACA,QACA6H,EAAMlO,aACNkO,EAAMyV,eAER,OAAO0W,EAAe3gC,EAAQygC,EAChC,CAl9BWG,CAAc5gC,EADPw6B,EAAQgE,cAAcr9B,KAAKiS,KAAKmB,OAAQ5H,GAClBA,EAAYxL,KAAK45B,QACvD,CACA8F,aAAAA,CAAcl0B,EAAYtF,GACxB,MAAMmN,EAAQgmB,EAAQgE,cAAcr9B,KAAKiS,KAAKmB,OAAQ5H,GAChDm0B,EAAmBC,EAAsB15B,GAC/C,QACImN,EAAMwsB,iBAAmBxsB,EAAMwsB,gBAAgB/uB,KAAK6uB,EAE1D,CACAG,eAAAA,CAAgBlyB,EAAa/O,GAE3B,OAw8BJ,SAAwBA,EAAQ2T,EAAQ5E,EAAa8sB,GACnD,MAAMjoB,EAASioB,EAAMV,KAAK7K,KAAKvhB,GAAa6E,QACtC,iBAAE6sB,GAAqBX,EAC3BlsB,EACA7E,EACA,SACA4E,EAAOrN,aACPqN,EAAOsW,eAET,OAAO0W,EAAe3gC,EAAQygC,EAChC,CAl9BWS,CAAelhC,EADPw6B,EAAQ2G,eAAehgC,KAAKiS,KAAKK,QAAS1E,GACnBA,EAAa5N,KAAK45B,QAC1D,CACAqG,cAAAA,CAAeryB,EAAa1H,GAC1B,MAAMsM,EAAS6mB,EAAQ2G,eAAehgC,KAAKiS,KAAKK,QAAS1E,GACnD+xB,EAAmBC,EAAsB15B,GAC/C,QACIsM,EAAOqtB,iBAAmBrtB,EAAOqtB,gBAAgB/uB,KAAK6uB,EAE5D,CACAO,6BAAAA,GACE7G,EAAQgE,cAAcr9B,KAAKiS,KAAKmB,OAAQ,GAIxC,OAHgBkqB,EAAMt9B,KAAKiS,KAAKmB,OAAO3V,QAAQiL,KAAIsW,GACjDhf,KAAKmgC,0BAA0BnhB,KAElB4Q,QAAO,CAACwQ,EAAOtlB,KAAgB,IAARA,GAAgBslB,IAAO,EAC/D,CACAD,yBAAAA,CAA0B30B,EAAY3M,GACpC,MAAMwU,EAAQrT,KAAKiS,KAAKmB,OAAO5H,GACzB2yB,GAAc9qB,GAAS,CAAC,GAAG8qB,WACjC,IAAK9qB,IAAU8qB,GAAcA,EAAW1gC,OAAS,EAC/C,MAAM,IAAI2B,MAAM,6BAClB,MAAMihC,EAASxhC,EACXs/B,EAAW/O,QAAO/gB,GAAOA,EAAIxP,OAAO2G,OAAO3G,KAC3Cs/B,EACJ,GAAIkC,EAAO5iC,OAAS,EAAG,MAAM,IAAI2B,MAAM,iCACvC,MAAMgjB,EAAU,GAChB,IAAIke,EACAC,EACAC,EACJ,IAAK,MAAMpC,KAAQiC,EAAQ,CACzB,MAAMhyB,EAAMyd,EAAQ7f,UAAUif,OAAOkT,EAAKnyB,YACpC,KAAE5F,EAAI,OAAEoM,GACZ+tB,IAAiBnyB,EAAIgwB,SACjBoC,EACEj1B,EACAgG,OAAOC,OAAO,CAAC,EAAG4B,EAAO,CAAE6qB,YAAa7vB,EAAIgwB,WAC5Cr+B,KAAK45B,SACL,GAEF,CAAEvzB,KAAMi6B,EAAW7tB,OAAQ8tB,GACjCC,EAAenyB,EAAIgwB,SACnBiC,EAAYj6B,EACZk6B,EAAc9tB,EACdiuB,EAAqBtC,EAAKv/B,OAAQ4T,EAAQ,UAC1C,MAAMkuB,EAAUnH,EAASpF,cAAcgK,EAAKv/B,QAC5CujB,EAAQniB,KAAK0gC,EAAQ/rB,OAAOvO,EAAMgI,EAAIpC,WACxC,CACA,OAAOmW,EAAQ2T,OAAMjb,IAAe,IAARA,GAC9B,CACA8lB,eAAAA,CACEC,EACAC,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,IAAKF,IAAcA,EAAU1rB,YAAc0rB,EAAUlxB,YACnD,MAAM,IAAIvQ,MAAM,+BAElB,MAAMgjB,EAAU,GAChB,IAAK,MAAM3iB,KAAK69B,EAAMt9B,KAAKiS,KAAKmB,OAAO3V,QACrC,IACEuC,KAAKghC,YAAYvhC,EAAGohC,EAAWC,GAC/B1e,EAAQniB,MAAK,EACf,CAAE,MAAOwyB,GACPrQ,EAAQniB,MAAK,EACf,CAEF,GAAImiB,EAAQ2T,OAAMxlB,IAAW,IAANA,IACrB,MAAM,IAAInR,MAAM,yBAElB,OAAOY,IACT,CACAihC,oBAAAA,CACEJ,EACAC,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,OAAO,IAAIG,SAAQ,CAACC,EAASC,KAC3B,IAAKP,IAAcA,EAAU1rB,YAAc0rB,EAAUlxB,YACnD,OAAOyxB,EAAO,IAAIhiC,MAAM,gCAE1B,MAAMgjB,EAAU,GACVif,EAAW,GACjB,IAAK,MAAM5hC,KAAK69B,EAAMt9B,KAAKiS,KAAKmB,OAAO3V,QACrC4jC,EAASphC,KACPD,KAAKshC,iBAAiB7hC,EAAGohC,EAAWC,GAAcnkB,MAChD,KACEyF,EAAQniB,MAAK,EAAK,IAEpB,KACEmiB,EAAQniB,MAAK,EAAM,KAK3B,OAAOihC,QAAQK,IAAIF,GAAU1kB,MAAK,KAChC,GAAIyF,EAAQ2T,OAAMxlB,IAAW,IAANA,IACrB,OAAO6wB,EAAO,IAAIhiC,MAAM,0BAE1B+hC,GAAS,GACT,GAEN,CACAH,WAAAA,CACEx1B,EACAq1B,EACAC,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,IAAKF,IAAcA,EAAU1rB,YAAc0rB,EAAUlxB,YACnD,MAAM,IAAIvQ,MAAM,+BAIlB,OAFgBoiC,EAAiBh2B,EAAYxL,KAAKiS,KAAKmB,OAAQytB,GACvDnjC,SAAQ+jC,GAAUzhC,KAAK0hC,UAAUl2B,EAAYi2B,EAAQX,KACtD9gC,IACT,CACAshC,gBAAAA,CACE91B,EACAq1B,EACAC,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,OAAO,IAAIG,SAAQ,CAACC,EAASC,KAC3B,IAAKP,IAAcA,EAAU1rB,YAAc0rB,EAAUlxB,YACnD,OAAOyxB,EAAO,IAAIhiC,MAAM,gCAE1B,MACMiiC,EADUG,EAAiBh2B,EAAYxL,KAAKiS,KAAKmB,OAAQytB,GACtCn4B,KAAI+4B,GAC3BzhC,KAAK2hC,eAAen2B,EAAYi2B,EAAQX,KAE1C,OAAOI,QAAQK,IAAIF,GAChB1kB,MAAK,KACJwkB,GAAS,IAEVS,MAAMR,EAAO,GAEpB,CACAS,aAAAA,CACEC,EACAhB,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,IAAKe,IAAYA,EAAQ3sB,UACvB,MAAM,IAAI/V,MAAM,6BAIlB,MAAMgjB,EAAU,GAChB,IAAK,MAAM3iB,KAAK69B,EAAMt9B,KAAKiS,KAAKmB,OAAO3V,QACrC,IACEuC,KAAK0hC,UAAUjiC,EAAGqiC,EAAShB,GAC3B1e,EAAQniB,MAAK,EACf,CAAE,MAAOwyB,GACPrQ,EAAQniB,MAAK,EACf,CAEF,GAAImiB,EAAQ2T,OAAMxlB,IAAW,IAANA,IACrB,MAAM,IAAInR,MAAM,yBAElB,OAAOY,IACT,CACA+hC,kBAAAA,CACED,EACAhB,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,OAAO,IAAIG,SAAQ,CAACC,EAASC,KAC3B,IAAKU,IAAYA,EAAQ3sB,UACvB,OAAOisB,EAAO,IAAIhiC,MAAM,8BAI1B,MAAMgjB,EAAU,GACVif,EAAW,GACjB,IAAK,MAAO5hC,KAAMO,KAAKiS,KAAKmB,OAAO4uB,UACjCX,EAASphC,KACPD,KAAK2hC,eAAeliC,EAAGqiC,EAAShB,GAAcnkB,MAC5C,KACEyF,EAAQniB,MAAK,EAAK,IAEpB,KACEmiB,EAAQniB,MAAK,EAAM,KAK3B,OAAOihC,QAAQK,IAAIF,GAAU1kB,MAAK,KAChC,GAAIyF,EAAQ2T,OAAMxlB,IAAW,IAANA,IACrB,OAAO6wB,EAAO,IAAIhiC,MAAM,0BAE1B+hC,GAAS,GACT,GAEN,CACAO,SAAAA,CACEl2B,EACAs2B,EACAhB,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,IAAKe,IAAYA,EAAQ3sB,UACvB,MAAM,IAAI/V,MAAM,6BAClB,MAAM,KAAEiH,EAAI,YAAE63B,GAAgB+D,EAC5BjiC,KAAKiS,KAAKmB,OACV5H,EACAs2B,EAAQ3sB,UACRnV,KAAK45B,QACLkH,GAEI3C,EAAa,CACjB,CACEt/B,OAAQijC,EAAQ3sB,UAChBlJ,UAAW6f,EAAQ7f,UAAUkf,OAAO2W,EAAQjO,KAAKxtB,GAAO63B,KAI5D,OADAl+B,KAAKiS,KAAKwsB,YAAYjzB,EAAY,CAAE2yB,eAC7Bn+B,IACT,CACA2hC,cAAAA,CACEn2B,EACAs2B,EACAhB,EAAe,CAACtmB,EAAcyT,YAAY8S,cAE1C,OAAOG,QAAQC,UAAUxkB,MAAK,KAC5B,IAAKmlB,IAAYA,EAAQ3sB,UACvB,MAAM,IAAI/V,MAAM,6BAClB,MAAM,KAAEiH,EAAI,YAAE63B,GAAgB+D,EAC5BjiC,KAAKiS,KAAKmB,OACV5H,EACAs2B,EAAQ3sB,UACRnV,KAAK45B,QACLkH,GAEF,OAAOI,QAAQC,QAAQW,EAAQjO,KAAKxtB,IAAOsW,MAAK1Q,IAC9C,MAAMkyB,EAAa,CACjB,CACEt/B,OAAQijC,EAAQ3sB,UAChBlJ,UAAW6f,EAAQ7f,UAAUkf,OAAOlf,EAAWiyB,KAGnDl+B,KAAKiS,KAAKwsB,YAAYjzB,EAAY,CAAE2yB,cAAa,GACjD,GAEN,CACAxsB,QAAAA,GAEE,OADAuwB,EAAWliC,KAAK45B,SACT55B,KAAKiS,KAAKN,UACnB,CACA0e,KAAAA,GAEE,OADA6R,EAAWliC,KAAK45B,SACT55B,KAAKiS,KAAKoe,OACnB,CACA8R,QAAAA,GAEE,OADAD,EAAWliC,KAAK45B,SACT55B,KAAKiS,KAAKkwB,UACnB,CACAC,YAAAA,CAAaC,GAEX,OADAriC,KAAKiS,KAAKmwB,aAAaC,GAChBriC,IACT,CACAy+B,WAAAA,CAAYjzB,EAAY62B,GAUtB,OATIA,EAAWvZ,eAAegT,EAAkBuG,EAAWvZ,eAC3D9oB,KAAKiS,KAAKwsB,YAAYjzB,EAAY62B,GAC9BA,EAAWtG,gBACbC,EACEh8B,KAAK45B,QACL55B,KAAKiS,KAAKmB,OAAO5H,GACjBA,GAGGxL,IACT,CACAsiC,YAAAA,CAAa10B,EAAay0B,GAExB,OADAriC,KAAKiS,KAAKqwB,aAAa10B,EAAay0B,GAC7BriC,IACT,CACAuiC,wBAAAA,CAAyBC,GAEvB,OADAxiC,KAAKiS,KAAKswB,yBAAyBC,GAC5BxiC,IACT,CACAyiC,uBAAAA,CAAwBj3B,EAAYg3B,GAElC,OADAxiC,KAAKiS,KAAKwwB,wBAAwBj3B,EAAYg3B,GACvCxiC,IACT,CACA0iC,wBAAAA,CAAyB90B,EAAa40B,GAEpC,OADAxiC,KAAKiS,KAAKywB,yBAAyB90B,EAAa40B,GACzCxiC,IACT,CACA6R,mBAAAA,CAAoBrG,GAElB,OADAxL,KAAKiS,KAAKJ,oBAAoBrG,GACvBxL,IACT,EAEF+qB,EAAQ8J,KAAOA,EAMf,MAAM4F,EAAwBn9B,GAAU,IAAIq8B,EAAgBr8B,GAK5D,MAAMq8B,EACJh6B,WAAAA,CAAYrC,EAASC,EAAOqD,KAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAC3DZ,KAAK+X,GAAKyC,EAAcyT,YAAYH,WAAWxwB,GAoLnD,SAAsBya,GAQpB,IAPgBA,EAAGkO,IAAI8P,OACrB1iB,GACEA,EAAMZ,QACkB,IAAxBY,EAAMZ,OAAOhV,QACb4V,EAAME,SACmB,IAAzBF,EAAME,QAAQ9V,SAGhB,MAAM,IAAI2B,MAAM,qDAEpB,CA9LIujC,CAAa3iC,KAAK+X,IAClBvG,OAAOka,eAAe1rB,KAAM,KAAM,CAChC82B,YAAY,EACZG,UAAU,GAEd,CACA2L,oBAAAA,GACE,MAAO,CACLp4B,WAAYxK,KAAK+X,GAAGkO,IAAIxoB,OACxBqN,YAAa9K,KAAK+X,GAAGoX,KAAK1xB,OAE9B,CACAo+B,QAAAA,CAASxoB,GACP,QACiBzM,IAAfyM,EAAMhN,WACUO,IAAhByM,EAAMzV,QACJL,EAAOo7B,SAAStlB,EAAMhN,OAA+B,kBAAfgN,EAAMhN,MACvB,kBAAhBgN,EAAMzV,MAEb,MAAM,IAAIwB,MAAM,uBAElB,MAAMiH,EACkB,kBAAfgN,EAAMhN,KACT8mB,EAAc4C,cAAcxyB,EAAOqD,KAAKyS,EAAMhN,KAAM,QACpDgN,EAAMhN,KACZrG,KAAK+X,GAAG8jB,SAASx1B,EAAMgN,EAAMzV,MAAOyV,EAAMrF,SAC5C,CACAsuB,SAAAA,CAAU9pB,GACR,QACoB5L,IAAlB4L,EAAOC,aACU7L,IAAjB4L,EAAOhT,QACNjC,EAAOo7B,SAASnmB,EAAOC,SACA,kBAAjBD,EAAOhT,MAEd,MAAM,IAAIJ,MAAM,wBAElBY,KAAK+X,GAAGukB,UAAU9pB,EAAOC,OAAQD,EAAOhT,MAC1C,CACAmS,QAAAA,GACE,OAAO3R,KAAK+X,GAAGpG,UACjB,EAeF,SAASuwB,EAAWxH,GAClB,IAAsC,IAAlCA,EAAMR,wBACR,MAAM,IAAI96B,MAAM,uCAEpB,CACA,SAASyjC,EAAQC,EAAY3E,EAAYv7B,GACvC,IAAKu7B,EAAY,OAAO,EACxB,IAAI4E,EAYJ,GAVEA,EADEngC,EACKA,EACJ8F,KAAIs6B,IACH,MAAMnkC,EAAS26B,EAASpF,cAAc4O,EAAM,CAAE7P,YAAY,IACvDhe,UACH,OAAOgpB,EAAW8E,MAAK7E,GAAQA,EAAKv/B,OAAO2G,OAAO3G,IAAQ,IAE3DuwB,QAAO7e,KAAOA,IAEV4tB,EAEL4E,EAAKtlC,OAASqlC,EAAY,MAAM,IAAI1jC,MAAM,uBAC9C,OAAO2jC,EAAKtlC,SAAWqlC,CACzB,CACA,SAASrG,EAAYppB,GACnB,QAASA,EAAMkrB,kBAAoBlrB,EAAMmrB,kBAC3C,CACA,SAAS0E,EAAiBC,GACxB,OAAO1wB,IACL,IAEE,OADA0wB,EAAQ,CAAE3wB,OAAQC,KACX,CACT,CAAE,MAAOggB,GACP,OAAO,CACT,EAEJ,CACA,MAAM2Q,EAASF,EAAiBrX,EAASuK,MACnCiN,EAASH,EAAiBrX,EAASyK,MACnCgN,EAAUJ,EAAiBrX,EAASvoB,OACpC06B,EAAWkF,EAAiBrX,EAASlmB,QACrC49B,EAAgBL,EAAiBrX,EAASgB,OAC1C2W,EAAeN,EAAiBrX,EAASzS,MAC/C,SAASwmB,EAAsB15B,GAC7B,OAAO0uB,KACAA,EAAE9rB,kBAAkBtD,OAAOU,EAAKyJ,gBAChCzJ,EAAKu9B,WAAW7O,EAAE72B,MAAMoX,UAAU3P,OAAOovB,EAAE/1B,OAGpD,CACA,SAAS08B,EAAWmI,GAClB,GACiB,kBAARA,GACPA,IAAQ18B,KAAKC,MAAMy8B,IACnBA,EAAM,YACNA,EAAM,EAEN,MAAM,IAAItkC,MAAM,yBAEpB,CAeA,SAASo8B,EAAyBpoB,EAAQuwB,GACxCvwB,EAAO1V,SAAQ2V,IACb,IAAIuwB,GAAS,EACTC,EAAQ,GACZ,GAAwC,KAAnCxwB,EAAM8qB,YAAc,IAAI1gC,OAAc,CACzC,IAAK4V,EAAMkrB,iBAAmBlrB,EAAMmrB,mBAAoB,OACxDqF,EAySN,SAAuCxwB,GACrC,MAAMywB,EAAezwB,EAAMkrB,gBAEvBzS,EAAQwG,UAAUjf,EAAMkrB,iBADxB,GAEEwF,EAAgB1wB,EAAMmrB,oBAExB1S,EAAQwG,UAAUjf,EAAMmrB,qBADxB,GAEJ,OAAOsF,EACJhjC,OAAOijC,GACP3U,QAAO4U,GACCzmC,EAAOo7B,SAASqL,IAASlY,EAAQuL,2BAA2B2M,KAEpEt7B,KAAI2F,IAAO,CAAGpC,UAAWoC,KAC9B,CAtTc41B,CAA8B5wB,EACxC,MACEwwB,EAAQxwB,EAAM8qB,WAsBhB,GApBA0F,EAAMnmC,SAAQ0gC,IACZ,MAAM,SAAEC,GAAavS,EAAQ7f,UAAUif,OAAOkT,EAAKnyB,WAC7Ci4B,EAAY,GAEhB7F,EAAW7jB,EAAcyT,YAAYkW,sBACnBD,EAAUjkC,KAAK,YAEnC,OAD2B,GAAXo+B,GAEd,KAAK7jB,EAAcyT,YAAY8S,YAC7B,MACF,KAAKvmB,EAAcyT,YAAYmW,eAC/B,KAAK5pB,EAAcyT,YAAYoW,aAC7BH,EAAUjkC,KAAK,aACfikC,EAAUjkC,KAAK,qBAGgB,IAA/BikC,EAAUI,QAAQX,KACpBC,GAAS,EACX,IAEEA,EACF,MAAM,IAAIxkC,MAAM,gDAClB,GAEJ,CAWA,SAASshC,EAAqB7hC,EAAQ4T,EAAQkxB,GAC5C,IAAKnE,EAAe3gC,EAAQ4T,GAC1B,MAAM,IAAIrT,MACR,WAAWukC,iCAAsC9kC,EAAOT,SAAS,SAGvE,CAkBA,SAASu8B,EAAkBD,EAAOrnB,GAChC,MAAMhL,EACJ8kB,EAAc4C,cAAcxyB,EAAOqD,KAAKyS,EAAMhN,OAAOjI,SAAS,OAC9D,IACAiV,EAAMzV,MACR,GAAI88B,EAAMX,cAAc1xB,GAAM,MAAM,IAAIjJ,MAAM,6BAC9Cs7B,EAAMX,cAAc1xB,GAAO,CAC7B,CACA,SAASk8B,EAAqBpB,EAASqB,GACrC,MAAO,CAACh5B,EAAY/H,EAAc0B,EAAcs/B,KAC9C,MAAMC,EAAqBvB,EAAQ,CACjCjL,OAAQ,CAAE1lB,OAAQrN,KACjBqN,OACH,IAAK/O,EAAa+B,OAAOk/B,GACvB,MAAM,IAAItlC,MACR,GAAGolC,SAAyBC,MAAWj5B,kDAE3C,CAEJ,CACA,MAAMm5B,EAAoBJ,EAAqB1Y,EAASzS,KAAM,iBACxDwrB,EAAqBL,EACzB1Y,EAASgB,MACT,kBAEF,SAASqQ,EAAgB70B,EAAK4U,EAAM7J,EAAQwW,GAC1C,IAAKxW,EAAO2iB,MAAM0G,GAChB,MAAM,IAAIr9B,MAAM,uCAAuC6d,KACzD,GAAY,eAAR5U,GAAwBuhB,EAAEsS,WAAY,OAAOtS,EAAEsS,WACnD,GAAY,UAAR7zB,GAAmBuhB,EAAEqS,MAAO,OAAOrS,EAAEqS,MACzC,IAAIlkB,EACA8sB,GAAe,EAQnB,OAPIjb,EAAE6R,gBACJ1jB,EAAK6R,EAAE6R,eACPoJ,GAAe,GAEf9sB,EAAK6R,EAAEoQ,KAAK7I,QAEd8L,EAAqB7pB,EAAQ2E,EAAI6R,EAAGib,GACxB,eAARx8B,EAA6BuhB,EAAEsS,WAClB,UAAR7zB,EAAwBuhB,EAAEqS,WAA9B,CACP,CACA,SAASwB,EAAgBjyB,EAAY6H,EAAOZ,EAAQuF,EAAU0lB,EAAQC,GACpE,MAAMmH,EAAazF,EAAe5sB,GAClC,IAtMF,SAAqBY,EAAOZ,EAAQqyB,GAClC,OAAQA,GACN,IAAK,SACL,IAAK,aACL,IAAK,oBACH,OAAOjC,EAAQ,EAAGxvB,EAAM8qB,YAC1B,IAAK,WACH,MAAM/H,EAAOvK,EAASuK,KAAK,CAAE5jB,OAAQC,IACrC,OAAOowB,EAAQzM,EAAKxtB,EAAGyK,EAAM8qB,WAAY/H,EAAKxzB,SAChD,QACE,OAAO,EAEb,CA0LOmiC,CAAY1xB,EAAOZ,EAAQqyB,GAC9B,MAAM,IAAI1lC,MAAM,2BAA2BoM,KAC7C,OASF,SACEiH,EACAqyB,EACA3G,EACAnmB,EACA0lB,EACAC,GAEA,IAAIY,EACAC,EAEJ,MAAM2E,EAuIR,SAAoB1wB,EAAQqyB,EAAY3G,GACtC,IAAIgF,EACJ,OAAQ2B,GACN,IAAK,WACH,MAAM/B,EAuGZ,SAAuBtwB,EAAQ0rB,GAC7B,MAAM/H,EAAOvK,EAASuK,KAAK,CAAE5jB,OAAQC,IAErC,OAAO2jB,EAAKxzB,QACT8F,KAAIs8B,IAGD7G,EAAW/O,QAAO6V,GACTA,EAAGpmC,OAAO2G,OAAOw/B,KACvB,IAAM,CAAC,GACV/4B,YAIHmjB,QAAO7e,KAAOA,GACnB,CAtHmB20B,CAAczyB,EAAQ0rB,GACnCgF,EAAUtX,EAASuK,KAAK,CACtB5jB,OAAQC,EACRiM,WAAYqkB,IAEd,MACF,IAAK,SACHI,EAAUtX,EAASyK,KAAK,CACtB9jB,OAAQC,EACRxG,UAAWkyB,EAAW,GAAGlyB,YAE3B,MACF,IAAK,aACHk3B,EAAUtX,EAASvoB,MAAM,CACvBkP,OAAQC,EACR5T,OAAQs/B,EAAW,GAAGt/B,OACtBoN,UAAWkyB,EAAW,GAAGlyB,YAE3B,MACF,IAAK,oBACHk3B,EAAUtX,EAASlmB,OAAO,CACxB6M,OAAQC,EACR5T,OAAQs/B,EAAW,GAAGt/B,OACtBoN,UAAWkyB,EAAW,GAAGlyB,YAI/B,OAAOk3B,CACT,CAvKkBgC,CAAW1yB,EAAQqyB,EAAY3G,GACzCtR,EAAS8Q,EAAiB9R,EAASgB,MAAM,CAAEqL,OAAQiL,IAAhC,KACnB/pB,EAAQskB,EAAgB7R,EAASzS,KAAK,CAAE8e,OAAQrL,GAASsW,IAAxC,KACnBnrB,GAEAwmB,EAAqB4G,EADnBvY,EAC+CA,EAAMtZ,QAEN4vB,EAAQ5vB,SAEvD6F,IACFmlB,EAAiBnlB,EAAK/F,QAItBkrB,EADEnlB,EACeA,EAAK/F,MAEL8vB,EAAQ9vB,MAG7B,MAAO,CACLkrB,iBACAC,qBAEJ,CA3CS6G,CACL5yB,EACAqyB,EACAzxB,EAAM8qB,WACNnmB,EACA0lB,EACAC,EAEJ,CAoCA,SAASsE,EACP7uB,EACA5H,EACA3M,EACA67B,EACAoG,GAEA,MAAMztB,EAAQgmB,EAAQgE,cAAcjqB,EAAQ5H,IACtC,KAAEnF,EAAI,YAAE63B,EAAW,OAAEzrB,GAAWguB,EACpCj1B,EACA6H,EACAqnB,GACA,EACAoG,GAGF,OADAJ,EAAqB7hC,EAAQ4T,EAAQ,QAC9B,CACLpM,OACA63B,cAEJ,CACA,SAASuC,EAAcj1B,EAAY6H,EAAOqnB,EAAO4K,EAAaxE,GAC5D,MAAM7G,EAAaS,EAAMV,KACnBkE,EACJ7qB,EAAM6qB,aAAe1jB,EAAcyT,YAAY8S,YACjD,GAAID,GAAgBA,EAAawD,QAAQpG,GAAe,EAAG,CACzD,MAAMvW,EAsOV,SAA6BuW,GAC3B,IAAIqH,EACFrH,EAAc1jB,EAAcyT,YAAYkW,qBACpC,0BACA,GAEN,OAD6B,GAAdjG,GAEb,KAAK1jB,EAAcyT,YAAY8S,YAC7BwE,GAAQ,cACR,MACF,KAAK/qB,EAAcyT,YAAYmW,eAC7BmB,GAAQ,iBACR,MACF,KAAK/qB,EAAcyT,YAAYoW,aAC7BkB,GAAQ,eAGZ,OAAOA,CACT,CAxPgBC,CAAoBtH,GAChC,MAAM,IAAI9+B,MAEN,yHAA0DuoB,IAEhE,CACA,IAAIthB,EACAiN,EACJ,GAAID,EAAM0oB,eAAgB,CACxB,MAAM6B,EAAmBC,EACvBnD,EACArnB,EACA7H,GAEIi6B,EAAcxL,EAAWhU,IAAIza,GAAYnF,KACzCq/B,EAAW9H,EAAiB9O,UAElC,IAAK2W,EAAYjgC,OAAOkgC,GACtB,MAAM,IAAItmC,MACR,oCAAoCoM,qDAGxC,MAAMsyB,EAAe7D,EAAWhU,IAAIza,GAAY5N,MAChD0V,EAAUsqB,EAAiBzO,KAAK2O,EAClC,KAAO,KAAIzqB,EAAM0qB,YAGf,MAAM,IAAI3+B,MAAM,sCAFhBkU,EAAUD,EAAM0qB,WAGlB,CACA,MAAM,iBAAEuB,EAAgB,KAAEF,GAAST,EACjCrrB,EAAQb,OACRjH,EACA,QACA6H,EAAMlO,aACNkO,EAAMyV,eAER,GAAI,CAAC,aAAc,SAASwb,QAAQlF,IAAS,EAC3C/4B,EAAO4zB,EAAW0L,iBAChBn6B,EACA8zB,EACAhsB,EAAQ9T,MACR0+B,QAEG,GAAIF,EAASsB,GAAmB,CAErC,MAAMsG,EAAgB/Z,EAASvoB,MAAM,CAAE+C,KAAMi5B,EAAiB5gC,MAAM,KACjE8T,OACHnM,EAAO4zB,EAAW0L,iBAChBn6B,EACAo6B,EACAtyB,EAAQ9T,MACR0+B,EAEJ,KAAO,CAEL,QAC2Bt3B,IAAzByM,EAAM0oB,iBAC4B,IAAlCrB,EAAMR,wBAEN,MAAM,IAAI96B,MACR,UAAUoM,4CACL8zB,EAAiBlhC,SAAS,UAE9BknC,IAAiD,IAAlC5K,EAAMR,yBACxB5R,QAAQC,KACN,icAQJliB,EAAO4zB,EAAW4L,iBAChBr6B,EACA8zB,EACApB,EAEJ,CACA,MAAO,CACLzrB,OAAQ6sB,EACRpB,cACA73B,OAEJ,CAgFA,SAASm7B,EAAiBh2B,EAAY4H,EAAQytB,GAC5C,MAAMxtB,EAAQgmB,EAAQgE,cAAcjqB,EAAQ5H,GAC5C,IAAK6H,EAAMwsB,iBAAoD,IAAjCxsB,EAAMwsB,gBAAgBpiC,OAClD,MAAM,IAAI2B,MAAM,wCAElB,MAAM0mC,EAAgBzyB,EAAMwsB,gBACzBn3B,KAAIq9B,GACCA,EAAMj9B,kBAAkBtD,OAAOq7B,EAAUlxB,aACpCo2B,OAEP,IAGH3W,QAAO7e,KAAOA,IACjB,GAA6B,IAAzBu1B,EAAcroC,OAChB,MAAM,IAAI2B,MACR,gFAUJ,OAPgB0mC,EAAcp9B,KAAIq9B,IAChC,MAAMt+B,EAAOo5B,EAAU4C,WAAWsC,EAAMhoC,MACxC,IAAKgoC,EAAMlnC,OAAO2G,OAAOiC,EAAK0N,WAC5B,MAAM,IAAI/V,MAAM,wCAElB,OAAOqI,CAAI,GAGf,CAiBA,SAASy3B,EAA4B5hC,GACnC,IAAI0D,EAAS,EAKb,SAASU,IACP,MAAMC,EAAKhB,EAAQuqB,OAAO5tB,EAAQ0D,GAElC,OADAA,GAAUL,EAAQuqB,OAAO1qB,MAClBmB,CACT,CACA,SAASC,IACP,OAViB3C,EAUAyC,IATjBV,GAAU/B,EACH3B,EAAOoB,MAAMsC,EAAS/B,EAAG+B,GAFlC,IAAmB/B,CAWnB,CAOA,OANA,WACE,MAAM6C,EAAQJ,IACRK,EAAS,GACf,IAAK,IAAItC,EAAI,EAAGA,EAAIqC,EAAOrC,IAAKsC,EAAO9B,KAAK2B,KAC5C,OAAOG,CACT,CACOF,EACT,CAoBA,SAASujC,EAA4B7xB,GACnC,IAAIjW,EAASC,EAAOujB,YAAY,GAIhC,SAASpgB,EAAYjB,GACnB,MAAMumC,EAAa1oC,EAAOG,OACpBwoC,EAAYtlC,EAAQgvB,eAAelwB,GACzCnC,EAASC,EAAOuD,OAAO,CAACxD,EAAQC,EAAOujB,YAAYmlB,KACnDtlC,EAAQwqB,OAAO1rB,EAAGnC,EAAQ0oC,EAC5B,CACA,SAASnlC,EAAcnC,GACrBgC,EAAYhC,EAAMjB,QAVpB,SAAoBiB,GAClBpB,EAASC,EAAOuD,OAAO,CAACxD,EAAQC,EAAOqD,KAAKlC,IAC9C,CASE+B,CAAW/B,EACb,CACA,IAAqBqD,EAKrB,OAJErB,GADmBqB,EAITwR,GAHS9V,QACnBsE,EAAOrE,QAAQmD,GAGVvD,CACT,CACA,SAAS0+B,EAAqBtB,EAAOrnB,EAAO7H,GAC1CkvB,EAAMZ,6BAA6BtuB,GAAc6H,EAAM0oB,eACvD,MAAMhkB,EAAKyC,EAAcyT,YAAYH,WAAWza,EAAM0oB,gBACtDrB,EAAMb,4BAA4BruB,GAAcuM,EAChD,MAAMmuB,EAAOxL,EACPyL,EAAY36B,SACX6H,EAAM0oB,eACbvqB,OAAOka,eAAerY,EAAO,iBAAkB,CAC7CyjB,YAAY,EACZ9lB,GAAAA,GACE,MAAMzN,EAAM2iC,EAAKpM,6BAA6BqM,GACxCC,EAAUF,EAAKrM,4BAA4BsM,GACjD,QAAYv/B,IAARrD,EACF,OAAOA,EACF,CACL,MAAM8iC,EAASD,EAAQz0B,WAEvB,OADAu0B,EAAKpM,6BAA6BqM,GAAaE,EACxCA,CACT,CACF,EACA71B,GAAAA,CAAIyB,GACFi0B,EAAKpM,6BAA6BqM,GAAal0B,CACjD,GAEJ,CACA,SAASgrB,EAAqB7pB,EAAQ2E,EAAI2iB,EAAOmK,GAC/C,IAAIyB,EAAc,EAClBlzB,EAAO1V,SAAQ,CAAC2V,EAAO2L,KAQrB,GAPI6lB,GAAgBxxB,EAAMkrB,iBACxBxmB,EAAGkO,IAAIjH,GAAKvM,OAASY,EAAMkrB,gBACzBsG,GAAgBxxB,EAAMmrB,qBACxBzmB,EAAGkO,IAAIjH,GAAKzL,QAAU2rB,EACpB7rB,EAAMmrB,qBAGNnrB,EAAM0qB,YACRuI,GAAejzB,EAAM0qB,YAAYv+B,WAC5B,GAAI6T,EAAM0oB,eAAgB,CAC/B,MAAMwK,EAAO1I,EAA0BnD,EAAOrnB,EAAO2L,GAC/CwnB,EAAOzuB,EAAGkO,IAAIjH,GAAKphB,MACnByxB,EAAMkX,EAAKpX,KAAKqX,GACtBF,GAAejX,EAAI7vB,KACrB,KAEF,MAAMinC,EAAe1uB,EAAGoX,KAAKS,QAAO,CAACtZ,EAAOsf,IAAMtf,EAAQsf,EAAEp2B,OAAO,GAC7DknC,EAAMJ,EAAcG,EAC1B,GAAIC,EAAM,EACR,MAAM,IAAItnC,MAAM,yCAElB,MAAMoB,EAAQuX,EAAG8kB,cACjBnC,EAAMuB,MAAQyK,EACdhM,EAAMe,eAAiB1jB,EACvB2iB,EAAMwB,WAAal1B,KAAKC,MAAMy/B,EAAMlmC,EACtC,CACA,SAASq9B,EAA0BnD,EAAOrnB,EAAO7H,GAC/C,MAAMoe,EAAI8Q,EAAMb,4BAIhB,OAHKjQ,EAAEpe,IACLwwB,EAAqBtB,EAAOrnB,EAAO7H,GAE9Boe,EAAEpe,EACX,CACA,SAASozB,EAAkBpzB,EAAY6H,EAAOqnB,GAC5C,QAA0B9zB,IAAtByM,EAAM0qB,YACR,OAAO1qB,EAAM0qB,YAAYtrB,OACpB,QAA6B7L,IAAzByM,EAAM0oB,eAA8B,CAM7C,OALyB8B,EACvBnD,EACArnB,EACA7H,GAEsB2jB,KAAKuL,EAAMV,KAAK/T,IAAIza,GAAY5N,OAAO6U,MACjE,CACE,MAAM,IAAIrT,MAAM,+CAEpB,CA+CA,SAAS4/B,EAAaz7B,GACpB,OAAsB,KAAfA,EAAI9F,QAAiBquB,EAAQ6a,kBAAkBpjC,EACxD,CAIA,SAASo7B,EACPlsB,EACA7U,EACA6mC,EACAt/B,EACA2jB,GAEA,MAAM4U,EAAS8F,EAAa/wB,GACtBm0B,EAAclJ,GAAUv4B,GAAgBo+B,EAAcp+B,GACtDw4B,EAAU4F,EAAc9wB,GAC9B,GAAIirB,QAA2B92B,IAAjBzB,EACZ,MAAM,IAAI/F,MAAM,iDAClB,IAAKu+B,GAAWiJ,SAAkChgC,IAAlBkiB,EAC9B,MAAM,IAAI1pB,MACR,mEAEJ,IAAIkgC,EAgBJ,OAfIsH,GACFtH,EAAmBxW,EACnB6b,EAAkB/mC,EAAO6U,EAAQtN,EAAcs/B,GAC/CG,EAAmBhnC,EAAOuH,EAAc2jB,EAAe2b,GACvD3I,EAAkBwD,IACT3B,GACT2B,EAAmBxW,EACnB8b,EAAmBhnC,EAAO6U,EAAQqW,EAAe2b,GACjD3I,EAAkBwD,IACT5B,GACT4B,EAAmBn6B,EACnBw/B,EAAkB/mC,EAAO6U,EAAQtN,EAAcs/B,IAE/CnF,EAAmB7sB,EAEd,CACL6sB,mBACAF,KAAMwH,EACF,aACAlJ,EACA,OACAC,EACA,QACA,MAER,CACA,SAAS7B,EAAkBrpB,GACzB,GAAIurB,EAASvrB,IAAW+wB,EAAa/wB,GACnC,MAAM,IAAIrT,MAAM,mDAEpB,CACA,SAASogC,EAAe3gC,EAAQ4T,GAC9B,MAAMjP,EAAa+1B,EAAS5G,QAAQ9zB,GAC9BgoC,EAAa/a,EAAQwG,UAAU7f,GACrC,GAAmB,OAAfo0B,EAAqB,MAAM,IAAIznC,MAAM,wBACzC,OAAOynC,EAAW/1B,MAAKnT,GACE,kBAAZA,IACJA,EAAQ6H,OAAO3G,IAAWlB,EAAQ6H,OAAOhC,KAEpD,CACA,SAAS67B,EAAe5sB,GACtB,OAAIurB,EAASvrB,GAAgB,oBACzB6wB,EAAQ7wB,GAAgB,aACxB2wB,EAAO3wB,GAAgB,WACvB4wB,EAAO5wB,GAAgB,SACpB,aACT,CACA,SAAS6qB,EAAMr+B,GACb,MAAO,IAAIosB,MAAMpsB,GAAGqJ,OACtB,C,qDCp3CAkJ,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMsnC,EAAelb,EAAQ,OACvBmb,EAAkBnb,EAAQ,OAC1BG,EAAQH,EAAQ,OAChBob,EAAQpb,EAAQ,OAChBiH,EAAMjH,EAAQ,OACdqb,EAAWrb,EAAQ,OACnBI,EAAYJ,EAAQ,MAC1Bb,EAAQ+J,IAAM,EAAd/J,OACA,MAAMmc,EAActb,EAAQ,OACtBsL,EAAcnM,EAAQ+J,IAAIqC,YAShC,SAASgQ,EAAgB3nC,GACvB,OAAOusB,EAAMxuB,OAAOiC,IATtB,SAAiBA,GACf,OACEusB,EAAM7sB,OAAOM,KACZA,IAAUurB,EAAQ+J,IAAIwC,MACpB93B,GAASurB,EAAQ+J,IAAIsS,MAAQ5nC,GAASurB,EAAQ+J,IAAIuS,OACnD7nC,IAAUurB,EAAQ+J,IAAIwS,WAE5B,CAEgCC,CAAQ/nC,EACxC,CACA,SAASk5B,EAAWl5B,GAClB,OAAOusB,EAAMV,MAAM7rB,IAAUA,EAAMu2B,MAAMoR,EAC3C,CAEA,SAASK,EAAYlqC,GACnB,OAAsB,IAAlBA,EAAOG,OAAqBstB,EAAQ+J,IAAIwC,KACtB,IAAlBh6B,EAAOG,OACPH,EAAO,IAAM,GAAKA,EAAO,IAAM,GAAW45B,EAAc55B,EAAO,GACjD,MAAdA,EAAO,GAAoBytB,EAAQ+J,IAAIwS,gBAA3C,OAFA,CAGF,CACA,SAASG,EAAelkC,GACtB,OAAOhG,EAAOo7B,SAASp1B,EACzB,CAIA,SAASmkC,EAAoBnkC,GAC3B,OAAOhG,EAAOo7B,SAASp1B,EACzB,CACA,SAAS2vB,EAAQ3L,GAEf,GAAIkgB,EAAelgB,GAAS,OAAOA,EACnCyE,EAAUD,EAAMV,MAAO9D,GACvB,MAAMogB,EAAapgB,EAAOqI,QAAO,CAACgY,EAAO7O,IAEnC2O,EAAoB3O,GAED,IAAjBA,EAAMt7B,aAAuCmJ,IAAvB4gC,EAAYzO,GAC7B6O,EAAQ,EAEVA,EAAQX,EAAStX,eAAeoJ,EAAMt7B,QAAUs7B,EAAMt7B,OAGxDmqC,EAAQ,GACd,GACGtqC,EAASC,EAAOujB,YAAY6mB,GAClC,IAAI3mC,EAAS,EAoBb,GAnBAumB,EAAO7pB,SAAQq7B,IAEb,GAAI2O,EAAoB3O,GAAQ,CAE9B,MAAM8O,EAASL,EAAYzO,GAC3B,QAAenyB,IAAXihC,EAGF,OAFAvqC,EAAO4C,WAAW2nC,EAAQ7mC,QAC1BA,GAAU,GAGZA,GAAUimC,EAAS9b,OAAO7tB,EAAQy7B,EAAMt7B,OAAQuD,GAChD+3B,EAAM7oB,KAAK5S,EAAQ0D,GACnBA,GAAU+3B,EAAMt7B,MAElB,MACEH,EAAO4C,WAAW64B,EAAO/3B,GACzBA,GAAU,CACZ,IAEEA,IAAW1D,EAAOG,OAAQ,MAAM,IAAI2B,MAAM,2BAC9C,OAAO9B,CACT,CAEA,SAASg1B,EAAUh1B,GAEjB,GAjDqBiG,EAiDHjG,EAhDXyuB,EAAMV,MAAM9nB,GAgDQ,OAAOjG,EAjDpC,IAAuBiG,EAkDrByoB,EAAUD,EAAMxuB,OAAQD,GACxB,MAAMiqB,EAAS,GACf,IAAI9nB,EAAI,EACR,KAAOA,EAAInC,EAAOG,QAAQ,CACxB,MAAMoqC,EAASvqC,EAAOmC,GAEtB,GAAIooC,EAAS9c,EAAQ+J,IAAIwC,MAAQuQ,GAAU9c,EAAQ+J,IAAIgT,aAAc,CACnE,MAAMlT,EAAIqS,EAAS/b,OAAO5tB,EAAQmC,GAElC,GAAU,OAANm1B,EAAY,OAAO,KAGvB,GAFAn1B,GAAKm1B,EAAEtuB,KAEH7G,EAAIm1B,EAAEmT,OAASzqC,EAAOG,OAAQ,OAAO,KACzC,MAAMwU,EAAO3U,EAAOoB,MAAMe,EAAGA,EAAIm1B,EAAEmT,QACnCtoC,GAAKm1B,EAAEmT,OAEP,MAAMC,EAAKR,EAAYv1B,QACZrL,IAAPohC,EACFzgB,EAAOtnB,KAAK+nC,GAEZzgB,EAAOtnB,KAAKgS,EAGhB,MACEsV,EAAOtnB,KAAK4nC,GACZpoC,GAAK,CAET,CACA,OAAO8nB,CACT,CA+CA,SAAS0gB,EAAkB5J,GACzB,MAAM6J,GAAyB,IAAX7J,EAEpB,OAAO6J,EAAc,GAAQA,EAAc,CAC7C,CA5IAnd,EAAQ2N,WAAaA,EAwDrB3N,EAAQmI,QAAUA,EAkClBnI,EAAQuH,UAAYA,EAkBpBvH,EAAQ+B,MAjBR,SAAevF,GAIb,OAHIkgB,EAAelgB,KACjBA,EAAS+K,EAAU/K,IAEdA,EACJ7e,KAAIqwB,IAEH,GAAI2O,EAAoB3O,GAAQ,CAC9B,MAAMiP,EAAKR,EAAYzO,GACvB,QAAWnyB,IAAPohC,EAAkB,OAAOjP,EAAM36B,SAAS,OAC5C26B,EAAQiP,CACV,CAEA,OAAOd,EAAYnO,EAAM,IAE1BT,KAAK,IACV,EAcAvN,EAAQod,QAZR,SAAiBC,GAEf,OADApc,EAAUD,EAAM2L,OAAQ0Q,GACjBlV,EACLkV,EAAIhe,MAAM,KAAK1hB,KAAI2/B,QAEazhC,IAA1BmkB,EAAQ+J,IAAIuT,GAAgCtd,EAAQ+J,IAAIuT,IAC5Drc,EAAUD,EAAMuc,IAAKD,GAEd9qC,EAAOqD,KAAKynC,EAAU,UAGnC,EAWAtd,EAAQmO,QATR,SAAiB3R,GAGf,OAFAA,EAAS+K,EAAU/K,GACnByE,EAAU0M,EAAYnR,GACfA,EAAO7e,KAAIs/B,GACZN,EAAoBM,GAAYA,EAChCA,IAAOjd,EAAQ+J,IAAIwC,KAAa/5B,EAAOujB,YAAY,GAChDgmB,EAAa3b,OAAO6c,EAAK9Q,IAEpC,EAKAnM,EAAQ4b,kBAHR,SAA2BrpC,GACzB,OAAOu1B,EAAIwB,QAAQ/2B,EACrB,EAOAytB,EAAQkd,kBAAoBA,EAM5Bld,EAAQsM,2BALR,SAAoC/5B,GAClC,QAAKC,EAAOo7B,SAASr7B,OAChB2qC,EAAkB3qC,EAAOA,EAAOG,OAAS,KACvCupC,EAAM3U,MAAM/0B,EAAOoB,MAAM,GAAI,IACtC,EAGAqsB,EAAQgd,OAASjB,EACjB/b,EAAQ9e,UAAY86B,C,qDC/KpBv1B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IA6BtDurB,EAAQG,OA5BR,SAAgB5tB,EAAQirC,EAAWC,GACjCD,EAAYA,GAAa,EACzBC,OAAsB5hC,IAAZ4hC,GAA+BA,EACzC,MAAM/qC,EAASH,EAAOG,OACtB,GAAe,IAAXA,EAAc,OAAO,EACzB,GAAIA,EAAS8qC,EAAW,MAAM,IAAIhf,UAAU,0BAC5C,GAAIif,GACkC,KAAV,IAArBlrC,EAAOG,EAAS,MACfA,GAAU,GAAqC,KAAV,IAArBH,EAAOG,EAAS,KAClC,MAAM,IAAI2B,MAAM,uCAItB,GAAe,IAAX3B,EAAc,CAChB,MAAMoyB,EAAIvyB,EAAOiE,aAAa,GACxBxB,EAAIzC,EAAO4D,UAAU,GAC3B,OAAQ,IAAJnB,IAAiC,aAAT,IAAJA,GAA2B8vB,GACxC,WAAJ9vB,EAAkB8vB,CAC3B,CAEA,IAAI1uB,EAAS,EACb,IAAK,IAAI1B,EAAI,EAAGA,EAAIhC,IAAUgC,EAC5B0B,GAAU7D,EAAOmC,IAAO,EAAIA,EAE9B,OAAyB,IAArBnC,EAAOG,EAAS,KACT0D,IAAW,KAAS,GAAK1D,EAAS,KACtC0D,CACT,EA+BA4pB,EAAQI,OAhBR,SAAgBsd,GACd,IAAIjpC,EAAQwH,KAAK0hC,IAAID,GACrB,MAAMniC,GAfe7G,EAeMD,GAdhB,WACP,EACAC,EAAI,QACJ,EACAA,EAAI,MACJ,EACAA,EAAI,IACJ,EACAA,EAAI,EACJ,EACA,EAXN,IAAuBA,EAgBrB,MAAMnC,EAASC,EAAOujB,YAAYxa,GAC5BqiC,EAAWF,EAAU,EAC3B,IAAK,IAAIhpC,EAAI,EAAGA,EAAI6G,IAAQ7G,EAC1BnC,EAAO4C,WAAmB,IAARV,EAAcC,GAChCD,IAAU,EAOZ,OALuB,IAAnBlC,EAAOgJ,EAAO,GAChBhJ,EAAO4C,WAAWyoC,EAAW,IAAO,EAAMriC,EAAO,GACxCqiC,IACTrrC,EAAOgJ,EAAO,IAAM,KAEfhJ,CACT,C,qDC1DAkU,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMusB,EAAQH,EAAQ,OAChBob,EAAQpb,EAAQ,OAChBI,EAAYJ,EAAQ,MACpBgd,EAAOrrC,EAAOC,MAAM,EAAG,GAC7B,SAASqrC,EAAMnkC,GACb,IAAIjF,EAAI,EACR,KAAgB,IAATiF,EAAEjF,MAAYA,EACrB,OAAIA,IAAMiF,EAAEjH,OAAemrC,EAEhB,KADXlkC,EAAIA,EAAEhG,MAAMe,IACN,GAAkBlC,EAAOuD,OAAO,CAAC8nC,EAAMlkC,GAAI,EAAIA,EAAEjH,QAChDiH,CACT,CACA,SAASokC,EAAQpkC,GACF,IAATA,EAAE,KAAaA,EAAIA,EAAEhG,MAAM,IAC/B,MAAMpB,EAASC,EAAOC,MAAM,GAAI,GAC1BurC,EAAS/hC,KAAK6pB,IAAI,EAAG,GAAKnsB,EAAEjH,QAElC,OADAiH,EAAEwL,KAAK5S,EAAQyrC,GACRzrC,CACT,CAaAytB,EAAQG,OAXR,SAAgB5tB,GACd,MAAM+gC,EAAW/gC,EAAO4D,UAAU5D,EAAOG,OAAS,GAC5CyqC,GAAyB,IAAX7J,EACpB,GAAI6J,GAAe,GAAKA,GAAe,EACrC,MAAM,IAAI9oC,MAAM,oBAAsBi/B,GACxC,MAAM7J,EAAUwS,EAAM9b,OAAO5tB,EAAOoB,MAAM,GAAI,IACxC4Z,EAAIwwB,EAAQtU,EAAQlc,GACpBC,EAAIuwB,EAAQtU,EAAQjc,GAE1B,MAAO,CAAEtM,UADS1O,EAAOuD,OAAO,CAACwX,EAAGC,GAAI,IACpB8lB,WACtB,EAmBAtT,EAAQI,OAjBR,SAAgBlf,EAAWoyB,GACzBrS,EACE,CACE/f,UAAW8f,EAAM4L,QAAQ,IACzB0G,SAAUtS,EAAMQ,OAElB,CAAEtgB,YAAWoyB,aAEf,MAAM6J,GAAyB,IAAX7J,EACpB,GAAI6J,GAAe,GAAKA,GAAe,EACrC,MAAM,IAAI9oC,MAAM,oBAAsBi/B,GACxC,MAAM2K,EAAiBzrC,EAAOujB,YAAY,GAC1CkoB,EAAe9oC,WAAWm+B,EAAU,GACpC,MAAM/lB,EAAIuwB,EAAM58B,EAAUvN,MAAM,EAAG,KAC7B6Z,EAAIswB,EAAM58B,EAAUvN,MAAM,GAAI,KACpC,OAAOnB,EAAOuD,OAAO,CAACkmC,EAAM7b,OAAO7S,EAAGC,GAAIywB,GAC5C,C,+BCjDAx3B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM6T,EAAQuY,EAAQ,OACtBb,EAAQ1X,MAAQA,EAChB,MAAMb,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,+BCHjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACzB,SAASqd,EAAiBzpC,GACxB,OACEA,IAAU8xB,EAASwD,IAAIwC,MAAQxL,EAAQuL,2BAA2B73B,EAEtE,CACA,SAAS6yB,EAAM5f,EAAQ8f,GACrB,MAAMhL,EAASuE,EAAQwG,UAAU7f,GACjC,QAAI8U,EAAO9pB,OAAS,KAChB8pB,EAAO,KAAO+J,EAASwD,IAAIwC,OAC3B/E,EACKhL,EAAO7oB,MAAM,GAAGq3B,MAAMkT,GAExB1hB,EAAO7oB,MAAM,GAAGq3B,MAAMjK,EAAQuL,6BACvC,CACAtM,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,gB,+BCnBT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACnBG,EAAQH,EAAQ,OAChBsL,EAAc5F,EAASwD,IAAIqC,YACjC,SAAS9E,EAAM5f,EAAQ8f,GACrB,MAAMhL,EAASuE,EAAQwG,UAAU7f,GACjC,GAAI8U,EAAO9pB,OAAS,EAAG,OAAO,EAC9B,GAAI8pB,EAAOA,EAAO9pB,OAAS,KAAO6zB,EAASwD,IAAIyC,iBAAkB,OAAO,EACxE,IAAKxL,EAAM7sB,OAAOqoB,EAAO,IAAK,OAAO,EACrC,IAAKwE,EAAM7sB,OAAOqoB,EAAOA,EAAO9pB,OAAS,IAAK,OAAO,EACrD,MAAMmL,EAAI2e,EAAO,GAAK2P,EAChBj4B,EAAIsoB,EAAOA,EAAO9pB,OAAS,GAAKy5B,EACtC,GAAItuB,GAAK,EAAG,OAAO,EACnB,GAAI3J,EAAI,GAAI,OAAO,EACnB,GAAI2J,EAAI3J,EAAG,OAAO,EAClB,GAAIA,IAAMsoB,EAAO9pB,OAAS,EAAG,OAAO,EACpC,GAAI80B,EAAiB,OAAO,EAE5B,OADahL,EAAO7oB,MAAM,GAAI,GAClBq3B,MAAMjK,EAAQ6a,kBAC5B,CACA5b,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,kB,8BCxBT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IAEtD,MAAMssB,EAAUF,EAAQ,OAClBkJ,EAAMhJ,EAAQgJ,IACpB,SAASzC,EAAM5f,GACb,MAAMnV,EAASwuB,EAAQoH,QAAQzgB,GAC/B,OAAOnV,EAAOG,OAAS,GAAKH,EAAO,KAAOw3B,EAAIgB,SAChD,CACA/K,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,mBAET,MAAM12B,EAAS,CAAE6f,SACjBtH,EAAQvY,OAASA,C,+BCbjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM6T,EAAQuY,EAAQ,OACtBb,EAAQ1X,MAAQA,EAChB,MAAMb,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,+BCHjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OACxB,SAASyG,EAAM5f,GACb,MAAM8U,EAASuE,EAAQwG,UAAU7f,GACjC,OAAyB,IAAlB8U,EAAO9pB,QAAgBquB,EAAQuL,2BAA2B9P,EAAO,GAC1E,CACAwD,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,c,+BCRT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACzB,SAASyG,EAAM5f,GACb,MAAM8U,EAASuE,EAAQwG,UAAU7f,GACjC,OACoB,IAAlB8U,EAAO9pB,QACPquB,EAAQ6a,kBAAkBpf,EAAO,KACjCA,EAAO,KAAO+J,EAASwD,IAAI2C,WAE/B,CACA1M,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,e,+BCdT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM6T,EAAQuY,EAAQ,OACtBb,EAAQ1X,MAAQA,EAChB,MAAMb,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,+BCHjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OACxB,SAASyG,EAAM5f,GACb,MAAM8U,EAASuE,EAAQwG,UAAU7f,GACjC,OACoB,IAAlB8U,EAAO9pB,QACPquB,EAAQuL,2BAA2B9P,EAAO,KAC1CuE,EAAQ6a,kBAAkBpf,EAAO,GAErC,CACAwD,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,kB,+BCZT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACzB,SAASyG,EAAM5f,GACb,MAAMnV,EAASwuB,EAAQoH,QAAQzgB,GAC/B,OACoB,KAAlBnV,EAAOG,QACPH,EAAO,KAAOg0B,EAASwD,IAAI+C,QAC3Bv6B,EAAO,KAAOg0B,EAASwD,IAAIgD,YACb,KAAdx6B,EAAO,IACPA,EAAO,MAAQg0B,EAASwD,IAAIiD,gBAC5Bz6B,EAAO,MAAQg0B,EAASwD,IAAI2C,WAEhC,CACA1M,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,mB,+BCjBT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM6T,EAAQuY,EAAQ,OACtBb,EAAQ1X,MAAQA,EAChB,MAAMb,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,qDCHjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClBwK,EAAOxK,EAAQ,OACf0K,EAAO1K,EAAQ,OACftoB,EAAQsoB,EAAQ,OAChBud,EAAUvd,EAAQ,OAClBwd,EAASxd,EAAQ,OACvB,SAASyG,EAAM5f,EAAQ8f,GACrB,MAAMhL,EAASuE,EAAQwG,UAAU7f,GACjC,GAAI8U,EAAO9pB,OAAS,EAAG,OAAO,EAC9B,MAAM4rC,EAAY9hB,EAAOA,EAAO9pB,OAAS,GACzC,IAAKF,EAAOo7B,SAAS0Q,GAAY,OAAO,EACxC,MAAMC,EAAkBxd,EAAQwG,UAC9BxG,EAAQoH,QAAQ3L,EAAO7oB,MAAM,GAAI,KAE7B6qC,EAAqBzd,EAAQwG,UAAU+W,GAE7C,QAAKE,MAEAzd,EAAQ4M,WAAW4Q,KAEF,IAAlB/hB,EAAO9pB,OAEP2rC,EAAO/W,MAAMkX,IAAuBJ,EAAQ9W,MAAMkX,MAKpDjmC,EAAM+P,MAAMgf,MAAMiX,KAClBhmC,EAAMkP,OAAO6f,MAAMkX,SAInBnT,EAAK/iB,MAAMgf,MAAMiX,EAAiB/W,KAClC6D,EAAK5jB,OAAO6f,MAAMkX,QAIlBjT,EAAKjjB,MAAMgf,MAAMiX,KACjBhT,EAAK9jB,OAAO6f,MAAMkX,MAItB,CACAxe,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,kB,+BC9CT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACzB,SAASyG,EAAM5f,GACb,MAAMnV,EAASwuB,EAAQoH,QAAQzgB,GAC/B,OACoB,KAAlBnV,EAAOG,QACPH,EAAO,KAAOg0B,EAASwD,IAAIgD,YACb,KAAdx6B,EAAO,IACPA,EAAO,MAAQg0B,EAASwD,IAAIsD,QAEhC,CACArN,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,mB,+BCfT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMgT,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,qDCDjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACnBG,EAAQH,EAAQ,OAChBI,EAAYJ,EAAQ,MACpB4d,EAASjsC,EAAOqD,KAAK,WAAY,OACvC,SAASyxB,EAAM5f,GACb,MAAMnV,EAASwuB,EAAQoH,QAAQzgB,GAC/B,OACEnV,EAAOG,OAAS,IAChBH,EAAO,KAAOg0B,EAASwD,IAAIgB,WACb,KAAdx4B,EAAO,IACPA,EAAOoB,MAAM,EAAG,GAAG8G,OAAOgkC,EAE9B,CACAze,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,4BASTne,EAAQI,OAPR,SAAgBhK,GACd6K,EAAUD,EAAM0d,WAAYtoB,GAC5B,MAAM7jB,EAASC,EAAOujB,YAAY,IAGlC,OAFA0oB,EAAOt5B,KAAK5S,EAAQ,GACpB6jB,EAAWjR,KAAK5S,EAAQ,GACjBwuB,EAAQoH,QAAQ,CAAC5B,EAASwD,IAAIgB,UAAWx4B,GAClD,EAMAytB,EAAQG,OAJR,SAAgB5tB,GAEd,OADA0uB,EAAUqG,EAAO/0B,GACVwuB,EAAQwG,UAAUh1B,GAAQ,GAAGoB,MAAM,EAAG,GAC/C,C,8BC/BA8S,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM6T,EAAQuY,EAAQ,MACtBb,EAAQ1X,MAAQA,EAChB,MAAMb,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,8BCHjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAIxB,SAASyG,EAAM5f,GACb,MAAM8U,EAASuE,EAAQwG,UAAU7f,GACjC,OACoB,IAAlB8U,EAAO9pB,QACPquB,EAAQuL,2BAA2B9P,EAAO,MAPTpH,EAQLoH,EAAO,GAP9BuE,EAAQ6a,kBAAkBxmB,IAA6B,KAAlBA,EAAO1iB,QADrD,IAAqC0iB,CAUrC,CACA4K,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,yB,+BCfT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACzB,SAASyG,EAAM5f,GACb,MAAMnV,EAASwuB,EAAQoH,QAAQzgB,GAC/B,OACoB,KAAlBnV,EAAOG,QACPH,EAAO,KAAOg0B,EAASwD,IAAIwC,MACb,KAAdh6B,EAAO,EAEX,CACAytB,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,2B,8BCdT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM6T,EAAQuY,EAAQ,OACtBb,EAAQ1X,MAAQA,EAChB,MAAMb,EAASoZ,EAAQ,OACvBb,EAAQvY,OAASA,C,qDCHjBhB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClBI,EAAYJ,EAAQ,MACpBwK,EAAOxK,EAAQ,OACf0K,EAAO1K,EAAQ,OACftoB,EAAQsoB,EAAQ,OACtB,SAASyG,EAAM9K,EAAQgL,GAErB,GADAvG,EAAUA,EAAUX,MAAO9D,GACvBA,EAAO9pB,OAAS,EAAG,OAAO,EAC9B,MAAMqrB,EAAgBvB,EAAOA,EAAO9pB,OAAS,GAC7C,IAAKF,EAAOo7B,SAAS7P,GAAgB,OAAO,EAC5C,MAAM4gB,EAAsB5d,EAAQwG,UAAUxJ,GAE9C,IAAK4gB,GAAsD,IAA/BA,EAAoBjsC,OAAc,OAAO,EACrE,MAAMksC,EAAsB7d,EAAQoH,QAAQ3L,EAAO7oB,MAAM,GAAI,IAE7D,SACE4E,EAAM+P,MAAMgf,MAAMsX,KAClBrmC,EAAMkP,OAAO6f,MAAMqX,SAInBtT,EAAK/iB,MAAMgf,MAAMsX,EAAqBpX,KACtC6D,EAAK5jB,OAAO6f,MAAMqX,QAIlBpT,EAAKjjB,MAAMgf,MAAMsX,KACjBrT,EAAK9jB,OAAO6f,MAAMqX,IAItB,CACA3e,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,yB,+BCnCT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMssB,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACzB,SAASyG,EAAM5f,GACb,MAAMnV,EAASwuB,EAAQoH,QAAQzgB,GAC/B,OACoB,KAAlBnV,EAAOG,QACPH,EAAO,KAAOg0B,EAASwD,IAAIwC,MACb,KAAdh6B,EAAO,EAEX,CACAytB,EAAQsH,MAAQA,EAChBA,EAAM6W,OAAS,IACN,2B,qDCdT13B,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM2tB,EAAgBvB,EAAQ,MACxBwB,EAAUxB,EAAQ,MAClBE,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACnBG,EAAQH,EAAQ,OAChBI,EAAYJ,EAAQ,MACpBjrB,EAAUirB,EAAQ,OACxB,SAASge,EAAaC,GACpB,MAAMpsC,EAASosC,EAAWpsC,OAC1B,OAAOkD,EAAQgvB,eAAelyB,GAAUA,CAC1C,CAUA,MAAMqsC,EAAevsC,EAAOujB,YAAY,GAClCipB,EAAgB,GAChBnB,EAAOrrC,EAAOqD,KAClB,mEACA,OAEIopC,EAAMzsC,EAAOqD,KACjB,mEACA,OAEIqpC,EAAmB1sC,EAAOqD,KAAK,mBAAoB,OACnDspC,EAAe,CACnBz3B,OAAQq3B,EACRK,YAAaF,GAKf,MAAMhc,EACJtuB,WAAAA,GACEK,KAAKlB,QAAU,EACfkB,KAAKkK,SAAW,EAChBlK,KAAKimB,IAAM,GACXjmB,KAAKmvB,KAAO,EACd,CACA,iBAAOrB,CAAWxwB,EAAQ8sC,GACxB,MAAMrc,EAAe,IAAIZ,EAAcpsB,aAAazD,GAC9Cya,EAAK,IAAIkW,EACflW,EAAGjZ,QAAUivB,EAAa3sB,YAC1B,MAAMipC,EAAStc,EAAa7sB,YACtBopC,EAAOvc,EAAa7sB,YAC1B,IAAIqpC,GAAe,EAEjBF,IAAWpc,EAAYuc,6BACvBF,IAASrc,EAAYwc,0BAErBF,GAAe,EAEfxc,EAAa/sB,QAAU,EAEzB,MAAM0pC,EAAS3c,EAAarsB,aAC5B,IAAK,IAAIjC,EAAI,EAAGA,EAAIirC,IAAUjrC,EAC5BsY,EAAGkO,IAAIhmB,KAAK,CACVoG,KAAM0nB,EAAatsB,UAAU,IAC7B7D,MAAOmwB,EAAazsB,aACpBmR,OAAQsb,EAAansB,eACrBoM,SAAU+f,EAAazsB,aACvBiS,QAASw2B,IAGb,MAAMY,EAAU5c,EAAarsB,aAC7B,IAAK,IAAIjC,EAAI,EAAGA,EAAIkrC,IAAWlrC,EAC7BsY,EAAGoX,KAAKlvB,KAAK,CACXT,MAAOuuB,EAAavsB,aACpBiR,OAAQsb,EAAansB,iBAGzB,GAAI2oC,EAAc,CAChB,IAAK,IAAI9qC,EAAI,EAAGA,EAAIirC,IAAUjrC,EAC5BsY,EAAGkO,IAAIxmB,GAAG8T,QAAUwa,EAAalsB,aAGnC,IAAKkW,EAAGwyB,eACN,MAAM,IAAInrC,MAAM,2CACpB,CAEA,GADA2Y,EAAG7N,SAAW6jB,EAAazsB,aACvB8oC,EAAY,OAAOryB,EACvB,GAAIgW,EAAa/sB,SAAW1D,EAAOG,OACjC,MAAM,IAAI2B,MAAM,mCAClB,OAAO2Y,CACT,CACA,cAAOsW,CAAQC,GACb,OAAOL,EAAYH,WAAWvwB,EAAOqD,KAAK0tB,EAAK,QAAQ,EACzD,CACA,qBAAOsc,CAAettC,GACpB0uB,EAAUD,EAAM0d,WAAYnsC,GAC5B,IAAK,IAAImC,EAAI,EAAGA,EAAI,KAAMA,EACxB,GAAkB,IAAdnC,EAAOmC,GAAU,OAAO,EAE9B,OAAO,CACT,CACAorC,UAAAA,GACE,OACsB,IAApB7qC,KAAKimB,IAAIxoB,QAAgBwwB,EAAY2c,eAAe5qC,KAAKimB,IAAI,GAAG5f,KAEpE,CACAw1B,QAAAA,CAASx1B,EAAMzI,EAAOoQ,EAAUjB,GAc9B,OAbAif,EACED,EAAMM,MACJN,EAAM0d,WACN1d,EAAMqF,OACNrF,EAAMkH,MAAMlH,EAAMqF,QAClBrF,EAAMkH,MAAMlH,EAAMxuB,SAEpBmjB,WAEEqL,EAAM+e,KAAK98B,KACbA,EAAWigB,EAAYhsB,kBAIvBjC,KAAKimB,IAAIhmB,KAAK,CACZoG,OACAzI,QACA6U,OAAQ1F,GAAa+8B,EACrB97B,SAAUA,EACVuF,QAASw2B,IACN,CAET,CACAzN,SAAAA,CAAU74B,EAAcjE,GAGtB,OAFAwsB,EAAUD,EAAMM,MAAMN,EAAMxuB,OAAQwuB,EAAMgf,SAAUrqB,WAGlD1gB,KAAKmvB,KAAKlvB,KAAK,CACbwS,OAAQhP,EACRjE,UACG,CAET,CACA+qC,YAAAA,GACE,OAAOvqC,KAAKimB,IAAInV,MAAKpM,GACS,IAArBA,EAAE6O,QAAQ9V,QAErB,CACA+xB,MAAAA,GAGE,OAAc,EAFDxvB,KAAKkuB,YAAW,GACfluB,KAAKkuB,YAAW,EAEhC,CACA2O,WAAAA,GACE,OAAO71B,KAAKsgB,KAAKtnB,KAAKwvB,SAAW,EACnC,CACAtB,UAAAA,CAAW8c,GAAiB,GAC1B,MAAMT,EAAeS,GAAkBhrC,KAAKuqC,eAC5C,OACGA,EAAe,GAAK,GACrB5pC,EAAQgvB,eAAe3vB,KAAKimB,IAAIxoB,QAChCkD,EAAQgvB,eAAe3vB,KAAKmvB,KAAK1xB,QACjCuC,KAAKimB,IAAI2J,QAAO,CAACqb,EAAK53B,IACb43B,EAAM,GAAKrB,EAAav2B,EAAMZ,SACpC,GACHzS,KAAKmvB,KAAKS,QAAO,CAACqb,EAAKz4B,IACdy4B,EAAM,EAAIrB,EAAap3B,EAAOC,SACpC,IACF83B,EACGvqC,KAAKimB,IAAI2J,QAAO,CAACqb,EAAK53B,IACb43B,EA5JnB,SAAoBC,GAClB,MAAMztC,EAASytC,EAAWztC,OAC1B,OACEkD,EAAQgvB,eAAelyB,GACvBytC,EAAWtb,QAAO,CAACqb,EAAK13B,IACf03B,EAAMrB,EAAar2B,IACzB,EAEP,CAoJyB43B,CAAW93B,EAAME,UAC7B,GACH,EAER,CACA4d,KAAAA,GACE,MAAMia,EAAQ,IAAInd,EAkBlB,OAjBAmd,EAAMtsC,QAAUkB,KAAKlB,QACrBssC,EAAMlhC,SAAWlK,KAAKkK,SACtBkhC,EAAMnlB,IAAMjmB,KAAKimB,IAAIvd,KAAI2iC,IAChB,CACLhlC,KAAMglC,EAAKhlC,KACXzI,MAAOytC,EAAKztC,MACZ6U,OAAQ44B,EAAK54B,OACbzE,SAAUq9B,EAAKr9B,SACfuF,QAAS83B,EAAK93B,YAGlB63B,EAAMjc,KAAOnvB,KAAKmvB,KAAKzmB,KAAI4iC,IAClB,CACL74B,OAAQ64B,EAAM74B,OACdjT,MAAO8rC,EAAM9rC,UAGV4rC,CACT,CASAvF,gBAAAA,CAAiB0F,EAASC,EAAenN,GAMvC,GALArS,EACED,EAAMM,MAAMN,EAAMqF,OAAQrF,EAAMxuB,OAA0BwuB,EAAM7sB,QAChEwhB,WAGE6qB,GAAWvrC,KAAKimB,IAAIxoB,OAAQ,OAAOusC,EAEvC,MAAMyB,EAAY3f,EAAQoH,QACxBpH,EAAQwG,UAAUkZ,GAAepc,QAAO1qB,GAC/BA,IAAM4sB,EAASwD,IAAI4W,oBAGxBC,EAAQ3rC,KAAKmxB,QAEnB,IAAgB,GAAXkN,KAAqBpQ,EAAYoW,aACpCsH,EAAMxc,KAAO,GAEbwc,EAAM1lB,IAAIvoB,SAAQ,CAAC2V,EAAO5T,KACpBA,IAAM8rC,IACVl4B,EAAMrF,SAAW,EAAC,SAGf,IAAgB,GAAXqwB,KAAqBpQ,EAAYmW,eAAgB,CAE3D,GAAImH,GAAWvrC,KAAKmvB,KAAK1xB,OAAQ,OAAOusC,EAExC2B,EAAMxc,KAAK1xB,OAAS8tC,EAAU,EAE9B,IAAK,IAAI9rC,EAAI,EAAGA,EAAI8rC,EAAS9rC,IAC3BksC,EAAMxc,KAAK1vB,GAAKyqC,EAGlByB,EAAM1lB,IAAIvoB,SAAQ,CAAC2V,EAAOu4B,KACpBA,IAAML,IACVl4B,EAAMrF,SAAW,EAAC,GAEtB,CAEIqwB,EAAWpQ,EAAYkW,sBACzBwH,EAAM1lB,IAAM,CAAC0lB,EAAM1lB,IAAIslB,IACvBI,EAAM1lB,IAAI,GAAGxT,OAASg5B,IAItBE,EAAM1lB,IAAIvoB,SAAQ2V,IAChBA,EAAMZ,OAASq3B,CAAY,IAE7B6B,EAAM1lB,IAAIslB,GAAS94B,OAASg5B,GAG9B,MAAMnuC,EAASC,EAAOujB,YAAY6qB,EAAMzd,YAAW,GAAS,GAG5D,OAFA5wB,EAAO8C,aAAai+B,EAAU/gC,EAAOG,OAAS,GAC9CkuC,EAAME,WAAWvuC,EAAQ,GAAG,GACrB8vB,EAAQxU,QAAQtb,EACzB,CACAqoC,gBAAAA,CAAiB4F,EAASC,EAAehsC,EAAO6+B,GAC9CrS,EACED,EAAMM,MAAMN,EAAMqF,OAAQrF,EAAMxuB,OAAQwuB,EAAMgf,QAAShf,EAAMqF,QAC7D1Q,WAEF,IACIyP,EADA2b,EAAUvuC,EAAOqD,KAAK,IAEtBmrC,EAAcnD,EACdoD,EAAepD,EACfqD,EAAerD,EAsBnB,GArBMvK,EAAWpQ,EAAYkW,uBAC3B2H,EAAUvuC,EAAOujB,YAAY,GAAK9gB,KAAKimB,IAAIxoB,QAC3C0yB,EAAe,IAAIhD,EAAcztB,aAAaosC,EAAS,GACvD9rC,KAAKimB,IAAIvoB,SAAQ2tC,IACflb,EAAa1vB,WAAW4qC,EAAKhlC,MAC7B8pB,EAAa9vB,YAAYgrC,EAAKztC,MAAM,IAEtCouC,EAAe5e,EAAQxU,QAAQkzB,IAG7BzN,EAAWpQ,EAAYkW,uBACb,GAAX9F,KAAqBpQ,EAAYmW,iBACtB,GAAX/F,KAAqBpQ,EAAYoW,eAElCyH,EAAUvuC,EAAOujB,YAAY,EAAI9gB,KAAKimB,IAAIxoB,QAC1C0yB,EAAe,IAAIhD,EAAcztB,aAAaosC,EAAS,GACvD9rC,KAAKimB,IAAIvoB,SAAQ2tC,IACflb,EAAa9vB,YAAYgrC,EAAKr9B,SAAS,IAEzCi+B,EAAe7e,EAAQxU,QAAQkzB,KAGnB,GAAXzN,KAAqBpQ,EAAYmW,iBACtB,GAAX/F,KAAqBpQ,EAAYoW,aAClC,CACA,MAAM6H,EAAalsC,KAAKmvB,KAAKS,QAAO,CAACqb,EAAKz4B,IACjCy4B,EAAM,EAAIrB,EAAap3B,EAAOC,SACpC,GACHq5B,EAAUvuC,EAAOujB,YAAYorB,GAC7B/b,EAAe,IAAIhD,EAAcztB,aAAaosC,EAAS,GACvD9rC,KAAKmvB,KAAKzxB,SAAQ2xB,IAChBc,EAAa5vB,YAAY8uB,EAAI7vB,OAC7B2wB,EAAatvB,cAAcwuB,EAAI5c,OAAO,IAExCs5B,EAAc3e,EAAQxU,QAAQkzB,EAChC,MAAO,IACO,GAAXzN,KAAqBpQ,EAAYmW,gBAClCmH,EAAUvrC,KAAKmvB,KAAK1xB,OACpB,CACA,MAAM+U,EAASxS,KAAKmvB,KAAKoc,GACzBO,EAAUvuC,EAAOujB,YAAY,EAAI8oB,EAAap3B,EAAOC,SACrD0d,EAAe,IAAIhD,EAAcztB,aAAaosC,EAAS,GACvD3b,EAAa5vB,YAAYiS,EAAOhT,OAChC2wB,EAAatvB,cAAc2R,EAAOC,QAClCs5B,EAAc3e,EAAQxU,QAAQkzB,EAChC,CACAA,EAAUvuC,EAAOujB,YAAY,IAAM8oB,EAAa4B,IAChDrb,EAAe,IAAIhD,EAAcztB,aAAaosC,EAAS,GACvD,MAAMz4B,EAAQrT,KAAKimB,IAAIslB,GAYvB,OAXApb,EAAa9vB,YAAYL,KAAKlB,SAC9BqxB,EAAa1vB,WAAWurC,GACxB7b,EAAa1vB,WAAWwrC,GACxB9b,EAAa1vB,WAAW4S,EAAMhN,MAC9B8pB,EAAa9vB,YAAYgT,EAAMzV,OAC/BuyB,EAAatvB,cAAc2qC,GAC3Brb,EAAa5vB,YAAYf,GACzB2wB,EAAa9vB,YAAYgT,EAAMrF,UAC/BmiB,EAAa1vB,WAAWsrC,GACxB5b,EAAa9vB,YAAYL,KAAKkK,UAC9BimB,EAAa9vB,YAAYg+B,GAClBjR,EAAQxU,QAAQkzB,EACzB,CACAhd,OAAAA,CAAQD,GAEN,OAAIA,GAAc7uB,KAAK6qC,aAAqBttC,EAAOC,MAAM,GAAI,GACtD4vB,EAAQxU,QAAQ5Y,KAAK6rC,gBAAWjlC,OAAWA,EAAWioB,GAC/D,CACAiB,KAAAA,GAEE,OAAO3C,EAAc4C,cAAc/vB,KAAK8uB,SAAQ,IAAQ1wB,SAAS,MACnE,CACAuT,QAAAA,CAASrU,EAAQ6uC,GACf,OAAOnsC,KAAK6rC,WAAWvuC,EAAQ6uC,GAAe,EAChD,CACA9b,KAAAA,GACE,OAAOrwB,KAAK2R,cAAS/K,OAAWA,GAAWxI,SAAS,MACtD,CACAguC,cAAAA,CAAexuC,EAAOmP,GACpBif,EAAUD,EAAMM,MAAMN,EAAM7sB,OAAQ6sB,EAAMxuB,QAASmjB,WACnD1gB,KAAKimB,IAAIroB,GAAO6U,OAAS1F,CAC3B,CACAs/B,UAAAA,CAAWzuC,EAAO2V,GAChByY,EAAUD,EAAMM,MAAMN,EAAM7sB,OAAQ,CAAC6sB,EAAMxuB,SAAUmjB,WACrD1gB,KAAKimB,IAAIroB,GAAO2V,QAAUA,CAC5B,CACAs4B,UAAAA,CAAWvuC,EAAQ6uC,EAAenB,GAAiB,GAC5C1tC,IAAQA,EAASC,EAAOujB,YAAY9gB,KAAKkuB,WAAW8c,KACzD,MAAM7a,EAAe,IAAIhD,EAAcztB,aACrCpC,EACA6uC,GAAiB,GAEnBhc,EAAahwB,WAAWH,KAAKlB,SAC7B,MAAMyrC,EAAeS,GAAkBhrC,KAAKuqC,eA4B5C,OA3BIA,IACFpa,EAAajwB,WAAW+tB,EAAYuc,6BACpCra,EAAajwB,WAAW+tB,EAAYwc,4BAEtCta,EAAazvB,YAAYV,KAAKimB,IAAIxoB,QAClCuC,KAAKimB,IAAIvoB,SAAQ2tC,IACflb,EAAa1vB,WAAW4qC,EAAKhlC,MAC7B8pB,EAAa9vB,YAAYgrC,EAAKztC,OAC9BuyB,EAAatvB,cAAcwqC,EAAK54B,QAChC0d,EAAa9vB,YAAYgrC,EAAKr9B,SAAS,IAEzCmiB,EAAazvB,YAAYV,KAAKmvB,KAAK1xB,QACnCuC,KAAKmvB,KAAKzxB,SAAQ4tC,SAhVC1kC,IAiVJ0kC,EAjVN9rC,MAkVL2wB,EAAa5vB,YAAY+qC,EAAM9rC,OAE/B2wB,EAAa1vB,WAAW6qC,EAAMnB,aAEhCha,EAAatvB,cAAcyqC,EAAM74B,OAAO,IAEtC83B,GACFvqC,KAAKimB,IAAIvoB,SAAQ2V,IACf8c,EAAakB,YAAYhe,EAAME,QAAQ,IAG3C4c,EAAa9vB,YAAYL,KAAKkK,eAERtD,IAAlBulC,EACK7uC,EAAOoB,MAAMytC,EAAehc,EAAanvB,QAC3C1D,CACT,EAEF2wB,EAAYhsB,iBAAmB,WAC/BgsB,EAAY8S,YAAc,EAC1B9S,EAAYoW,aAAe,EAC3BpW,EAAYmW,eAAiB,EAC7BnW,EAAYkW,qBAAuB,IACnClW,EAAYuc,4BAA8B,EAC1Cvc,EAAYwc,0BAA4B,EACxC1f,EAAQkD,YAAcA,C,qDChZtBzc,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAM8sC,EAAW1gB,EAAQ,OACnBuB,EAAgBvB,EAAQ,MACxB2gB,EAAW3gB,EAAQ,OACnBwB,EAAUxB,EAAQ,MAClB0H,EAAS1H,EAAQ,MACjBD,EAAWC,EAAQ,OACnBC,EAAWD,EAAQ,OACnBE,EAAUF,EAAQ,OAClB0F,EAAW1F,EAAQ,OACnBpR,EAAgBoR,EAAQ,OACxBG,EAAQH,EAAQ,OAChBI,EAAYJ,EAAQ,MACpB4gB,EAAeD,EAASxgB,MACxB0gB,EAAgB,IAAIzzB,IAAI,CAE5B,QACA,OACA,SACA,OAEA,aACA,YACA,cACA,YAEA,cACA,aACA,aAEA,mBACA,kBACA,oBAEF,SAAS0zB,EAAUtN,EAAM5/B,EAAO6Y,GAC9B,IACE2T,EAAUoT,EAAM5/B,EAClB,CAAE,MAAOizB,GACP,MAAM,IAAIrzB,MAAMiZ,EAClB,CACF,CAOA,MAAM0c,EAGJp1B,WAAAA,CAAYgtB,EAAUhB,EAASiB,QAAS8M,EAAiB,MACvD15B,KAAK2sB,QAAUA,EACf3sB,KAAK05B,eAAiBA,EACtB15B,KAAK2sC,cAAgB,CAAC,EACtB3sC,KAAK4sC,SAAW,GAChB5sC,KAAKg6B,KAAO,IAAIxf,EAAcyT,YAC9BjuB,KAAKg6B,KAAKl7B,QAAU,EACpBkB,KAAK6sC,aAAc,EACnBvkB,QAAQC,KACN,+SAMJ,CACA,sBAAOukB,CAAgBrhC,EAAakhB,GAClC,MAAMogB,EAAM,IAAIhY,EAAmBpI,GAoBnC,OAlBAogB,EAAI5S,WAAW1uB,EAAY3M,SAC3BiuC,EAAIC,YAAYvhC,EAAYvB,UAE5BuB,EAAY0jB,KAAKzxB,SAAQ4tC,IACvByB,EAAIzQ,UAAUgP,EAAM74B,OAAQ64B,EAAM9rC,MAAM,IAG1CiM,EAAYwa,IAAIvoB,SAAQ2tC,IACtB0B,EAAIE,iBAAiB5B,EAAKhlC,KAAMglC,EAAKztC,MAAO,CAC1CoQ,SAAUq9B,EAAKr9B,SACfyE,OAAQ44B,EAAK54B,OACbc,QAAS83B,EAAK93B,SACd,IAGJw5B,EAAIH,SAASlvC,SAAQ,CAAC2V,EAAO5T,MAmVjC,SAA0B4T,EAAO5H,EAAayhC,GAC5C,GAAI75B,EAAM85B,mBAAqBX,EAAa5a,OAASve,EAAMlO,aACzD,OACF,GAAIkO,EAAMzQ,QAAQnF,SAAW4V,EAAMqL,WAAWjhB,OAAQ,OACtD,MAAM2vC,EAAY/5B,EAAMqL,WAAW5d,SACnCuS,EAAMqL,WAAarL,EAAMzQ,QAAQ8F,KAAIyX,IACnC,MAAM2hB,EAAUxO,EAAOc,cAAcjU,GACrC,IAAIktB,EAmBJ,OAjBAD,EAAUt8B,MAAK,CAAC7E,EAAWxM,KAEzB,IAAKwM,EAAW,OAAO,EAEvB,MAAMqhC,EAASxhB,EAAQ7f,UAAUif,OAAOjf,GAClC5F,EAAOoF,EAAYo6B,iBACvBqH,EACA75B,EAAMlO,aACNmoC,EAAOjP,UAGT,QAAKyD,EAAQltB,OAAOvO,EAAMinC,EAAOrhC,aAEjCmhC,EAAU3tC,QAAKmH,EACfymC,EAAQphC,GACD,EAAI,IAENohC,CAAK,GAEhB,CA9WME,CAAiBl6B,EAAO5H,EAAahM,EAAE,IAElCstC,CACT,CACAS,OAAAA,CAAQC,GAMN,OALAzhB,EAAUA,EAAUiH,MAAMjH,EAAUoH,SAAUqa,QAC9B7mC,IAAZ6mC,IACFA,GAAU,GAEZztC,KAAK6sC,YAAcY,EACZA,CACT,CACAT,WAAAA,CAAY9iC,GAGV,GAFA8hB,EAAUD,EAAMqF,OAAQlnB,GAGtBlK,KAAK4sC,SAAS97B,MAAKuC,KACZA,EAAMqL,YACJrL,EAAMqL,WAAW5N,MAAKyH,QAAW3R,IAAN2R,MAGpC,MAAM,IAAInZ,MAAM,wCAElBY,KAAKg6B,KAAK9vB,SAAWA,CACvB,CACAiwB,UAAAA,CAAWr7B,GACTktB,EAAUD,EAAMqF,OAAQtyB,GAExBkB,KAAKg6B,KAAKl7B,QAAUA,CACtB,CACA+8B,QAAAA,CAAS6R,EAAQlH,EAAMx4B,EAAUw9B,GAC/B,IAAKxrC,KAAK2tC,oBACR,MAAM,IAAIvuC,MAAM,wCAElB,IAAII,EAEJ,GA/EmB,kBADHuY,EAgFD21B,IA/EgB31B,aAAc2f,OAiF3CgW,EAASvgB,EAAc4C,cAAcxyB,EAAOqD,KAAK8sC,EAAQ,aAEpD,GAjFX,SAAyB31B,GACvB,OAAOA,aAAcyC,EAAcyT,WACrC,CA+Ee2f,CAAgBF,GAAS,CAClC,MAAMpC,EAAQoC,EAAOve,KAAKqX,GAC1BgF,EAAgBF,EAAM74B,OACtBjT,EAAQ8rC,EAAM9rC,MACdkuC,EAASA,EAAO5e,SAAQ,EAC1B,CAzFJ,IAAoB/W,EA0FhB,OAAO/X,KAAKitC,iBAAiBS,EAAQlH,EAAM,CACzCx4B,WACAw9B,gBACAhsC,SAEJ,CACA88B,SAAAA,CAAU74B,EAAcjE,GACtB,IAAKQ,KAAK6tC,qBACR,MAAM,IAAIzuC,MAAM,wCAMlB,MAH4B,kBAAjBqE,IACTA,EAAe6oC,EAASvf,eAAetpB,EAAczD,KAAK2sB,UAErD3sB,KAAKg6B,KAAKsC,UAAU74B,EAAcjE,EAC3C,CACAsuC,KAAAA,GACE,OAAO9tC,KAAK+tC,SAAQ,EACtB,CACAC,eAAAA,GACE,OAAOhuC,KAAK+tC,SAAQ,EACtB,CACAla,IAAAA,CACEoa,EACAnM,EACA38B,EACAk5B,EACA6P,EACAplB,IAixBJ,UAAiB,MACfzV,EAAK,UACL86B,EAAS,QACTrM,EAAO,cACPsM,EAAa,SACb/P,EAAQ,QACRgQ,IAGA,IAAIC,GAAS,EACb,IAAK,MAAO7uC,EAAG0gB,KAAW9M,EAAMzQ,QAAQo/B,UAAW,CACjD,IAAKmM,EAAU3oC,OAAO2a,GAAS,SAC/B,GAAI9M,EAAMqL,WAAWjf,GAAI,MAAM,IAAIL,MAAM,4BAEzC,GAAyB,KAArB+uC,EAAU1wC,QAAiB4V,EAAMkc,WACnC,MAAM,IAAInwB,MACR,8DAGJ,MAAM6M,EAAY61B,EAAQjO,KAAKua,EAAeC,GAC9Ch7B,EAAMqL,WAAWjf,GAAKqsB,EAAQ7f,UAAUkf,OAAOlf,EAAWoyB,GAC1DiQ,GAAS,CACX,CACA,IAAKA,EAAQ,MAAM,IAAIlvC,MAAM,sCAC/B,CAvyBImvC,CAwyBJ,SACE5hB,EACAvZ,EACAo7B,EACAz2B,EACAk2B,EACAnM,EACA38B,EACAk5B,EACA6P,EACAplB,EACAulB,GAEA,IAAInB,EACJ,GAA0B,kBAAfe,EACT3lB,QAAQC,KACN,+GAGF2kB,EAAMe,MACD,IAA0B,kBAAfA,EAWhB,MAAM,IAAI1kB,UACR,mEAzQN,SAAuBnW,EAAQ66B,GAC7B,IAAKxB,EAAcr4B,IAAI65B,EAAWQ,mBAChC,MAAM,IAAIllB,UACR,8BAA8B0kB,EAAWQ,sBAG7C/B,EACE1gB,EAAU9sB,OACV+uC,EAAWf,IACX,2DAEFR,EACE3gB,EAAM2iB,OACNT,EAAWnM,QACX,2DAEF4K,EACE1gB,EAAUiH,MAAMjH,EAAU9sB,QAC1B+uC,EAAW5P,SACX,4CAEF,MAAMsQ,GAAev7B,EAAO66B,EAAWf,MAAQ,IAAIyB,YAC7CC,EAAUX,EAAWQ,kBAC3B,OAAQG,GACN,IAAK,QACH,GAAID,GAA+B,eAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,6BAA6ByB,KAGtDjC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWnlB,cACX,GAAG8lB,+BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAW9oC,aACX,GAAGypC,8BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWC,aACX,GAAGU,8BAEL,MACF,IAAK,OACH,GAAID,GAA+B,WAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,4BAA4ByB,KAGrDjC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWnlB,cACX,GAAG8lB,+BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAW9oC,aACX,GAAGypC,8BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWC,aACX,GAAGU,8BAEL,MACF,IAAK,SACH,GAAID,GAA+B,sBAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,8BAA8ByB,KAGvDjC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWnlB,cACX,GAAG8lB,+BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAW9oC,aACX,GAAGypC,8BAELlC,EACE3gB,EAAMgf,QACNkD,EAAWC,aACX,GAAGU,2BAEL,MACF,IAAK,OACH,GAAID,GAA+B,aAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,4BAA4ByB,KAGrDjC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWnlB,cACX,GAAG8lB,+BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAW9oC,aACX,GAAGypC,8BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWC,aACX,GAAGU,8BAEL,MACF,IAAK,cACH,GAAID,GAA+B,eAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,mCAAmCyB,KAG5DjC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWnlB,cACX,GAAG8lB,+BAELlC,EACE1gB,EAAUzuB,OACV0wC,EAAW9oC,aACX,GAAGypC,2BAELlC,EACE3gB,EAAMgf,QACNkD,EAAWC,aACX,GAAGU,2BAEL,MACF,IAAK,YACL,IAAK,YACL,IAAK,aACH,GAAID,GAA+B,eAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,sBAAsB0B,MAAYD,KAG3DjC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWnlB,cACX,GAAG8lB,+BAELlC,EACE1gB,EAAUzuB,OACV0wC,EAAW9oC,aACX,GAAGypC,2BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAWC,aACX,GAAGU,8BAEL,MACF,IAAK,aACL,IAAK,aACL,IAAK,cACH,GAAID,GAA+B,sBAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,sBAAsB0B,MAAYD,KAG3DjC,EACE1gB,EAAUzuB,OACV0wC,EAAWnlB,cACX,GAAG8lB,4BAELlC,EACE1gB,EAAUxsB,WAAMoH,GAChBqnC,EAAW9oC,aACX,GAAGypC,8BAELlC,EACE3gB,EAAMgf,QACNkD,EAAWC,aACX,GAAGU,2BAEL,MACF,IAAK,kBACL,IAAK,kBACL,IAAK,mBACH,GAAID,GAA+B,eAAhBA,EACjB,MAAM,IAAIplB,UACR,UAAU0kB,EAAWf,sBAAsB0B,MAAYD,KAG3DjC,EACE1gB,EAAUzuB,OACV0wC,EAAWnlB,cACX,GAAG8lB,4BAELlC,EACE1gB,EAAUzuB,OACV0wC,EAAW9oC,aACX,GAAGypC,4BAELlC,EACE3gB,EAAMgf,QACNkD,EAAWC,aACX,GAAGU,4BAIX,CA+CIC,CAAcz7B,EAAQ66B,KAEpBf,MACApL,UACA38B,eACAk5B,WACA6P,eACAplB,iBACEmlB,EAKN,CACA,QAAgBrnC,IAAZk7B,EACF,MAAM,IAAI1iC,MAAM,yBAGlB,GAAI0iC,EAAQnV,SAAWmV,EAAQnV,UAAYA,EACzC,MAAM,IAAIpD,UAAU,wBACtB,IAAKnW,EAAO85B,GAAM,MAAM,IAAI9tC,MAAM,sBAAwB8tC,GAE1D,GADA7O,EAAWA,GAAY7jB,EAAcyT,YAAY8S,YAC7CyN,EAAanQ,GAAW,MAAM,IAAIj/B,MAAM,6BAC5C,MAAMiU,EAAQD,EAAO85B,GAErB,QACyBtmC,IAAvByM,EAAMlO,cACNA,IACCkO,EAAMlO,aAAaK,OAAOL,GAE3B,MAAM,IAAI/F,MAAM,6BAElB,MAAM+uC,EACJrM,EAAQ3sB,WAAc2sB,EAAQgN,cAAgBhN,EAAQgN,eACxD,IAAKC,EAAQ17B,GAAQ,CACnB,QAAqBzM,IAAjBsnC,EAA4B,CAC9B,QAAoBtnC,IAAhByM,EAAM7T,OAAuB6T,EAAM7T,QAAU0uC,EAC/C,MAAM,IAAI9uC,MAAM,oCAClB4sB,EAAUD,EAAMgf,QAASmD,GACzB76B,EAAM7T,MAAQ0uC,CAChB,CACA,IAAKa,EAAQ17B,GAAQ,CACnB,MAAM27B,EAphBZ,SAAsB37B,EAAO86B,EAAWhpC,EAAc2jB,GACpD,GAAI3jB,GAAgB2jB,EAAe,CACjC,MAAM+D,EAAQhB,EAASgB,MAAM,CAC3BqL,OAAQ,CAAE1lB,OAAQsW,KAEdmmB,EAAWpjB,EAASgB,MAAM,CAAEra,OAAQrN,IACpCiU,EAAOyS,EAASzS,KAAK,CAAE8e,OAAQ,CAAE1lB,OAAQrN,KACzC+pC,EAAUrjB,EAASzS,KAAK,CAAE8e,OAAQrL,IAExC,IAAKA,EAAMxmB,KAAKb,OAAOypC,EAAS5oC,MAC9B,MAAM,IAAIjH,MAAM,kDAClB,IAAKga,EAAK/S,KAAKb,OAAO0pC,EAAQ7oC,MAC5B,MAAM,IAAIjH,MAAM,iDAClB,MAAM+vC,EAAWC,EAAaviB,EAAMqL,OAAO1lB,OAAQ27B,GACnD,IAAKgB,EAASvsC,QACZ,MAAM,IAAIxD,MACR+vC,EAAS/P,KACP,oCACAtT,EAAQgB,MAAMhE,GACd,KAEFzV,EAAMqL,YAAcrL,EAAMqL,WAAW5N,MAAKpM,QAAWkC,IAANlC,MACjDyqC,EAASzwB,WAAarL,EAAMqL,YAE9B,MAAM2wB,EAAavmB,EACnB,GAAIqmB,EAAS/P,OAASoN,EAAata,OACjC,MAAM,IAAI9yB,MAAM,8CAClB,MAAO,CACL+F,eACAgoC,iBAAkBX,EAAara,MAC/BrJ,gBACAwmB,kBAAmBH,EAAS/P,KAC5BuP,YAAanC,EAAava,KAC1BuZ,cAAepyB,EAAK5G,OACpB+c,YAAY,EACZ8f,aACAE,SAAUJ,EAAS/P,KACnBx8B,QAASusC,EAASvsC,QAClB8b,WAAYywB,EAASzwB,WACrB8wB,cAAeL,EAASK,cAE5B,CACA,GAAIrqC,EAAc,CAChB,MAAMiU,EAAOyS,EAASzS,KAAK,CAAE8e,OAAQ,CAAE1lB,OAAQrN,KAC/C,GAAIkO,EAAMm4B,cAAe,CACvB,IAAI0D,EACJ,IACEA,EAAUrjB,EAASzS,KAAK,CAAE5G,OAAQa,EAAMm4B,eAC1C,CAAE,MAAO5tB,GACP,MAAM,IAAIxe,MAAM,6BAClB,CACA,IAAKga,EAAK/S,KAAKb,OAAO0pC,EAAQ7oC,MAC5B,MAAM,IAAIjH,MAAM,gDACpB,CACA,MAAM+vC,EAAWC,EAAah2B,EAAK8e,OAAO1lB,OAAQ27B,GAClD,IAAKgB,EAASvsC,QACZ,MAAM,IAAIxD,MACR+vC,EAAS/P,KACP,mCACAtT,EAAQgB,MAAM3nB,GACd,KAEFkO,EAAMqL,YAAcrL,EAAMqL,WAAW5N,MAAKpM,QAAWkC,IAANlC,MACjDyqC,EAASzwB,WAAarL,EAAMqL,YAE9B,IAAI2wB,EAAalqC,EAIjB,OAHIgqC,EAAS/P,OAASoN,EAAata,SACjCmd,EAAaxjB,EAASvoB,MAAM,CAAEzE,OAAQswC,EAASvsC,QAAQ,KAAM4P,QAExD,CACLrN,eACAgoC,iBAAkBgC,EAAS/P,KAC3BuP,YAAanC,EAAava,KAC1BuZ,cAAepyB,EAAK5G,OACpB+c,WAAY4f,EAAS/P,OAASoN,EAAata,OAC3Cmd,aACAE,SAAUJ,EAAS/P,KACnBx8B,QAASusC,EAASvsC,QAClB8b,WAAYywB,EAASzwB,WACrB8wB,cAAeL,EAASK,cAE5B,CACA,GAAI1mB,EAAe,CACjB,MAAM+D,EAAQhB,EAASgB,MAAM,CAAEqL,OAAQ,CAAE1lB,OAAQsW,KACjD,GAAIzV,EAAMm4B,cAAe,CACvB,MAAMyD,EAAWpjB,EAASgB,MAAM,CAAEra,OAAQa,EAAMm4B,gBAChD,IAAK3e,EAAMxmB,KAAKb,OAAOypC,EAAS5oC,MAC9B,MAAM,IAAIjH,MAAM,iDACpB,CACA,MAAM+vC,EAAWC,EAAaviB,EAAMqL,OAAO1lB,OAAQ27B,GACnD,IAAKgB,EAASvsC,QACZ,MAAM,IAAIxD,MACR+vC,EAAS/P,KACP,oCACAtT,EAAQgB,MAAMhE,GACd,KAEFzV,EAAMqL,YAAcrL,EAAMqL,WAAW5N,MAAKpM,QAAWkC,IAANlC,MACjDyqC,EAASzwB,WAAarL,EAAMqL,YAE9B,MAAM2wB,EAAavmB,EACnB,GAAIqmB,EAAS/P,OAASoN,EAAata,OACjC,MAAM,IAAI9yB,MAAM,wCAClB,MAAO,CACL0pB,gBACAwmB,kBAAmBH,EAAS/P,KAC5BuP,YAAanC,EAAara,MAC1BqZ,cAAe3e,EAAMra,OACrB+c,YAAY,EACZ8f,aACAE,SAAUJ,EAAS/P,KACnBx8B,QAASusC,EAASvsC,QAClB8b,WAAYywB,EAASzwB,WACrB8wB,cAAeL,EAASK,cAE5B,CACA,GAAIn8B,EAAMs7B,aAAet7B,EAAMm4B,cAAe,CAE5C,GAAIn4B,EAAMs7B,cAAgBnC,EAAava,KACrC,MAAM,IAAI7yB,MACR,oBAAsBiU,EAAMs7B,YAAc,2BAE9C,GAAIt7B,EAAMs7B,cAAgBnC,EAAara,MACrC,MAAM,IAAI/yB,MACR,oBAAsBiU,EAAMs7B,YAAc,4BAE9C,IAAKt7B,EAAMm4B,cAAe,MAAM,IAAIpsC,MAAM,4BAC1C,MAAM+vC,EAAWC,EAAa/7B,EAAMm4B,cAAe2C,GACnD,IAAKgB,EAASvsC,QACZ,MAAM,IAAIxD,MACR+vC,EAAS/P,KACP,mBACAtT,EAAQgB,MAAMzZ,EAAMm4B,eACpB,KAEFn4B,EAAMqL,YAAcrL,EAAMqL,WAAW5N,MAAKpM,QAAWkC,IAANlC,MACjDyqC,EAASzwB,WAAarL,EAAMqL,YAE9B,IAAI2wB,EAAah8B,EAAMm4B,cAIvB,OAHI2D,EAAS/P,OAASoN,EAAata,SACjCmd,EAAaxjB,EAASvoB,MAAM,CAAEzE,OAAQswC,EAASvsC,QAAQ,KAAM4P,QAExD,CACLm8B,YAAaQ,EAAS/P,KACtBoM,cAAen4B,EAAMm4B,cACrBjc,WAAY4f,EAAS/P,OAASoN,EAAata,OAC3Cmd,aACAE,SAAUJ,EAAS/P,KACnBx8B,QAASusC,EAASvsC,QAClB8b,WAAYywB,EAASzwB,WACrB8wB,cAAeL,EAASK,cAE5B,CACA,MAAMhE,EAAgB3f,EAASvoB,MAAM,CAAEzE,OAAQsvC,IAAa37B,OAC5D,MAAO,CACLm8B,YAAanC,EAAaxa,MAC1BwZ,gBACAjc,YAAY,EACZ8f,WAAY7D,EACZ+D,SAAU/C,EAAaxa,MACvBpvB,QAAS,CAACurC,GACVzvB,WAAY,MAAC9X,GAEjB,CAiXuB6oC,CACfp8B,EACA86B,EACAhpC,EACA2jB,GAGFtX,OAAOC,OAAO4B,EAAO27B,EACvB,CACA,IAAKD,EAAQ17B,GAAQ,MAAMjU,MAAMiU,EAAMs7B,YAAc,iBACvD,CAEA,IAAIP,EAEFA,EADE/6B,EAAMkc,WACQxX,EAAG4tB,iBACjBuH,EACA75B,EAAMg8B,WACNh8B,EAAM7T,MACN6+B,GAGctmB,EAAG8tB,iBAAiBqH,EAAK75B,EAAMg8B,WAAYhR,GAE7D,MAAO,CACLhrB,QACA86B,YACArM,UACAsM,gBACA/P,WACAgQ,UAAWA,EAEf,CAr4BMqB,CACE1vC,KAAK2sB,QACL3sB,KAAK4sC,SACL5sC,KAAK2vC,eAAeC,KAAK5vC,MACzBA,KAAKg6B,KACLiU,EACAnM,EACA38B,EACAk5B,EACA6P,EACAplB,EACA9oB,KAAK6sC,aAGX,CACAI,gBAAAA,CAAiBS,EAAQlH,EAAMhtB,GAC7B,GAAIgB,EAAcyT,YAAY2c,eAAe8C,GAC3C,MAAM,IAAItuC,MAAM,iCAElB,MAAMywC,EAAYnC,EAAOtvC,SAAS,OAAS,IAAMooC,EACjD,QAAsC5/B,IAAlC5G,KAAK2sC,cAAckD,GACrB,MAAM,IAAIzwC,MAAM,oBAAsBywC,GACxC,IAAIx8B,EAAQ,CAAC,EAUb,QARuBzM,IAAnB4S,EAAQ/G,SACVY,EAAQy8B,EAAYt2B,EAAQ/G,OAAQ+G,EAAQjG,SAAW,UAGnC3M,IAAlB4S,EAAQha,QACV6T,EAAM7T,MAAQga,EAAQha,QAGnB6T,EAAMm4B,eAAiBhyB,EAAQgyB,cAAe,CACjD,IAAImD,EACJ,IAAKt7B,EAAMzQ,UAAYyQ,EAAMqL,WAAY,CACvC,MAAMywB,EAAWC,EAAa51B,EAAQgyB,eAClC2D,EAASvsC,UACXyQ,EAAMzQ,QAAUusC,EAASvsC,QACzByQ,EAAMqL,WAAaywB,EAASzwB,YAE9BiwB,EAAcQ,EAAS/P,IACzB,CACA/rB,EAAMm4B,cAAgBhyB,EAAQgyB,cAC9Bn4B,EAAMs7B,YAAcA,GAAepC,EAAS/5B,OAAOgH,EAAQgyB,cAC7D,CACA,MAAM0B,EAAMltC,KAAKg6B,KAAK6B,SACpB6R,EACAlH,EACAhtB,EAAQxL,SACRwL,EAAQzM,WAIV,OAFA/M,KAAK4sC,SAASM,GAAO75B,EACrBrT,KAAK2sC,cAAckD,IAAa,EACzB3C,CACT,CACAa,OAAAA,CAAQxb,GACN,IAAKA,EAAiB,CACpB,IAAKvyB,KAAKg6B,KAAK/T,IAAIxoB,OAAQ,MAAM,IAAI2B,MAAM,6BAC3C,IAAKY,KAAKg6B,KAAK7K,KAAK1xB,OAAQ,MAAM,IAAI2B,MAAM,6BAC9C,CACA,MAAM2Y,EAAK/X,KAAKg6B,KAAK7I,QAerB,GAbAnxB,KAAK4sC,SAASlvC,SAAQ,CAAC2V,EAAO5T,KAC5B,IAAK4T,EAAMs7B,cAAgBpc,EACzB,MAAM,IAAInzB,MAAM,+BAClB,MAAM+B,EAAS2sC,EAAMz6B,EAAMs7B,YAAat7B,EAAOkf,GAC/C,GAAKpxB,EAML4W,EAAGq0B,eAAe3sC,EAAG0B,EAAOkS,OAC5B0E,EAAGs0B,WAAW5sC,EAAG0B,EAAOoS,aAPxB,CACE,IAAKgf,GAAmBlf,EAAMs7B,cAAgBnC,EAAa3a,YACzD,MAAM,IAAIzyB,MAAM,sBAClB,IAAKmzB,EAAiB,MAAM,IAAInzB,MAAM,yBAExC,CAEgC,KAE7BmzB,GAECvyB,KAAK+vC,kBAAkBh4B,EAAG8kB,eAC5B,MAAM,IAAIz9B,MAAM,+BAGpB,OAAO2Y,CACT,CACA41B,iBAAAA,GACE,OAAO3tC,KAAK4sC,SAAS7W,OAAM1iB,IACpBA,EAAMqL,YACJrL,EAAMqL,WAAWqX,OAAM9pB,IAC5B,IAAKA,EAAW,OAAO,EAIvB,OACkE,KAJjD+jC,EAAkB/jC,GAIrBuO,EAAcyT,YAAYkW,qBAA2B,KAIzE,CACAwL,cAAAA,CAAeM,GACb,OAAIA,IAAoBz1B,EAAcyT,YAAY8S,YACf,IAA1B/gC,KAAKg6B,KAAK7K,KAAK1xB,OAKI,IAA1BuC,KAAKg6B,KAAK7K,KAAK1xB,QACfuC,KAAK4sC,SAAS97B,MAAKuC,KACZA,EAAMqL,YACJrL,EAAMqL,WAAW5N,MAAK7E,IAC3B,IAAKA,EAAW,OAAO,EAEvB,QADiB+jC,EAAkB/jC,GACpBuO,EAAcyT,YAAYoW,aAC9B,KAInB,CACAwJ,kBAAAA,GACE,MAAMqC,EAAUlwC,KAAKg6B,KAAK/T,IAAIxoB,OACxB0yC,EAAWnwC,KAAKg6B,KAAK7K,KAAK1xB,OAChC,OAAOuC,KAAK4sC,SAAS7W,OAAM1iB,QACAzM,IAArByM,EAAMqL,YACHrL,EAAMqL,WAAWqX,OAAM9pB,IAC5B,IAAKA,EAAW,OAAO,EACvB,MACMi8B,EAAyB,GADd8H,EAAkB/jC,GAEnC,OAAIi8B,IAAgB1tB,EAAcyT,YAAYoW,cAC1C6D,IAAgB1tB,EAAcyT,YAAYmW,gBAIrC8L,GAAWC,CAER,KAGlB,CACAJ,iBAAAA,CAAkBvvC,GAQhB,OANiBR,KAAK4sC,SAAShd,QAAO,CAACC,EAAGnrB,IAAMmrB,GAAKnrB,EAAElF,QAAU,IAAI,GAGpDQ,KAAKg6B,KAAK7K,KAAKS,QAAO,CAACC,EAAGnrB,IAAMmrB,EAAInrB,EAAElF,OAAO,IAExCgB,EACLR,KAAK05B,cACxB,EAGF,SAASoW,EAAY/iC,EAAWqjC,EAAchR,EAAM37B,GAClD,GAAyB,IAArBsJ,EAAUtP,QAAwC,IAAxB2yC,EAAa3yC,OAAc,MAAO,CAAC,EACjE,IAAK2hC,EAAM,CACT,IAAIiR,EAAS9D,EAASl5B,MAAMtG,GAAW,GACnCujC,EAAS/D,EAASh5B,QAAQ68B,GAAc,GACxCC,IAAW7D,EAAa3a,cAAawe,OAASzpC,GAC9C0pC,IAAW9D,EAAa3a,cAAaye,OAAS1pC,GAClDw4B,EAAOiR,GAAUC,CACnB,CACA,OAAQlR,GACN,KAAKoN,EAAata,OAAQ,CACxB,MAAM,OAAE1f,EAAM,OAAE3T,EAAM,UAAEoN,GAAc4f,EAASlmB,OAAO,CACpD4N,QAAS68B,IAEX,MAAO,CACL5E,cAAeh5B,EACfm8B,YAAanC,EAAata,OAC1BtvB,QAAS,CAAC/D,GACV6f,WAAY,CAACzS,GAEjB,CACA,KAAKugC,EAAaxa,MAAO,CACvB,MAAM,OAAExf,EAAM,OAAE3T,EAAM,UAAEoN,GAAc4f,EAASvoB,MAAM,CACnD+P,MAAOtG,IAET,MAAO,CACLy+B,cAAeh5B,EACfm8B,YAAanC,EAAaxa,MAC1BpvB,QAAS,CAAC/D,GACV6f,WAAY,CAACzS,GAEjB,CACA,KAAKugC,EAAaza,KAAM,CACtB,MAAM,UAAE9lB,GAAc4f,EAASyK,KAAK,CAAEjjB,MAAOtG,IAC7C,MAAO,CACL4hC,YAAanC,EAAaza,KAC1BnvB,QAAS,MAACgE,GACV8X,WAAY,CAACzS,GAEjB,CACA,KAAKugC,EAAa5a,KAAM,CACtB,MAAM,EAAEhpB,EAAC,QAAEhG,EAAO,WAAE8b,GAAemN,EAASuK,KAC1C,CACE/iB,MAAOtG,EACPyF,OAAQ/O,GAEV,CAAE8uB,iBAAiB,IAErB,MAAO,CACLoc,YAAanC,EAAa5a,KAC1BhvB,UACA8b,aACA8wB,cAAe5mC,EAEnB,EAEF,GAAIw2B,IAASoN,EAAava,KAAM,CAC9B,MAAM,OAAEzf,EAAM,OAAE0lB,GAAWrM,EAASzS,KAAK,CACvC/F,MAAOtG,EACPwG,QAAS68B,IAELG,EAAahE,EAAS/5B,OAAO0lB,EAAO1lB,QACpC28B,EAAWW,EACf5X,EAAO7kB,MACP6kB,EAAO3kB,QACPg9B,EACArY,EAAO1lB,QAET,OAAK28B,EAASR,YACP,CACLnD,cAAeh5B,EACfm8B,YAAanC,EAAava,KAC1B9sB,aAAc+yB,EAAO1lB,OACrB26B,iBAAkBgC,EAASR,YAC3B7lB,cAAeqmB,EAASrmB,cACxBwmB,kBAAmBH,EAASG,kBAC5B1sC,QAASusC,EAASvsC,QAClB8b,WAAYywB,EAASzwB,YATW,CAAC,CAWrC,CACA,GAAI0gB,IAASoN,EAAara,MAAO,CAC/B,MAAM,OAAE3f,EAAM,OAAE0lB,GAAWrM,EAASgB,MAAM,CACxCxZ,MAAOtG,EACPwG,QAAS68B,IAELG,EAAahE,EAAS/5B,OAAO0lB,EAAO1lB,QAC1C,IAAI28B,EAWJ,OATEA,EADEoB,IAAe/D,EAAata,OACnB4d,EAAY5X,EAAO7kB,MAAO6kB,EAAO3kB,QAASg9B,GAE1CT,EACThkB,EAAQoH,QAAQgF,EAAO3kB,SACvB,GACAg9B,EACArY,EAAO1lB,QAGN28B,EAASR,YACP,CACLnD,cAAeh5B,EACfm8B,YAAanC,EAAara,MAC1BrJ,cAAeoP,EAAO1lB,OACtB88B,kBAAmBH,EAASR,YAC5B/rC,QAASusC,EAASvsC,QAClB8b,WAAYywB,EAASzwB,YAPW,CAAC,CASrC,CACA,MAAO,CACLiwB,YAAanC,EAAa3a,YAC1B2Z,cAAez+B,EAEnB,CA+BA,SAASqiC,EAAa38B,EAAQ07B,GAC5BniB,EAAUD,EAAMxuB,OAAQkV,GACxB,MAAM2sB,EAAOmN,EAAS/5B,OAAOC,GAC7B,OAAQ2sB,GACN,KAAKoN,EAAaxa,MAAO,CACvB,IAAKmc,EAAW,MAAO,CAAE/O,QAEzB,MAAMoR,EAAO3kB,EAASvoB,MAAM,CAAEkP,OAAQC,IAAUpM,KAC1CoqC,EAAOrjB,EAAQuF,QAAQwb,GAC7B,OAAKqC,EAAKhrC,OAAOirC,GACV,CACLrR,OACAx8B,QAAS,CAACurC,GACVzvB,WAAY,MAAC9X,IAJgB,CAAEw4B,OAMnC,CACA,KAAKoN,EAAata,OAAQ,CACxB,IAAKic,EAAW,MAAO,CAAE/O,QAEzB,MAAMsR,EAAQ7kB,EAASlmB,OAAO,CAAE6M,OAAQC,IAAUpM,KAC5CsqC,EAAQvjB,EAAQuF,QAAQwb,GAC9B,OAAKuC,EAAMlrC,OAAOmrC,GACX,CACLvR,OACAx8B,QAAS,CAACurC,GACVzvB,WAAY,MAAC9X,IAJkB,CAAEw4B,OAMrC,CACA,KAAKoN,EAAaza,KAEhB,MAAO,CACLqN,OACAx8B,QAAS,CAHEipB,EAASyK,KAAK,CAAE9jB,OAAQC,IAGpB5T,QACf6f,WAAY,MAAC9X,IAGjB,KAAK4lC,EAAa5a,KAAM,CACtB,MAAMwE,EAAOvK,EAASuK,KAAK,CAAE5jB,OAAQC,IACrC,MAAO,CACL2sB,OACAx8B,QAASwzB,EAAKxzB,QACd8b,WAAY0X,EAAKxzB,QAAQ8F,KAAI,KAAe,IAC5C8mC,cAAepZ,EAAKxtB,EAExB,EAEF,MAAO,CAAEw2B,OACX,CAqKA,SAAS0O,EAAM1O,EAAM/rB,EAAOkf,GAC1B,MAAM3vB,EAAUyQ,EAAMzQ,SAAW,GACjC,IAAI8b,EAAarL,EAAMqL,YAAc,GACrC,OAAQ0gB,GACN,KAAKoN,EAAaxa,MAChB,GAAuB,IAAnBpvB,EAAQnF,OAAc,MAC1B,GAA0B,IAAtBihB,EAAWjhB,OAAc,MAC7B,OAAOouB,EAASvoB,MAAM,CAAEzE,OAAQ+D,EAAQ,GAAIqJ,UAAWyS,EAAW,KAEpE,KAAK8tB,EAAata,OAChB,GAAuB,IAAnBtvB,EAAQnF,OAAc,MAC1B,GAA0B,IAAtBihB,EAAWjhB,OAAc,MAC7B,OAAOouB,EAASlmB,OAAO,CAAE9G,OAAQ+D,EAAQ,GAAIqJ,UAAWyS,EAAW,KAErE,KAAK8tB,EAAaza,KAChB,GAAuB,IAAnBnvB,EAAQnF,OAAc,MAC1B,GAA0B,IAAtBihB,EAAWjhB,OAAc,MAC7B,OAAOouB,EAASyK,KAAK,CAAErqB,UAAWyS,EAAW,KAE/C,KAAK8tB,EAAa5a,KAAM,CACtB,MAAMhpB,EAAIyK,EAAMm8B,cAEd9wB,EADE6T,EACW7T,EAAWhW,KAAIhE,GAAKA,GAAK4sB,EAASwD,IAAIwC,OAEtC5Y,EAAW0Q,QAAO1qB,GAAKA,IAItC,MAAMgxB,GAAYnD,GAAmB3pB,IAAM8V,EAAWjhB,OACtD,OAAOouB,EAASuK,KACd,CAAExtB,IAAGhG,UAAS8b,cACd,CAAE6T,kBAAiBmD,YAEvB,CACA,KAAK8W,EAAava,KAAM,CACtB,MAAMiG,EAAS4V,EAAMz6B,EAAM85B,iBAAkB95B,EAAOkf,GACpD,IAAK2F,EAAQ,OACb,OAAOrM,EAASzS,KAAK,CACnB8e,OAAQ,CACN1lB,OAAQ0lB,EAAO1lB,QAAUa,EAAMlO,aAC/BkO,MAAO6kB,EAAO7kB,MACdE,QAAS2kB,EAAO3kB,UAGtB,CACA,KAAKi5B,EAAara,MAAO,CACvB,MAAM+F,EAAS4V,EAAMz6B,EAAMi8B,kBAAmBj8B,EAAOkf,GACrD,IAAK2F,EAAQ,OACb,OAAOrM,EAASgB,MAAM,CACpBqL,OAAQ,CACN1lB,OAAQa,EAAMyV,cACdzV,MAAO6kB,EAAO7kB,MACdE,QAAS2kB,EAAO3kB,UAGtB,EAEJ,CACA,SAASw7B,EAAQ17B,GACf,YACuBzM,IAArByM,EAAMg8B,iBACazoC,IAAnByM,EAAMk8B,eACY3oC,IAAlByM,EAAMzQ,cACegE,IAArByM,EAAMqL,YACNrL,EAAMqL,WAAWjhB,SAAW4V,EAAMzQ,QAAQnF,QAC1C4V,EAAMzQ,QAAQnF,OAAS,KACD,IAArB4V,EAAMkc,iBAAwC3oB,IAAhByM,EAAM7T,MAEzC,CACA,SAASwwC,EAAkB1yC,GACzB,OAAOA,EAAO4D,UAAU5D,EAAOG,OAAS,EAC1C,CA1aAstB,EAAQgK,mBAAqBA,C,+BCrT7BvjB,OAAOka,eAAeX,EAAS,aAA/BvZ,CAA+ChS,OAAO,IACtD,MAAMwsB,EAAYJ,EAAQ,MACpBglB,EAAa5pC,KAAK6pC,IAAI,EAAG,IAAM,EAKrC,SAASC,EAAUtxC,GACjB,OAAOwsB,EAAU0L,OAAOl4B,MAAYA,EAAM6tC,MAAM,0BAClD,CAHAtiB,EAAQgmB,OAHR,SAAgBvxC,GACd,OAAOwsB,EAAUoF,OAAO5xB,IAAUA,GAASoxC,CAC7C,EAKA7lB,EAAQ+lB,UAAYA,EACpBA,EAAU5H,OAAS,IACV,wBASTne,EAAQ2jB,OAPR,SAAgBrU,GACd,OACGrO,EAAUzuB,OAAO88B,EAAIllB,YACQ,oBAArBklB,EAAIyU,eACO,oBAAbzU,EAAIxG,IAEf,EAMA9I,EAAQggB,QAHR,SAAiBvrC,GACf,OAAOwsB,EAAUglB,OAAOxxC,IAAUA,GAFhB,KAGpB,EAGAurB,EAAQkmB,QAAUjlB,EAAUklB,WAAW,SAEvCnmB,EAAQsI,QAAUrH,EAAUkH,QAAQ,CAClC8B,cAAehJ,EAAUmlB,MAAMnlB,EAAUzuB,OAAQyuB,EAAU0L,QAC3DzC,MAAO,CACLC,OAAQlJ,EAAUoF,OAClB+D,QAASnJ,EAAUoF,QAErBlE,WAAYlB,EAAUO,MACtBlnB,WAAY2mB,EAAUO,MACtBwG,IAAK/G,EAAUO,QAEjBxB,EAAQmJ,aAAelI,EAAU2L,QAAQ,IACzC5M,EAAQuB,WAAaN,EAAU2L,QAAQ,IACvC5M,EAAQ0e,WAAazd,EAAU2L,QAAQ,IACvC5M,EAAQ7rB,OAAS8sB,EAAU9sB,OAC3B6rB,EAAQM,MAAQW,EAAUX,MAC1BN,EAAQqI,QAAUpH,EAAUoH,QAC5BrI,EAAQ2M,OAAS1L,EAAU0L,OAC3B3M,EAAQxtB,OAASyuB,EAAUzuB,OAC3BwtB,EAAQud,IAAMtc,EAAUsc,IACxBvd,EAAQkI,MAAQjH,EAAUiH,MAC1BlI,EAAQsB,MAAQL,EAAUK,MAC1BtB,EAAQwB,MAAQP,EAAUO,MAC1BxB,EAAQqG,OAASpF,EAAUoF,OAC3BrG,EAAQgE,SAAW/C,EAAU+C,SAC7BhE,EAAQ4M,QAAU3L,EAAU2L,QAC5B5M,EAAQ+f,KAAO9e,EAAU8e,KACzB/f,EAAQomB,MAAQnlB,EAAUmlB,K,+BCvD1B,IAAIC,EAASxlB,EAAQ,OACjBruB,EAASquB,EAAAA,MAAAA,OAEbd,EAAOC,QAAU,SAAUsmB,GAWzB,SAASC,EAAWh0C,GAClB,IAAI4uB,EAAU5uB,EAAOoB,MAAM,GAAI,GAC3B6hB,EAAWjjB,EAAOoB,OAAO,GACzB6yC,EAAcF,EAAWnlB,GAE7B,KAAI3L,EAAS,GAAKgxB,EAAY,GAC1BhxB,EAAS,GAAKgxB,EAAY,GAC1BhxB,EAAS,GAAKgxB,EAAY,GAC1BhxB,EAAS,GAAKgxB,EAAY,IAE9B,OAAOrlB,CACT,CAiBA,MAAO,CACLf,OAtCF,SAAiBe,GACf,IAAI3L,EAAW8wB,EAAWnlB,GAE1B,OAAOklB,EAAOjmB,OAAO5tB,EAAOuD,OAAO,CACjCorB,EACA3L,GACC2L,EAAQzuB,OAAS,GACtB,EAgCEytB,OATF,SAAiBsmB,GACf,IACItlB,EAAUolB,EADDF,EAAOlmB,OAAOsmB,IAE3B,IAAKtlB,EAAS,MAAM,IAAI9sB,MAAM,oBAC9B,OAAO8sB,CACT,EAKElB,aAjBF,SAAuBwmB,GACrB,IAAIl0C,EAAS8zC,EAAOpmB,aAAawmB,GACjC,GAAKl0C,EAEL,OAAOg0C,EAAUh0C,EACnB,EAcF,C,8BC/CA,IAAIk1B,EAAa5G,EAAQ,OACrB6lB,EAAgB7lB,EAAQ,OAQ5Bd,EAAOC,QAAU0mB,GALjB,SAAmBn0C,GACjB,IAAI2zB,EAAMuB,EAAW,UAAUpwB,OAAO9E,GAAQgF,SAC9C,OAAOkwB,EAAW,UAAUpwB,OAAO6uB,GAAK3uB,QAC1C,G,kBCTA,MAAMovC,EAAMC,OAAO,cAEnB,MAAMC,EACJ,cAAWF,GACT,OAAOA,CACT,CAEA/xC,WAAAA,CAAakyC,EAAMr4B,GAGjB,GAFAA,EAAUs4B,EAAat4B,GAEnBq4B,aAAgBD,EAAY,CAC9B,GAAIC,EAAKE,UAAYv4B,EAAQu4B,MAC3B,OAAOF,EAEPA,EAAOA,EAAKryC,KAEhB,CAEAqyC,EAAOA,EAAKG,OAAO5nB,MAAM,OAAOkO,KAAK,KACrC2Z,EAAM,aAAcJ,EAAMr4B,GAC1BxZ,KAAKwZ,QAAUA,EACfxZ,KAAK+xC,QAAUv4B,EAAQu4B,MACvB/xC,KAAKm7B,MAAM0W,GAEP7xC,KAAK0d,SAAWg0B,EAClB1xC,KAAKR,MAAQ,GAEbQ,KAAKR,MAAQQ,KAAKkyC,SAAWlyC,KAAK0d,OAAO5e,QAG3CmzC,EAAM,OAAQjyC,KAChB,CAEAm7B,KAAAA,CAAO0W,GACL,MAAMv5B,EAAItY,KAAKwZ,QAAQu4B,MAAQI,EAAGl5B,EAAEm5B,iBAAmBD,EAAGl5B,EAAEo5B,YACtDzpC,EAAIipC,EAAKxE,MAAM/0B,GAErB,IAAK1P,EACH,MAAM,IAAI2gB,UAAU,uBAAuBsoB,KAG7C7xC,KAAKkyC,cAAoBtrC,IAATgC,EAAE,GAAmBA,EAAE,GAAK,GACtB,MAAlB5I,KAAKkyC,WACPlyC,KAAKkyC,SAAW,IAIbtpC,EAAE,GAGL5I,KAAK0d,OAAS,IAAI40B,EAAO1pC,EAAE,GAAI5I,KAAKwZ,QAAQu4B,OAF5C/xC,KAAK0d,OAASg0B,CAIlB,CAEAtzC,QAAAA,GACE,OAAO4B,KAAKR,KACd,CAEA+yC,IAAAA,CAAMzzC,GAGJ,GAFAmzC,EAAM,kBAAmBnzC,EAASkB,KAAKwZ,QAAQu4B,OAE3C/xC,KAAK0d,SAAWg0B,GAAO5yC,IAAY4yC,EACrC,OAAO,EAGT,GAAuB,kBAAZ5yC,EACT,IACEA,EAAU,IAAIwzC,EAAOxzC,EAASkB,KAAKwZ,QACrC,CAAE,MAAOg5B,GACP,OAAO,CACT,CAGF,OAAOC,EAAI3zC,EAASkB,KAAKkyC,SAAUlyC,KAAK0d,OAAQ1d,KAAKwZ,QACvD,CAEAk5B,UAAAA,CAAYb,EAAMr4B,GAChB,KAAMq4B,aAAgBD,GACpB,MAAM,IAAIroB,UAAU,4BAGtB,MAAsB,KAAlBvpB,KAAKkyC,SACY,KAAflyC,KAAKR,OAGF,IAAImzC,EAAMd,EAAKryC,MAAOga,GAAS+4B,KAAKvyC,KAAKR,OACrB,KAAlBqyC,EAAKK,SACK,KAAfL,EAAKryC,OAGF,IAAImzC,EAAM3yC,KAAKR,MAAOga,GAAS+4B,KAAKV,EAAKn0B,WAGlDlE,EAAUs4B,EAAat4B,IAGXo5B,mBACM,aAAf5yC,KAAKR,OAAuC,aAAfqyC,EAAKryC,YAGhCga,EAAQo5B,oBACV5yC,KAAKR,MAAMqzC,WAAW,WAAahB,EAAKryC,MAAMqzC,WAAW,iBAKxD7yC,KAAKkyC,SAASW,WAAW,OAAQhB,EAAKK,SAASW,WAAW,WAI1D7yC,KAAKkyC,SAASW,WAAW,OAAQhB,EAAKK,SAASW,WAAW,UAK3D7yC,KAAK0d,OAAO5e,UAAY+yC,EAAKn0B,OAAO5e,UACrCkB,KAAKkyC,SAASn/B,SAAS,OAAQ8+B,EAAKK,SAASn/B,SAAS,WAIpD0/B,EAAIzyC,KAAK0d,OAAQ,IAAKm0B,EAAKn0B,OAAQlE,IACrCxZ,KAAKkyC,SAASW,WAAW,MAAQhB,EAAKK,SAASW,WAAW,UAIxDJ,EAAIzyC,KAAK0d,OAAQ,IAAKm0B,EAAKn0B,OAAQlE,IACrCxZ,KAAKkyC,SAASW,WAAW,MAAQhB,EAAKK,SAASW,WAAW,UAI9D,EAGF/nB,EAAOC,QAAU6mB,EAEjB,MAAME,EAAelmB,EAAQ,QACrBknB,OAAQX,EAAE,EAAEl5B,GAAM2S,EAAQ,OAC5B6mB,EAAM7mB,EAAQ,OACdqmB,EAAQrmB,EAAQ,OAChB0mB,EAAS1mB,EAAQ,OACjB+mB,EAAQ/mB,EAAQ,M,kBC5ItB,MAAMmnB,EAAmB,OAGzB,MAAMJ,EACJhzC,WAAAA,CAAa29B,EAAO9jB,GAGlB,GAFAA,EAAUs4B,EAAat4B,GAEnB8jB,aAAiBqV,EACnB,OACErV,EAAMyU,UAAYv4B,EAAQu4B,OAC1BzU,EAAMsV,sBAAwBp5B,EAAQo5B,kBAE/BtV,EAEA,IAAIqV,EAAMrV,EAAM0V,IAAKx5B,GAIhC,GAAI8jB,aAAiBsU,EAKnB,OAHA5xC,KAAKgzC,IAAM1V,EAAM99B,MACjBQ,KAAKwQ,IAAM,CAAC,CAAC8sB,IACbt9B,KAAKizC,eAAYrsC,EACV5G,KAsBT,GAnBAA,KAAKwZ,QAAUA,EACfxZ,KAAK+xC,QAAUv4B,EAAQu4B,MACvB/xC,KAAK4yC,oBAAsBp5B,EAAQo5B,kBAKnC5yC,KAAKgzC,IAAM1V,EAAM0U,OAAOkB,QAAQH,EAAkB,KAGlD/yC,KAAKwQ,IAAMxQ,KAAKgzC,IACb5oB,MAAM,MAEN1hB,KAAI4P,GAAKtY,KAAKmzC,WAAW76B,EAAE05B,UAI3B5iB,QAAOxF,GAAKA,EAAEnsB,UAEZuC,KAAKwQ,IAAI/S,OACZ,MAAM,IAAI8rB,UAAU,yBAAyBvpB,KAAKgzC,OAIpD,GAAIhzC,KAAKwQ,IAAI/S,OAAS,EAAG,CAEvB,MAAM21C,EAAQpzC,KAAKwQ,IAAI,GAEvB,GADAxQ,KAAKwQ,IAAMxQ,KAAKwQ,IAAI4e,QAAOxF,IAAMypB,EAAUzpB,EAAE,MACrB,IAApB5pB,KAAKwQ,IAAI/S,OACXuC,KAAKwQ,IAAM,CAAC4iC,QACP,GAAIpzC,KAAKwQ,IAAI/S,OAAS,EAE3B,IAAK,MAAMmsB,KAAK5pB,KAAKwQ,IACnB,GAAiB,IAAboZ,EAAEnsB,QAAgB61C,EAAM1pB,EAAE,IAAK,CACjC5pB,KAAKwQ,IAAM,CAACoZ,GACZ,KACF,CAGN,CAEA5pB,KAAKizC,eAAYrsC,CACnB,CAEA,SAAI02B,GACF,QAAuB12B,IAAnB5G,KAAKizC,UAAyB,CAChCjzC,KAAKizC,UAAY,GACjB,IAAK,IAAIxzC,EAAI,EAAGA,EAAIO,KAAKwQ,IAAI/S,OAAQgC,IAAK,CACpCA,EAAI,IACNO,KAAKizC,WAAa,MAEpB,MAAMM,EAAQvzC,KAAKwQ,IAAI/Q,GACvB,IAAK,IAAIkJ,EAAI,EAAGA,EAAI4qC,EAAM91C,OAAQkL,IAC5BA,EAAI,IACN3I,KAAKizC,WAAa,KAEpBjzC,KAAKizC,WAAaM,EAAM5qC,GAAGvK,WAAW4zC,MAE1C,CACF,CACA,OAAOhyC,KAAKizC,SACd,CAEAh+B,MAAAA,GACE,OAAOjV,KAAKs9B,KACd,CAEAl/B,QAAAA,GACE,OAAO4B,KAAKs9B,KACd,CAEA6V,UAAAA,CAAY7V,GAGV,MAGMkW,IAFHxzC,KAAKwZ,QAAQo5B,mBAAqBa,IAClCzzC,KAAKwZ,QAAQu4B,OAAS2B,IACE,IAAMpW,EAC3BqW,EAASjZ,EAAM1pB,IAAIwiC,GACzB,GAAIG,EACF,OAAOA,EAGT,MAAM5B,EAAQ/xC,KAAKwZ,QAAQu4B,MAErB6B,EAAK7B,EAAQI,EAAGl5B,EAAE46B,kBAAoB1B,EAAGl5B,EAAE66B,aACjDxW,EAAQA,EAAM4V,QAAQU,EAAIG,EAAc/zC,KAAKwZ,QAAQo5B,oBACrDX,EAAM,iBAAkB3U,GAGxBA,EAAQA,EAAM4V,QAAQf,EAAGl5B,EAAE+6B,gBAAiBC,GAC5ChC,EAAM,kBAAmB3U,GAGzBA,EAAQA,EAAM4V,QAAQf,EAAGl5B,EAAEi7B,WAAYC,GACvClC,EAAM,aAAc3U,GAGpBA,EAAQA,EAAM4V,QAAQf,EAAGl5B,EAAEm7B,WAAYC,GACvCpC,EAAM,aAAc3U,GAKpB,IAAIgX,EAAYhX,EACblT,MAAM,KACN1hB,KAAImpC,GAAQ0C,EAAgB1C,EAAM7xC,KAAKwZ,WACvC8e,KAAK,KACLlO,MAAM,OAEN1hB,KAAImpC,GAAQ2C,EAAY3C,EAAM7xC,KAAKwZ,WAElCu4B,IAEFuC,EAAYA,EAAUllB,QAAOyiB,IAC3BI,EAAM,uBAAwBJ,EAAM7xC,KAAKwZ,WAChCq4B,EAAKxE,MAAM8E,EAAGl5B,EAAEm5B,sBAG7BH,EAAM,aAAcqC,GAKpB,MAAMG,EAAW,IAAIjrC,IACfkrC,EAAcJ,EAAU5rC,KAAImpC,GAAQ,IAAID,EAAWC,EAAM7xC,KAAKwZ,WACpE,IAAK,MAAMq4B,KAAQ6C,EAAa,CAC9B,GAAIrB,EAAUxB,GACZ,MAAO,CAACA,GAEV4C,EAASjkC,IAAIqhC,EAAKryC,MAAOqyC,EAC3B,CACI4C,EAASnuC,KAAO,GAAKmuC,EAASrgC,IAAI,KACpCqgC,EAASxkC,OAAO,IAGlB,MAAM9O,EAAS,IAAIszC,EAASzzB,UAE5B,OADA0Z,EAAMlqB,IAAIgjC,EAASryC,GACZA,CACT,CAEAuxC,UAAAA,CAAYpV,EAAO9jB,GACjB,KAAM8jB,aAAiBqV,GACrB,MAAM,IAAIppB,UAAU,uBAGtB,OAAOvpB,KAAKwQ,IAAIM,MAAM6jC,GAElBC,EAAcD,EAAiBn7B,IAC/B8jB,EAAM9sB,IAAIM,MAAM+jC,GAEZD,EAAcC,EAAkBr7B,IAChCm7B,EAAgB5e,OAAO+e,GACdD,EAAiB9e,OAAOgf,GACtBD,EAAepC,WAAWqC,EAAiBv7B,UAOhE,CAGA+4B,IAAAA,CAAMzzC,GACJ,IAAKA,EACH,OAAO,EAGT,GAAuB,kBAAZA,EACT,IACEA,EAAU,IAAIwzC,EAAOxzC,EAASkB,KAAKwZ,QACrC,CAAE,MAAOg5B,GACP,OAAO,CACT,CAGF,IAAK,IAAI/yC,EAAI,EAAGA,EAAIO,KAAKwQ,IAAI/S,OAAQgC,IACnC,GAAIu1C,EAAQh1C,KAAKwQ,IAAI/Q,GAAIX,EAASkB,KAAKwZ,SACrC,OAAO,EAGX,OAAO,CACT,EAGFsR,EAAOC,QAAU4nB,EAEjB,MACMjY,EAAQ,IADF9O,EAAQ,OAGdkmB,EAAelmB,EAAQ,OACvBgmB,EAAahmB,EAAQ,OACrBqmB,EAAQrmB,EAAQ,OAChB0mB,EAAS1mB,EAAQ,QAErBknB,OAAQX,EAAE,EACVl5B,EAAC,sBACDg7B,EAAqB,iBACrBE,EAAgB,iBAChBE,GACEzoB,EAAQ,QACN,wBAAE6nB,EAAuB,WAAEC,GAAe9nB,EAAQ,OAElDynB,EAAYzpB,GAAiB,aAAZA,EAAEpqB,MACnB8zC,EAAQ1pB,GAAiB,KAAZA,EAAEpqB,MAIfo1C,EAAgBA,CAACF,EAAal7B,KAClC,IAAIrY,GAAS,EACb,MAAM8zC,EAAuBP,EAAYh2C,QACzC,IAAIw2C,EAAiBD,EAAqBxgB,MAE1C,KAAOtzB,GAAU8zC,EAAqBx3C,QACpC0D,EAAS8zC,EAAqBlf,OAAOof,GAC5BD,EAAexC,WAAWyC,EAAiB37B,KAGpD07B,EAAiBD,EAAqBxgB,MAGxC,OAAOtzB,CAAM,EAMTozC,EAAkBA,CAAC1C,EAAMr4B,KAC7By4B,EAAM,OAAQJ,EAAMr4B,GACpBq4B,EAAOuD,EAAcvD,EAAMr4B,GAC3By4B,EAAM,QAASJ,GACfA,EAAOwD,EAAcxD,EAAMr4B,GAC3By4B,EAAM,SAAUJ,GAChBA,EAAOyD,EAAezD,EAAMr4B,GAC5By4B,EAAM,SAAUJ,GAChBA,EAAO0D,EAAa1D,EAAMr4B,GAC1By4B,EAAM,QAASJ,GACRA,GAGH2D,EAAMC,IAAOA,GAA2B,MAArBA,EAAGxrB,eAAgC,MAAPwrB,EAS/CJ,EAAgBA,CAACxD,EAAMr4B,IACpBq4B,EACJG,OACA5nB,MAAM,OACN1hB,KAAKkhB,GAAM8rB,EAAa9rB,EAAGpQ,KAC3B8e,KAAK,KAGJod,EAAeA,CAAC7D,EAAMr4B,KAC1B,MAAMlB,EAAIkB,EAAQu4B,MAAQI,EAAGl5B,EAAE08B,YAAcxD,EAAGl5B,EAAE28B,OAClD,OAAO/D,EAAKqB,QAAQ56B,GAAG,CAACyiB,EAAG8a,EAAGjtC,EAAGqO,EAAG6+B,KAElC,IAAI5uB,EAoBJ,OArBA+qB,EAAM,QAASJ,EAAM9W,EAAG8a,EAAGjtC,EAAGqO,EAAG6+B,GAG7BN,EAAIK,GACN3uB,EAAM,GACGsuB,EAAI5sC,GACbse,EAAM,KAAK2uB,WAAWA,EAAI,UACjBL,EAAIv+B,GAEbiQ,EAAM,KAAK2uB,KAAKjtC,QAAQitC,MAAMjtC,EAAI,QACzBktC,GACT7D,EAAM,kBAAmB6D,GACzB5uB,EAAM,KAAK2uB,KAAKjtC,KAAKqO,KAAK6+B,MACrBD,MAAMjtC,EAAI,SAGfse,EAAM,KAAK2uB,KAAKjtC,KAAKqO,MAChB4+B,MAAMjtC,EAAI,QAGjBqpC,EAAM,eAAgB/qB,GACfA,CAAG,GACV,EAWEkuB,EAAgBA,CAACvD,EAAMr4B,IACpBq4B,EACJG,OACA5nB,MAAM,OACN1hB,KAAKkhB,GAAMmsB,EAAansB,EAAGpQ,KAC3B8e,KAAK,KAGJyd,EAAeA,CAAClE,EAAMr4B,KAC1By4B,EAAM,QAASJ,EAAMr4B,GACrB,MAAMlB,EAAIkB,EAAQu4B,MAAQI,EAAGl5B,EAAE+8B,YAAc7D,EAAGl5B,EAAEg9B,OAC5C5sB,EAAI7P,EAAQo5B,kBAAoB,KAAO,GAC7C,OAAOf,EAAKqB,QAAQ56B,GAAG,CAACyiB,EAAG8a,EAAGjtC,EAAGqO,EAAG6+B,KAElC,IAAI5uB,EA2CJ,OA5CA+qB,EAAM,QAASJ,EAAM9W,EAAG8a,EAAGjtC,EAAGqO,EAAG6+B,GAG7BN,EAAIK,GACN3uB,EAAM,GACGsuB,EAAI5sC,GACbse,EAAM,KAAK2uB,QAAQxsB,OAAOwsB,EAAI,UACrBL,EAAIv+B,GAEXiQ,EADQ,MAAN2uB,EACI,KAAKA,KAAKjtC,MAAMygB,MAAMwsB,MAAMjtC,EAAI,QAEhC,KAAKitC,KAAKjtC,MAAMygB,OAAOwsB,EAAI,UAE1BC,GACT7D,EAAM,kBAAmB6D,GAGrB5uB,EAFM,MAAN2uB,EACQ,MAANjtC,EACI,KAAKitC,KAAKjtC,KAAKqO,KAAK6+B,MACrBD,KAAKjtC,MAAMqO,EAAI,MAEd,KAAK4+B,KAAKjtC,KAAKqO,KAAK6+B,MACrBD,MAAMjtC,EAAI,QAGX,KAAKitC,KAAKjtC,KAAKqO,KAAK6+B,OACpBD,EAAI,YAGZ5D,EAAM,SAGF/qB,EAFM,MAAN2uB,EACQ,MAANjtC,EACI,KAAKitC,KAAKjtC,KAAKqO,IAClBoS,MAAMwsB,KAAKjtC,MAAMqO,EAAI,MAElB,KAAK4+B,KAAKjtC,KAAKqO,IAClBoS,MAAMwsB,MAAMjtC,EAAI,QAGf,KAAKitC,KAAKjtC,KAAKqO,OACf4+B,EAAI,WAId5D,EAAM,eAAgB/qB,GACfA,CAAG,GACV,EAGEouB,EAAiBA,CAACzD,EAAMr4B,KAC5By4B,EAAM,iBAAkBJ,EAAMr4B,GACvBq4B,EACJznB,MAAM,OACN1hB,KAAKkhB,GAAMssB,EAActsB,EAAGpQ,KAC5B8e,KAAK,MAGJ4d,EAAgBA,CAACrE,EAAMr4B,KAC3Bq4B,EAAOA,EAAKG,OACZ,MAAM15B,EAAIkB,EAAQu4B,MAAQI,EAAGl5B,EAAEk9B,aAAehE,EAAGl5B,EAAEm9B,QACnD,OAAOvE,EAAKqB,QAAQ56B,GAAG,CAAC4O,EAAKmvB,EAAMR,EAAGjtC,EAAGqO,EAAG6+B,KAC1C7D,EAAM,SAAUJ,EAAM3qB,EAAKmvB,EAAMR,EAAGjtC,EAAGqO,EAAG6+B,GAC1C,MAAMQ,EAAKd,EAAIK,GACTU,EAAKD,GAAMd,EAAI5sC,GACf4tC,EAAKD,GAAMf,EAAIv+B,GACfw/B,EAAOD,EA+Db,MA7Da,MAATH,GAAgBI,IAClBJ,EAAO,IAKTP,EAAKt8B,EAAQo5B,kBAAoB,KAAO,GAEpC0D,EAGApvB,EAFW,MAATmvB,GAAyB,MAATA,EAEZ,WAGA,IAECA,GAAQI,GAGbF,IACF3tC,EAAI,GAENqO,EAAI,EAES,MAATo/B,GAGFA,EAAO,KACHE,GACFV,GAAKA,EAAI,EACTjtC,EAAI,EACJqO,EAAI,IAEJrO,GAAKA,EAAI,EACTqO,EAAI,IAEY,OAATo/B,IAGTA,EAAO,IACHE,EACFV,GAAKA,EAAI,EAETjtC,GAAKA,EAAI,GAIA,MAATytC,IACFP,EAAK,MAGP5uB,EAAM,GAAGmvB,EAAOR,KAAKjtC,KAAKqO,IAAI6+B,KACrBS,EACTrvB,EAAM,KAAK2uB,QAAQC,OAAQD,EAAI,UACtBW,IACTtvB,EAAM,KAAK2uB,KAAKjtC,MAAMktC,MACjBD,MAAMjtC,EAAI,SAGjBqpC,EAAM,gBAAiB/qB,GAEhBA,CAAG,GACV,EAKEquB,EAAeA,CAAC1D,EAAMr4B,KAC1By4B,EAAM,eAAgBJ,EAAMr4B,GAErBq4B,EACJG,OACAkB,QAAQf,EAAGl5B,EAAEy9B,MAAO,KAGnBlC,EAAcA,CAAC3C,EAAMr4B,KACzBy4B,EAAM,cAAeJ,EAAMr4B,GACpBq4B,EACJG,OACAkB,QAAQf,EAAG34B,EAAQo5B,kBAAoB35B,EAAE09B,QAAU19B,EAAE29B,MAAO,KAS3D7C,EAAgB8C,GAAS,CAACC,EAC9Bl2C,EAAMm2C,EAAIC,EAAIC,EAAIC,EAAKC,EACvBhnC,EAAIinC,EAAIC,EAAIC,EAAIC,IA2BT,GAzBL32C,EADE40C,EAAIuB,GACC,GACEvB,EAAIwB,GACN,KAAKD,QAASF,EAAQ,KAAO,KAC3BrB,EAAIyB,GACN,KAAKF,KAAMC,MAAOH,EAAQ,KAAO,KAC/BK,EACF,KAAKt2C,IAEL,KAAKA,IAAOi2C,EAAQ,KAAO,QAIlC1mC,EADEqlC,EAAI4B,GACD,GACI5B,EAAI6B,GACR,KAAKD,EAAK,UACN5B,EAAI8B,GACR,IAAIF,MAAOC,EAAK,QACZE,EACJ,KAAKH,KAAMC,KAAMC,KAAMC,IACnBV,EACJ,IAAIO,KAAMC,MAAOC,EAAK,MAEtB,KAAKnnC,MAGW6hC,OAGnBgD,EAAUA,CAACxkC,EAAK1R,EAAS0a,KAC7B,IAAK,IAAI/Z,EAAI,EAAGA,EAAI+Q,EAAI/S,OAAQgC,IAC9B,IAAK+Q,EAAI/Q,GAAG8yC,KAAKzzC,GACf,OAAO,EAIX,GAAIA,EAAQ04C,WAAW/5C,SAAW+b,EAAQo5B,kBAAmB,CAM3D,IAAK,IAAInzC,EAAI,EAAGA,EAAI+Q,EAAI/S,OAAQgC,IAE9B,GADAwyC,EAAMzhC,EAAI/Q,GAAGie,QACTlN,EAAI/Q,GAAGie,SAAWk0B,EAAWF,KAI7BlhC,EAAI/Q,GAAGie,OAAO85B,WAAW/5C,OAAS,EAAG,CACvC,MAAMg6C,EAAUjnC,EAAI/Q,GAAGie,OACvB,GAAI+5B,EAAQC,QAAU54C,EAAQ44C,OAC1BD,EAAQE,QAAU74C,EAAQ64C,OAC1BF,EAAQG,QAAU94C,EAAQ84C,MAC5B,OAAO,CAEX,CAIF,OAAO,CACT,CAEA,OAAO,CAAI,C,kBCxiBb,MAAM3F,EAAQrmB,EAAQ,QAChB,WAAEisB,EAAU,iBAAE14C,GAAqBysB,EAAQ,QACzCknB,OAAQX,EAAE,EAAEl5B,GAAM2S,EAAQ,OAE5BkmB,EAAelmB,EAAQ,QACvB,mBAAEksB,GAAuBlsB,EAAQ,OACvC,MAAM0mB,EACJ3yC,WAAAA,CAAab,EAAS0a,GAGpB,GAFAA,EAAUs4B,EAAat4B,GAEnB1a,aAAmBwzC,EAAQ,CAC7B,GAAIxzC,EAAQizC,UAAYv4B,EAAQu4B,OAC5BjzC,EAAQ8zC,sBAAwBp5B,EAAQo5B,kBAC1C,OAAO9zC,EAEPA,EAAUA,EAAQA,OAEtB,MAAO,GAAuB,kBAAZA,EAChB,MAAM,IAAIyqB,UAAU,uDAAuDzqB,OAG7E,GAAIA,EAAQrB,OAASo6C,EACnB,MAAM,IAAItuB,UACR,0BAA0BsuB,gBAI9B5F,EAAM,SAAUnzC,EAAS0a,GACzBxZ,KAAKwZ,QAAUA,EACfxZ,KAAK+xC,QAAUv4B,EAAQu4B,MAGvB/xC,KAAK4yC,oBAAsBp5B,EAAQo5B,kBAEnC,MAAMhqC,EAAI9J,EAAQkzC,OAAO3E,MAAM7zB,EAAQu4B,MAAQI,EAAGl5B,EAAE8+B,OAAS5F,EAAGl5B,EAAE++B,OAElE,IAAKpvC,EACH,MAAM,IAAI2gB,UAAU,oBAAoBzqB,KAU1C,GAPAkB,KAAKgzC,IAAMl0C,EAGXkB,KAAK03C,OAAS9uC,EAAE,GAChB5I,KAAK23C,OAAS/uC,EAAE,GAChB5I,KAAK43C,OAAShvC,EAAE,GAEZ5I,KAAK03C,MAAQv4C,GAAoBa,KAAK03C,MAAQ,EAChD,MAAM,IAAInuB,UAAU,yBAGtB,GAAIvpB,KAAK23C,MAAQx4C,GAAoBa,KAAK23C,MAAQ,EAChD,MAAM,IAAIpuB,UAAU,yBAGtB,GAAIvpB,KAAK43C,MAAQz4C,GAAoBa,KAAK43C,MAAQ,EAChD,MAAM,IAAIruB,UAAU,yBAIjB3gB,EAAE,GAGL5I,KAAKw3C,WAAa5uC,EAAE,GAAGwhB,MAAM,KAAK1hB,KAAK+sC,IACrC,GAAI,WAAWlD,KAAKkD,GAAK,CACvB,MAAM/R,GAAO+R,EACb,GAAI/R,GAAO,GAAKA,EAAMvkC,EACpB,OAAOukC,CAEX,CACA,OAAO+R,CAAE,IATXz1C,KAAKw3C,WAAa,GAapBx3C,KAAK8tC,MAAQllC,EAAE,GAAKA,EAAE,GAAGwhB,MAAM,KAAO,GACtCpqB,KAAKiV,QACP,CAEAA,MAAAA,GAKE,OAJAjV,KAAKlB,QAAU,GAAGkB,KAAK03C,SAAS13C,KAAK23C,SAAS33C,KAAK43C,QAC/C53C,KAAKw3C,WAAW/5C,SAClBuC,KAAKlB,SAAW,IAAIkB,KAAKw3C,WAAWlf,KAAK,QAEpCt4B,KAAKlB,OACd,CAEAV,QAAAA,GACE,OAAO4B,KAAKlB,OACd,CAEAsc,OAAAA,CAAS68B,GAEP,GADAhG,EAAM,iBAAkBjyC,KAAKlB,QAASkB,KAAKwZ,QAASy+B,KAC9CA,aAAiB3F,GAAS,CAC9B,GAAqB,kBAAV2F,GAAsBA,IAAUj4C,KAAKlB,QAC9C,OAAO,EAETm5C,EAAQ,IAAI3F,EAAO2F,EAAOj4C,KAAKwZ,QACjC,CAEA,OAAIy+B,EAAMn5C,UAAYkB,KAAKlB,QAClB,EAGFkB,KAAKk4C,YAAYD,IAAUj4C,KAAKm4C,WAAWF,EACpD,CAEAC,WAAAA,CAAaD,GAKX,OAJMA,aAAiB3F,IACrB2F,EAAQ,IAAI3F,EAAO2F,EAAOj4C,KAAKwZ,UAI/Bs+B,EAAmB93C,KAAK03C,MAAOO,EAAMP,QACrCI,EAAmB93C,KAAK23C,MAAOM,EAAMN,QACrCG,EAAmB93C,KAAK43C,MAAOK,EAAML,MAEzC,CAEAO,UAAAA,CAAYF,GAMV,GALMA,aAAiB3F,IACrB2F,EAAQ,IAAI3F,EAAO2F,EAAOj4C,KAAKwZ,UAI7BxZ,KAAKw3C,WAAW/5C,SAAWw6C,EAAMT,WAAW/5C,OAC9C,OAAQ,EACH,IAAKuC,KAAKw3C,WAAW/5C,QAAUw6C,EAAMT,WAAW/5C,OACrD,OAAO,EACF,IAAKuC,KAAKw3C,WAAW/5C,SAAWw6C,EAAMT,WAAW/5C,OACtD,OAAO,EAGT,IAAIgC,EAAI,EACR,EAAG,CACD,MAAMowB,EAAI7vB,KAAKw3C,WAAW/3C,GACpBM,EAAIk4C,EAAMT,WAAW/3C,GAE3B,GADAwyC,EAAM,qBAAsBxyC,EAAGowB,EAAG9vB,QACxB6G,IAANipB,QAAyBjpB,IAAN7G,EACrB,OAAO,EACF,QAAU6G,IAAN7G,EACT,OAAO,EACF,QAAU6G,IAANipB,EACT,OAAQ,EACH,GAAIA,IAAM9vB,EAGf,OAAO+3C,EAAmBjoB,EAAG9vB,EAEjC,SAAWN,EACb,CAEA24C,YAAAA,CAAcH,GACNA,aAAiB3F,IACrB2F,EAAQ,IAAI3F,EAAO2F,EAAOj4C,KAAKwZ,UAGjC,IAAI/Z,EAAI,EACR,EAAG,CACD,MAAMowB,EAAI7vB,KAAK8tC,MAAMruC,GACfM,EAAIk4C,EAAMnK,MAAMruC,GAEtB,GADAwyC,EAAM,gBAAiBxyC,EAAGowB,EAAG9vB,QACnB6G,IAANipB,QAAyBjpB,IAAN7G,EACrB,OAAO,EACF,QAAU6G,IAAN7G,EACT,OAAO,EACF,QAAU6G,IAANipB,EACT,OAAQ,EACH,GAAIA,IAAM9vB,EAGf,OAAO+3C,EAAmBjoB,EAAG9vB,EAEjC,SAAWN,EACb,CAIA44C,GAAAA,CAAKC,EAASC,EAAYC,GACxB,OAAQF,GACN,IAAK,WACHt4C,KAAKw3C,WAAW/5C,OAAS,EACzBuC,KAAK43C,MAAQ,EACb53C,KAAK23C,MAAQ,EACb33C,KAAK03C,QACL13C,KAAKq4C,IAAI,MAAOE,EAAYC,GAC5B,MACF,IAAK,WACHx4C,KAAKw3C,WAAW/5C,OAAS,EACzBuC,KAAK43C,MAAQ,EACb53C,KAAK23C,QACL33C,KAAKq4C,IAAI,MAAOE,EAAYC,GAC5B,MACF,IAAK,WAIHx4C,KAAKw3C,WAAW/5C,OAAS,EACzBuC,KAAKq4C,IAAI,QAASE,EAAYC,GAC9Bx4C,KAAKq4C,IAAI,MAAOE,EAAYC,GAC5B,MAGF,IAAK,aAC4B,IAA3Bx4C,KAAKw3C,WAAW/5C,QAClBuC,KAAKq4C,IAAI,QAASE,EAAYC,GAEhCx4C,KAAKq4C,IAAI,MAAOE,EAAYC,GAC5B,MAEF,IAAK,QAMc,IAAfx4C,KAAK23C,OACU,IAAf33C,KAAK43C,OACsB,IAA3B53C,KAAKw3C,WAAW/5C,QAEhBuC,KAAK03C,QAEP13C,KAAK23C,MAAQ,EACb33C,KAAK43C,MAAQ,EACb53C,KAAKw3C,WAAa,GAClB,MACF,IAAK,QAKgB,IAAfx3C,KAAK43C,OAA0C,IAA3B53C,KAAKw3C,WAAW/5C,QACtCuC,KAAK23C,QAEP33C,KAAK43C,MAAQ,EACb53C,KAAKw3C,WAAa,GAClB,MACF,IAAK,QAK4B,IAA3Bx3C,KAAKw3C,WAAW/5C,QAClBuC,KAAK43C,QAEP53C,KAAKw3C,WAAa,GAClB,MAGF,IAAK,MAAO,CACV,MAAMiB,EAAOv5C,OAAOs5C,GAAkB,EAAI,EAE1C,IAAKD,IAAiC,IAAnBC,EACjB,MAAM,IAAIp5C,MAAM,mDAGlB,GAA+B,IAA3BY,KAAKw3C,WAAW/5C,OAClBuC,KAAKw3C,WAAa,CAACiB,OACd,CACL,IAAIh5C,EAAIO,KAAKw3C,WAAW/5C,OACxB,OAASgC,GAAK,GACsB,kBAAvBO,KAAKw3C,WAAW/3C,KACzBO,KAAKw3C,WAAW/3C,KAChBA,GAAK,GAGT,IAAW,IAAPA,EAAU,CAEZ,GAAI84C,IAAev4C,KAAKw3C,WAAWlf,KAAK,OAA2B,IAAnBkgB,EAC9C,MAAM,IAAIp5C,MAAM,yDAElBY,KAAKw3C,WAAWv3C,KAAKw4C,EACvB,CACF,CACA,GAAIF,EAAY,CAGd,IAAIf,EAAa,CAACe,EAAYE,IACP,IAAnBD,IACFhB,EAAa,CAACe,IAE2C,IAAvDT,EAAmB93C,KAAKw3C,WAAW,GAAIe,GACrCG,MAAM14C,KAAKw3C,WAAW,MACxBx3C,KAAKw3C,WAAaA,GAGpBx3C,KAAKw3C,WAAaA,CAEtB,CACA,KACF,CACA,QACE,MAAM,IAAIp4C,MAAM,+BAA+Bk5C,KAMnD,OAJAt4C,KAAKgzC,IAAMhzC,KAAKiV,SACZjV,KAAK8tC,MAAMrwC,SACbuC,KAAKgzC,KAAO,IAAIhzC,KAAK8tC,MAAMxV,KAAK,QAE3Bt4B,IACT,EAGF8qB,EAAOC,QAAUunB,C,kBC7SjB,MAAMnX,EAAQvP,EAAQ,MAKtBd,EAAOC,QAJO4tB,CAAC75C,EAAS0a,KACtB,MAAMjB,EAAI4iB,EAAMr8B,EAAQkzC,OAAOkB,QAAQ,SAAU,IAAK15B,GACtD,OAAOjB,EAAIA,EAAEzZ,QAAU,IAAI,C,kBCH7B,MAAM85C,EAAKhtB,EAAQ,OACbitB,EAAMjtB,EAAQ,OACdktB,EAAKltB,EAAQ,OACbmtB,EAAMntB,EAAQ,MACdotB,EAAKptB,EAAQ,OACbqtB,EAAMrtB,EAAQ,OA8CpBd,EAAOC,QA5CK0nB,CAAC5iB,EAAGmY,EAAIjoC,EAAGgyC,KACrB,OAAQ/J,GACN,IAAK,MAOH,MANiB,kBAANnY,IACTA,EAAIA,EAAE/wB,SAES,kBAANiB,IACTA,EAAIA,EAAEjB,SAED+wB,IAAM9vB,EAEf,IAAK,MAOH,MANiB,kBAAN8vB,IACTA,EAAIA,EAAE/wB,SAES,kBAANiB,IACTA,EAAIA,EAAEjB,SAED+wB,IAAM9vB,EAEf,IAAK,GACL,IAAK,IACL,IAAK,KACH,OAAO64C,EAAG/oB,EAAG9vB,EAAGgyC,GAElB,IAAK,KACH,OAAO8G,EAAIhpB,EAAG9vB,EAAGgyC,GAEnB,IAAK,IACH,OAAO+G,EAAGjpB,EAAG9vB,EAAGgyC,GAElB,IAAK,KACH,OAAOgH,EAAIlpB,EAAG9vB,EAAGgyC,GAEnB,IAAK,IACH,OAAOiH,EAAGnpB,EAAG9vB,EAAGgyC,GAElB,IAAK,KACH,OAAOkH,EAAIppB,EAAG9vB,EAAGgyC,GAEnB,QACE,MAAM,IAAIxoB,UAAU,qBAAqBye,KAC7C,C,kBCjDF,MAAMsK,EAAS1mB,EAAQ,OACjBuP,EAAQvP,EAAQ,OACdknB,OAAQX,EAAE,EAAEl5B,GAAM2S,EAAQ,OAyDlCd,EAAOC,QAvDQmuB,CAACp6C,EAAS0a,KACvB,GAAI1a,aAAmBwzC,EACrB,OAAOxzC,EAOT,GAJuB,kBAAZA,IACTA,EAAU44B,OAAO54B,IAGI,kBAAZA,EACT,OAAO,KAKT,IAAIuuC,EAAQ,KACZ,IAHA7zB,EAAUA,GAAW,CAAC,GAGT2/B,IAEN,CAUL,MAAMC,EAAiB5/B,EAAQo5B,kBAAoBT,EAAGl5B,EAAEogC,eAAiBlH,EAAGl5B,EAAEqgC,WAC9E,IAAIC,EACJ,MAAQA,EAAOH,EAAeI,KAAK16C,OAC7BuuC,GAASA,EAAMzvC,MAAQyvC,EAAM,GAAG5vC,SAAWqB,EAAQrB,SAElD4vC,GACCkM,EAAK37C,MAAQ27C,EAAK,GAAG97C,SAAW4vC,EAAMzvC,MAAQyvC,EAAM,GAAG5vC,SAC3D4vC,EAAQkM,GAEVH,EAAeK,UAAYF,EAAK37C,MAAQ27C,EAAK,GAAG97C,OAAS87C,EAAK,GAAG97C,OAGnE27C,EAAeK,WAAa,CAC9B,MAxBEpM,EAAQvuC,EAAQuuC,MAAM7zB,EAAQo5B,kBAAoBT,EAAGl5B,EAAEygC,YAAcvH,EAAGl5B,EAAE0gC,SA0B5E,GAAc,OAAVtM,EACF,OAAO,KAGT,MAAMqK,EAAQrK,EAAM,GACdsK,EAAQtK,EAAM,IAAM,IACpBuK,EAAQvK,EAAM,IAAM,IACpBmK,EAAah+B,EAAQo5B,mBAAqBvF,EAAM,GAAK,IAAIA,EAAM,KAAO,GACtES,EAAQt0B,EAAQo5B,mBAAqBvF,EAAM,GAAK,IAAIA,EAAM,KAAO,GAEvE,OAAOlS,EAAM,GAAGuc,KAASC,KAASC,IAAQJ,IAAa1J,IAASt0B,EAAQ,C,kBCzD1E,MAAM84B,EAAS1mB,EAAQ,OAMvBd,EAAOC,QALcqtB,CAACvoB,EAAG9vB,EAAGgyC,KAC1B,MAAM6H,EAAW,IAAItH,EAAOziB,EAAGkiB,GACzB8H,EAAW,IAAIvH,EAAOvyC,EAAGgyC,GAC/B,OAAO6H,EAASx+B,QAAQy+B,IAAaD,EAASxB,aAAayB,EAAS,C,kBCJtE,MAAMz+B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADc+uB,CAACjqB,EAAG9vB,IAAMqb,EAAQyU,EAAG9vB,GAAG,E,kBCD7C,MAAMuyC,EAAS1mB,EAAQ,OAIvBd,EAAOC,QAHS3P,CAACyU,EAAG9vB,EAAGgyC,IACrB,IAAIO,EAAOziB,EAAGkiB,GAAO32B,QAAQ,IAAIk3B,EAAOvyC,EAAGgyC,G,kBCF7C,MAAM5W,EAAQvP,EAAQ,MAgEtBd,EAAOC,QA9DMgvB,CAACC,EAAUC,KACtB,MAAMC,EAAK/e,EAAM6e,EAAU,MAAM,GAC3BG,EAAKhf,EAAM8e,EAAU,MAAM,GAC3BG,EAAaF,EAAG9+B,QAAQ++B,GAE9B,GAAmB,IAAfC,EACF,OAAO,KAGT,MAAMC,EAAWD,EAAa,EACxBE,EAAcD,EAAWH,EAAKC,EAC9BI,EAAaF,EAAWF,EAAKD,EAC7BM,IAAeF,EAAY9C,WAAW/5C,OAG5C,KAFoB88C,EAAW/C,WAAW/5C,SAExB+8C,EAQhB,OAAKD,EAAW3C,OAAU2C,EAAW5C,MAMjC2C,EAAY1C,MAEP,QAGL0C,EAAY3C,MAEP,QAIF,QAhBE,QAoBX,MAAMx9B,EAASqgC,EAAa,MAAQ,GAEpC,OAAIN,EAAGxC,QAAUyC,EAAGzC,MACXv9B,EAAS,QAGd+/B,EAAGvC,QAAUwC,EAAGxC,MACXx9B,EAAS,QAGd+/B,EAAGtC,QAAUuC,EAAGvC,MACXz9B,EAAS,QAIX,YAAY,C,kBC7DrB,MAAMiB,EAAUwQ,EAAQ,OAExBd,EAAOC,QADI6tB,CAAC/oB,EAAG9vB,EAAGgyC,IAAmC,IAAzB32B,EAAQyU,EAAG9vB,EAAGgyC,E,kBCD1C,MAAM32B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADI+tB,CAACjpB,EAAG9vB,EAAGgyC,IAAU32B,EAAQyU,EAAG9vB,EAAGgyC,GAAS,C,iBCDnD,MAAM32B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADKguB,CAAClpB,EAAG9vB,EAAGgyC,IAAU32B,EAAQyU,EAAG9vB,EAAGgyC,IAAU,C,kBCDrD,MAAMO,EAAS1mB,EAAQ,OAkBvBd,EAAOC,QAhBKstB,CAACv5C,EAASw5C,EAAS9+B,EAAS++B,EAAYC,KACzB,kBAAbh/B,IACVg/B,EAAiBD,EACjBA,EAAa/+B,EACbA,OAAU5S,GAGZ,IACE,OAAO,IAAI0rC,EACTxzC,aAAmBwzC,EAASxzC,EAAQA,QAAUA,EAC9C0a,GACA6+B,IAAIC,EAASC,EAAYC,GAAgB15C,OAC7C,CAAE,MAAO0zC,GACP,OAAO,IACT,E,kBChBF,MAAMp3B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADIiuB,CAACnpB,EAAG9vB,EAAGgyC,IAAU32B,EAAQyU,EAAG9vB,EAAGgyC,GAAS,C,kBCDnD,MAAM32B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADKkuB,CAACppB,EAAG9vB,EAAGgyC,IAAU32B,EAAQyU,EAAG9vB,EAAGgyC,IAAU,C,iBCDrD,MAAMO,EAAS1mB,EAAQ,OAEvBd,EAAOC,QADO2sB,CAAC7nB,EAAGkiB,IAAU,IAAIO,EAAOziB,EAAGkiB,GAAO2F,K,kBCDjD,MAAMpF,EAAS1mB,EAAQ,OAEvBd,EAAOC,QADO4sB,CAAC9nB,EAAGkiB,IAAU,IAAIO,EAAOziB,EAAGkiB,GAAO4F,K,kBCDjD,MAAMv8B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADK8tB,CAAChpB,EAAG9vB,EAAGgyC,IAAmC,IAAzB32B,EAAQyU,EAAG9vB,EAAGgyC,E,iBCD3C,MAAMO,EAAS1mB,EAAQ,OAevBd,EAAOC,QAdOoQ,CAACr8B,EAAS0a,EAASihC,GAAc,KAC7C,GAAI37C,aAAmBwzC,EACrB,OAAOxzC,EAET,IACE,OAAO,IAAIwzC,EAAOxzC,EAAS0a,EAC7B,CAAE,MAAOg5B,GACP,IAAKiI,EACH,OAAO,KAET,MAAMjI,CACR,E,kBCZF,MAAMF,EAAS1mB,EAAQ,OAEvBd,EAAOC,QADO6sB,CAAC/nB,EAAGkiB,IAAU,IAAIO,EAAOziB,EAAGkiB,GAAO6F,K,kBCDjD,MAAMzc,EAAQvP,EAAQ,MAKtBd,EAAOC,QAJYysB,CAAC14C,EAAS0a,KAC3B,MAAM8zB,EAASnS,EAAMr8B,EAAS0a,GAC9B,OAAQ8zB,GAAUA,EAAOkK,WAAW/5C,OAAU6vC,EAAOkK,WAAa,IAAI,C,kBCHxE,MAAMp8B,EAAUwQ,EAAQ,OAExBd,EAAOC,QADU2vB,CAAC7qB,EAAG9vB,EAAGgyC,IAAU32B,EAAQrb,EAAG8vB,EAAGkiB,E,kBCDhD,MAAMqG,EAAexsB,EAAQ,OAE7Bd,EAAOC,QADO4vB,CAACC,EAAM7I,IAAU6I,EAAK74B,MAAK,CAAC8N,EAAG9vB,IAAMq4C,EAAar4C,EAAG8vB,EAAGkiB,I,kBCDtE,MAAMY,EAAQ/mB,EAAQ,OAStBd,EAAOC,QARW8vB,CAAC/7C,EAASw+B,EAAO9jB,KACjC,IACE8jB,EAAQ,IAAIqV,EAAMrV,EAAO9jB,EAC3B,CAAE,MAAOg5B,GACP,OAAO,CACT,CACA,OAAOlV,EAAMiV,KAAKzzC,EAAQ,C,kBCP5B,MAAMs5C,EAAexsB,EAAQ,OAE7Bd,EAAOC,QADMhJ,CAAC64B,EAAM7I,IAAU6I,EAAK74B,MAAK,CAAC8N,EAAG9vB,IAAMq4C,EAAavoB,EAAG9vB,EAAGgyC,I,kBCDrE,MAAM5W,EAAQvP,EAAQ,MAKtBd,EAAOC,QAJO+vB,CAACh8C,EAAS0a,KACtB,MAAMjJ,EAAI4qB,EAAMr8B,EAAS0a,GACzB,OAAOjJ,EAAIA,EAAEzR,QAAU,IAAI,C,iBCF7B,MAAMi8C,EAAanvB,EAAQ,OACrBovB,EAAYpvB,EAAQ,OACpB0mB,EAAS1mB,EAAQ,OACjBqvB,EAAcrvB,EAAQ,OACtBuP,EAAQvP,EAAQ,MAChBkvB,EAAQlvB,EAAQ,OAChB+sB,EAAQ/sB,EAAQ,OAChBysB,EAAMzsB,EAAQ,OACdmuB,EAAOnuB,EAAQ,OACf8rB,EAAQ9rB,EAAQ,MAChB+rB,EAAQ/rB,EAAQ,OAChBgsB,EAAQhsB,EAAQ,OAChB4rB,EAAa5rB,EAAQ,OACrBxQ,EAAUwQ,EAAQ,OAClB8uB,EAAW9uB,EAAQ,OACnBkuB,EAAeluB,EAAQ,OACvBwsB,EAAexsB,EAAQ,OACvB7J,EAAO6J,EAAQ,OACf+uB,EAAQ/uB,EAAQ,OAChBktB,EAAKltB,EAAQ,OACbotB,EAAKptB,EAAQ,OACbgtB,EAAKhtB,EAAQ,OACbitB,EAAMjtB,EAAQ,OACdmtB,EAAMntB,EAAQ,MACdqtB,EAAMrtB,EAAQ,OACd6mB,EAAM7mB,EAAQ,OACdstB,EAASttB,EAAQ,OACjBgmB,EAAahmB,EAAQ,OACrB+mB,EAAQ/mB,EAAQ,OAChBivB,EAAYjvB,EAAQ,OACpBsvB,EAAgBtvB,EAAQ,OACxBuvB,EAAgBvvB,EAAQ,OACxBwvB,EAAgBxvB,EAAQ,OACxByvB,EAAazvB,EAAQ,OACrB0vB,EAAa1vB,EAAQ,OACrB2vB,EAAU3vB,EAAQ,OAClB4vB,EAAM5vB,EAAQ,OACd6vB,EAAM7vB,EAAQ,OACd8mB,EAAa9mB,EAAQ,OACrB8vB,EAAgB9vB,EAAQ,OACxB+vB,EAAS/vB,EAAQ,OACvBd,EAAOC,QAAU,CACfoQ,QACA2f,QACAnC,QACAN,MACA0B,OACArC,QACAC,QACAC,QACAJ,aACAp8B,UACAs/B,WACAZ,eACA1B,eACAr2B,OACA44B,QACA7B,KACAE,KACAJ,KACAC,MACAE,MACAE,MACAxG,MACAyG,SACAtH,aACAe,QACAkI,YACAK,gBACAC,gBACAC,gBACAC,aACAC,aACAC,UACAC,MACAC,MACA/I,aACAgJ,gBACAC,SACArJ,SACAH,GAAI4I,EAAW5I,GACfyJ,IAAKb,EAAWa,IAChBC,OAAQd,EAAW9hC,EACnB6iC,oBAAqBd,EAAUc,oBAC/BC,cAAef,EAAUe,cACzBjE,mBAAoBmD,EAAYnD,mBAChCkE,oBAAqBf,EAAYe,oB,YCrFnC,MAGM78C,EAAmBD,OAAOC,kBACL,iBAmB3B2rB,EAAOC,QAAU,CACf8sB,WAtBiB,IAuBjBoE,0BAlBgC,GAmBhCC,sBAf4BrE,IAgB5B14C,mBACA48C,cAfoB,CACpB,QACA,WACA,QACA,WACA,QACA,WACA,cASAD,oBA7B0B,QA8B1BrI,wBAAyB,EACzBC,WAAY,E,kBCjCd,MAAMzB,EACe,kB,UAEnBkK,CAAAA,SAAAA,aAAAA,WAAAA,GAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,cAAAA,GAAYC,YACZ,cAAc7J,KAAK4J,CAAAA,SAAAA,aAAAA,WAAAA,GAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,cAAAA,GAAYC,YAC7B,IAAIC,IAAS/zB,QAAQg0B,MAAM,YAAaD,GACxC,OAEJvxB,EAAOC,QAAUknB,C,YCRjB,MAAMsK,EAAU,WACVzE,EAAqBA,CAACjoB,EAAG9vB,KAC7B,MAAMy8C,EAAOD,EAAQhK,KAAK1iB,GACpB4sB,EAAOF,EAAQhK,KAAKxyC,GAO1B,OALIy8C,GAAQC,IACV5sB,GAAKA,EACL9vB,GAAKA,GAGA8vB,IAAM9vB,EAAI,EACZy8C,IAASC,GAAS,EAClBA,IAASD,EAAQ,EAClB3sB,EAAI9vB,GAAK,EACT,CAAC,EAKP+qB,EAAOC,QAAU,CACf+sB,qBACAkE,oBAJ0BA,CAACnsB,EAAG9vB,IAAM+3C,EAAmB/3C,EAAG8vB,G,WCsB5D/E,EAAOC,QAvCP,MACEprB,WAAAA,GACEK,KAAK6wB,IAAM,IACX7wB,KAAK0I,IAAM,IAAIc,GACjB,CAEAwH,GAAAA,CAAK3I,GACH,MAAM7I,EAAQQ,KAAK0I,IAAIsI,IAAI3I,GAC3B,YAAczB,IAAVpH,OACF,GAGAQ,KAAK0I,IAAIuH,OAAO5H,GAChBrI,KAAK0I,IAAI8H,IAAInI,EAAK7I,GACXA,EAEX,CAEAyQ,OAAQ5H,GACN,OAAOrI,KAAK0I,IAAIuH,OAAO5H,EACzB,CAEAmI,GAAAA,CAAKnI,EAAK7I,GAGR,IAFgBQ,KAAKiQ,OAAO5H,SAEFzB,IAAVpH,EAAqB,CAEnC,GAAIQ,KAAK0I,IAAIpC,MAAQtG,KAAK6wB,IAAK,CAC7B,MAAM6rB,EAAW18C,KAAK0I,IAAIJ,OAAOixC,OAAO/5C,MACxCQ,KAAKiQ,OAAOysC,EACd,CAEA18C,KAAK0I,IAAI8H,IAAInI,EAAK7I,EACpB,CAEA,OAAOQ,IACT,E,YCnCF,MAAM28C,EAAcnrC,OAAOorC,OAAO,CAAE7K,OAAO,IACrC8K,EAAYrrC,OAAOorC,OAAO,CAAE,GAYlC9xB,EAAOC,QAXcvR,GACdA,EAIkB,kBAAZA,EACFmjC,EAGFnjC,EAPEqjC,C,kBCLX,MAAM,0BACJZ,EAAyB,sBACzBC,EAAqB,WACrBrE,GACEjsB,EAAQ,OACNqmB,EAAQrmB,EAAQ,OAIhBumB,GAHNpnB,EAAUD,EAAOC,QAAU,CAAC,GAGTonB,GAAK,GAClBW,EAAS/nB,EAAQ+nB,OAAS,GAC1B8I,EAAM7wB,EAAQ6wB,IAAM,GACpB3iC,EAAI8R,EAAQ9R,EAAI,CAAC,EACvB,IAAI6jC,EAAI,EAER,MAAMC,EAAmB,eAQnBC,EAAwB,CAC5B,CAAC,MAAO,GACR,CAAC,MAAOnF,GACR,CAACkF,EAAkBb,IAYfe,EAAcA,CAAChgC,EAAMzd,EAAO09C,KAChC,MAAMC,EAVe39C,KACrB,IAAK,MAAO49C,EAAOvsB,KAAQmsB,EACzBx9C,EAAQA,EACL4qB,MAAM,GAAGgzB,MAAU9kB,KAAK,GAAG8kB,OAAWvsB,MACtCzG,MAAM,GAAGgzB,MAAU9kB,KAAK,GAAG8kB,OAAWvsB,MAE3C,OAAOrxB,CAAK,EAIC69C,CAAc79C,GACrB5B,EAAQk/C,IACd7K,EAAMh1B,EAAMrf,EAAO4B,GACnByZ,EAAEgE,GAAQrf,EACVg+C,EAAIh+C,GAAS4B,EACb2yC,EAAGv0C,GAAS,IAAI0/C,OAAO99C,EAAO09C,EAAW,SAAMt2C,GAC/CksC,EAAOl1C,GAAS,IAAI0/C,OAAOH,EAAMD,EAAW,SAAMt2C,EAAU,EAS9Dq2C,EAAY,oBAAqB,eACjCA,EAAY,yBAA0B,QAMtCA,EAAY,uBAAwB,gBAAgBF,MAKpDE,EAAY,cAAe,IAAIrB,EAAI3iC,EAAEskC,0BACd3B,EAAI3iC,EAAEskC,0BACN3B,EAAI3iC,EAAEskC,uBAE7BN,EAAY,mBAAoB,IAAIrB,EAAI3iC,EAAEukC,+BACd5B,EAAI3iC,EAAEukC,+BACN5B,EAAI3iC,EAAEukC,4BAKlCP,EAAY,uBAAwB,MAAMrB,EAAI3iC,EAAEskC,sBAC5C3B,EAAI3iC,EAAEwkC,0BAEVR,EAAY,4BAA6B,MAAMrB,EAAI3iC,EAAEukC,2BACjD5B,EAAI3iC,EAAEwkC,0BAMVR,EAAY,aAAc,QAAQrB,EAAI3iC,EAAEykC,8BAC/B9B,EAAI3iC,EAAEykC,6BAEfT,EAAY,kBAAmB,SAASrB,EAAI3iC,EAAE0kC,mCACrC/B,EAAI3iC,EAAE0kC,kCAKfV,EAAY,kBAAmB,GAAGF,MAMlCE,EAAY,QAAS,UAAUrB,EAAI3iC,EAAE2kC,yBAC5BhC,EAAI3iC,EAAE2kC,wBAWfX,EAAY,YAAa,KAAKrB,EAAI3iC,EAAE4kC,eACjCjC,EAAI3iC,EAAE6kC,eACPlC,EAAI3iC,EAAE8kC,WAERd,EAAY,OAAQ,IAAIrB,EAAI3iC,EAAE+kC,eAK9Bf,EAAY,aAAc,WAAWrB,EAAI3iC,EAAEglC,oBACxCrC,EAAI3iC,EAAEilC,oBACPtC,EAAI3iC,EAAE8kC,WAERd,EAAY,QAAS,IAAIrB,EAAI3iC,EAAEklC,gBAE/BlB,EAAY,OAAQ,gBAKpBA,EAAY,wBAAyB,GAAGrB,EAAI3iC,EAAEukC,mCAC9CP,EAAY,mBAAoB,GAAGrB,EAAI3iC,EAAEskC,8BAEzCN,EAAY,cAAe,YAAYrB,EAAI3iC,EAAEmlC,4BAChBxC,EAAI3iC,EAAEmlC,4BACNxC,EAAI3iC,EAAEmlC,wBACVxC,EAAI3iC,EAAE6kC,gBACVlC,EAAI3iC,EAAE8kC,eAG3Bd,EAAY,mBAAoB,YAAYrB,EAAI3iC,EAAEolC,iCAChBzC,EAAI3iC,EAAEolC,iCACNzC,EAAI3iC,EAAEolC,6BACVzC,EAAI3iC,EAAEilC,qBACVtC,EAAI3iC,EAAE8kC,eAGhCd,EAAY,SAAU,IAAIrB,EAAI3iC,EAAEqlC,YAAY1C,EAAI3iC,EAAEslC,iBAClDtB,EAAY,cAAe,IAAIrB,EAAI3iC,EAAEqlC,YAAY1C,EAAI3iC,EAAEulC,sBAIvDvB,EAAY,cAAe,oBACDhB,mBACIA,qBACAA,SAC9BgB,EAAY,SAAU,GAAGrB,EAAI3iC,EAAEwlC,4BAC/BxB,EAAY,aAAcrB,EAAI3iC,EAAEwlC,aAClB,MAAM7C,EAAI3iC,EAAE6kC,gBACZ,MAAMlC,EAAI3iC,EAAE8kC,wBAE1Bd,EAAY,YAAarB,EAAI3iC,EAAE0gC,SAAS,GACxCsD,EAAY,gBAAiBrB,EAAI3iC,EAAEygC,aAAa,GAIhDuD,EAAY,YAAa,WAEzBA,EAAY,YAAa,SAASrB,EAAI3iC,EAAEylC,kBAAkB,GAC1D3zB,EAAQopB,iBAAmB,MAE3B8I,EAAY,QAAS,IAAIrB,EAAI3iC,EAAEylC,aAAa9C,EAAI3iC,EAAEslC,iBAClDtB,EAAY,aAAc,IAAIrB,EAAI3iC,EAAEylC,aAAa9C,EAAI3iC,EAAEulC,sBAIvDvB,EAAY,YAAa,WAEzBA,EAAY,YAAa,SAASrB,EAAI3iC,EAAE0lC,kBAAkB,GAC1D5zB,EAAQspB,iBAAmB,MAE3B4I,EAAY,QAAS,IAAIrB,EAAI3iC,EAAE0lC,aAAa/C,EAAI3iC,EAAEslC,iBAClDtB,EAAY,aAAc,IAAIrB,EAAI3iC,EAAE0lC,aAAa/C,EAAI3iC,EAAEulC,sBAGvDvB,EAAY,kBAAmB,IAAIrB,EAAI3iC,EAAEqlC,aAAa1C,EAAI3iC,EAAEklC,oBAC5DlB,EAAY,aAAc,IAAIrB,EAAI3iC,EAAEqlC,aAAa1C,EAAI3iC,EAAE+kC,mBAIvDf,EAAY,iBAAkB,SAASrB,EAAI3iC,EAAEqlC,aACrC1C,EAAI3iC,EAAEklC,eAAevC,EAAI3iC,EAAEslC,iBAAiB,GACpDxzB,EAAQkpB,sBAAwB,SAMhCgJ,EAAY,cAAe,SAASrB,EAAI3iC,EAAEslC,0BAEnB3C,EAAI3iC,EAAEslC,sBAG7BtB,EAAY,mBAAoB,SAASrB,EAAI3iC,EAAEulC,+BAEnB5C,EAAI3iC,EAAEulC,2BAIlCvB,EAAY,OAAQ,mBAEpBA,EAAY,OAAQ,6BACpBA,EAAY,UAAW,8B,kBCvNvB,MAAM1B,EAAU3vB,EAAQ,OAExBd,EAAOC,QADKywB,CAAC18C,EAASw+B,EAAO9jB,IAAY+hC,EAAQz8C,EAASw+B,EAAO,IAAK9jB,E,kBCFtE,MAAMm5B,EAAQ/mB,EAAQ,OAMtBd,EAAOC,QALY2nB,CAACkM,EAAIC,EAAIrlC,KAC1BolC,EAAK,IAAIjM,EAAMiM,EAAIplC,GACnBqlC,EAAK,IAAIlM,EAAMkM,EAAIrlC,GACZolC,EAAGlM,WAAWmM,EAAIrlC,G,kBCJ3B,MAAM+hC,EAAU3vB,EAAQ,OAGxBd,EAAOC,QADK0wB,CAAC38C,EAASw+B,EAAO9jB,IAAY+hC,EAAQz8C,EAASw+B,EAAO,IAAK9jB,E,kBCFtE,MAAM84B,EAAS1mB,EAAQ,OACjB+mB,EAAQ/mB,EAAQ,OAuBtBd,EAAOC,QArBeowB,CAAC2D,EAAUxhB,EAAO9jB,KACtC,IAAIqX,EAAM,KACNkuB,EAAQ,KACRC,EAAW,KACf,IACEA,EAAW,IAAIrM,EAAMrV,EAAO9jB,EAC9B,CAAE,MAAOg5B,GACP,OAAO,IACT,CAWA,OAVAsM,EAASphD,SAAS6S,IACZyuC,EAASzM,KAAKhiC,KAEXsgB,IAA6B,IAAtBkuB,EAAM3jC,QAAQ7K,KAExBsgB,EAAMtgB,EACNwuC,EAAQ,IAAIzM,EAAOzhB,EAAKrX,IAE5B,IAEKqX,CAAG,C,kBCtBZ,MAAMyhB,EAAS1mB,EAAQ,OACjB+mB,EAAQ/mB,EAAQ,OAsBtBd,EAAOC,QArBeqwB,CAAC0D,EAAUxhB,EAAO9jB,KACtC,IAAI4J,EAAM,KACN67B,EAAQ,KACRD,EAAW,KACf,IACEA,EAAW,IAAIrM,EAAMrV,EAAO9jB,EAC9B,CAAE,MAAOg5B,GACP,OAAO,IACT,CAWA,OAVAsM,EAASphD,SAAS6S,IACZyuC,EAASzM,KAAKhiC,KAEX6S,GAA4B,IAArB67B,EAAM7jC,QAAQ7K,KAExB6S,EAAM7S,EACN0uC,EAAQ,IAAI3M,EAAOlvB,EAAK5J,IAE5B,IAEK4J,CAAG,C,kBCrBZ,MAAMkvB,EAAS1mB,EAAQ,OACjB+mB,EAAQ/mB,EAAQ,OAChBktB,EAAKltB,EAAQ,OA0DnBd,EAAOC,QAxDYswB,CAAC/d,EAAOyU,KACzBzU,EAAQ,IAAIqV,EAAMrV,EAAOyU,GAEzB,IAAImN,EAAS,IAAI5M,EAAO,SACxB,GAAIhV,EAAMiV,KAAK2M,GACb,OAAOA,EAIT,GADAA,EAAS,IAAI5M,EAAO,WAChBhV,EAAMiV,KAAK2M,GACb,OAAOA,EAGTA,EAAS,KACT,IAAK,IAAIz/C,EAAI,EAAGA,EAAI69B,EAAM9sB,IAAI/S,SAAUgC,EAAG,CACzC,MAAMi1C,EAAcpX,EAAM9sB,IAAI/Q,GAE9B,IAAI0/C,EAAS,KACbzK,EAAYh3C,SAAS0hD,IAEnB,MAAMC,EAAU,IAAI/M,EAAO8M,EAAW1hC,OAAO5e,SAC7C,OAAQsgD,EAAWlN,UACjB,IAAK,IAC+B,IAA9BmN,EAAQ7H,WAAW/5C,OACrB4hD,EAAQzH,QAERyH,EAAQ7H,WAAWv3C,KAAK,GAE1Bo/C,EAAQrM,IAAMqM,EAAQpqC,SAExB,IAAK,GACL,IAAK,KACEkqC,IAAUrG,EAAGuG,EAASF,KACzBA,EAASE,GAEX,MACF,IAAK,IACL,IAAK,KAEH,MAEF,QACE,MAAM,IAAIjgD,MAAM,yBAAyBggD,EAAWlN,YACxD,KAEEiN,GAAYD,IAAUpG,EAAGoG,EAAQC,KACnCD,EAASC,EAEb,CAEA,OAAID,GAAU5hB,EAAMiV,KAAK2M,GAChBA,EAGF,IAAI,C,kBC1Db,MAAM5M,EAAS1mB,EAAQ,OACjBgmB,EAAahmB,EAAQ,QACrB,IAAE8lB,GAAQE,EACVe,EAAQ/mB,EAAQ,OAChBivB,EAAYjvB,EAAQ,OACpBktB,EAAKltB,EAAQ,OACbotB,EAAKptB,EAAQ,OACbqtB,EAAMrtB,EAAQ,OACdmtB,EAAMntB,EAAQ,MAuEpBd,EAAOC,QArESwwB,CAACz8C,EAASw+B,EAAOgiB,EAAM9lC,KAIrC,IAAI+lC,EAAMC,EAAOC,EAAM5N,EAAM6N,EAC7B,OAJA5gD,EAAU,IAAIwzC,EAAOxzC,EAAS0a,GAC9B8jB,EAAQ,IAAIqV,EAAMrV,EAAO9jB,GAGjB8lC,GACN,IAAK,IACHC,EAAOzG,EACP0G,EAAQvG,EACRwG,EAAOzG,EACPnH,EAAO,IACP6N,EAAQ,KACR,MACF,IAAK,IACHH,EAAOvG,EACPwG,EAAQzG,EACR0G,EAAO3G,EACPjH,EAAO,IACP6N,EAAQ,KACR,MACF,QACE,MAAM,IAAIn2B,UAAU,yCAIxB,GAAIsxB,EAAU/7C,EAASw+B,EAAO9jB,GAC5B,OAAO,EAMT,IAAK,IAAI/Z,EAAI,EAAGA,EAAI69B,EAAM9sB,IAAI/S,SAAUgC,EAAG,CACzC,MAAMi1C,EAAcpX,EAAM9sB,IAAI/Q,GAE9B,IAAIkgD,EAAO,KACPC,EAAM,KAiBV,GAfAlL,EAAYh3C,SAAS0hD,IACfA,EAAW1hC,SAAWg0B,IACxB0N,EAAa,IAAIxN,EAAW,YAE9B+N,EAAOA,GAAQP,EACfQ,EAAMA,GAAOR,EACTG,EAAKH,EAAW1hC,OAAQiiC,EAAKjiC,OAAQlE,GACvCmmC,EAAOP,EACEK,EAAKL,EAAW1hC,OAAQkiC,EAAIliC,OAAQlE,KAC7ComC,EAAMR,EACR,IAKEO,EAAKzN,WAAaL,GAAQ8N,EAAKzN,WAAawN,EAC9C,OAAO,EAKT,KAAME,EAAI1N,UAAY0N,EAAI1N,WAAaL,IACnC2N,EAAM1gD,EAAS8gD,EAAIliC,QACrB,OAAO,EACF,GAAIkiC,EAAI1N,WAAawN,GAASD,EAAK3gD,EAAS8gD,EAAIliC,QACrD,OAAO,CAEX,CACA,OAAO,CAAI,C,kBCzEb,MAAMm9B,EAAYjvB,EAAQ,OACpBxQ,EAAUwQ,EAAQ,OACxBd,EAAOC,QAAU,CAAC+zB,EAAUxhB,EAAO9jB,KACjC,MAAMhJ,EAAM,GACZ,IAAI4iC,EAAQ,KACRyM,EAAO,KACX,MAAMtvC,EAAIuuC,EAAS/8B,MAAK,CAAC8N,EAAG9vB,IAAMqb,EAAQyU,EAAG9vB,EAAGyZ,KAChD,IAAK,MAAM1a,KAAWyR,EAAG,CACNsqC,EAAU/7C,EAASw+B,EAAO9jB,IAEzCqmC,EAAO/gD,EACFs0C,IACHA,EAAQt0C,KAGN+gD,GACFrvC,EAAIvQ,KAAK,CAACmzC,EAAOyM,IAEnBA,EAAO,KACPzM,EAAQ,KAEZ,CACIA,GACF5iC,EAAIvQ,KAAK,CAACmzC,EAAO,OAGnB,MAAM0M,EAAS,GACf,IAAK,MAAO18B,EAAKyN,KAAQrgB,EACnB4S,IAAQyN,EACVivB,EAAO7/C,KAAKmjB,GACFyN,GAAOzN,IAAQ7S,EAAE,GAEjBsgB,EAEDzN,IAAQ7S,EAAE,GACnBuvC,EAAO7/C,KAAK,KAAK4wB,KAEjBivB,EAAO7/C,KAAK,GAAGmjB,OAASyN,KAJxBivB,EAAO7/C,KAAK,KAAKmjB,KAFjB08B,EAAO7/C,KAAK,KAShB,MAAM8/C,EAAaD,EAAOxnB,KAAK,QACzB0nB,EAAgC,kBAAd1iB,EAAM0V,IAAmB1V,EAAM0V,IAAMtb,OAAO4F,GACpE,OAAOyiB,EAAWtiD,OAASuiD,EAASviD,OAASsiD,EAAaziB,CAAK,C,kBC7CjE,MAAMqV,EAAQ/mB,EAAQ,OAChBgmB,EAAahmB,EAAQ,QACrB,IAAE8lB,GAAQE,EACViJ,EAAYjvB,EAAQ,OACpBxQ,EAAUwQ,EAAQ,OAkElBq0B,EAA+B,CAAC,IAAIrO,EAAW,cAC/CsO,EAAiB,CAAC,IAAItO,EAAW,YAEjCuO,EAAeA,CAACC,EAAKC,EAAK7mC,KAC9B,GAAI4mC,IAAQC,EACV,OAAO,EAGT,GAAmB,IAAfD,EAAI3iD,QAAgB2iD,EAAI,GAAG1iC,SAAWg0B,EAAK,CAC7C,GAAmB,IAAf2O,EAAI5iD,QAAgB4iD,EAAI,GAAG3iC,SAAWg0B,EACxC,OAAO,EAEP0O,EADS5mC,EAAQo5B,kBACXqN,EAEAC,CAEV,CAEA,GAAmB,IAAfG,EAAI5iD,QAAgB4iD,EAAI,GAAG3iC,SAAWg0B,EAAK,CAC7C,GAAIl4B,EAAQo5B,kBACV,OAAO,EAEPyN,EAAMH,CAEV,CAEA,MAAMI,EAAQ,IAAItnC,IAClB,IAAI8/B,EAAIE,EAeJuH,EA6BAC,EAAQC,EACRC,EAAUC,EA5Cd,IAAK,MAAM/2B,KAAKw2B,EACK,MAAfx2B,EAAEsoB,UAAmC,OAAftoB,EAAEsoB,SAC1B4G,EAAK8H,EAAS9H,EAAIlvB,EAAGpQ,GACG,MAAfoQ,EAAEsoB,UAAmC,OAAftoB,EAAEsoB,SACjC8G,EAAK6H,EAAQ7H,EAAIpvB,EAAGpQ,GAEpB8mC,EAAMQ,IAAIl3B,EAAElM,QAIhB,GAAI4iC,EAAMh6C,KAAO,EACf,OAAO,KAIT,GAAIwyC,GAAME,EAAI,CAEZ,GADAuH,EAAWnlC,EAAQ09B,EAAGp7B,OAAQs7B,EAAGt7B,OAAQlE,GACrC+mC,EAAW,EACb,OAAO,KACF,GAAiB,IAAbA,IAAmC,OAAhBzH,EAAG5G,UAAqC,OAAhB8G,EAAG9G,UACvD,OAAO,IAEX,CAGA,IAAK,MAAM0G,KAAM0H,EAAO,CACtB,GAAIxH,IAAO+B,EAAUjC,EAAIlhB,OAAOohB,GAAKt/B,GACnC,OAAO,KAGT,GAAIw/B,IAAO6B,EAAUjC,EAAIlhB,OAAOshB,GAAKx/B,GACnC,OAAO,KAGT,IAAK,MAAMoQ,KAAKy2B,EACd,IAAKxF,EAAUjC,EAAIlhB,OAAO9N,GAAIpQ,GAC5B,OAAO,EAIX,OAAO,CACT,CAMA,IAAIunC,KAAe/H,GAChBx/B,EAAQo5B,oBACToG,EAAGt7B,OAAO85B,WAAW/5C,SAASu7C,EAAGt7B,OAC/BsjC,KAAelI,GAChBt/B,EAAQo5B,oBACTkG,EAAGp7B,OAAO85B,WAAW/5C,SAASq7C,EAAGp7B,OAE/BqjC,GAAmD,IAAnCA,EAAavJ,WAAW/5C,QACxB,MAAhBu7C,EAAG9G,UAAmD,IAA/B6O,EAAavJ,WAAW,KACjDuJ,GAAe,GAGjB,IAAK,MAAMn3B,KAAKy2B,EAAK,CAGnB,GAFAM,EAAWA,GAA2B,MAAf/2B,EAAEsoB,UAAmC,OAAftoB,EAAEsoB,SAC/CwO,EAAWA,GAA2B,MAAf92B,EAAEsoB,UAAmC,OAAftoB,EAAEsoB,SAC3C4G,EASF,GARIkI,GACEp3B,EAAElM,OAAO85B,YAAc5tB,EAAElM,OAAO85B,WAAW/5C,QAC3CmsB,EAAElM,OAAOg6B,QAAUsJ,EAAatJ,OAChC9tB,EAAElM,OAAOi6B,QAAUqJ,EAAarJ,OAChC/tB,EAAElM,OAAOk6B,QAAUoJ,EAAapJ,QAClCoJ,GAAe,GAGA,MAAfp3B,EAAEsoB,UAAmC,OAAftoB,EAAEsoB,UAE1B,GADAsO,EAASI,EAAS9H,EAAIlvB,EAAGpQ,GACrBgnC,IAAW52B,GAAK42B,IAAW1H,EAC7B,OAAO,OAEJ,GAAoB,OAAhBA,EAAG5G,WAAsB2I,EAAU/B,EAAGp7B,OAAQga,OAAO9N,GAAIpQ,GAClE,OAAO,EAGX,GAAIw/B,EASF,GARI+H,GACEn3B,EAAElM,OAAO85B,YAAc5tB,EAAElM,OAAO85B,WAAW/5C,QAC3CmsB,EAAElM,OAAOg6B,QAAUqJ,EAAarJ,OAChC9tB,EAAElM,OAAOi6B,QAAUoJ,EAAapJ,OAChC/tB,EAAElM,OAAOk6B,QAAUmJ,EAAanJ,QAClCmJ,GAAe,GAGA,MAAfn3B,EAAEsoB,UAAmC,OAAftoB,EAAEsoB,UAE1B,GADAuO,EAAQI,EAAQ7H,EAAIpvB,EAAGpQ,GACnBinC,IAAU72B,GAAK62B,IAAUzH,EAC3B,OAAO,OAEJ,GAAoB,OAAhBA,EAAG9G,WAAsB2I,EAAU7B,EAAGt7B,OAAQga,OAAO9N,GAAIpQ,GAClE,OAAO,EAGX,IAAKoQ,EAAEsoB,WAAa8G,GAAMF,IAAoB,IAAbyH,EAC/B,OAAO,CAEX,CAKA,QAAIzH,GAAM4H,IAAa1H,GAAmB,IAAbuH,OAIzBvH,GAAM2H,IAAa7H,GAAmB,IAAbyH,MAOzBS,IAAgBD,GAIT,EAIPH,EAAWA,CAAC/wB,EAAG9vB,EAAGyZ,KACtB,IAAKqW,EACH,OAAO9vB,EAET,MAAM8xC,EAAOz2B,EAAQyU,EAAEnS,OAAQ3d,EAAE2d,OAAQlE,GACzC,OAAOq4B,EAAO,EAAIhiB,EACdgiB,EAAO,GACQ,MAAf9xC,EAAEmyC,UAAmC,OAAfriB,EAAEqiB,SADbnyC,EAEX8vB,CAAC,EAIDgxB,EAAUA,CAAChxB,EAAG9vB,EAAGyZ,KACrB,IAAKqW,EACH,OAAO9vB,EAET,MAAM8xC,EAAOz2B,EAAQyU,EAAEnS,OAAQ3d,EAAE2d,OAAQlE,GACzC,OAAOq4B,EAAO,EAAIhiB,EACdgiB,EAAO,GACQ,MAAf9xC,EAAEmyC,UAAmC,OAAfriB,EAAEqiB,SADbnyC,EAEX8vB,CAAC,EAGP/E,EAAOC,QA5MQ4wB,CAACyE,EAAKC,EAAK7mC,EAAU,CAAC,KACnC,GAAI4mC,IAAQC,EACV,OAAO,EAGTD,EAAM,IAAIzN,EAAMyN,EAAK5mC,GACrB6mC,EAAM,IAAI1N,EAAM0N,EAAK7mC,GACrB,IAAIynC,GAAa,EAEjBC,EAAO,IAAK,MAAMC,KAAaf,EAAI5vC,IAAK,CACtC,IAAK,MAAM4wC,KAAaf,EAAI7vC,IAAK,CAC/B,MAAM6wC,EAAQlB,EAAagB,EAAWC,EAAW5nC,GAEjD,GADAynC,EAAaA,GAAwB,OAAVI,EACvBA,EACF,SAASH,CAEb,CAKA,GAAID,EACF,OAAO,CAEX,CACA,OAAO,CAAI,C,kBCnEb,MAAMtO,EAAQ/mB,EAAQ,OAOtBd,EAAOC,QAJemwB,CAAC5d,EAAO9jB,IAC5B,IAAIm5B,EAAMrV,EAAO9jB,GAAShJ,IACvB9H,KAAImpC,GAAQA,EAAKnpC,KAAIkhB,GAAKA,EAAEpqB,QAAO84B,KAAK,KAAK0Z,OAAO5nB,MAAM,M,kBCL/D,MAAMuoB,EAAQ/mB,EAAQ,OAUtBd,EAAOC,QATYuwB,CAAChe,EAAO9jB,KACzB,IAGE,OAAO,IAAIm5B,EAAMrV,EAAO9jB,GAAS8jB,OAAS,GAC5C,CAAE,MAAOkV,GACP,OAAO,IACT,E,0DC0BF,IAAIiD,EAAK,EACT,MAAM6L,EAA4B,GAQrBviC,EAAMA,CAACqgB,EAAe/mB,EAAkBpG,KACnD,MAAMooB,EAAW,CACf+E,OACAqW,GAAI/d,SAAS+d,GACbxlB,KAAM,IAAIhS,MAER5F,IAASgiB,EAAIhiB,QAAUA,GACvBpG,IAAMooB,EAAIpoB,KAAOA,GACrBsvC,EAASlnB,EAAI,EA4CT,MAAOmnB,EACX7hD,WAAAA,CACUy/B,EACAqiB,GADA,KAAAriB,KAAAA,EACA,KAAAqiB,QAAAA,CACP,CAEHC,KAAAA,CAAMrpC,EAAiBpG,GAvCJyvC,GACnBtiB,OACA/mB,UACApG,OACAwvC,cAOA,MAAMpnB,EAAW,CACf+E,OACAqW,GAAI/d,SAAS+d,GACbxlB,KAAM,IAAIhS,MAGR5F,IAASgiB,EAAIhiB,QAAUA,GACvBpG,IAAMooB,EAAIpoB,KAAOA,GACjBwvC,IAASpnB,EAAIonB,QAAUA,GAE3BF,EAASlnB,EAAI,EAmBXqnB,CAAM,CACJtiB,KAAMp/B,KAAKo/B,KACX/mB,UACApG,OACAwvC,QAASzhD,KAAKyhD,SAElB,CAEAE,UAAAA,GACE,OAAO3hD,KAAKyhD,OACd,CAEAG,UAAAA,CAAWH,GACTzhD,KAAKyhD,QAAUA,CACjB,CAEAI,aAAAA,CAAcC,GACZ9hD,KAAKyhD,QAAOjwC,OAAAC,OAAAD,OAAAC,OAAA,GAAQzR,KAAKyhD,SAAYK,EACvC,CAEAC,OAAAA,GACE,OAAO/hD,KAAKo/B,IACd,CAEA4iB,OAAAA,CAAQ5iB,GACNp/B,KAAKo/B,KAAOA,CACd,CAQA6iB,QAAAA,CAAS7iB,GACP,OAAO,IAAIoiB,EAAYpiB,EAAMp/B,KAAKyhD,QACpC,CAUAS,WAAAA,CAAYT,GACV,OAAO,IAAID,EAAYxhD,KAAKo/B,KAAMqiB,EACpC,CASAU,kBAAAA,CAAmBL,GACjB,OAAO,IAAIN,EAAYxhD,KAAKo/B,KAAI5tB,OAAAC,OAAAD,OAAAC,OAAA,GAAOzR,KAAKyhD,SAAYK,GAC1D,EASK,MAAMM,EAAUC,IACrBf,EAAYrhD,KAAKoiD,GACV,KACL,MAAM5iD,EAAI6hD,EAAYhd,QAAQ+d,IAEnB,IAAP5iD,IAEF6hD,EAAY7hD,GAAK6hD,EAAYA,EAAY7jD,OAAS,GAClD6jD,EAAY7sB,M,GAKlB,SAAS8sB,EAASxiC,GAChB,IAAK,IAAItf,EAAI,EAAGA,EAAI6hD,EAAY7jD,OAAQgC,IACtC,IACE6hD,EAAY7hD,GAAGsf,E,CACf,MAAOnB,GACP0K,QAAQg0B,MAAM1+B,E,CAGpB,CAUsB,qBAAX0kC,SACTA,OAAOC,mBAAqBH,E,YCrM9B,MAAMI,EAAW,WAEjB,IAAIC,EAAU,SAAU1kD,GACtB,IAAKstB,MAAMC,QAAQvtB,GACjB,MAAM,IAAIqB,MAAM,0BAElB,GAAoB,IAAhBrB,EAAKN,OACP,MAAM,IAAI2B,MAAM,wCAElB,IAAK,IAAIK,EAAI,EAAGA,EAAI1B,EAAKN,OAAQgC,IAC/B,GAAuB,kBAAZ1B,EAAK0B,GACd,MAAM,IAAIL,MAAM,gCAGpBY,KAAKjC,KAAOA,CACd,EAEA0kD,EAAQC,kBAAoB,SAAU3kD,GACpC,IAEE,OADA0kD,EAAQE,cAAc5kD,IACf,CACT,CAAE,MAAO6f,GACP,OAAO,CACT,CACF,EAEA6kC,EAAQG,eAAiB,SAAUrd,EAAMsd,GACvC,IAEE,OADAJ,EAAQK,WAAWvd,EAAMsd,IAClB,CACT,CAAE,MAAOjlC,GACP,OAAO,CACT,CACF,EAEA6kC,EAAQE,cAAgB,SAAU5kD,GAChC,OAAO,IAAI0kD,EAAQ1kD,EACrB,EAEA0kD,EAAQK,WAAa,SAAUvd,EAAMsd,GAEnC,GAAI,QAAQtQ,KAAKhN,GACfA,EAAOA,EAAK7mC,MAAM,QACb,GAAImkD,EACT,MAAM,IAAIzjD,MAAM,4BAKlB,IAFA,IAAIrB,EAAOwnC,EAAKnb,MAAM,KAClBlD,EAAM,IAAImE,MAAMttB,EAAKN,QAChBgC,EAAI,EAAGA,EAAI1B,EAAKN,OAAQgC,IAAK,CACpC,IAAIwxB,EAAM,iBAAiBuoB,KAAKz7C,EAAK0B,IACrC,GAAY,OAARwxB,EACF,MAAM,IAAI7xB,MAAM,iBAIlB,GAFA8nB,EAAIznB,GAAKsjD,SAAS9xB,EAAI,GAAI,IAEtB/J,EAAIznB,IAAM+iD,EACZ,MAAM,IAAIpjD,MAAM,uBAGlB,GAAe,MAAX6xB,EAAI,IAAyB,MAAXA,EAAI,IAAyB,MAAXA,EAAI,GAC1C/J,EAAIznB,IAAM+iD,OACL,GAAqB,GAAjBvxB,EAAI,GAAGxzB,OAChB,MAAM,IAAI2B,MAAM,mBAEpB,CACA,OAAO,IAAIqjD,EAAQv7B,EACrB,EAEAu7B,EAAQO,UAAU3kD,YAAc,WAC9B,OAAO2B,KAAKjC,IACd,EAEA0kD,EAAQO,UAAU5kD,SAAW,SAAU6kD,EAAQC,GAE7C,IADA,IAAIh8B,EAAM,IAAImE,MAAMrrB,KAAKjC,KAAKN,QACrBgC,EAAI,EAAGA,EAAIO,KAAKjC,KAAKN,OAAQgC,IAAK,CACzC,IAAIwxB,EAAMjxB,KAAKjC,KAAK0B,GAElBynB,EAAIznB,GADFwxB,EAAMuxB,GACEvxB,GAAOuxB,IAAaU,EAAW,IAAM,KAEtCjyB,CAEb,CACA,OAAQgyB,EAAS,GAAK,MAAQ/7B,EAAIoR,KAAK,IACzC,EAEAmqB,EAAQO,UAAUG,QAAU,WAC1B,MAAO,YAAcnjD,KAAK5B,WAAa,GACzC,EAEA0sB,EAAOC,QAAU03B,C,+BC7FjB,IAAIrR,EAASxlB,EAAQ,OACjBruB,EAASquB,EAAAA,MAAAA,OAEbd,EAAOC,QAAU,SAAUsmB,GAWzB,SAASC,EAAWh0C,GAClB,IAAI4uB,EAAU5uB,EAAOoB,MAAM,GAAI,GAC3B6hB,EAAWjjB,EAAOoB,OAAO,GACzB6yC,EAAcF,EAAWnlB,GAE7B,KAAI3L,EAAS,GAAKgxB,EAAY,GAC1BhxB,EAAS,GAAKgxB,EAAY,GAC1BhxB,EAAS,GAAKgxB,EAAY,GAC1BhxB,EAAS,GAAKgxB,EAAY,IAE9B,OAAOrlB,CACT,CAiBA,MAAO,CACLf,OAtCF,SAAiBe,GACf,IAAI3L,EAAW8wB,EAAWnlB,GAE1B,OAAOklB,EAAOjmB,OAAO5tB,EAAOuD,OAAO,CACjCorB,EACA3L,GACC2L,EAAQzuB,OAAS,GACtB,EAgCEytB,OATF,SAAiBsmB,GACf,IACItlB,EAAUolB,EADDF,EAAOlmB,OAAOsmB,IAE3B,IAAKtlB,EAAS,MAAM,IAAI9sB,MAAM,oBAC9B,OAAO8sB,CACT,EAKElB,aAjBF,SAAuBwmB,GACrB,IAAIl0C,EAAS8zC,EAAOpmB,aAAawmB,GACjC,GAAKl0C,EAEL,OAAOg0C,EAAUh0C,EACnB,EAcF,C,+BC/CA,IAAIk1B,EAAa5G,EAAQ,OACrB6lB,EAAgB7lB,EAAQ,OAQ5Bd,EAAOC,QAAU0mB,GALjB,SAAmBn0C,GACjB,IAAI2zB,EAAMuB,EAAW,UAAUpwB,OAAO9E,GAAQgF,SAC9C,OAAOkwB,EAAW,UAAUpwB,OAAO6uB,GAAK3uB,QAC1C,G,qDCRAkP,OAAOka,eAAeX,EAAS,aAAc,CAAEvrB,OAAO,IACtD,MAAMoF,EAASgnB,EAAQ,OACjBntB,EAAYmtB,EAAQ,OACpBiH,EAAMjH,EAAQ,OACdI,EAAYJ,EAAQ,MACpBmH,EAAMnH,EAAQ,MACdw3B,EAAep3B,EAAU2L,QAAQ,IACjC0rB,EAAer3B,EAAUkH,QAAQ,CACnCH,IAAK/G,EAAUO,MACf0I,MAAO,CACHC,OAAQlJ,EAAUoF,OAClB+D,QAASnJ,EAAUoF,UAGrBkyB,EAAU,CACZtuB,cAAe,gCACf3b,OAAQ,KACR4b,MAAO,CACHC,OAAQ,SACRC,QAAS,UAEbjI,WAAY,EACZ7nB,WAAY,EACZ0tB,IAAK,KAEHwwB,EAAc,WACd3S,EAAa5pC,KAAK6pC,IAAI,EAAG,IAAM,EACrC,SAASC,EAAUtxC,GACf,OAAQwsB,EAAU0L,OAAOl4B,IAAqD,OAA3CA,EAAM6tC,MAAM,0BACnD,CACA,SAAS0D,EAAOvxC,GACZ,OAAOwsB,EAAUoF,OAAO5xB,IAAUA,GAASoxC,CAC/C,CACA,MAAM4S,EACF7jD,WAAAA,CAAY4zB,EAAKC,EAAKle,EAAWqX,EAAS82B,EAAU,EAAGC,EAAU,EAAGC,EAAuB,GACvF3jD,KAAKuzB,IAAMA,EACXvzB,KAAKwzB,IAAMA,EACXxzB,KAAKsV,UAAYA,EACjBtV,KAAK2sB,QAAUA,EACf3sB,KAAKyjD,QAAUA,EACfzjD,KAAK0jD,QAAUA,EACf1jD,KAAK2jD,qBAAuBA,EAC5B33B,EAAUq3B,EAAc12B,GACxB3sB,KAAKyzB,MAAO,CAChB,CACA,SAAIxT,GACA,OAAOjgB,KAAKyjD,OAChB,CACA,SAAI7lD,GACA,OAAOoC,KAAK0jD,OAChB,CACA,qBAAIxjC,GACA,OAAOlgB,KAAK2jD,oBAChB,CACA,aAAIxuC,GAGA,YAFiBvO,IAAb5G,KAAKwzB,MACLxzB,KAAKwzB,IAAMX,EAAIc,gBAAgB3zB,KAAKuzB,KAAK,IACtCvzB,KAAKwzB,GAChB,CACA,cAAIE,GACA,OAAO1zB,KAAKuzB,GAChB,CACA,cAAIglB,GACA,OAAO3zC,EAAO+tB,QAAQ3yB,KAAKmV,UAC/B,CACA,eAAIxF,GACA,OAAO3P,KAAKu4C,WAAW75C,MAAM,EAAG,EACpC,CACA,cAAIy0B,GACA,OAAO,CACX,CAGAywB,UAAAA,GACI,YAAoBh9C,IAAb5G,KAAKuzB,GAChB,CACAswB,QAAAA,GACI,OAAOC,EAAmB9jD,KAAKmV,UAAWnV,KAAKsV,UAAWtV,KAAK2sB,QAAS3sB,KAAKigB,MAAOjgB,KAAKpC,MAAOoC,KAAKkgB,kBACzG,CACA6jC,QAAAA,GACI,MAAMp3B,EAAU3sB,KAAK2sB,QACf7tB,EAAWkB,KAAK4jD,aAEhBj3B,EAAQsI,MAAMC,OADdvI,EAAQsI,MAAME,QAEd73B,EAASC,EAAOujB,YAAY,IAuBlC,OArBAxjB,EAAOO,cAAciB,EAAS,GAE9BxB,EAAO4C,WAAWF,KAAKigB,MAAO,GAE9B3iB,EAAOO,cAAcmC,KAAKkgB,kBAAmB,GAG7C5iB,EAAOO,cAAcmC,KAAKpC,MAAO,GAEjCoC,KAAKsV,UAAUpF,KAAK5S,EAAQ,IAEvB0C,KAAK4jD,aAQN5jD,KAAKmV,UAAUjF,KAAK5S,EAAQ,KAN5BA,EAAO4C,WAAW,EAAG,IACrBF,KAAK0zB,WAAWxjB,KAAK5S,EAAQ,KAO1BmB,EAAU0sB,OAAO7tB,EAC5B,CACAs2B,KAAAA,GACI,IAAK5zB,KAAK0zB,WACN,MAAM,IAAInK,UAAU,uBACxB,OAAOwJ,EAAI5H,OAAOnrB,KAAK2sB,QAAQoG,IAAK/yB,KAAK0zB,YAAY,EACzD,CAEAswB,MAAAA,CAAOpmD,GACHouB,EAAUA,EAAUoF,OAAQxzB,GAC5B,MAAMqmD,EAAarmD,GAAS2lD,EACtBtxC,EAAO1U,EAAOujB,YAAY,IAEhC,GAAImjC,EAAY,CACZ,GAAIjkD,KAAK4jD,aACL,MAAM,IAAIr6B,UAAU,8CAExBtX,EAAK,GAAK,EACVjS,KAAK0zB,WAAWxjB,KAAK+B,EAAM,GAC3BA,EAAKpU,cAAcD,EAAO,GAE9B,MAIIoC,KAAKmV,UAAUjF,KAAK+B,EAAM,GAC1BA,EAAKpU,cAAcD,EAAO,IAE9B,MAAMsmD,EAAIt/C,EAAOu/C,WAAWnkD,KAAKsV,UAAWrD,GACtCmyC,EAAKF,EAAExlD,MAAM,EAAG,IAChB2lD,EAAKH,EAAExlD,MAAM,IAEnB,IAAKm0B,EAAIsB,UAAUiwB,GACf,OAAOpkD,KAAKgkD,OAAOpmD,EAAQ,GAE/B,IAAI0mD,EACJ,GAAKtkD,KAAK4jD,aASL,CAGD,MAAMW,EAAK1xB,EAAI5tB,eAAejF,KAAKmV,UAAWivC,GAAI,GAElD,GAAW,OAAPG,EACA,OAAOvkD,KAAKgkD,OAAOpmD,EAAQ,GAC/B0mD,EAAKR,EAAmBS,EAAIF,EAAIrkD,KAAK2sB,QAAS3sB,KAAKigB,MAAQ,EAAGriB,EAAOoC,KAAK2P,YAAY5Q,aAAa,GACvG,KAjBwB,CAEpB,MAAMylD,EAAK3xB,EAAI4xB,WAAWzkD,KAAK0zB,WAAY0wB,GAE3C,GAAU,MAANI,EACA,OAAOxkD,KAAKgkD,OAAOpmD,EAAQ,GAC/B0mD,EAAKI,EAAoBF,EAAIH,EAAIrkD,KAAK2sB,QAAS3sB,KAAKigB,MAAQ,EAAGriB,EAAOoC,KAAK2P,YAAY5Q,aAAa,GAExG,CAUA,OAAOulD,CACX,CACAK,cAAAA,CAAe/mD,GAGX,OAFAouB,EAAU+kB,EAAQnzC,GAEXoC,KAAKgkD,OAAOpmD,EAAQ2lD,EAC/B,CACA9f,UAAAA,CAAW1lC,GACPiuB,EAAU8kB,EAAW/yC,GACrB,IAAI6mD,EAAY7mD,EAAKqsB,MAAM,KAC3B,GAAqB,MAAjBw6B,EAAU,GAAY,CACtB,GAAI5kD,KAAKkgB,kBACL,MAAM,IAAIqJ,UAAU,8BACxBq7B,EAAYA,EAAUlmD,MAAM,EAChC,CACA,OAAOkmD,EAAUh1B,QAAO,CAACi1B,EAAQC,KAC7B,IAAIlnD,EACJ,MAA2B,MAAvBknD,EAASpmD,OAAO,IAChBd,EAAQmlD,SAAS+B,EAASpmD,MAAM,GAAI,GAAI,IACjCmmD,EAAOF,eAAe/mD,KAG7BA,EAAQmlD,SAAS+B,EAAU,IACpBD,EAAOb,OAAOpmD,GACzB,GACDoC,KACP,CACA6zB,IAAAA,CAAKxtB,EAAMotB,GACP,IAAKzzB,KAAK0zB,WACN,MAAM,IAAIt0B,MAAM,uBAGpB,QAFawH,IAAT6sB,IACAA,EAAOzzB,KAAKyzB,OACH,IAATA,EACA,OAAOZ,EAAIgB,KAAKxtB,EAAMrG,KAAK0zB,YAE1B,CACD,IAAIrlB,EAAMwkB,EAAIgB,KAAKxtB,EAAMrG,KAAK0zB,YAC9B,MAAMjgB,EAAYlW,EAAOC,MAAM,GAAI,GACnC,IAAIs2B,EAAU,EAGd,KAAOzlB,EAAI,GAAK,KACZylB,IACArgB,EAAUsgB,YAAYD,EAAS,EAAG,GAClCzlB,EAAMwkB,EAAImB,gBAAgB3tB,EAAMrG,KAAK0zB,WAAYjgB,GAErD,OAAOpF,CACX,CACJ,CACAuG,MAAAA,CAAOvO,EAAM4F,GACT,OAAO4mB,EAAIje,OAAOvO,EAAMrG,KAAKmV,UAAWlJ,EAC5C,EA0CJ,SAASgoB,EAAeP,EAAYpe,EAAWqX,GAC3C,OAAO+3B,EAAoBhxB,EAAYpe,EAAWqX,EACtD,CAEA,SAAS+3B,EAAoBhxB,EAAYpe,EAAWqX,EAAS1M,EAAOriB,EAAOsiB,GAMvE,GALA8L,EAAU,CACN0H,WAAY0vB,EACZ9tC,UAAW8tC,GACZ,CAAE1vB,aAAYpe,cACjBqX,EAAUA,GAAW22B,GAChBzwB,EAAIsB,UAAUT,GACf,MAAM,IAAInK,UAAU,mCACxB,OAAO,IAAIi6B,EAAM9vB,OAAY9sB,EAAW0O,EAAWqX,EAAS1M,EAAOriB,EAAOsiB,EAC9E,CAKA,SAAS4jC,EAAmB3uC,EAAWG,EAAWqX,EAAS1M,EAAOriB,EAAOsiB,GAOrE,GANA8L,EAAU,CACN7W,UAAW6W,EAAU2L,QAAQ,IAC7BriB,UAAW8tC,GACZ,CAAEjuC,YAAWG,cAChBqX,EAAUA,GAAW22B,GAEhBzwB,EAAIwB,QAAQlf,GACb,MAAM,IAAIoU,UAAU,6BACxB,OAAO,IAAIi6B,OAAM58C,EAAWuO,EAAWG,EAAWqX,EAAS1M,EAAOriB,EAAOsiB,EAC7E,CA7BA6K,EAAQg6B,WAvCR,SAAoBC,EAAUr4B,GAC1B,MAAMrvB,EAASmB,EAAUysB,OAAO85B,GAChC,GAAsB,KAAlB1nD,EAAOG,OACP,MAAM,IAAI8rB,UAAU,yBACxBoD,EAAUA,GAAW22B,EAErB,MAAMxkD,EAAUxB,EAAOyB,aAAa,GACpC,GAAID,IAAY6tB,EAAQsI,MAAME,SAAWr2B,IAAY6tB,EAAQsI,MAAMC,OAC/D,MAAM,IAAI3L,UAAU,2BAExB,MAAMtJ,EAAQ3iB,EAAO,GAEf4iB,EAAoB5iB,EAAOyB,aAAa,GAC9C,GAAc,IAAVkhB,GAC0B,IAAtBC,EACA,MAAM,IAAIqJ,UAAU,8BAI5B,MAAM3rB,EAAQN,EAAOyB,aAAa,GAClC,GAAc,IAAVkhB,GAAyB,IAAVriB,EACf,MAAM,IAAI2rB,UAAU,iBAExB,MAAMjU,EAAYhY,EAAOoB,MAAM,GAAI,IACnC,IAAI4lD,EAEJ,GAAIxlD,IAAY6tB,EAAQsI,MAAME,QAAS,CACnC,GAA6B,IAAzB73B,EAAO4D,UAAU,IACjB,MAAM,IAAIqoB,UAAU,uBAExB+6B,EAAKI,EADKpnD,EAAOoB,MAAM,GAAI,IACC4W,EAAWqX,EAAS1M,EAAOriB,EAAOsiB,EAElE,KACK,CAEDokC,EAAKR,EADKxmD,EAAOoB,MAAM,GAAI,IACA4W,EAAWqX,EAAS1M,EAAOriB,EAAOsiB,EACjE,CACA,OAAOokC,CACX,EAKAv5B,EAAQkJ,eAAiBA,EAczBlJ,EAAQqJ,cAHR,SAAuBjf,EAAWG,EAAWqX,GACzC,OAAOm3B,EAAmB3uC,EAAWG,EAAWqX,EACpD,EAyBA5B,EAAQk6B,SAZR,SAAkBC,EAAMv4B,GAEpB,GADAX,EAAUA,EAAUzuB,OAAQ2nD,GACxBA,EAAKznD,OAAS,GACd,MAAM,IAAI8rB,UAAU,oCACxB,GAAI27B,EAAKznD,OAAS,GACd,MAAM,IAAI8rB,UAAU,mCACxBoD,EAAUA,GAAW22B,EACrB,MAAMY,EAAIt/C,EAAOu/C,WAAW5mD,EAAOqD,KAAK,eAAgB,QAASskD,GAGjE,OAAOjxB,EAFIiwB,EAAExlD,MAAM,EAAG,IACXwlD,EAAExlD,MAAM,IACWiuB,EAClC,C,+BCtSAnb,OAAOka,eAAeX,EAAS,aAAc,CAAEvrB,OAAO,IACtD,MAAMgzB,EAAa5G,EAAQ,OACrBu5B,EAAav5B,EAAQ,OAgB3Bb,EAAQ4H,QAfR,SAAiBr1B,GACb,MAAM8nD,EAAa5yB,EAAW,UACzBpwB,OAAO9E,GACPgF,SACL,IACI,OAAOkwB,EAAW,UACbpwB,OAAOgjD,GACP9iD,QACT,CACA,MAAOmwB,GACH,OAAOD,EAAW,aACbpwB,OAAOgjD,GACP9iD,QACT,CACJ,EAOAyoB,EAAQo5B,WALR,SAAoB97C,EAAK4J,GACrB,OAAOkzC,EAAW,SAAU98C,GACvBjG,OAAO6P,GACP3P,QACT,C,+BCvBAkP,OAAOka,eAAeX,EAAS,aAAc,CAAEvrB,OAAO,IACtD,IAAI6lD,EAAUz5B,EAAQ,OACtBb,EAAQk6B,SAAWI,EAAQJ,SAC3Bl6B,EAAQg6B,WAAaM,EAAQN,WAC7Bh6B,EAAQqJ,cAAgBixB,EAAQjxB,cAChCrJ,EAAQkJ,eAAiBoxB,EAAQpxB,c,kBCNjC,IAAIa,EAAMlJ,EAAQ,OAEdljB,EAAM,CAAC,EACX,IAAK,IAAIs/B,KAAMlT,EAAK,CAElBpsB,EADWosB,EAAIkT,IACHA,CACd,CAEAld,EAAOC,QAAUriB,C,yBCwCjBoiB,EAAOC,QA5BS,SAASu6B,EAAWrwC,EAAQ4a,EAAG9vB,EAAG6pB,EAAGgL,EAAGhX,EAAGgZ,GAOzD,IAAK0uB,EAAW,CACd,IAAIhJ,EACJ,QAAe11C,IAAXqO,EACFqnC,EAAQ,IAAIl9C,MACV,qIAGG,CACL,IAAIi9C,EAAO,CAACxsB,EAAG9vB,EAAG6pB,EAAGgL,EAAGhX,EAAGgZ,GACvB2uB,EAAW,GACfjJ,EAAQ,IAAIl9C,MACV6V,EAAOi+B,QAAQ,OAAO,WAAa,OAAOmJ,EAAKkJ,IAAa,MAExDtoC,KAAO,qBACf,CAGA,MADAq/B,EAAMkJ,YAAc,EACdlJ,CACR,CACF,C,kBC9CA,IAAIxnB,EAAMlJ,EAAQ,OAElB,SAAS+D,EAAgBlwB,GACvB,OAAOA,EAAIq1B,EAAI2wB,aAAe,EAC5BhmD,GAAK,IAAO,EACZA,GAAK,MAAS,EACd,CACJ,CAiEAqrB,EAAOC,QAAU,CACf4E,eAAgBA,EAChBxE,OAjEF,SAAiB7tB,EAAQyqC,EAAQ/mC,GAC/B,IAAIsF,EAAOqpB,EAAeoY,GAsB1B,OAnBa,IAATzhC,EACFhJ,EAAO4C,WAAW6nC,EAAQ/mC,GAGR,IAATsF,GACThJ,EAAO4C,WAAW40B,EAAI2wB,aAAczkD,GACpC1D,EAAO4C,WAAW6nC,EAAQ/mC,EAAS,IAGjB,IAATsF,GACThJ,EAAO4C,WAAW40B,EAAI4wB,aAAc1kD,GACpC1D,EAAO4U,cAAc61B,EAAQ/mC,EAAS,KAItC1D,EAAO4C,WAAW40B,EAAIgT,aAAc9mC,GACpC1D,EAAOgD,cAAcynC,EAAQ/mC,EAAS,IAGjCsF,CACT,EA0CE4kB,OAxCF,SAAiB5tB,EAAQ0D,GACvB,IACI+mC,EAAQzhC,EADRuhC,EAASvqC,EAAO4D,UAAUF,GAI9B,GAAI6mC,EAAS/S,EAAI2wB,aACf1d,EAASF,EACTvhC,EAAO,OAGF,GAAIuhC,IAAW/S,EAAI2wB,aAAc,CACtC,GAAIzkD,EAAS,EAAI1D,EAAOG,OAAQ,OAAO,KACvCsqC,EAASzqC,EAAO4D,UAAUF,EAAS,GACnCsF,EAAO,CAGT,MAAO,GAAIuhC,IAAW/S,EAAI4wB,aAAc,CACtC,GAAI1kD,EAAS,EAAI1D,EAAOG,OAAQ,OAAO,KACvCsqC,EAASzqC,EAAOqoD,aAAa3kD,EAAS,GACtCsF,EAAO,CAGT,KAAO,CACL,GAAItF,EAAS,EAAI1D,EAAOG,OAAQ,OAAO,KACvC,GAAIoqC,IAAW/S,EAAIgT,aAAc,MAAM,IAAI1oC,MAAM,qBAEjD2oC,EAASzqC,EAAOiE,aAAaP,EAAS,GACtCsF,EAAO,CACT,CAEA,MAAO,CACLuhC,OAAQA,EACRE,OAAQA,EACRzhC,KAAMA,EAEV,E","sources":["../node_modules/@ledgerhq/hw-app-btc/src/bip32.ts","../node_modules/@ledgerhq/hw-app-btc/src/buffertools.ts","../node_modules/@ledgerhq/hw-app-btc/src/constants.ts","../node_modules/@ledgerhq/hw-app-btc/src/hashPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/accounttype.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkle.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/policy.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtv2.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtFinalizer.ts","../node_modules/@ledgerhq/hw-app-btc/src/varint.ts","../node_modules/@ledgerhq/hw-app-btc/src/serializeTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/BtcNew.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtExtractor.ts","../node_modules/@ledgerhq/hw-app-btc/src/getWalletPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/getTrustedInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/startUntrustedHashTransactionInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/getTrustedInputBIP143.ts","../node_modules/@ledgerhq/hw-app-btc/src/compressPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/signTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/finalizeInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/getAppAndVersion.ts","../node_modules/@ledgerhq/hw-app-btc/src/createTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/shouldUseTrustedInputForSegwit.ts","../node_modules/@ledgerhq/hw-app-btc/src/BtcOld.ts","../node_modules/@ledgerhq/hw-app-btc/src/signMessage.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkleMap.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkelizedPsbt.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/clientCommands.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/appClient.ts","../node_modules/@ledgerhq/hw-app-btc/src/debug.ts","../node_modules/@ledgerhq/hw-app-btc/src/signP2SHTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/Btc.ts","../node_modules/@ledgerhq/hw-app-btc/src/splitTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/node_modules/bech32/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/address.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/block.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/bufferutils.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/classify.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/crypto.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/ecpair.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/networks.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/embed.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/lazy.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2ms.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2pk.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2pkh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2sh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2wsh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/psbt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script_number.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script_signature.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/nulldata.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/transaction.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/transaction_builder.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/types.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58check/base.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58check/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/comparator.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/range.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/semver.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/clean.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/cmp.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/coerce.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare-build.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare-loose.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/diff.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/eq.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/gt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/gte.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/inc.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/lt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/lte.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/major.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/minor.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/neq.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/parse.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/patch.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/prerelease.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/rcompare.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/rsort.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/satisfies.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/sort.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/valid.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/constants.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/debug.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/identifiers.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/lrucache.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/parse-options.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/re.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/gtr.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/intersects.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/ltr.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/max-satisfying.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/min-satisfying.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/min-version.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/outside.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/simplify.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/subset.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/to-comparators.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/valid.js","../node_modules/@ledgerhq/logs/src/index.ts","../node_modules/bip32-path/index.js","../node_modules/bip32/node_modules/bs58check/base.js","../node_modules/bip32/node_modules/bs58check/index.js","../node_modules/bip32/src/bip32.js","../node_modules/bip32/src/crypto.js","../node_modules/bip32/src/index.js","../node_modules/bitcoin-ops/map.js","../node_modules/invariant/browser.js","../node_modules/pushdata-bitcoin/index.js"],"sourcesContent":["/**\n * @file bip32.ts\n * @description BIP32 Path Handling for Bitcoin Wallets\n *\n * This file provides utility functions to handle BIP32 paths,\n * which are commonly used in hierarchical deterministic (HD) wallets.\n * It includes functions to convert BIP32 paths to and from different formats,\n * extract components from extended public keys (xpubs), and manipulate path elements.\n */\n\nimport bippath from \"bip32-path\";\nimport bs58check from \"bs58check\";\n\nexport function pathElementsToBuffer(paths: number[]): Buffer {\n  const buffer = Buffer.alloc(1 + paths.length * 4);\n  buffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  return buffer;\n}\n\nexport function bip32asBuffer(path: string): Buffer {\n  const pathElements = !path ? [] : pathStringToArray(path);\n  return pathElementsToBuffer(pathElements);\n}\n\nexport function pathArrayToString(pathElements: number[]): string {\n  // Limitation: bippath can't handle and empty path. It shouldn't affect us\n  // right now, but might in the future.\n  // TODO: Fix support for empty path.\n  return bippath.fromPathArray(pathElements).toString();\n}\n\nexport function pathStringToArray(path: string): number[] {\n  return bippath.fromString(path).toPathArray();\n}\n\nexport function pubkeyFromXpub(xpub: string): Buffer {\n  const xpubBuf = bs58check.decode(xpub);\n  return xpubBuf.slice(xpubBuf.length - 33);\n}\n\nexport function getXpubComponents(xpub: string): {\n  chaincode: Buffer;\n  pubkey: Buffer;\n  version: number;\n} {\n  const xpubBuf: Buffer = bs58check.decode(xpub);\n  return {\n    chaincode: xpubBuf.slice(13, 13 + 32),\n    pubkey: xpubBuf.slice(xpubBuf.length - 33),\n    version: xpubBuf.readUInt32BE(0),\n  };\n}\n\nexport function hardenedPathOf(pathElements: number[]): number[] {\n  for (let i = pathElements.length - 1; i >= 0; i--) {\n    if (pathElements[i] >= 0x80000000) {\n      return pathElements.slice(0, i + 1);\n    }\n  }\n  return [];\n}\n","import varuint from \"varuint-bitcoin\";\n\nexport function unsafeTo64bitLE(n: number): Buffer {\n  // we want to represent the input as a 8-bytes array\n  if (n > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"Can't convert numbers > MAX_SAFE_INT\");\n  }\n  const byteArray = Buffer.alloc(8, 0);\n  for (let index = 0; index < byteArray.length; index++) {\n    const byte = n & 0xff;\n    byteArray[index] = byte;\n    n = (n - byte) / 256;\n  }\n  return byteArray;\n}\n\nexport function unsafeFrom64bitLE(byteArray: Buffer): number {\n  let value = 0;\n  if (byteArray.length != 8) {\n    throw new Error(\"Expected Bufffer of lenght 8\");\n  }\n  if (byteArray[7] != 0) {\n    throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n  }\n  if (byteArray[6] > 0x1f) {\n    throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n  }\n  for (let i = byteArray.length - 1; i >= 0; i--) {\n    value = value * 256 + byteArray[i];\n  }\n  return value;\n}\n\nexport class BufferWriter {\n  private bufs: Buffer[] = [];\n\n  write(alloc: number, fn: (b: Buffer) => void): void {\n    const b = Buffer.alloc(alloc);\n    fn(b);\n    this.bufs.push(b);\n  }\n\n  writeUInt8(i: number): void {\n    this.write(1, b => b.writeUInt8(i, 0));\n  }\n\n  writeInt32(i: number): void {\n    this.write(4, b => b.writeInt32LE(i, 0));\n  }\n\n  writeUInt32(i: number): void {\n    this.write(4, b => b.writeUInt32LE(i, 0));\n  }\n\n  writeUInt64(i: number): void {\n    const bytes = unsafeTo64bitLE(i);\n    this.writeSlice(bytes);\n  }\n\n  writeVarInt(i: number): void {\n    this.bufs.push(varuint.encode(i));\n  }\n\n  writeSlice(slice: Buffer): void {\n    this.bufs.push(Buffer.from(slice));\n  }\n\n  writeVarSlice(slice: Buffer): void {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n\n  buffer(): Buffer {\n    return Buffer.concat(this.bufs);\n  }\n}\n\nexport class BufferReader {\n  constructor(\n    public buffer: Buffer,\n    public offset: number = 0,\n  ) {}\n\n  available(): number {\n    return this.buffer.length - this.offset;\n  }\n\n  readUInt8(): number {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n\n  readInt32(): number {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt32(): number {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt64(): number {\n    const buf = this.readSlice(8);\n    const n = unsafeFrom64bitLE(buf);\n    return n;\n  }\n\n  readVarInt(): number {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  readSlice(n: number): Buffer {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error(\"Cannot read slice out of bounds\");\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n\n  readVarSlice(): Buffer {\n    return this.readSlice(this.readVarInt());\n  }\n\n  readVector(): Buffer[] {\n    const count = this.readVarInt();\n    const vector: Buffer[] = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\n","// the maximum number of bytes allowed in a single chunk when processing bitcoin script data.\n// if the Bitcoin script is too large, we will process it in several chunks.\nexport const MAX_SCRIPT_BLOCK = 50;\nexport const DEFAULT_VERSION = 1;\nexport const DEFAULT_LOCKTIME = 0;\n// input sequence for non-rbf transactions\nexport const DEFAULT_SEQUENCE = 0xffffffff;\n// SIGHASH flags(Sign all inputs and outputs)\n// refer to https://wiki.bitcoinsv.io/index.php/SIGHASH_flags for more details\nexport const SIGHASH_ALL = 1;\n// refer to https://en.bitcoin.it/wiki/Script for Opcodes(OP_DUP, OP_HASH160...) that are used in bitcoin script\nexport const OP_DUP = 0x76;\nexport const OP_HASH160 = 0xa9;\nexport const HASH_SIZE = 0x14;\nexport const OP_EQUAL = 0x87;\nexport const OP_EQUALVERIFY = 0x88;\nexport const OP_CHECKSIG = 0xac;\nexport const OP_RETURN = 0x6a;\n","import RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nexport function hashPublicKey(buffer: Buffer): Buffer {\n  return new RIPEMD160().update(sha(\"sha256\").update(buffer).digest()).digest();\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pointAddScalar } from \"tiny-secp256k1\";\nimport { BufferWriter } from \"../buffertools\";\nimport { HASH_SIZE, OP_CHECKSIG, OP_DUP, OP_EQUAL, OP_EQUALVERIFY, OP_HASH160 } from \"../constants\";\nimport { hashPublicKey } from \"../hashPublicKey\";\nimport { DefaultDescriptorTemplate } from \"./policy\";\nimport { PsbtV2 } from \"./psbtv2\";\n\nexport type SpendingCondition = {\n  scriptPubKey: Buffer;\n  redeemScript?: Buffer;\n  // Possible future extension:\n  // witnessScript?: Buffer; // For p2wsh witnessScript\n  // tapScript?: {tapPath: Buffer[], script: Buffer} // For taproot\n};\n\nexport type SpentOutput = { cond: SpendingCondition; amount: Buffer };\n\n/**\n * Encapsulates differences between account types, for example p2wpkh,\n * p2wpkhWrapped, p2tr.\n */\nexport interface AccountType {\n  /**\n   * Generates a scriptPubKey (output script) from a list of public keys. If a\n   * p2sh redeemScript or a p2wsh witnessScript is needed it will also be set on\n   * the returned SpendingCondition.\n   *\n   * The pubkeys are expected to be 33 byte ecdsa compressed pubkeys.\n   */\n  spendingCondition(pubkeys: Buffer[]): SpendingCondition;\n\n  /**\n   * Populates the psbt with account type-specific data for an input.\n   * @param i The index of the input map to populate\n   * @param inputTx The full transaction containing the spent output. This may\n   * be omitted for taproot.\n   * @param spentOutput The amount and spending condition of the spent output\n   * @param pubkeys The 33 byte ecdsa compressed public keys involved in the input\n   * @param pathElems The paths corresponding to the pubkeys, in same order.\n   */\n  setInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkeys: Buffer[],\n    pathElems: number[][],\n  ): void;\n\n  /**\n   * Populates the psbt with account type-specific data for an output. This is typically\n   * done for change outputs and other outputs that goes to the same account as\n   * being spent from.\n   * @param i The index of the output map to populate\n   * @param cond The spending condition for this output\n   * @param pubkeys The 33 byte ecdsa compressed public keys involved in this output\n   * @param paths The paths corresponding to the pubkeys, in same order.\n   */\n  setOwnOutput(i: number, cond: SpendingCondition, pubkeys: Buffer[], paths: number[][]): void;\n\n  /**\n   * Returns the descriptor template for this account type. Currently only\n   * DefaultDescriptorTemplates are allowed, but that might be changed in the\n   * future. See class WalletPolicy for more information on descriptor\n   * templates.\n   */\n  getDescriptorTemplate(): DefaultDescriptorTemplate;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface BaseAccount extends AccountType {}\n\nabstract class BaseAccount implements AccountType {\n  constructor(\n    protected psbt: PsbtV2,\n    protected masterFp: Buffer,\n  ) {}\n}\n\n/**\n * Superclass for single signature accounts. This will make sure that the pubkey\n * arrays and path arrays in the method arguments contains exactly one element\n * and calls an abstract method to do the actual work.\n */\nabstract class SingleKeyAccount extends BaseAccount {\n  spendingCondition(pubkeys: Buffer[]): SpendingCondition {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    return this.singleKeyCondition(pubkeys[0]);\n  }\n  protected abstract singleKeyCondition(pubkey: Buffer): SpendingCondition;\n\n  setInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkeys: Buffer[],\n    pathElems: number[][],\n  ) {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    if (pathElems.length != 1) {\n      throw new Error(\"Expected single path, got \" + pathElems.length);\n    }\n    this.setSingleKeyInput(i, inputTx, spentOutput, pubkeys[0], pathElems[0]);\n  }\n  protected abstract setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  );\n\n  setOwnOutput(i: number, cond: SpendingCondition, pubkeys: Buffer[], paths: number[][]) {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    if (paths.length != 1) {\n      throw new Error(\"Expected single path, got \" + paths.length);\n    }\n    this.setSingleKeyOutput(i, cond, pubkeys[0], paths[0]);\n  }\n  protected abstract setSingleKeyOutput(\n    i: number,\n    cond: SpendingCondition,\n    pubkey: Buffer,\n    path: number[],\n  );\n}\n\nexport class p2pkh extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const pubkeyHash = hashPublicKey(pubkey);\n    buf.writeSlice(Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]));\n    buf.writeSlice(pubkeyHash);\n    buf.writeSlice(Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]));\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    _spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"pkh(@0)\";\n  }\n}\n\nexport class p2tr extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const xonlyPubkey = pubkey.slice(1); // x-only pubkey\n    const buf = new BufferWriter();\n    const outputKey = this.getTaprootOutputKey(xonlyPubkey);\n    buf.writeSlice(Buffer.from([0x51, 32])); // push1, pubkeylen\n    buf.writeSlice(outputKey);\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    _inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    const xonly = pubkey.slice(1);\n    this.psbt.setInputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    const xonly = pubkey.slice(1);\n    this.psbt.setOutputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"tr(@0)\";\n  }\n\n  /*\n  The following two functions are copied from wallet-btc and adapted.\n  They should be moved to a library to avoid code reuse.\n  */\n  private hashTapTweak(x: Buffer): Buffer {\n    // hash_tag(x) = SHA256(SHA256(tag) || SHA256(tag) || x), see BIP340\n    // See https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification\n    const h = crypto.sha256(Buffer.from(\"TapTweak\", \"utf-8\"));\n    return crypto.sha256(Buffer.concat([h, h, x]));\n  }\n\n  /**\n   * Calculates a taproot output key from an internal key. This output key will be\n   * used as witness program in a taproot output. The internal key is tweaked\n   * according to recommendation in BIP341:\n   * https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-22-0\n   *\n   * @param internalPubkey A 32 byte x-only taproot internal key\n   * @returns The output key\n   */\n  getTaprootOutputKey(internalPubkey: Buffer): Buffer {\n    if (internalPubkey.length != 32) {\n      throw new Error(\"Expected 32 byte pubkey. Got \" + internalPubkey.length);\n    }\n    // A BIP32 derived key can be converted to a schnorr pubkey by dropping\n    // the first byte, which represent the oddness/evenness. In schnorr all\n    // pubkeys are even.\n    // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#public-key-conversion\n    const evenEcdsaPubkey = Buffer.concat([Buffer.from([0x02]), internalPubkey]);\n    const tweak = this.hashTapTweak(internalPubkey);\n\n    // Q = P + int(hash_TapTweak(bytes(P)))G\n    const outputEcdsaKey = Buffer.from(pointAddScalar(evenEcdsaPubkey, tweak));\n    // Convert to schnorr.\n    const outputSchnorrKey = outputEcdsaKey.slice(1);\n    // Create address\n    return outputSchnorrKey;\n  }\n}\n\nexport class p2wpkhWrapped extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const redeemScript = this.createRedeemScript(pubkey);\n    const scriptHash = hashPublicKey(redeemScript);\n    buf.writeSlice(Buffer.from([OP_HASH160, HASH_SIZE]));\n    buf.writeSlice(scriptHash);\n    buf.writeUInt8(OP_EQUAL);\n    return { scriptPubKey: buf.buffer(), redeemScript: redeemScript };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n\n    const userSuppliedRedeemScript = spentOutput.cond.redeemScript;\n    const expectedRedeemScript = this.createRedeemScript(pubkey);\n    if (userSuppliedRedeemScript && !expectedRedeemScript.equals(userSuppliedRedeemScript)) {\n      // At what point might a user set the redeemScript on its own?\n      throw new Error(`User-supplied redeemScript ${userSuppliedRedeemScript.toString(\n        \"hex\",\n      )} doesn't\n       match expected ${expectedRedeemScript.toString(\"hex\")} for input ${i}`);\n    }\n    this.psbt.setInputRedeemScript(i, expectedRedeemScript);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputRedeemScript(i, cond.redeemScript!);\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"sh(wpkh(@0))\";\n  }\n\n  private createRedeemScript(pubkey: Buffer): Buffer {\n    const pubkeyHash = hashPublicKey(pubkey);\n    return Buffer.concat([Buffer.from(\"0014\", \"hex\"), pubkeyHash]);\n  }\n}\n\nexport class p2wpkh extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const pubkeyHash = hashPublicKey(pubkey);\n    buf.writeSlice(Buffer.from([0, HASH_SIZE]));\n    buf.writeSlice(pubkeyHash);\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"wpkh(@0)\";\n  }\n}\n","import { crypto } from \"bitcoinjs-lib\";\n\n/**\n * This class implements the merkle tree used by Ledger Bitcoin app v2+,\n * which is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md\n */\nexport class Merkle {\n  private leaves: Buffer[];\n  private rootNode: Node;\n  private leafNodes: Node[];\n  private h: (buf: Buffer) => Buffer;\n  constructor(leaves: Buffer[], hasher: (buf: Buffer) => Buffer = crypto.sha256) {\n    this.leaves = leaves;\n    this.h = hasher;\n    const nodes = this.calculateRoot(leaves);\n    this.rootNode = nodes.root;\n    this.leafNodes = nodes.leaves;\n  }\n  getRoot(): Buffer {\n    return this.rootNode.hash;\n  }\n  size(): number {\n    return this.leaves.length;\n  }\n  getLeaves(): Buffer[] {\n    return this.leaves;\n  }\n  getLeafHash(index: number): Buffer {\n    return this.leafNodes[index].hash;\n  }\n  getProof(index: number): Buffer[] {\n    if (index >= this.leaves.length) throw Error(\"Index out of bounds\");\n    return proveNode(this.leafNodes[index]);\n  }\n\n  calculateRoot(leaves: Buffer[]): { root: Node; leaves: Node[] } {\n    const n = leaves.length;\n    if (n == 0) {\n      return {\n        root: new Node(undefined, undefined, Buffer.alloc(32, 0)),\n        leaves: [],\n      };\n    }\n    if (n == 1) {\n      const newNode = new Node(undefined, undefined, leaves[0]);\n      return { root: newNode, leaves: [newNode] };\n    }\n    const leftCount = highestPowerOf2LessThan(n);\n    const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));\n    const rightBranch = this.calculateRoot(leaves.slice(leftCount));\n    const leftChild = leftBranch.root;\n    const rightChild = rightBranch.root;\n    const hash = this.hashNode(leftChild.hash, rightChild.hash);\n    const node = new Node(leftChild, rightChild, hash);\n    leftChild.parent = node;\n    rightChild.parent = node;\n    return { root: node, leaves: leftBranch.leaves.concat(rightBranch.leaves) };\n  }\n\n  hashNode(left: Buffer, right: Buffer): Buffer {\n    return this.h(Buffer.concat([Buffer.from([1]), left, right]));\n  }\n}\n\nexport function hashLeaf(\n  buf: Buffer,\n  hashFunction: (buf: Buffer) => Buffer = crypto.sha256,\n): Buffer {\n  return hashConcat(Buffer.from([0]), buf, hashFunction);\n}\n\nfunction hashConcat(bufA: Buffer, bufB: Buffer, hashFunction: (buf: Buffer) => Buffer): Buffer {\n  return hashFunction(Buffer.concat([bufA, bufB]));\n}\n\nclass Node {\n  leftChild?: Node;\n  rightChild?: Node;\n  parent?: Node;\n  hash: Buffer;\n  constructor(left: Node | undefined, right: Node | undefined, hash: Buffer) {\n    this.leftChild = left;\n    this.rightChild = right;\n    this.hash = hash;\n  }\n  isLeaf(): boolean {\n    return this.leftChild == undefined;\n  }\n}\n\nfunction proveNode(node: Node): Buffer[] {\n  if (!node.parent) {\n    return [];\n  }\n  if (node.parent.leftChild == node) {\n    if (!node.parent.rightChild) {\n      throw new Error(\"Expected right child to exist\");\n    }\n    return [node.parent.rightChild.hash, ...proveNode(node.parent)];\n  } else {\n    if (!node.parent.leftChild) {\n      throw new Error(\"Expected left child to exist\");\n    }\n    return [node.parent.leftChild.hash, ...proveNode(node.parent)];\n  }\n}\n\nfunction highestPowerOf2LessThan(n: number) {\n  if (n < 2) {\n    throw Error(\"Expected n >= 2\");\n  }\n  if (isPowerOf2(n)) {\n    return n / 2;\n  }\n  return 1 << Math.floor(Math.log2(n));\n}\n\nfunction isPowerOf2(n: number): boolean {\n  return (n & (n - 1)) == 0;\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pathArrayToString } from \"../bip32\";\nimport { BufferWriter } from \"../buffertools\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\nexport type DefaultDescriptorTemplate = \"pkh(@0)\" | \"sh(wpkh(@0))\" | \"wpkh(@0)\" | \"tr(@0)\";\n\n/**\n * The Bitcon hardware app uses a descriptors-like thing to describe\n * how to construct output scripts from keys. A \"Wallet Policy\" consists\n * of a \"Descriptor Template\" and a list of \"keys\". A key is basically\n * a serialized BIP32 extended public key with some added derivation path\n * information. This is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/wallet.md\n */\nexport class WalletPolicy {\n  descriptorTemplate: string;\n  keys: string[];\n  /**\n   * For now, we only support default descriptor templates.\n   */\n  constructor(descriptorTemplate: DefaultDescriptorTemplate, key: string) {\n    this.descriptorTemplate = descriptorTemplate;\n    this.keys = [key];\n  }\n\n  getWalletId(): Buffer {\n    // wallet_id (sha256 of the wallet serialization),\n    return crypto.sha256(this.serialize());\n  }\n\n  serialize(): Buffer {\n    const keyBuffers = this.keys.map(k => {\n      return Buffer.from(k, \"ascii\");\n    });\n    const m = new Merkle(keyBuffers.map(k => hashLeaf(k)));\n\n    const buf = new BufferWriter();\n    buf.writeUInt8(0x01); // wallet type (policy map)\n    buf.writeUInt8(0); // length of wallet name (empty string for default wallets)\n    buf.writeVarSlice(Buffer.from(this.descriptorTemplate, \"ascii\"));\n    buf.writeVarInt(this.keys.length), buf.writeSlice(m.getRoot());\n    return buf.buffer();\n  }\n}\n\nexport function createKey(masterFingerprint: Buffer, path: number[], xpub: string): string {\n  const accountPath = pathArrayToString(path);\n  return `[${masterFingerprint.toString(\"hex\")}${accountPath.substring(1)}]${xpub}/**`;\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { BufferReader, BufferWriter, unsafeFrom64bitLE, unsafeTo64bitLE } from \"../buffertools\";\n\nexport enum psbtGlobal {\n  TX_VERSION = 0x02,\n  FALLBACK_LOCKTIME = 0x03,\n  INPUT_COUNT = 0x04,\n  OUTPUT_COUNT = 0x05,\n  TX_MODIFIABLE = 0x06,\n  VERSION = 0xfb,\n}\nexport enum psbtIn {\n  NON_WITNESS_UTXO = 0x00,\n  WITNESS_UTXO = 0x01,\n  PARTIAL_SIG = 0x02,\n  SIGHASH_TYPE = 0x03,\n  REDEEM_SCRIPT = 0x04,\n  BIP32_DERIVATION = 0x06,\n  FINAL_SCRIPTSIG = 0x07,\n  FINAL_SCRIPTWITNESS = 0x08,\n  PREVIOUS_TXID = 0x0e,\n  OUTPUT_INDEX = 0x0f,\n  SEQUENCE = 0x10,\n  TAP_KEY_SIG = 0x13,\n  TAP_BIP32_DERIVATION = 0x16,\n}\nexport enum psbtOut {\n  REDEEM_SCRIPT = 0x00,\n  BIP_32_DERIVATION = 0x02,\n  AMOUNT = 0x03,\n  SCRIPT = 0x04,\n  TAP_BIP32_DERIVATION = 0x07,\n}\n\nconst PSBT_MAGIC_BYTES = Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]);\n\nexport class NoSuchEntry extends Error {}\n\n/**\n * Implements Partially Signed Bitcoin Transaction version 2, BIP370, as\n * documented at https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki\n * and https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki\n *\n * A psbt is a data structure that can carry all relevant information about a\n * transaction through all stages of the signing process. From constructing an\n * unsigned transaction to extracting the final serialized transaction ready for\n * broadcast.\n *\n * This implementation is limited to what's needed in ledgerjs to carry out its\n * duties, which means that support for features like multisig or taproot script\n * path spending are not implemented. Specifically, it supports p2pkh,\n * p2wpkhWrappedInP2sh, p2wpkh and p2tr key path spending.\n *\n * This class is made purposefully dumb, so it's easy to add support for\n * complemantary fields as needed in the future.\n */\nexport class PsbtV2 {\n  protected globalMap: Map<string, Buffer> = new Map();\n  protected inputMaps: Map<string, Buffer>[] = [];\n  protected outputMaps: Map<string, Buffer>[] = [];\n\n  setGlobalTxVersion(version: number) {\n    this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));\n  }\n  getGlobalTxVersion(): number {\n    return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);\n  }\n  setGlobalFallbackLocktime(locktime: number) {\n    this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));\n  }\n  getGlobalFallbackLocktime(): number | undefined {\n    return this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)?.readUInt32LE(0);\n  }\n  setGlobalInputCount(inputCount: number) {\n    this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));\n  }\n  getGlobalInputCount(): number {\n    return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));\n  }\n  setGlobalOutputCount(outputCount: number) {\n    this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));\n  }\n  getGlobalOutputCount(): number {\n    return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));\n  }\n  setGlobalTxModifiable(byte: Buffer) {\n    this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);\n  }\n  getGlobalTxModifiable(): Buffer | undefined {\n    return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);\n  }\n  setGlobalPsbtVersion(psbtVersion: number) {\n    this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));\n  }\n  getGlobalPsbtVersion(): number {\n    return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);\n  }\n\n  setInputNonWitnessUtxo(inputIndex: number, transaction: Buffer) {\n    this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);\n  }\n  getInputNonWitnessUtxo(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());\n  }\n  setInputWitnessUtxo(inputIndex: number, amount: Buffer, scriptPubKey: Buffer) {\n    const buf = new BufferWriter();\n    buf.writeSlice(amount);\n    buf.writeVarSlice(scriptPubKey);\n    this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());\n  }\n  getInputWitnessUtxo(inputIndex: number): { amount: Buffer; scriptPubKey: Buffer } | undefined {\n    const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());\n    if (!utxo) return undefined;\n    const buf = new BufferReader(utxo);\n    return { amount: buf.readSlice(8), scriptPubKey: buf.readVarSlice() };\n  }\n  setInputPartialSig(inputIndex: number, pubkey: Buffer, signature: Buffer) {\n    this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);\n  }\n  getInputPartialSig(inputIndex: number, pubkey: Buffer): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);\n  }\n  setInputSighashType(inputIndex: number, sigHashtype: number) {\n    this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));\n  }\n  getInputSighashType(inputIndex: number): number | undefined {\n    const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());\n    if (!result) return undefined;\n    return result.readUInt32LE(0);\n  }\n  setInputRedeemScript(inputIndex: number, redeemScript: Buffer) {\n    this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);\n  }\n  getInputRedeemScript(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());\n  }\n  setInputBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    if (pubkey.length != 33) throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n    this.setInput(\n      inputIndex,\n      psbtIn.BIP32_DERIVATION,\n      pubkey,\n      this.encodeBip32Derivation(masterFingerprint, path),\n    );\n  }\n  getInputBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n  ): { masterFingerprint: Buffer; path: number[] } | undefined {\n    const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);\n    if (!buf) return undefined;\n    return this.decodeBip32Derivation(buf);\n  }\n  setInputFinalScriptsig(inputIndex: number, scriptSig: Buffer) {\n    this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);\n  }\n  getInputFinalScriptsig(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());\n  }\n  setInputFinalScriptwitness(inputIndex: number, scriptWitness: Buffer) {\n    this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);\n  }\n  getInputFinalScriptwitness(inputIndex: number): Buffer {\n    return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());\n  }\n  setInputPreviousTxId(inputIndex: number, txid: Buffer) {\n    this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);\n  }\n  getInputPreviousTxid(inputIndex: number): Buffer {\n    return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());\n  }\n  setInputOutputIndex(inputIndex: number, outputIndex: number) {\n    this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));\n  }\n  getInputOutputIndex(inputIndex: number): number {\n    return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);\n  }\n  setInputSequence(inputIndex: number, sequence: number) {\n    this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));\n  }\n  getInputSequence(inputIndex: number): number {\n    return this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())?.readUInt32LE(0) ?? 0xffffffff;\n  }\n  setInputTapKeySig(inputIndex: number, sig: Buffer) {\n    this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);\n  }\n  getInputTapKeySig(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());\n  }\n  setInputTapBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n    hashes: Buffer[],\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    if (pubkey.length != 32) throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n    const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);\n    this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);\n  }\n  getInputTapBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n  ): { hashes: Buffer[]; masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);\n    return this.decodeTapBip32Derivation(buf);\n  }\n  getInputKeyDatas(inputIndex: number, keyType: KeyType): Buffer[] {\n    return this.getKeyDatas(this.inputMaps[inputIndex], keyType);\n  }\n\n  setOutputRedeemScript(outputIndex: number, redeemScript: Buffer) {\n    this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);\n  }\n  getOutputRedeemScript(outputIndex: number): Buffer {\n    return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());\n  }\n  setOutputBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    this.setOutput(\n      outputIndex,\n      psbtOut.BIP_32_DERIVATION,\n      pubkey,\n      this.encodeBip32Derivation(masterFingerprint, path),\n    );\n  }\n  getOutputBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n  ): { masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);\n    return this.decodeBip32Derivation(buf);\n  }\n  setOutputAmount(outputIndex: number, amount: number) {\n    this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));\n  }\n  getOutputAmount(outputIndex: number): number {\n    const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());\n    return unsafeFrom64bitLE(buf);\n  }\n  setOutputScript(outputIndex: number, scriptPubKey: Buffer) {\n    this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);\n  }\n  getOutputScript(outputIndex: number): Buffer {\n    return this.getOutput(outputIndex, psbtOut.SCRIPT, b());\n  }\n  setOutputTapBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n    hashes: Buffer[],\n    fingerprint: Buffer,\n    path: number[],\n  ) {\n    const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);\n    this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);\n  }\n  getOutputTapBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n  ): { hashes: Buffer[]; masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);\n    return this.decodeTapBip32Derivation(buf);\n  }\n\n  deleteInputEntries(inputIndex: number, keyTypes: psbtIn[]) {\n    const map = this.inputMaps[inputIndex];\n    map.forEach((_v, k, m) => {\n      if (this.isKeyType(k, keyTypes)) {\n        m.delete(k);\n      }\n    });\n  }\n\n  copy(to: PsbtV2) {\n    this.copyMap(this.globalMap, to.globalMap);\n    this.copyMaps(this.inputMaps, to.inputMaps);\n    this.copyMaps(this.outputMaps, to.outputMaps);\n  }\n  copyMaps(from: Map<string, Buffer>[], to: Map<string, Buffer>[]) {\n    from.forEach((m, index) => {\n      const to_index = new Map();\n      this.copyMap(m, to_index);\n      to[index] = to_index;\n    });\n  }\n  copyMap(from: Map<string, Buffer>, to: Map<string, Buffer>) {\n    from.forEach((v, k) => to.set(k, Buffer.from(v)));\n  }\n  serialize(): Buffer {\n    const buf = new BufferWriter();\n    buf.writeSlice(Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]));\n    serializeMap(buf, this.globalMap);\n    this.inputMaps.forEach(map => {\n      serializeMap(buf, map);\n    });\n    this.outputMaps.forEach(map => {\n      serializeMap(buf, map);\n    });\n    return buf.buffer();\n  }\n  deserialize(psbt: Buffer) {\n    const buf = new BufferReader(psbt);\n    if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) {\n      throw new Error(\"Invalid magic bytes\");\n    }\n    while (this.readKeyPair(this.globalMap, buf));\n    for (let i = 0; i < this.getGlobalInputCount(); i++) {\n      this.inputMaps[i] = new Map();\n      while (this.readKeyPair(this.inputMaps[i], buf));\n    }\n    for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n      this.outputMaps[i] = new Map();\n      while (this.readKeyPair(this.outputMaps[i], buf));\n    }\n  }\n  private readKeyPair(map: Map<string, Buffer>, buf: BufferReader): boolean {\n    const keyLen = buf.readVarInt();\n    if (keyLen == 0) {\n      return false;\n    }\n    const keyType = buf.readUInt8();\n    const keyData = buf.readSlice(keyLen - 1);\n    const value = buf.readVarSlice();\n    set(map, keyType, keyData, value);\n    return true;\n  }\n  private getKeyDatas(map: Map<string, Buffer>, keyType: KeyType): Buffer[] {\n    const result: Buffer[] = [];\n    map.forEach((_v, k) => {\n      if (this.isKeyType(k, [keyType])) {\n        result.push(Buffer.from(k.substring(2), \"hex\"));\n      }\n    });\n    return result;\n  }\n  private isKeyType(hexKey: string, keyTypes: KeyType[]): boolean {\n    const keyType = Buffer.from(hexKey.substring(0, 2), \"hex\").readUInt8(0);\n    return keyTypes.some(k => k == keyType);\n  }\n  private setGlobal(keyType: KeyType, value: Buffer) {\n    const key = new Key(keyType, Buffer.from([]));\n    this.globalMap.set(key.toString(), value);\n  }\n  private getGlobal(keyType: KeyType): Buffer {\n    return get(this.globalMap, keyType, b(), false)!;\n  }\n  private getGlobalOptional(keyType: KeyType): Buffer | undefined {\n    return get(this.globalMap, keyType, b(), true);\n  }\n  private setInput(index: number, keyType: KeyType, keyData: Buffer, value: Buffer) {\n    set(this.getMap(index, this.inputMaps), keyType, keyData, value);\n  }\n  private getInput(index: number, keyType: KeyType, keyData: Buffer): Buffer {\n    return get(this.inputMaps[index], keyType, keyData, false)!;\n  }\n  private getInputOptional(index: number, keyType: KeyType, keyData: Buffer): Buffer | undefined {\n    return get(this.inputMaps[index], keyType, keyData, true);\n  }\n  private setOutput(index: number, keyType: KeyType, keyData: Buffer, value: Buffer) {\n    set(this.getMap(index, this.outputMaps), keyType, keyData, value);\n  }\n  private getOutput(index: number, keyType: KeyType, keyData: Buffer): Buffer {\n    return get(this.outputMaps[index], keyType, keyData, false)!;\n  }\n  private getMap(index: number, maps: Map<string, Buffer>[]): Map<string, Buffer> {\n    if (maps[index]) {\n      return maps[index];\n    }\n    return (maps[index] = new Map());\n  }\n  private encodeBip32Derivation(masterFingerprint: Buffer, path: number[]) {\n    const buf = new BufferWriter();\n    this.writeBip32Derivation(buf, masterFingerprint, path);\n    return buf.buffer();\n  }\n  private decodeBip32Derivation(buffer: Buffer): {\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const buf = new BufferReader(buffer);\n    return this.readBip32Derivation(buf);\n  }\n  private writeBip32Derivation(buf: BufferWriter, masterFingerprint: Buffer, path: number[]) {\n    buf.writeSlice(masterFingerprint);\n    path.forEach(element => {\n      buf.writeUInt32(element);\n    });\n  }\n  private readBip32Derivation(buf: BufferReader): {\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const masterFingerprint = buf.readSlice(4);\n    const path: number[] = [];\n    while (buf.offset < buf.buffer.length) {\n      path.push(buf.readUInt32());\n    }\n    return { masterFingerprint, path };\n  }\n  private encodeTapBip32Derivation(\n    hashes: Buffer[],\n    masterFingerprint: Buffer,\n    path: number[],\n  ): Buffer {\n    const buf = new BufferWriter();\n    buf.writeVarInt(hashes.length);\n    hashes.forEach(h => {\n      buf.writeSlice(h);\n    });\n    this.writeBip32Derivation(buf, masterFingerprint, path);\n    return buf.buffer();\n  }\n  private decodeTapBip32Derivation(buffer: Buffer): {\n    hashes: Buffer[];\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const buf = new BufferReader(buffer);\n    const hashCount = buf.readVarInt();\n    const hashes: Buffer[] = [];\n    for (let i = 0; i < hashCount; i++) {\n      hashes.push(buf.readSlice(32));\n    }\n    const deriv = this.readBip32Derivation(buf);\n    return { hashes, ...deriv };\n  }\n}\nfunction get(\n  map: Map<string, Buffer>,\n  keyType: KeyType,\n  keyData: Buffer,\n  acceptUndefined: boolean,\n): Buffer | undefined {\n  if (!map) throw Error(\"No such map\");\n  const key = new Key(keyType, keyData);\n  const value = map.get(key.toString());\n  if (!value) {\n    if (acceptUndefined) {\n      return undefined;\n    }\n    throw new NoSuchEntry(key.toString());\n  }\n  // Make sure to return a copy, to protect the underlying data.\n  return Buffer.from(value);\n}\ntype KeyType = number;\n\nclass Key {\n  keyType: KeyType;\n  keyData: Buffer;\n  constructor(keyType: KeyType, keyData: Buffer) {\n    this.keyType = keyType;\n    this.keyData = keyData;\n  }\n  toString(): string {\n    const buf = new BufferWriter();\n    this.toBuffer(buf);\n    return buf.buffer().toString(\"hex\");\n  }\n  serialize(buf: BufferWriter) {\n    buf.writeVarInt(1 + this.keyData.length);\n    this.toBuffer(buf);\n  }\n  private toBuffer(buf: BufferWriter) {\n    buf.writeUInt8(this.keyType);\n    buf.writeSlice(this.keyData);\n  }\n}\nclass KeyPair {\n  key: Key;\n  value: Buffer;\n  constructor(key: Key, value: Buffer) {\n    this.key = key;\n    this.value = value;\n  }\n  serialize(buf: BufferWriter) {\n    this.key.serialize(buf);\n    buf.writeVarSlice(this.value);\n  }\n}\nfunction createKey(buf: Buffer): Key {\n  return new Key(buf.readUInt8(0), buf.slice(1));\n}\nfunction serializeMap(buf: BufferWriter, map: Map<string, Buffer>) {\n  for (const k of map.keys()) {\n    const value = map.get(k)!;\n    const keyPair = new KeyPair(createKey(Buffer.from(k, \"hex\")), value);\n    keyPair.serialize(buf);\n  }\n  buf.writeUInt8(0);\n}\n\nfunction b(): Buffer {\n  return Buffer.from([]);\n}\nfunction set(map: Map<string, Buffer>, keyType: KeyType, keyData: Buffer, value: Buffer) {\n  const key = new Key(keyType, keyData);\n  map.set(key.toString(), value);\n}\nfunction uint32LE(n: number): Buffer {\n  const b = Buffer.alloc(4);\n  b.writeUInt32LE(n, 0);\n  return b;\n}\nfunction uint64LE(n: number): Buffer {\n  return unsafeTo64bitLE(n);\n}\nfunction varint(n: number): Buffer {\n  const b = new BufferWriter();\n  b.writeVarInt(n);\n  return b.buffer();\n}\nfunction fromVarint(buf: Buffer): number {\n  return new BufferReader(buf).readVarInt();\n}\n","import { BufferWriter } from \"../buffertools\";\nimport { psbtIn, PsbtV2 } from \"./psbtv2\";\n\n/**\n * This roughly implements the \"input finalizer\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki). However\n * the role is documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki).\n *\n * Verify that all inputs have a signature, and set inputFinalScriptwitness\n * and/or inputFinalScriptSig depending on the type of the spent outputs. Clean\n * fields that aren't useful anymore, partial signatures, redeem script and\n * derivation paths.\n *\n * @param psbt The psbt with all signatures added as partial sigs, either\n * through PSBT_IN_PARTIAL_SIG or PSBT_IN_TAP_KEY_SIG\n */\nexport function finalize(psbt: PsbtV2): void {\n  // First check that each input has a signature\n  const inputCount = psbt.getGlobalInputCount();\n  for (let i = 0; i < inputCount; i++) {\n    const legacyPubkeys = psbt.getInputKeyDatas(i, psbtIn.PARTIAL_SIG);\n    const taprootSig = psbt.getInputTapKeySig(i);\n    if (legacyPubkeys.length == 0 && !taprootSig) {\n      throw Error(`No signature for input ${i} present`);\n    }\n    if (legacyPubkeys.length > 0) {\n      if (legacyPubkeys.length > 1) {\n        throw Error(`Expected exactly one signature, got ${legacyPubkeys.length}`);\n      }\n      if (taprootSig) {\n        throw Error(\"Both taproot and non-taproot signatures present.\");\n      }\n\n      const isSegwitV0 = !!psbt.getInputWitnessUtxo(i);\n      const redeemScript = psbt.getInputRedeemScript(i);\n      const isWrappedSegwit = !!redeemScript;\n      const signature = psbt.getInputPartialSig(i, legacyPubkeys[0]);\n      if (!signature) throw new Error(\"Expected partial signature for input \" + i);\n      if (isSegwitV0) {\n        const witnessBuf = new BufferWriter();\n        witnessBuf.writeVarInt(2);\n        witnessBuf.writeVarInt(signature.length);\n        witnessBuf.writeSlice(signature);\n        witnessBuf.writeVarInt(legacyPubkeys[0].length);\n        witnessBuf.writeSlice(legacyPubkeys[0]);\n        psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n        if (isWrappedSegwit) {\n          if (!redeemScript || redeemScript.length == 0) {\n            throw new Error(\"Expected non-empty redeemscript. Can't finalize intput \" + i);\n          }\n          const scriptSigBuf = new BufferWriter();\n          // Push redeemScript length\n          scriptSigBuf.writeUInt8(redeemScript.length);\n          scriptSigBuf.writeSlice(redeemScript);\n          psbt.setInputFinalScriptsig(i, scriptSigBuf.buffer());\n        }\n      } else {\n        // Legacy input\n        const scriptSig = new BufferWriter();\n        writePush(scriptSig, signature);\n        writePush(scriptSig, legacyPubkeys[0]);\n        psbt.setInputFinalScriptsig(i, scriptSig.buffer());\n      }\n    } else {\n      // Taproot input\n      const signature = psbt.getInputTapKeySig(i);\n      if (!signature) {\n        throw Error(\"No taproot signature found\");\n      }\n      if (signature.length != 64 && signature.length != 65) {\n        throw Error(\"Unexpected length of schnorr signature.\");\n      }\n      const witnessBuf = new BufferWriter();\n      witnessBuf.writeVarInt(1);\n      witnessBuf.writeVarSlice(signature);\n      psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n    }\n    clearFinalizedInput(psbt, i);\n  }\n}\n\n/**\n * Deletes fields that are no longer neccesary from the psbt.\n *\n * Note, the spec doesn't say anything about removing ouput fields\n * like PSBT_OUT_BIP32_DERIVATION_PATH and others, so we keep them\n * without actually knowing why. I think we should remove them too.\n */\nfunction clearFinalizedInput(psbt: PsbtV2, inputIndex: number) {\n  const keyTypes = [\n    psbtIn.BIP32_DERIVATION,\n    psbtIn.PARTIAL_SIG,\n    psbtIn.TAP_BIP32_DERIVATION,\n    psbtIn.TAP_KEY_SIG,\n  ];\n  const witnessUtxoAvailable = !!psbt.getInputWitnessUtxo(inputIndex);\n  const nonWitnessUtxoAvailable = !!psbt.getInputNonWitnessUtxo(inputIndex);\n  if (witnessUtxoAvailable && nonWitnessUtxoAvailable) {\n    // Remove NON_WITNESS_UTXO for segwit v0 as it's only needed while signing.\n    // Segwit v1 doesn't have NON_WITNESS_UTXO set.\n    // See https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#cite_note-7\n    keyTypes.push(psbtIn.NON_WITNESS_UTXO);\n  }\n  psbt.deleteInputEntries(inputIndex, keyTypes);\n}\n\n/**\n * Writes a script push operation to buf, which looks different\n * depending on the size of the data. See\n * https://en.bitcoin.it/wiki/Script#Constants\n *\n * @param buf the BufferWriter to write to\n * @param data the Buffer to be pushed.\n */\nfunction writePush(buf: BufferWriter, data: Buffer) {\n  if (data.length <= 75) {\n    buf.writeUInt8(data.length);\n  } else if (data.length <= 256) {\n    buf.writeUInt8(76);\n    buf.writeUInt8(data.length);\n  } else if (data.length <= 256 * 256) {\n    buf.writeUInt8(77);\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(data.length, 0);\n    buf.writeSlice(b);\n  }\n  buf.writeSlice(data);\n}\n","export function getVarint(data: Buffer, offset: number): [number, number] {\n  if (data[offset] < 0xfd) {\n    return [data[offset], 1];\n  }\n\n  if (data[offset] === 0xfd) {\n    return [(data[offset + 2] << 8) + data[offset + 1], 3];\n  }\n\n  if (data[offset] === 0xfe) {\n    return [\n      (data[offset + 4] << 24) +\n        (data[offset + 3] << 16) +\n        (data[offset + 2] << 8) +\n        data[offset + 1],\n      5,\n    ];\n  }\n\n  throw new Error(\"getVarint called with unexpected parameters\");\n}\nexport function createVarint(value: number): Buffer {\n  if (value < 0xfd) {\n    const buffer = Buffer.alloc(1);\n    buffer[0] = value;\n    return buffer;\n  }\n\n  if (value <= 0xffff) {\n    const buffer = Buffer.alloc(3);\n    buffer[0] = 0xfd;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    return buffer;\n  }\n\n  const buffer = Buffer.alloc(5);\n  buffer[0] = 0xfe;\n  buffer[1] = value & 0xff;\n  buffer[2] = (value >> 8) & 0xff;\n  buffer[3] = (value >> 16) & 0xff;\n  buffer[4] = (value >> 24) & 0xff;\n  return buffer;\n}\n","import type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\n\n/**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\nexport function serializeTransactionOutputs({ outputs }: Transaction): Buffer {\n  let outputBuffer = Buffer.alloc(0);\n\n  if (typeof outputs !== \"undefined\") {\n    outputBuffer = Buffer.concat([outputBuffer, createVarint(outputs.length)]);\n    outputs.forEach(output => {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        output.amount,\n        createVarint(output.script.length),\n        output.script,\n      ]);\n    });\n  }\n\n  return outputBuffer;\n}\nexport function serializeTransaction(\n  transaction: Transaction,\n  skipWitness: boolean,\n  timestamp?: Buffer,\n  additionals: string[] = [],\n) {\n  const isDecred = additionals.includes(\"decred\");\n  const isZcash = additionals.includes(\"zcash\");\n  const isBech32 = additionals.includes(\"bech32\");\n  let inputBuffer = Buffer.alloc(0);\n  const useWitness = typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n  transaction.inputs.forEach(input => {\n    inputBuffer =\n      isDecred || isBech32\n        ? Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            Buffer.from([0x00]), //tree\n            input.sequence,\n          ])\n        : Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            createVarint(input.script.length),\n            input.script,\n            input.sequence,\n          ]);\n  });\n  let outputBuffer = serializeTransactionOutputs(transaction);\n\n  if (typeof transaction.outputs !== \"undefined\" && typeof transaction.locktime !== \"undefined\") {\n    outputBuffer = Buffer.concat([\n      outputBuffer,\n      (useWitness && transaction.witness) || Buffer.alloc(0),\n      transaction.locktime,\n      transaction.nExpiryHeight || Buffer.alloc(0),\n      transaction.extraData || Buffer.alloc(0),\n    ]);\n  }\n  // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n  if (isZcash) {\n    return Buffer.concat([\n      transaction.version,\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      Buffer.from([0xb4, 0xd0, 0xd6, 0xc2]), // Zcash Consensus Branch ID: 0xC2D6D0B4 refer to https://z.cash/upgrade/nu5/\n      transaction.locktime || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n      transaction.nExpiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n      useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n      createVarint(transaction.inputs.length),\n      inputBuffer,\n      outputBuffer,\n    ]);\n  }\n  return Buffer.concat([\n    transaction.version,\n    timestamp ? timestamp : Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n    inputBuffer,\n    outputBuffer,\n  ]);\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pointCompress } from \"tiny-secp256k1\";\nimport {\n  getXpubComponents,\n  hardenedPathOf,\n  pathArrayToString,\n  pathStringToArray,\n  pubkeyFromXpub,\n} from \"./bip32\";\nimport { BufferReader } from \"./buffertools\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport {\n  AccountType,\n  p2pkh,\n  p2tr,\n  p2wpkh,\n  p2wpkhWrapped,\n  SpendingCondition,\n} from \"./newops/accounttype\";\nimport { AppClient as Client } from \"./newops/appClient\";\nimport { createKey, DefaultDescriptorTemplate, WalletPolicy } from \"./newops/policy\";\nimport { extract } from \"./newops/psbtExtractor\";\nimport { finalize } from \"./newops/psbtFinalizer\";\nimport { psbtIn, PsbtV2 } from \"./newops/psbtv2\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport type { Transaction } from \"./types\";\n\n/**\n * @class BtcNew\n * @description This class implements the same interface as BtcOld (formerly\n * named Btc), but interacts with Bitcoin hardware app version 2.1.0+\n * which uses a totally new APDU protocol. This new\n * protocol is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n *\n * Since the interface must remain compatible with BtcOld, the methods\n * of this class are quite clunky, because it needs to adapt legacy\n * input data into the PSBT process. In the future, a new interface should\n * be developed that exposes PSBT to the outer world, which would render\n * a much cleaner implementation.\n *\n */\nexport default class BtcNew {\n  constructor(private client: Client) {}\n\n  /**\n   * This is a new method that allow users to get an xpub at a standard path.\n   * Standard paths are described at\n   * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#description\n   *\n   * This boils down to paths (N=0 for Bitcoin, N=1 for Testnet):\n   * M/44'/N'/x'/**\n   * M/48'/N'/x'/y'/**\n   * M/49'/N'/x'/**\n   * M/84'/N'/x'/**\n   * M/86'/N'/x'/**\n   *\n   * The method was added because of added security in the hardware app v2+. The\n   * new hardware app will allow export of any xpub up to and including the\n   * deepest hardened key of standard derivation paths, whereas the old app\n   * would allow export of any key.\n   *\n   * This caused an issue for callers of this class, who only had\n   * getWalletPublicKey() to call which means they have to constuct xpub\n   * themselves:\n   *\n   * Suppose a user of this class wants to create an account xpub on a standard\n   * path, M/44'/0'/Z'. The user must get the parent key fingerprint (see BIP32)\n   * by requesting the parent key M/44'/0'. The new app won't allow that, because\n   * it only allows exporting deepest level hardened path. So the options are to\n   * allow requesting M/44'/0' from the app, or to add a new function\n   * \"getWalletXpub\".\n   *\n   * We opted for adding a new function, which can greatly simplify client code.\n   */\n  async getWalletXpub({\n    path,\n    xpubVersion,\n  }: {\n    path: string;\n    xpubVersion: number;\n  }): Promise<string> {\n    const pathElements: number[] = pathStringToArray(path);\n    const xpub = await this.client.getExtendedPubkey(false, pathElements);\n    const xpubComponents = getXpubComponents(xpub);\n    if (xpubComponents.version != xpubVersion) {\n      throw new Error(\n        `Expected xpub version ${xpubVersion} doesn't match the xpub version from the device ${xpubComponents.version}`,\n      );\n    }\n    return xpub;\n  }\n\n  /**\n   * This method returns a public key, a bitcoin address, and and a chaincode\n   * for a specific derivation path.\n   *\n   * Limitation: If the path is not a leaf node of a standard path, the address\n   * will be the empty string \"\", see this.getWalletAddress() for details.\n   */\n  async getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    if (!isPathNormal(path)) {\n      throw Error(`non-standard path: ${path}`);\n    }\n    const pathElements: number[] = pathStringToArray(path);\n    const xpub = await this.client.getExtendedPubkey(false, pathElements);\n\n    const display = opts?.verify ?? false;\n\n    const address = await this.getWalletAddress(\n      pathElements,\n      descrTemplFrom(opts?.format ?? \"legacy\"),\n      display,\n    );\n    const components = getXpubComponents(xpub);\n    const uncompressedPubkey = Buffer.from(pointCompress(components.pubkey, false));\n    return {\n      publicKey: uncompressedPubkey.toString(\"hex\"),\n      bitcoinAddress: address,\n      chainCode: components.chaincode.toString(\"hex\"),\n    };\n  }\n\n  /**\n   * Get an address for the specified path.\n   *\n   * If display is true, we must get the address from the device, which would require\n   * us to determine WalletPolicy. This requires two *extra* queries to the device, one\n   * for the account xpub and one for master key fingerprint.\n   *\n   * If display is false we *could* generate the address ourselves, but chose to\n   * get it from the device to save development time. However, it shouldn't take\n   * too much time to implement local address generation.\n   *\n   * Moreover, if the path is not for a leaf, ie accountPath+/X/Y, there is no\n   * way to get the address from the device. In this case we have to create it\n   * ourselves, but we don't at this time, and instead return an empty (\"\") address.\n   */\n  private async getWalletAddress(\n    pathElements: number[],\n    descrTempl: DefaultDescriptorTemplate,\n    display: boolean,\n  ): Promise<string> {\n    const accountPath = hardenedPathOf(pathElements);\n    if (accountPath.length + 2 != pathElements.length) {\n      return \"\";\n    }\n    const accountXpub = await this.client.getExtendedPubkey(false, accountPath);\n    const masterFingerprint = await this.client.getMasterFingerprint();\n    const policy = new WalletPolicy(\n      descrTempl,\n      createKey(masterFingerprint, accountPath, accountXpub),\n    );\n    const changeAndIndex = pathElements.slice(-2, pathElements.length);\n    return this.client.getWalletAddress(\n      policy,\n      Buffer.alloc(32, 0),\n      changeAndIndex[0],\n      changeAndIndex[1],\n      display,\n    );\n  }\n\n  /**\n   * Build and sign a transaction. See Btc.createPaymentTransaction for\n   * details on how to use this method.\n   *\n   * This method will convert the legacy arguments, CreateTransactionArg, into\n   * a psbt which is finally signed and finalized, and the extracted fully signed\n   * transaction is returned.\n   */\n  async createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    const inputCount = arg.inputs.length;\n    if (inputCount == 0) {\n      throw Error(\"No inputs\");\n    }\n    const psbt = new PsbtV2();\n    // The master fingerprint is needed when adding BIP32 derivation paths on\n    // the psbt.\n    const masterFp = await this.client.getMasterFingerprint();\n\n    const accountType = accountTypeFromArg(arg, psbt, masterFp);\n\n    if (arg.lockTime != undefined) {\n      // The signer will assume locktime 0 if unset\n      psbt.setGlobalFallbackLocktime(arg.lockTime);\n    }\n    psbt.setGlobalInputCount(inputCount);\n    psbt.setGlobalPsbtVersion(2);\n    psbt.setGlobalTxVersion(2);\n\n    let notifyCount = 0;\n    const progress = () => {\n      if (!arg.onDeviceStreaming) return;\n      arg.onDeviceStreaming({\n        total: 2 * inputCount,\n        index: notifyCount,\n        progress: ++notifyCount / (2 * inputCount),\n      });\n    };\n\n    let accountXpub = \"\";\n    let accountPath: number[] = [];\n    for (let i = 0; i < inputCount; i++) {\n      progress();\n      const pathElems: number[] = pathStringToArray(arg.associatedKeysets[i]);\n      if (accountXpub == \"\") {\n        // We assume all inputs belong to the same account so we set\n        // the account xpub and path based on the first input.\n        accountPath = pathElems.slice(0, -2);\n        accountXpub = await this.client.getExtendedPubkey(false, accountPath);\n      }\n      await this.setInput(\n        psbt,\n        i,\n        arg.inputs[i],\n        pathElems,\n        accountType,\n        masterFp,\n        arg.sigHashType,\n      );\n    }\n\n    const outputsConcat = Buffer.from(arg.outputScriptHex, \"hex\");\n    const outputsBufferReader = new BufferReader(outputsConcat);\n    const outputCount = outputsBufferReader.readVarInt();\n    psbt.setGlobalOutputCount(outputCount);\n    const changeData = await this.outputScriptAt(accountPath, accountType, arg.changePath);\n    // If the caller supplied a changePath, we must make sure there actually is\n    // a change output. If no change output found, we'll throw an error.\n    let changeFound = !changeData;\n    for (let i = 0; i < outputCount; i++) {\n      const amount = Number(outputsBufferReader.readUInt64());\n      const outputScript = outputsBufferReader.readVarSlice();\n      psbt.setOutputAmount(i, amount);\n      psbt.setOutputScript(i, outputScript);\n\n      // We won't know if we're paying to ourselves, because there's no\n      // information in arg to support multiple \"change paths\". One exception is\n      // if there are multiple outputs to the change address.\n      const isChange = changeData && outputScript.equals(changeData?.cond.scriptPubKey);\n      if (isChange) {\n        changeFound = true;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const changePath = pathStringToArray(arg.changePath!);\n        const pubkey = changeData.pubkey;\n\n        accountType.setOwnOutput(i, changeData.cond, [pubkey], [changePath]);\n      }\n    }\n    if (!changeFound) {\n      throw new Error(\n        \"Change script not found among outputs! \" + changeData?.cond.scriptPubKey.toString(\"hex\"),\n      );\n    }\n\n    const key = createKey(masterFp, accountPath, accountXpub);\n    const p = new WalletPolicy(accountType.getDescriptorTemplate(), key);\n    // This is cheating, because it's not actually requested on the\n    // device yet, but it will be, soonish.\n    if (arg.onDeviceSignatureRequested) arg.onDeviceSignatureRequested();\n\n    let firstSigned = false;\n    // This callback will be called once for each signature yielded.\n    const progressCallback = () => {\n      if (!firstSigned) {\n        firstSigned = true;\n        arg.onDeviceSignatureGranted && arg.onDeviceSignatureGranted();\n      }\n      progress();\n    };\n\n    await this.signPsbt(psbt, p, progressCallback);\n    finalize(psbt);\n    const serializedTx = extract(psbt);\n    return serializedTx.toString(\"hex\");\n  }\n\n  /**\n   * Signs an arbitrary hex-formatted message with the private key at\n   * the provided derivation path according to the Bitcoin Signature format\n   * and returns v, r, s.\n   */\n  async signMessage({ path, messageHex }: { path: string; messageHex: string }): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    const pathElements: number[] = pathStringToArray(path);\n    const message = Buffer.from(messageHex, \"hex\");\n    const sig = await this.client.signMessage(message, pathElements);\n    const buf = Buffer.from(sig, \"base64\");\n\n    const v = buf.readUInt8() - 27 - 4;\n    const r = buf.slice(1, 33).toString(\"hex\");\n    const s = buf.slice(33, 65).toString(\"hex\");\n\n    return {\n      v,\n      r,\n      s,\n    };\n  }\n\n  /**\n   * Calculates an output script along with public key and possible redeemScript\n   * from a path and accountType. The accountPath must be a prefix of path.\n   *\n   * @returns an object with output script (property \"script\"), redeemScript (if\n   * wrapped p2wpkh), and pubkey at provided path. The values of these three\n   * properties depend on the accountType used.\n   */\n  private async outputScriptAt(\n    accountPath: number[],\n    accountType: AccountType,\n    path: string | undefined,\n  ): Promise<{ cond: SpendingCondition; pubkey: Buffer } | undefined> {\n    if (!path) return undefined;\n    const pathElems = pathStringToArray(path);\n    // Make sure path is in our account, otherwise something fishy is probably\n    // going on.\n    for (let i = 0; i < accountPath.length; i++) {\n      if (accountPath[i] != pathElems[i]) {\n        throw new Error(`Path ${path} not in account ${pathArrayToString(accountPath)}`);\n      }\n    }\n    const xpub = await this.client.getExtendedPubkey(false, pathElems);\n    const pubkey = pubkeyFromXpub(xpub);\n    const cond = accountType.spendingCondition([pubkey]);\n    return { cond, pubkey };\n  }\n\n  /**\n   * Adds relevant data about an input to the psbt. This includes sequence,\n   * previous txid, output index, spent UTXO, redeem script for wrapped p2wpkh,\n   * public key and its derivation path.\n   */\n  private async setInput(\n    psbt: PsbtV2,\n    i: number,\n    input: [Transaction, number, string | null | undefined, number | null | undefined],\n    pathElements: number[],\n    accountType: AccountType,\n    masterFP: Buffer,\n    sigHashType?: number,\n  ): Promise<void> {\n    const inputTx = input[0];\n    const spentOutputIndex = input[1];\n    // redeemScript will be null for wrapped p2wpkh, we need to create it\n    // ourselves. But if set, it should be used.\n    const redeemScript = input[2] ? Buffer.from(input[2], \"hex\") : undefined;\n    const sequence = input[3];\n    if (sequence != undefined) {\n      psbt.setInputSequence(i, sequence);\n    }\n    if (sigHashType != undefined) {\n      psbt.setInputSighashType(i, sigHashType);\n    }\n    const inputTxBuffer = serializeTransaction(inputTx, true);\n    const inputTxid = crypto.hash256(inputTxBuffer);\n    const xpubBase58 = await this.client.getExtendedPubkey(false, pathElements);\n\n    const pubkey = pubkeyFromXpub(xpubBase58);\n    if (!inputTx.outputs) throw Error(\"Missing outputs array in transaction to sign\");\n    const spentTxOutput = inputTx.outputs[spentOutputIndex];\n    const spendCondition: SpendingCondition = {\n      scriptPubKey: spentTxOutput.script,\n      redeemScript: redeemScript,\n    };\n    const spentOutput = { cond: spendCondition, amount: spentTxOutput.amount };\n    accountType.setInput(i, inputTxBuffer, spentOutput, [pubkey], [pathElements]);\n\n    psbt.setInputPreviousTxId(i, inputTxid);\n    psbt.setInputOutputIndex(i, spentOutputIndex);\n  }\n\n  /**\n   * This implements the \"Signer\" role of the BIP370 transaction signing\n   * process.\n   *\n   * It ssks the hardware device to sign the a psbt using the specified wallet\n   * policy. This method assumes BIP32 derived keys are used for all inputs, see\n   * comment in-line. The signatures returned from the hardware device is added\n   * to the appropriate input fields of the PSBT.\n   */\n  private async signPsbt(\n    psbt: PsbtV2,\n    walletPolicy: WalletPolicy,\n    progressCallback: () => void,\n  ): Promise<void> {\n    const sigs: Map<number, Buffer> = await this.client.signPsbt(\n      psbt,\n      walletPolicy,\n      Buffer.alloc(32, 0),\n      progressCallback,\n    );\n    sigs.forEach((v, k) => {\n      // Note: Looking at BIP32 derivation does not work in the generic case,\n      // since some inputs might not have a BIP32-derived pubkey.\n      const pubkeys = psbt.getInputKeyDatas(k, psbtIn.BIP32_DERIVATION);\n      let pubkey;\n      if (pubkeys.length != 1) {\n        // No legacy BIP32_DERIVATION, assume we're using taproot.\n        pubkey = psbt.getInputKeyDatas(k, psbtIn.TAP_BIP32_DERIVATION);\n        if (pubkey.length == 0) {\n          throw Error(`Missing pubkey derivation for input ${k}`);\n        }\n        psbt.setInputTapKeySig(k, v);\n      } else {\n        pubkey = pubkeys[0];\n        psbt.setInputPartialSig(k, pubkey, v);\n      }\n    });\n  }\n}\n\n/**\n * This function returns a descriptor template based on the address format.\n * See https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md for details of\n * the bitcoin descriptor template.\n */\nfunction descrTemplFrom(addressFormat: AddressFormat): DefaultDescriptorTemplate {\n  if (addressFormat == \"legacy\") return \"pkh(@0)\";\n  if (addressFormat == \"p2sh\") return \"sh(wpkh(@0))\";\n  if (addressFormat == \"bech32\") return \"wpkh(@0)\";\n  if (addressFormat == \"bech32m\") return \"tr(@0)\";\n  throw new Error(\"Unsupported address format \" + addressFormat);\n}\n\nfunction accountTypeFromArg(\n  arg: CreateTransactionArg,\n  psbt: PsbtV2,\n  masterFp: Buffer,\n): AccountType {\n  if (arg.additionals.includes(\"bech32m\")) return new p2tr(psbt, masterFp);\n  if (arg.additionals.includes(\"bech32\")) return new p2wpkh(psbt, masterFp);\n  if (arg.segwit) return new p2wpkhWrapped(psbt, masterFp);\n  return new p2pkh(psbt, masterFp);\n}\n\n/*\n  The new protocol only allows standard path.\n  Standard paths are (currently):\n  M/44'/(1|0|88)'/X'\n  M/49'/(1|0|88)'/X'\n  M/84'/(1|0|88)'/X'\n  M/86'/(1|0|88)'/X'\n  M/48'/(1|0|88)'/X'/Y'\n  followed by \"\", \"(0|1)\", or \"(0|1)/b\", where a and b are \n  non-hardened. For example, the following paths are standard\n  M/48'/1'/99'/7'\n  M/86'/1'/99'/0\n  M/48'/0'/99'/7'/1/17\n  The following paths are non-standard\n  M/48'/0'/99'           // Not deepest hardened path\n  M/48'/0'/99'/7'/1/17/2 // Too many non-hardened derivation steps\n  M/199'/0'/1'/0/88      // Not a known purpose 199\n  M/86'/1'/99'/2         // Change path item must be 0 or 1\n\n  Useful resource on derivation paths: https://learnmeabitcoin.com/technical/derivation-paths\n*/\n\n//path is not deepest hardened node of a standard path or deeper, use BtcOld\nconst H = 0x80000000; //HARDENED from bip32\n\nconst VALID_COIN_TYPES = [\n  0, // Bitcoin\n  1, // Bitcoin (Testnet)\n  88, // Qtum\n];\n\nconst VALID_SINGLE_SIG_PURPOSES = [\n  44, // BIP44 - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\n  49, // BIP49 - https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki\n  84, // BIP84 - https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki\n  86, // BIP86 - https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki\n];\n\nconst VALID_MULTISIG_PURPOSES = [\n  48, // BIP48 - https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki\n];\n\nconst hard = (n: number) => n >= H;\nconst soft = (n: number | undefined) => n === undefined || n < H;\nconst change = (n: number | undefined) => n === undefined || n === 0 || n === 1;\n\nconst validCoinPathPartsSet = new Set(VALID_COIN_TYPES.map(t => t + H));\nconst validSingleSigPurposePathPartsSet = new Set(VALID_SINGLE_SIG_PURPOSES.map(t => t + H));\nconst validMultiSigPurposePathPartsSet = new Set(VALID_MULTISIG_PURPOSES.map(t => t + H));\n\nexport function isPathNormal(path: string): boolean {\n  const pathElems = pathStringToArray(path);\n\n  // Single sig\n  if (\n    pathElems.length >= 3 &&\n    pathElems.length <= 5 &&\n    validSingleSigPurposePathPartsSet.has(pathElems[0]) &&\n    validCoinPathPartsSet.has(pathElems[1]) &&\n    hard(pathElems[2]) &&\n    change(pathElems[3]) &&\n    soft(pathElems[4])\n  ) {\n    return true;\n  }\n\n  // Multi sig\n  if (\n    pathElems.length >= 4 &&\n    pathElems.length <= 6 &&\n    validMultiSigPurposePathPartsSet.has(pathElems[0]) &&\n    validCoinPathPartsSet.has(pathElems[1]) &&\n    hard(pathElems[2]) &&\n    hard(pathElems[3]) &&\n    change(pathElems[4]) &&\n    soft(pathElems[5])\n  ) {\n    return true;\n  }\n  return false;\n}\n","import { BufferWriter } from \"../buffertools\";\nimport { PsbtV2 } from \"./psbtv2\";\n\n/**\n * This implements the \"Transaction Extractor\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#transaction-extractor). However\n * the role is partially documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#transaction-extractor).\n */\nexport function extract(psbt: PsbtV2): Buffer {\n  const tx = new BufferWriter();\n  tx.writeUInt32(psbt.getGlobalTxVersion());\n\n  const isSegwit = !!psbt.getInputWitnessUtxo(0);\n  if (isSegwit) {\n    tx.writeSlice(Buffer.from([0, 1]));\n  }\n  const inputCount = psbt.getGlobalInputCount();\n  tx.writeVarInt(inputCount);\n  const witnessWriter = new BufferWriter();\n  for (let i = 0; i < inputCount; i++) {\n    tx.writeSlice(psbt.getInputPreviousTxid(i));\n    tx.writeUInt32(psbt.getInputOutputIndex(i));\n    tx.writeVarSlice(psbt.getInputFinalScriptsig(i) ?? Buffer.from([]));\n    tx.writeUInt32(psbt.getInputSequence(i));\n    if (isSegwit) {\n      witnessWriter.writeSlice(psbt.getInputFinalScriptwitness(i));\n    }\n  }\n  const outputCount = psbt.getGlobalOutputCount();\n  tx.writeVarInt(outputCount);\n  for (let i = 0; i < outputCount; i++) {\n    tx.writeUInt64(psbt.getOutputAmount(i));\n    tx.writeVarSlice(psbt.getOutputScript(i));\n  }\n  tx.writeSlice(witnessWriter.buffer());\n  tx.writeUInt32(psbt.getGlobalFallbackLocktime() ?? 0);\n  return tx.buffer();\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\n\n/**\n * address format is one of legacy | p2sh | bech32 | bech32m | cashaddr\n */\nexport type AddressFormat = \"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\";\nconst addressFormatMap = {\n  legacy: 0,\n  p2sh: 1,\n  bech32: 2,\n  cashaddr: 3,\n};\nexport async function getWalletPublicKey(\n  transport: Transport,\n  options: {\n    path: string;\n    verify?: boolean;\n    format?: AddressFormat;\n  },\n): Promise<{\n  publicKey: string;\n  bitcoinAddress: string;\n  chainCode: string;\n}> {\n  const { path, verify, format } = {\n    verify: false,\n    format: \"legacy\",\n    ...options,\n  };\n\n  if (!(format in addressFormatMap)) {\n    throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n  }\n\n  const buffer = bip32asBuffer(path);\n  const p1 = verify ? 1 : 0;\n  const p2 = addressFormatMap[format];\n  const response = await transport.send(0xe0, 0x40, p1, p2, buffer);\n  const publicKeyLength = response[0];\n  const addressLength = response[1 + publicKeyLength];\n  const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n  const bitcoinAddress = response\n    .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n    .toString(\"ascii\");\n  const chainCode = response\n    .slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32)\n    .toString(\"hex\");\n  return {\n    publicKey,\n    bitcoinAddress,\n    chainCode,\n  };\n}\n","import invariant from \"invariant\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nimport { createVarint } from \"./varint\";\nexport async function getTrustedInputRaw(\n  transport: Transport,\n  transactionData: Buffer,\n  indexLookup?: number | null | undefined,\n): Promise<string> {\n  let data;\n  let firstRound = false;\n\n  if (typeof indexLookup === \"number\") {\n    firstRound = true;\n    const prefix = Buffer.alloc(4);\n    prefix.writeUInt32BE(indexLookup, 0);\n    data = Buffer.concat([prefix, transactionData], transactionData.length + 4);\n  } else {\n    data = transactionData;\n  }\n\n  const trustedInput = await transport.send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data);\n  const res = trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\");\n  return res;\n}\nexport async function getTrustedInput(\n  transport: Transport,\n  indexLookup: number,\n  transaction: Transaction,\n  additionals: Array<string> = [],\n): Promise<string> {\n  const { version, inputs, outputs, locktime, nExpiryHeight, extraData } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n  const isXST = additionals.includes(\"stealthcoin\");\n\n  const processScriptBlocks = async (script, sequence?: Buffer) => {\n    const seq = sequence || Buffer.alloc(0);\n    const scriptBlocks: Buffer[] = [];\n    let offset = 0;\n\n    while (offset !== script.length) {\n      const blockSize =\n        script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : script.length - offset;\n\n      if (offset + blockSize !== script.length) {\n        scriptBlocks.push(script.slice(offset, offset + blockSize));\n      } else {\n        scriptBlocks.push(Buffer.concat([script.slice(offset, offset + blockSize), seq]));\n      }\n\n      offset += blockSize;\n    }\n\n    // Handle case when no script length: we still want to pass the sequence\n    // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n    if (script.length === 0) {\n      scriptBlocks.push(seq);\n    }\n\n    let res;\n\n    for (const scriptBlock of scriptBlocks) {\n      res = await getTrustedInputRaw(transport, scriptBlock);\n    }\n\n    return res;\n  };\n\n  const processWholeScriptBlock = block => getTrustedInputRaw(transport, block);\n\n  await getTrustedInputRaw(\n    transport,\n    Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      createVarint(inputs.length),\n    ]),\n    indexLookup,\n  );\n\n  for (const input of inputs) {\n    const isXSTV2 = isXST && Buffer.compare(version, Buffer.from([0x02, 0x00, 0x00, 0x00])) === 0;\n    const treeField = isDecred ? input.tree || Buffer.from([0x00]) : Buffer.alloc(0);\n    const data = Buffer.concat([\n      input.prevout,\n      treeField,\n      isXSTV2 ? Buffer.from([0x00]) : createVarint(input.script.length),\n    ]);\n    await getTrustedInputRaw(transport, data);\n    // iteration (eachSeries) ended\n    // TODO notify progress\n    // deferred.notify(\"input\");\n    // Reference: https://github.com/StealthSend/Stealth/commit/5be35d6c2c500b32ed82e5d6913d66d18a4b0a7f#diff-e8db9b851adc2422aadfffca88f14c91R566\n    await (isDecred\n      ? processWholeScriptBlock(Buffer.concat([input.script, input.sequence]))\n      : isXSTV2\n        ? processWholeScriptBlock(input.sequence)\n        : processScriptBlocks(input.script, input.sequence));\n  }\n\n  await getTrustedInputRaw(transport, createVarint(outputs.length));\n\n  for (const output of outputs) {\n    const data = Buffer.concat([\n      output.amount,\n      isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n      createVarint(output.script.length),\n      output.script,\n    ]);\n    await getTrustedInputRaw(transport, data);\n  }\n\n  const endData: Buffer[] = [];\n\n  if (nExpiryHeight && nExpiryHeight.length > 0) {\n    endData.push(nExpiryHeight);\n  }\n\n  if (extraData && extraData.length > 0) {\n    endData.push(extraData);\n  }\n\n  let extraPart;\n\n  if (endData.length) {\n    const data = Buffer.concat(endData);\n    extraPart = isDecred ? data : Buffer.concat([createVarint(data.length), data]);\n  }\n\n  const res = await processScriptBlocks(Buffer.concat([locktime, extraPart || Buffer.alloc(0)]));\n  invariant(res, \"missing result in processScriptBlocks\");\n  return res;\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function startUntrustedHashTransactionInputRaw(\n  transport: Transport,\n  newTransaction: boolean,\n  firstRound: boolean,\n  transactionData: Buffer,\n  bip143 = false,\n  overwinter = false,\n  additionals: Array<string> = [],\n): Promise<Buffer> {\n  const p2 = additionals.includes(\"cashaddr\")\n    ? 0x03\n    : bip143\n      ? additionals.includes(\"sapling\")\n        ? 0x05\n        : overwinter\n          ? 0x04\n          : 0x02\n      : 0x00;\n  return transport.send(\n    0xe0,\n    0x44,\n    firstRound ? 0x00 : 0x80,\n    newTransaction ? p2 : 0x80,\n    transactionData,\n  );\n}\nexport async function startUntrustedHashTransactionInput(\n  transport: Transport,\n  newTransaction: boolean,\n  transaction: Transaction,\n  inputs: Array<{\n    trustedInput: boolean;\n    value: Buffer;\n  }>,\n  bip143 = false,\n  overwinter = false,\n  additionals: Array<string> = [],\n  useTrustedInputForSegwit = false,\n): Promise<any> {\n  let data = Buffer.concat([\n    transaction.version,\n    transaction.timestamp || Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n  ]);\n  await startUntrustedHashTransactionInputRaw(\n    transport,\n    newTransaction,\n    true,\n    data,\n    bip143,\n    overwinter,\n    additionals,\n  );\n  let i = 0;\n  const isDecred = additionals.includes(\"decred\");\n\n  for (const input of transaction.inputs) {\n    let prefix;\n    const inputValue = inputs[i].value;\n\n    if (bip143) {\n      if (useTrustedInputForSegwit && inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputValue.length]);\n      } else {\n        prefix = Buffer.from([0x02]);\n      }\n    } else {\n      if (inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputs[i].value.length]);\n      } else {\n        prefix = Buffer.from([0x00]);\n      }\n    }\n\n    data = Buffer.concat([\n      prefix,\n      inputValue,\n      isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n      createVarint(input.script.length),\n    ]);\n    await startUntrustedHashTransactionInputRaw(\n      transport,\n      newTransaction,\n      false,\n      data,\n      bip143,\n      overwinter,\n      additionals,\n    );\n    const scriptBlocks: Buffer[] = [];\n    let offset = 0;\n\n    if (input.script.length === 0) {\n      scriptBlocks.push(input.sequence);\n    } else {\n      while (offset !== input.script.length) {\n        const blockSize =\n          input.script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : input.script.length - offset;\n\n        if (offset + blockSize !== input.script.length) {\n          scriptBlocks.push(input.script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([input.script.slice(offset, offset + blockSize), input.sequence]),\n          );\n        }\n\n        offset += blockSize;\n      }\n    }\n\n    for (const scriptBlock of scriptBlocks) {\n      await startUntrustedHashTransactionInputRaw(\n        transport,\n        newTransaction,\n        false,\n        scriptBlock,\n        bip143,\n        overwinter,\n        additionals,\n      );\n    }\n\n    i++;\n  }\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport shajs from \"sha.js\";\nimport type { Transaction } from \"./types\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nexport function getTrustedInputBIP143(\n  transport: Transport,\n  indexLookup: number,\n  transaction: Transaction,\n  additionals: Array<string> = [],\n): string {\n  if (!transaction) {\n    throw new Error(\"getTrustedInputBIP143: missing tx\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n\n  if (isDecred) {\n    throw new Error(\"Decred does not implement BIP143\");\n  }\n\n  let hash = shajs(\"sha256\")\n    .update(shajs(\"sha256\").update(serializeTransaction(transaction, true)).digest())\n    .digest();\n  const data = Buffer.alloc(4);\n  data.writeUInt32LE(indexLookup, 0);\n  const { outputs, locktime } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n  }\n\n  if (!outputs[indexLookup]) {\n    throw new Error(\"getTrustedInputBIP143: wrong index\");\n  }\n\n  hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n  return hash.toString(\"hex\");\n}\n","export function compressPublicKey(publicKey: Buffer): Buffer {\n  const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n  const prefixBuffer = Buffer.alloc(1);\n  prefixBuffer[0] = prefix;\n  return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\nexport function signTransaction(\n  transport: Transport,\n  path: string,\n  lockTime: number,\n  sigHashType: number,\n  expiryHeight?: Buffer,\n  additionals: Array<string> = [],\n): Promise<Buffer> {\n  const isDecred = additionals.includes(\"decred\");\n  const pathsBuffer = bip32asBuffer(path);\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32BE(lockTime, 0);\n  let buffer = isDecred\n    ? Buffer.concat([\n        pathsBuffer,\n        lockTimeBuffer,\n        expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n        Buffer.from([sigHashType]),\n      ])\n    : Buffer.concat([pathsBuffer, Buffer.from([0x00]), lockTimeBuffer, Buffer.from([sigHashType])]);\n\n  if (expiryHeight && !isDecred) {\n    buffer = Buffer.concat([buffer, expiryHeight]);\n  }\n\n  return transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n    if (result.length > 0) {\n      result[0] = 0x30;\n      return result.slice(0, result.length - 2);\n    }\n\n    return result;\n  });\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function provideOutputFullChangePath(transport: Transport, path: string): Promise<Buffer> {\n  const buffer = bip32asBuffer(path);\n  return transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n}\nexport async function hashOutputFull(\n  transport: Transport,\n  outputScript: Buffer,\n  additionals: Array<string> = [],\n): Promise<Buffer | void> {\n  let offset = 0;\n  const p1 = Number(0x80);\n  const isDecred = additionals.includes(\"decred\");\n\n  ///WARNING: Decred works only with one call (without chunking)\n  //TODO: test without this for Decred\n  if (isDecred) {\n    return transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n  }\n\n  while (offset < outputScript.length) {\n    const blockSize =\n      offset + MAX_SCRIPT_BLOCK >= outputScript.length\n        ? outputScript.length - offset\n        : MAX_SCRIPT_BLOCK;\n    const p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n    const data = outputScript.slice(offset, offset + blockSize);\n    await transport.send(0xe0, 0x4a, p1, 0x00, data);\n    offset += blockSize;\n  }\n}\n","import invariant from \"invariant\";\nimport Transport from \"@ledgerhq/hw-transport\";\n\nexport type AppAndVersion = {\n  name: string;\n  version: string;\n  flags: number | Buffer;\n};\n\nexport const getAppAndVersion = async (transport: Transport): Promise<AppAndVersion> => {\n  const r = await transport.send(0xb0, 0x01, 0x00, 0x00);\n  let i = 0;\n  const format = r[i++];\n  invariant(format === 1, \"getAppAndVersion: format not supported\");\n  const nameLength = r[i++];\n  const name = r.slice(i, (i += nameLength)).toString(\"ascii\");\n  const versionLength = r[i++];\n  const version = r.slice(i, (i += versionLength)).toString(\"ascii\");\n  const flagLength = r[i++];\n  const flags = r.slice(i, (i += flagLength));\n  return {\n    name,\n    version,\n    flags,\n  };\n};\n\nexport const checkIsBtcLegacy = async (transport: Transport): Promise<boolean> => {\n  try {\n    // Call old btc API, it will throw an exception with new btc app. It is a workaround to differentiate new/old btc nano app\n    await transport.send(0xe0, 0xc4, 0, 0);\n  } catch (e: unknown) {\n    return false;\n  }\n  return true;\n};\n","import { log } from \"@ledgerhq/logs\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { hashPublicKey } from \"./hashPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { compressPublicKey } from \"./compressPublicKey\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull, provideOutputFullChangePath } from \"./finalizeInput\";\nimport { getAppAndVersion } from \"./getAppAndVersion\";\nimport type { TransactionOutput, Transaction } from \"./types\";\nimport {\n  DEFAULT_LOCKTIME,\n  DEFAULT_SEQUENCE,\n  SIGHASH_ALL,\n  OP_DUP,\n  OP_HASH160,\n  HASH_SIZE,\n  OP_EQUALVERIFY,\n  OP_CHECKSIG,\n} from \"./constants\";\nimport { shouldUseTrustedInputForSegwit } from \"./shouldUseTrustedInputForSegwit\";\nexport type { AddressFormat };\nconst defaultsSignTransaction = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  additionals: [],\n  onDeviceStreaming: _e => {},\n  onDeviceSignatureGranted: () => {},\n  onDeviceSignatureRequested: () => {},\n};\n\n/**\n *\n */\nexport type CreateTransactionArg = {\n  inputs: Array<[Transaction, number, string | null | undefined, number | null | undefined]>;\n  associatedKeysets: string[];\n  changePath?: string;\n  outputScriptHex: string;\n  lockTime?: number;\n  sigHashType?: number;\n  segwit?: boolean;\n  initialTimestamp?: number;\n  additionals: Array<string>;\n  expiryHeight?: Buffer;\n  useTrustedInputForSegwit?: boolean;\n  onDeviceStreaming?: (arg0: { progress: number; total: number; index: number }) => void;\n  onDeviceSignatureRequested?: () => void;\n  onDeviceSignatureGranted?: () => void;\n};\nexport async function createTransaction(\n  transport: Transport,\n  arg: CreateTransactionArg,\n): Promise<string> {\n  const signTx = { ...defaultsSignTransaction, ...arg };\n  const {\n    inputs,\n    associatedKeysets,\n    changePath,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    initialTimestamp,\n    additionals,\n    expiryHeight,\n    onDeviceStreaming,\n    onDeviceSignatureGranted,\n    onDeviceSignatureRequested,\n  } = signTx;\n  let useTrustedInputForSegwit = signTx.useTrustedInputForSegwit;\n\n  if (useTrustedInputForSegwit === undefined) {\n    try {\n      const a = await getAppAndVersion(transport);\n      useTrustedInputForSegwit = shouldUseTrustedInputForSegwit(a);\n    } catch (e: any) {\n      if (e.statusCode === 0x6d00) {\n        useTrustedInputForSegwit = false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // loop: 0 or 1 (before and after)\n  // i: index of the input being streamed\n  // i goes on 0...n, inluding n. in order for the progress value to go to 1\n  // we normalize the 2 loops to make a global percentage\n  const notify = (loop, i) => {\n    const { length } = inputs;\n    if (length < 3) return; // there is not enough significant event to worth notifying (aka just use a spinner)\n\n    const index = length * loop + i;\n    const total = 2 * length;\n    const progress = index / total;\n    onDeviceStreaming({\n      progress,\n      total,\n      index,\n    });\n  };\n\n  const isDecred = additionals.includes(\"decred\");\n  const isZcash = additionals.includes(\"zcash\");\n  const isXST = additionals.includes(\"stealthcoin\");\n  const startTime = Date.now();\n  const sapling = additionals.includes(\"sapling\");\n  const bech32 = segwit && additionals.includes(\"bech32\");\n  const useBip143 =\n    segwit ||\n    (!!additionals &&\n      (additionals.includes(\"abc\") ||\n        additionals.includes(\"gold\") ||\n        additionals.includes(\"bip143\"))) ||\n    (!!expiryHeight && !isDecred);\n  // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32LE(lockTime, 0);\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  !!expiryHeight && !isDecred\n    ? defaultVersion.writeUInt32LE(isZcash ? 0x80000005 : sapling ? 0x80000004 : 0x80000003, 0) // v5 format for zcash refer to https://zips.z.cash/zip-0225\n    : isXST\n      ? defaultVersion.writeUInt32LE(2, 0)\n      : defaultVersion.writeUInt32LE(1, 0);\n  // Default version to 2 for XST not to have timestamp\n  const trustedInputs: Array<any> = [];\n  const regularOutputs: Array<TransactionOutput> = [];\n  const signatures: Buffer[] = [];\n  const publicKeys: Buffer[] = [];\n  let firstRun = true;\n  const resuming = false;\n  const targetTransaction: Transaction = {\n    inputs: [],\n    version: defaultVersion,\n    timestamp: Buffer.alloc(0),\n  };\n  const getTrustedInputCall =\n    useBip143 && !useTrustedInputForSegwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n  notify(0, 0);\n  // first pass on inputs to get trusted inputs\n  for (const input of inputs) {\n    if (!resuming) {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0], additionals);\n      log(\"hw\", \"got trustedInput=\" + trustedInput);\n      const sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(\n        input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n        0,\n      );\n      trustedInputs.push({\n        trustedInput: true,\n        value: Buffer.from(trustedInput, \"hex\"),\n        sequence,\n      });\n    }\n\n    const { outputs } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n\n    if (expiryHeight && !isDecred) {\n      targetTransaction.nVersionGroupId = Buffer.from(\n        // nVersionGroupId is 0x26A7270A for zcash NU5 upgrade\n        // refer to https://github.com/zcash/zcash/blob/master/src/primitives/transaction.h\n        isZcash\n          ? [0x0a, 0x27, 0xa7, 0x26]\n          : sapling\n            ? [0x85, 0x20, 0x2f, 0x89]\n            : [0x70, 0x82, 0xc4, 0x03],\n      );\n      targetTransaction.nExpiryHeight = expiryHeight;\n      // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n      // Overwinter : use nJoinSplit (1)\n      targetTransaction.extraData = Buffer.from(\n        sapling ? [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] : [0x00],\n      );\n    } else if (isDecred) {\n      targetTransaction.nExpiryHeight = expiryHeight;\n    }\n  }\n\n  targetTransaction.inputs = inputs.map((input, idx) => {\n    const sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(\n      input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n      0,\n    );\n    return {\n      script: isZcash ? regularOutputs[idx].script : nullScript,\n      prevout: nullPrevout,\n      sequence,\n    };\n  });\n\n  if (!resuming) {\n    // Collect public keys\n    const result: {\n      publicKey: string;\n      bitcoinAddress: string;\n      chainCode: string;\n    }[] = [];\n\n    for (let i = 0; i < inputs.length; i++) {\n      const r = await getWalletPublicKey(transport, {\n        path: associatedKeysets[i],\n      });\n      notify(0, i + 1);\n      result.push(r);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      publicKeys.push(compressPublicKey(Buffer.from(result[i].publicKey, \"hex\")));\n    }\n  }\n\n  if (initialTimestamp !== undefined) {\n    targetTransaction.timestamp = Buffer.alloc(4);\n    targetTransaction.timestamp.writeUInt32LE(\n      Math.floor(initialTimestamp + (Date.now() - startTime) / 1000),\n      0,\n    );\n  }\n\n  onDeviceSignatureRequested();\n\n  if (useBip143) {\n    // Do the first run with all inputs\n    await startUntrustedHashTransactionInput(\n      transport,\n      true,\n      targetTransaction,\n      trustedInputs,\n      true,\n      !!expiryHeight,\n      additionals,\n      useTrustedInputForSegwit,\n    );\n\n    if (!resuming && changePath) {\n      await provideOutputFullChangePath(transport, changePath);\n    }\n\n    await hashOutputFull(transport, outputScript);\n  }\n\n  if (!!expiryHeight && !isDecred) {\n    await signTransaction(transport, \"\", lockTime, SIGHASH_ALL, expiryHeight);\n  }\n\n  // Do the second run with the individual transaction\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const script =\n      inputs[i].length >= 3 && typeof input[2] === \"string\"\n        ? Buffer.from(input[2], \"hex\")\n        : !segwit\n          ? regularOutputs[i].script\n          : Buffer.concat([\n              Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n              hashPublicKey(publicKeys[i]),\n              Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]),\n            ]);\n    const pseudoTX = Object.assign({}, targetTransaction);\n    const pseudoTrustedInputs = useBip143 ? [trustedInputs[i]] : trustedInputs;\n\n    if (useBip143) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(\n      transport,\n      !useBip143 && firstRun,\n      pseudoTX,\n      pseudoTrustedInputs,\n      useBip143,\n      !!expiryHeight && !isDecred,\n      additionals,\n      useTrustedInputForSegwit,\n    );\n\n    if (!useBip143) {\n      if (!resuming && changePath) {\n        await provideOutputFullChangePath(transport, changePath);\n      }\n\n      await hashOutputFull(transport, outputScript, additionals);\n    }\n\n    if (firstRun) {\n      onDeviceSignatureGranted();\n      notify(1, 0);\n    }\n\n    const signature = await signTransaction(\n      transport,\n      associatedKeysets[i],\n      lockTime,\n      sigHashType,\n      expiryHeight,\n      additionals,\n    );\n    notify(1, i + 1);\n    signatures.push(signature);\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  // Populate the final input scripts\n  for (let i = 0; i < inputs.length; i++) {\n    if (segwit) {\n      targetTransaction.witness = Buffer.alloc(0);\n\n      if (!bech32) {\n        targetTransaction.inputs[i].script = Buffer.concat([\n          Buffer.from(\"160014\", \"hex\"),\n          hashPublicKey(publicKeys[i]),\n        ]);\n      }\n    } else {\n      const signatureSize = Buffer.alloc(1);\n      const keySize = Buffer.alloc(1);\n      signatureSize[0] = signatures[i].length;\n      keySize[0] = publicKeys[i].length;\n      targetTransaction.inputs[i].script = Buffer.concat([\n        signatureSize,\n        signatures[i],\n        keySize,\n        publicKeys[i],\n      ]);\n    }\n\n    const offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;\n    targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 0x24);\n  }\n  targetTransaction.locktime = lockTimeBuffer;\n  let result = Buffer.concat([\n    serializeTransaction(targetTransaction, false, targetTransaction.timestamp, additionals),\n    outputScript,\n  ]);\n\n  if (segwit && !isDecred) {\n    let witness = Buffer.alloc(0);\n\n    for (let i = 0; i < inputs.length; i++) {\n      const tmpScriptData = Buffer.concat([\n        Buffer.from(\"02\", \"hex\"),\n        Buffer.from([signatures[i].length]),\n        signatures[i],\n        Buffer.from([publicKeys[i].length]),\n        publicKeys[i],\n      ]);\n      witness = Buffer.concat([witness, tmpScriptData]);\n    }\n\n    result = Buffer.concat([result, witness]);\n  }\n\n  // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n  if (!isZcash) {\n    result = Buffer.concat([result, lockTimeBuffer]);\n    if (expiryHeight) {\n      result = Buffer.concat([\n        result,\n        targetTransaction.nExpiryHeight || Buffer.alloc(0),\n        targetTransaction.extraData || Buffer.alloc(0),\n      ]);\n    }\n  }\n  if (isDecred) {\n    let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n    inputs.forEach((input, inputIndex) => {\n      decredWitness = Buffer.concat([\n        decredWitness,\n        Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n        Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n        Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n        Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n        targetTransaction.inputs[inputIndex].script,\n      ]);\n    });\n    result = Buffer.concat([result, decredWitness]);\n  }\n  if (isZcash) {\n    result = Buffer.concat([result, Buffer.from([0x00, 0x00, 0x00])]);\n  }\n  return result.toString(\"hex\");\n}\n","import semver from \"semver\";\nexport function shouldUseTrustedInputForSegwit({\n  version,\n  name,\n}: {\n  version: string;\n  name: string;\n}): boolean {\n  if (name === \"Decred\") return false;\n  if (name === \"Exchange\") return true;\n  return semver.gte(version, \"1.4.0\");\n}\n","import bs58 from \"bs58\";\nimport RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport { createTransaction } from \"./createTransaction\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport { pathArrayToString, pathStringToArray } from \"./bip32\";\nimport { signMessage } from \"./signMessage\";\nexport type { AddressFormat };\n\n/**\n * @class BtcOld\n * @description This Bitcoin old API is compatible with versions of the Bitcoin nano app that are earlier than 2.1.0\n *\n */\n\nexport default class BtcOld {\n  constructor(private transport: Transport) {}\n\n  private derivationsCache = {};\n  private async derivatePath(path: string) {\n    if (this.derivationsCache[path]) return this.derivationsCache[path];\n    const res = await getWalletPublicKey(this.transport, {\n      path,\n    });\n    this.derivationsCache[path] = res;\n    return res;\n  }\n\n  async getWalletXpub({\n    path,\n    xpubVersion,\n  }: {\n    path: string;\n    xpubVersion: number;\n  }): Promise<string> {\n    const pathElements = pathStringToArray(path);\n    const parentPath = pathElements.slice(0, -1);\n    const parentDerivation = await this.derivatePath(pathArrayToString(parentPath));\n    const accountDerivation = await this.derivatePath(path);\n    const fingerprint = makeFingerprint(\n      compressPublicKeySECP256(Buffer.from(parentDerivation.publicKey, \"hex\")),\n    );\n    const xpub = makeXpub(\n      xpubVersion,\n      pathElements.length,\n      fingerprint,\n      pathElements[pathElements.length - 1],\n      Buffer.from(accountDerivation.chainCode, \"hex\"),\n      compressPublicKeySECP256(Buffer.from(accountDerivation.publicKey, \"hex\")),\n    );\n    return xpub;\n  }\n\n  /**\n   * @param path a BIP 32 path\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) will ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 84' paths\n   *\n   * - bech32m format with 86' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    if (opts?.format === \"bech32m\") {\n      throw new Error(\"Unsupported address format bech32m\");\n    }\n    return getWalletPublicKey(this.transport, { ...opts, path });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"decred\" for decred\n   * - \"zcash\" for zcash\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n  createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    if (arguments.length > 1) {\n      throw new Error(\n        \"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\",\n      );\n    }\n    return createTransaction(this.transport, arg);\n  }\n\n  async signMessage({ path, messageHex }: { path: string; messageHex: string }): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    return signMessage(this.transport, {\n      path,\n      messageHex,\n    });\n  }\n}\n\nfunction makeFingerprint(compressedPubKey) {\n  return hash160(compressedPubKey).slice(0, 4);\n}\n\nfunction asBufferUInt32BE(n: number): Buffer {\n  const buf = Buffer.allocUnsafe(4);\n  buf.writeUInt32BE(n, 0);\n  return buf;\n}\n\nconst compressPublicKeySECP256 = (publicKey: Buffer) =>\n  Buffer.concat([Buffer.from([0x02 + (publicKey[64] & 0x01)]), publicKey.slice(1, 33)]);\n\nfunction makeXpub(\n  version: number,\n  depth: number,\n  parentFingerprint: Buffer,\n  index: number,\n  chainCode: Buffer,\n  pubKey: Buffer,\n) {\n  const indexBuffer = asBufferUInt32BE(index);\n  indexBuffer[0] |= 0x80;\n  const extendedKeyBytes = Buffer.concat([\n    asBufferUInt32BE(version),\n    Buffer.from([depth]),\n    parentFingerprint,\n    indexBuffer,\n    chainCode,\n    pubKey,\n  ]);\n  const checksum = hash256(extendedKeyBytes).slice(0, 4);\n  return bs58.encode(Buffer.concat([extendedKeyBytes, checksum]));\n}\n\nfunction sha256(buffer: Buffer | string) {\n  return sha(\"sha256\").update(buffer).digest();\n}\nfunction hash256(buffer: Buffer | string) {\n  return sha256(sha256(buffer));\n}\nfunction ripemd160(buffer: Buffer | string) {\n  return new RIPEMD160().update(buffer).digest();\n}\nfunction hash160(buffer: Buffer | string) {\n  return ripemd160(sha256(buffer));\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport bippath from \"bip32-path\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport async function signMessage(\n  transport: Transport,\n  {\n    path,\n    messageHex,\n  }: {\n    path: string;\n    messageHex: string;\n  },\n): Promise<{\n  v: number;\n  r: string;\n  s: string;\n}> {\n  const paths = bippath.fromString(path).toPathArray();\n  const message = Buffer.from(messageHex, \"hex\");\n  let offset = 0;\n\n  while (offset !== message.length) {\n    const maxChunkSize =\n      offset === 0 ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4 : MAX_SCRIPT_BLOCK;\n    const chunkSize =\n      offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n    const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);\n\n    if (offset === 0) {\n      buffer[0] = paths.length;\n      paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n      message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);\n    } else {\n      message.copy(buffer, 0, offset, offset + chunkSize);\n    }\n\n    await transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n    offset += chunkSize;\n  }\n\n  const res = await transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n  const v = res[0] - 0x30;\n  let r: Buffer | string = res.slice(4, 4 + res[3]);\n\n  if (r[0] === 0) {\n    r = r.slice(1);\n  }\n\n  r = r.toString(\"hex\");\n  offset = 4 + res[3] + 2;\n  let s: Buffer | string = res.slice(offset, offset + res[offset - 1]);\n\n  if (s[0] === 0) {\n    s = s.slice(1);\n  }\n\n  s = s.toString(\"hex\");\n  return {\n    v,\n    r,\n    s,\n  };\n}\n","import { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\n/**\n * This implements \"Merkelized Maps\", documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md#merkleized-maps\n *\n * A merkelized map consist of two merkle trees, one for the keys of\n * a map and one for the values of the same map, thus the two merkle\n * trees have the same shape. The commitment is the number elements\n * in the map followed by the keys' merkle root followed by the\n * values' merkle root.\n */\nexport class MerkleMap {\n  keys: Buffer[];\n  keysTree: Merkle;\n  values: Buffer[];\n  valuesTree: Merkle;\n  /**\n   * @param keys Sorted list of (unhashed) keys\n   * @param values values, in corresponding order as the keys, and of equal length\n   */\n  constructor(keys: Buffer[], values: Buffer[]) {\n    if (keys.length != values.length) {\n      throw new Error(\"keys and values should have the same length\");\n    }\n\n    // Sanity check: verify that keys are actually sorted and with no duplicates\n    for (let i = 0; i < keys.length - 1; i++) {\n      if (keys[i].toString(\"hex\") >= keys[i + 1].toString(\"hex\")) {\n        throw new Error(\"keys must be in strictly increasing order\");\n      }\n    }\n\n    this.keys = keys;\n    this.keysTree = new Merkle(keys.map(k => hashLeaf(k)));\n    this.values = values;\n    this.valuesTree = new Merkle(values.map(v => hashLeaf(v)));\n  }\n\n  commitment(): Buffer {\n    // returns a buffer between 65 and 73 (included) bytes long\n    return Buffer.concat([\n      createVarint(this.keys.length),\n      this.keysTree.getRoot(),\n      this.valuesTree.getRoot(),\n    ]);\n  }\n}\n","import { MerkleMap } from \"./merkleMap\";\nimport { PsbtV2 } from \"./psbtv2\";\n\n/**\n * This class merkelizes a PSBTv2, by merkelizing the different\n * maps of the psbt. This is used during the transaction signing process,\n * where the hardware app can request specific parts of the psbt from the\n * client code and be sure that the response data actually belong to the psbt.\n * The reason for this is the limited amount of memory available to the app,\n * so it can't always store the full psbt in memory.\n *\n * The signing process is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#sign_psbt\n */\nexport class MerkelizedPsbt extends PsbtV2 {\n  public globalMerkleMap: MerkleMap;\n  public inputMerkleMaps: MerkleMap[] = [];\n  public outputMerkleMaps: MerkleMap[] = [];\n  public inputMapCommitments: Buffer[];\n  public outputMapCommitments: Buffer[];\n  constructor(psbt: PsbtV2) {\n    super();\n    psbt.copy(this);\n    this.globalMerkleMap = MerkelizedPsbt.createMerkleMap(this.globalMap);\n\n    for (let i = 0; i < this.getGlobalInputCount(); i++) {\n      this.inputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));\n    }\n    this.inputMapCommitments = [...this.inputMerkleMaps.values()].map(v => v.commitment());\n\n    for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n      this.outputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));\n    }\n    this.outputMapCommitments = [...this.outputMerkleMaps.values()].map(v => v.commitment());\n  }\n  // These public functions are for MerkelizedPsbt.\n  getGlobalSize(): number {\n    return this.globalMap.size;\n  }\n  getGlobalKeysValuesRoot(): Buffer {\n    return this.globalMerkleMap.commitment();\n  }\n\n  private static createMerkleMap(map: Map<string, Buffer>): MerkleMap {\n    const sortedKeysStrings = [...map.keys()].sort();\n    const values = sortedKeysStrings.map(k => {\n      const v = map.get(k);\n      if (!v) {\n        throw new Error(\"No value for key \" + k);\n      }\n      return v;\n    });\n    const sortedKeys = sortedKeysStrings.map(k => Buffer.from(k, \"hex\"));\n\n    const merkleMap = new MerkleMap(sortedKeys, values);\n    return merkleMap;\n  }\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { BufferReader } from \"../buffertools\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\nimport { MerkleMap } from \"./merkleMap\";\n\nenum ClientCommandCode {\n  YIELD = 0x10,\n  GET_PREIMAGE = 0x40,\n  GET_MERKLE_LEAF_PROOF = 0x41,\n  GET_MERKLE_LEAF_INDEX = 0x42,\n  GET_MORE_ELEMENTS = 0xa0,\n}\n\nabstract class ClientCommand {\n  abstract code: ClientCommandCode;\n  abstract execute(request: Buffer): Buffer;\n}\n\nexport class YieldCommand extends ClientCommand {\n  private results: Buffer[];\n\n  code = ClientCommandCode.YIELD;\n\n  constructor(\n    results: Buffer[],\n    private progressCallback: () => void,\n  ) {\n    super();\n    this.results = results;\n  }\n\n  execute(request: Buffer): Buffer {\n    this.results.push(Buffer.from(request.subarray(1)));\n    this.progressCallback();\n    return Buffer.from(\"\");\n  }\n}\n\nexport class GetPreimageCommand extends ClientCommand {\n  private known_preimages: Map<string, Buffer>;\n  private queue: Buffer[];\n\n  code = ClientCommandCode.GET_PREIMAGE;\n\n  constructor(known_preimages: Map<string, Buffer>, queue: Buffer[]) {\n    super();\n    this.known_preimages = known_preimages;\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    // we expect no more data to read\n    if (req.length != 1 + 32) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    if (req[0] != 0) {\n      throw new Error(\"Unsupported request, the first byte should be 0\");\n    }\n\n    // read the hash\n    const hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      hash[i] = req[1 + i];\n    }\n    const req_hash_hex = hash.toString(\"hex\");\n\n    const known_preimage = this.known_preimages.get(req_hash_hex);\n    if (known_preimage != undefined) {\n      const preimage_len_varint = createVarint(known_preimage.length);\n\n      // We can send at most 255 - len(preimage_len_out) - 1 bytes in a single message;\n      // the rest will be stored in the queue for GET_MORE_ELEMENTS\n      const max_payload_size = 255 - preimage_len_varint.length - 1;\n\n      const payload_size = Math.min(max_payload_size, known_preimage.length);\n\n      if (payload_size < known_preimage.length) {\n        for (let i = payload_size; i < known_preimage.length; i++) {\n          this.queue.push(Buffer.from([known_preimage[i]]));\n        }\n      }\n\n      return Buffer.concat([\n        preimage_len_varint,\n        Buffer.from([payload_size]),\n        Buffer.from(known_preimage.subarray(0, payload_size)),\n      ]);\n    }\n\n    throw Error(`Requested unknown preimage for: ${req_hash_hex}`);\n  }\n}\n\nexport class GetMerkleLeafProofCommand extends ClientCommand {\n  private known_trees: Map<string, Merkle>;\n  private queue: Buffer[];\n\n  code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;\n\n  constructor(known_trees: Map<string, Merkle>, queue: Buffer[]) {\n    super();\n    this.known_trees = known_trees;\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    if (req.length < 32 + 1 + 1) {\n      throw new Error(\"Invalid request, expected at least 34 bytes\");\n    }\n\n    const reqBuf = new BufferReader(req);\n    const hash = reqBuf.readSlice(32);\n    const hash_hex = hash.toString(\"hex\");\n\n    let tree_size;\n    let leaf_index;\n    try {\n      tree_size = reqBuf.readVarInt();\n      leaf_index = reqBuf.readVarInt();\n    } catch (e: any) {\n      throw new Error(\"Invalid request, couldn't parse tree_size or leaf_index\");\n    }\n\n    const mt = this.known_trees.get(hash_hex);\n    if (!mt) {\n      throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);\n    }\n\n    if (leaf_index >= tree_size || mt.size() != tree_size) {\n      throw Error(\"Invalid index or tree size.\");\n    }\n\n    if (this.queue.length != 0) {\n      throw Error(\"This command should not execute when the queue is not empty.\");\n    }\n\n    const proof = mt.getProof(leaf_index);\n\n    const n_response_elements = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), proof.length);\n    const n_leftover_elements = proof.length - n_response_elements;\n\n    // Add to the queue any proof elements that do not fit the response\n    if (n_leftover_elements > 0) {\n      this.queue.push(...proof.slice(-n_leftover_elements));\n    }\n\n    return Buffer.concat([\n      mt.getLeafHash(leaf_index),\n      Buffer.from([proof.length]),\n      Buffer.from([n_response_elements]),\n      ...proof.slice(0, n_response_elements),\n    ]);\n  }\n}\n\nexport class GetMerkleLeafIndexCommand extends ClientCommand {\n  private known_trees: Map<string, Merkle>;\n\n  code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;\n\n  constructor(known_trees: Map<string, Merkle>) {\n    super();\n    this.known_trees = known_trees;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    if (req.length != 32 + 32) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    // read the root hash\n    const root_hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      root_hash[i] = req.readUInt8(i);\n    }\n    const root_hash_hex = root_hash.toString(\"hex\");\n\n    // read the leaf hash\n    const leef_hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      leef_hash[i] = req.readUInt8(32 + i);\n    }\n    const leef_hash_hex = leef_hash.toString(\"hex\");\n\n    const mt = this.known_trees.get(root_hash_hex);\n    if (!mt) {\n      throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);\n    }\n\n    let leaf_index = 0;\n    let found = 0;\n    for (let i = 0; i < mt.size(); i++) {\n      if (mt.getLeafHash(i).toString(\"hex\") == leef_hash_hex) {\n        found = 1;\n        leaf_index = i;\n        break;\n      }\n    }\n    return Buffer.concat([Buffer.from([found]), createVarint(leaf_index)]);\n  }\n}\n\nexport class GetMoreElementsCommand extends ClientCommand {\n  queue: Buffer[];\n\n  code = ClientCommandCode.GET_MORE_ELEMENTS;\n\n  constructor(queue: Buffer[]) {\n    super();\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    if (request.length != 1) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    if (this.queue.length === 0) {\n      throw new Error(\"No elements to get\");\n    }\n\n    // all elements should have the same length\n    const element_len = this.queue[0].length;\n    if (this.queue.some(el => el.length != element_len)) {\n      throw new Error(\n        \"The queue contains elements with different byte length, which is not expected\",\n      );\n    }\n\n    const max_elements = Math.floor(253 / element_len);\n    const n_returned_elements = Math.min(max_elements, this.queue.length);\n\n    const returned_elements = this.queue.splice(0, n_returned_elements);\n\n    return Buffer.concat([\n      Buffer.from([n_returned_elements]),\n      Buffer.from([element_len]),\n      ...returned_elements,\n    ]);\n  }\n}\n\n/**\n * This class will dispatch a client command coming from the hardware device to\n * the appropriate client command implementation. Those client commands\n * typically requests data from a merkle tree or merkelized maps.\n *\n * A ClientCommandInterpreter is prepared by adding the merkle trees and\n * merkelized maps it should be able to serve to the hardware device. This class\n * doesn't know anything about the semantics of the data it holds, it just\n * serves merkle data. It doesn't even know in what context it is being\n * executed, ie SignPsbt, getWalletAddress, etc.\n *\n * If the command yelds results to the client, as signPsbt does, the yielded\n * data will be accessible after the command completed by calling getYielded(),\n * which will return the yields in the same order as they came in.\n */\nexport class ClientCommandInterpreter {\n  private roots: Map<string, Merkle> = new Map();\n  private preimages: Map<string, Buffer> = new Map();\n\n  private yielded: Buffer[] = [];\n\n  private queue: Buffer[] = [];\n\n  private commands: Map<ClientCommandCode, ClientCommand> = new Map();\n\n  constructor(progressCallback: () => void) {\n    const commands = [\n      new YieldCommand(this.yielded, progressCallback),\n      new GetPreimageCommand(this.preimages, this.queue),\n      new GetMerkleLeafIndexCommand(this.roots),\n      new GetMerkleLeafProofCommand(this.roots, this.queue),\n      new GetMoreElementsCommand(this.queue),\n    ];\n\n    for (const cmd of commands) {\n      if (this.commands.has(cmd.code)) {\n        throw new Error(`Multiple commands with code ${cmd.code}`);\n      }\n      this.commands.set(cmd.code, cmd);\n    }\n  }\n\n  getYielded(): Buffer[] {\n    return this.yielded;\n  }\n\n  addKnownPreimage(preimage: Buffer): void {\n    this.preimages.set(crypto.sha256(preimage).toString(\"hex\"), preimage);\n  }\n\n  addKnownList(elements: Buffer[]): void {\n    for (const el of elements) {\n      const preimage = Buffer.concat([Buffer.from([0]), el]);\n      this.addKnownPreimage(preimage);\n    }\n    const mt = new Merkle(elements.map(el => hashLeaf(el)));\n    this.roots.set(mt.getRoot().toString(\"hex\"), mt);\n  }\n\n  addKnownMapping(mm: MerkleMap): void {\n    this.addKnownList(mm.keys);\n    this.addKnownList(mm.values);\n  }\n\n  execute(request: Buffer): Buffer {\n    if (request.length == 0) {\n      throw new Error(\"Unexpected empty command\");\n    }\n\n    const cmdCode = request[0];\n    const cmd = this.commands.get(cmdCode);\n    if (!cmd) {\n      throw new Error(`Unexpected command code ${cmdCode}`);\n    }\n\n    return cmd.execute(request);\n  }\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport { pathElementsToBuffer } from \"../bip32\";\nimport { PsbtV2 } from \"./psbtv2\";\nimport { MerkelizedPsbt } from \"./merkelizedPsbt\";\nimport { ClientCommandInterpreter } from \"./clientCommands\";\nimport { WalletPolicy } from \"./policy\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\nconst CLA_BTC = 0xe1;\nconst CLA_FRAMEWORK = 0xf8;\n\nenum BitcoinIns {\n  GET_PUBKEY = 0x00,\n  // GET_ADDRESS = 0x01, // Removed from app\n  REGISTER_WALLET = 0x02,\n  GET_WALLET_ADDRESS = 0x03,\n  SIGN_PSBT = 0x04,\n  GET_MASTER_FINGERPRINT = 0x05,\n  SIGN_MESSAGE = 0x10,\n}\n\nenum FrameworkIns {\n  CONTINUE_INTERRUPTED = 0x01,\n}\n\n/**\n * This class encapsulates the APDU protocol documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n */\nexport class AppClient {\n  transport: Transport;\n\n  constructor(transport: Transport) {\n    this.transport = transport;\n  }\n\n  private async makeRequest(\n    ins: BitcoinIns,\n    data: Buffer,\n    cci?: ClientCommandInterpreter,\n  ): Promise<Buffer> {\n    let response: Buffer = await this.transport.send(CLA_BTC, ins, 0, 0, data, [0x9000, 0xe000]);\n    while (response.readUInt16BE(response.length - 2) === 0xe000) {\n      if (!cci) {\n        throw new Error(\"Unexpected SW_INTERRUPTED_EXECUTION\");\n      }\n\n      const hwRequest = response.slice(0, -2);\n      const commandResponse = cci.execute(hwRequest);\n\n      response = await this.transport.send(\n        CLA_FRAMEWORK,\n        FrameworkIns.CONTINUE_INTERRUPTED,\n        0,\n        0,\n        commandResponse,\n        [0x9000, 0xe000],\n      );\n    }\n    return response.slice(0, -2); // drop the status word (can only be 0x9000 at this point)\n  }\n\n  async getExtendedPubkey(display: boolean, pathElements: number[]): Promise<string> {\n    if (pathElements.length > 6) {\n      throw new Error(\"Path too long. At most 6 levels allowed.\");\n    }\n    const response = await this.makeRequest(\n      BitcoinIns.GET_PUBKEY,\n      Buffer.concat([Buffer.from(display ? [1] : [0]), pathElementsToBuffer(pathElements)]),\n    );\n    return response.toString(\"ascii\");\n  }\n\n  async getWalletAddress(\n    walletPolicy: WalletPolicy,\n    walletHMAC: Buffer | null,\n    change: number,\n    addressIndex: number,\n    display: boolean,\n  ): Promise<string> {\n    if (change !== 0 && change !== 1) throw new Error(\"Change can only be 0 or 1\");\n    if (addressIndex < 0 || !Number.isInteger(addressIndex))\n      throw new Error(\"Invalid address index\");\n\n    if (walletHMAC != null && walletHMAC.length != 32) {\n      throw new Error(\"Invalid HMAC length\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(() => {});\n    clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n    clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n\n    const addressIndexBuffer = Buffer.alloc(4);\n    addressIndexBuffer.writeUInt32BE(addressIndex, 0);\n\n    const response = await this.makeRequest(\n      BitcoinIns.GET_WALLET_ADDRESS,\n      Buffer.concat([\n        Buffer.from(display ? [1] : [0]),\n        walletPolicy.getWalletId(),\n        walletHMAC || Buffer.alloc(32, 0),\n        Buffer.from([change]),\n        addressIndexBuffer,\n      ]),\n      clientInterpreter,\n    );\n\n    return response.toString(\"ascii\");\n  }\n\n  async signPsbt(\n    psbt: PsbtV2,\n    walletPolicy: WalletPolicy,\n    walletHMAC: Buffer | null,\n    progressCallback: () => void,\n  ): Promise<Map<number, Buffer>> {\n    const merkelizedPsbt = new MerkelizedPsbt(psbt);\n\n    if (walletHMAC != null && walletHMAC.length != 32) {\n      throw new Error(\"Invalid HMAC length\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(progressCallback);\n\n    // prepare ClientCommandInterpreter\n    clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n    clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n\n    clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);\n    for (const map of merkelizedPsbt.inputMerkleMaps) {\n      clientInterpreter.addKnownMapping(map);\n    }\n    for (const map of merkelizedPsbt.outputMerkleMaps) {\n      clientInterpreter.addKnownMapping(map);\n    }\n\n    clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);\n    const inputMapsRoot = new Merkle(\n      merkelizedPsbt.inputMapCommitments.map(m => hashLeaf(m)),\n    ).getRoot();\n    clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);\n    const outputMapsRoot = new Merkle(\n      merkelizedPsbt.outputMapCommitments.map(m => hashLeaf(m)),\n    ).getRoot();\n\n    await this.makeRequest(\n      BitcoinIns.SIGN_PSBT,\n      Buffer.concat([\n        merkelizedPsbt.getGlobalKeysValuesRoot(),\n        createVarint(merkelizedPsbt.getGlobalInputCount()),\n        inputMapsRoot,\n        createVarint(merkelizedPsbt.getGlobalOutputCount()),\n        outputMapsRoot,\n        walletPolicy.getWalletId(),\n        walletHMAC || Buffer.alloc(32, 0),\n      ]),\n      clientInterpreter,\n    );\n\n    const yielded = clientInterpreter.getYielded();\n\n    const ret: Map<number, Buffer> = new Map();\n    for (const inputAndSig of yielded) {\n      ret.set(inputAndSig[0], inputAndSig.slice(1));\n    }\n    return ret;\n  }\n\n  async getMasterFingerprint(): Promise<Buffer> {\n    return this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));\n  }\n\n  async signMessage(message: Buffer, pathElements: number[]): Promise<string> {\n    if (pathElements.length > 6) {\n      throw new Error(\"Path too long. At most 6 levels allowed.\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(() => {});\n\n    // prepare ClientCommandInterpreter\n    const nChunks = Math.ceil(message.length / 64);\n    const chunks: Buffer[] = [];\n    for (let i = 0; i < nChunks; i++) {\n      chunks.push(message.subarray(64 * i, 64 * i + 64));\n    }\n\n    clientInterpreter.addKnownList(chunks);\n    const chunksRoot = new Merkle(chunks.map(m => hashLeaf(m))).getRoot();\n\n    const response = await this.makeRequest(\n      BitcoinIns.SIGN_MESSAGE,\n      Buffer.concat([pathElementsToBuffer(pathElements), createVarint(message.length), chunksRoot]),\n      clientInterpreter,\n    );\n\n    return response.toString(\"base64\");\n  }\n}\n","import type { Transaction } from \"./types\";\nexport function formatTransactionDebug(transaction: Transaction): string {\n  let str = \"TX\";\n  str += \" version \" + transaction.version.toString(\"hex\");\n\n  if (transaction.locktime) {\n    str += \" locktime \" + transaction.locktime.toString(\"hex\");\n  }\n\n  if (transaction.witness) {\n    str += \" witness \" + transaction.witness.toString(\"hex\");\n  }\n\n  if (transaction.timestamp) {\n    str += \" timestamp \" + transaction.timestamp.toString(\"hex\");\n  }\n\n  if (transaction.nVersionGroupId) {\n    str += \" nVersionGroupId \" + transaction.nVersionGroupId.toString(\"hex\");\n  }\n\n  if (transaction.nExpiryHeight) {\n    str += \" nExpiryHeight \" + transaction.nExpiryHeight.toString(\"hex\");\n  }\n\n  if (transaction.extraData) {\n    str += \" extraData \" + transaction.extraData.toString(\"hex\");\n  }\n\n  transaction.inputs.forEach(({ prevout, script, sequence }, i) => {\n    str += `\\ninput ${i}:`;\n    str += ` prevout ${prevout.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n    str += ` sequence ${sequence.toString(\"hex\")}`;\n  });\n  (transaction.outputs || []).forEach(({ amount, script }, i) => {\n    str += `\\noutput ${i}:`;\n    str += ` amount ${amount.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n  });\n  return str;\n}\nexport function displayTransactionDebug(transaction: Transaction): void {\n  console.log(formatTransactionDebug(transaction));\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull } from \"./finalizeInput\";\nimport type { TransactionOutput, Transaction, TrustedInput } from \"./types\";\nimport { DEFAULT_LOCKTIME, DEFAULT_VERSION, DEFAULT_SEQUENCE, SIGHASH_ALL } from \"./constants\";\nconst defaultArg = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  transactionVersion: DEFAULT_VERSION,\n};\n\n/**\n *\n */\nexport type SignP2SHTransactionArg = {\n  inputs: Array<[Transaction, number, string | null | undefined, number | null | undefined]>;\n  associatedKeysets: string[];\n  outputScriptHex: string;\n  lockTime?: number;\n  sigHashType?: number;\n  segwit?: boolean;\n  transactionVersion?: number;\n};\nexport async function signP2SHTransaction(transport: Transport, arg: SignP2SHTransactionArg) {\n  const {\n    inputs,\n    associatedKeysets,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    transactionVersion,\n  } = { ...defaultArg, ...arg };\n  // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  defaultVersion.writeUInt32LE(transactionVersion, 0);\n  const trustedInputs: TrustedInput[] = [];\n  const regularOutputs: Array<TransactionOutput> = [];\n  const signatures: string[] = [];\n  let firstRun = true;\n  const resuming = false;\n  const targetTransaction: Transaction = {\n    inputs: [],\n    version: defaultVersion,\n  };\n  const getTrustedInputCall = segwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n  for (const input of inputs) {\n    if (!resuming) {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0]);\n      const sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(\n        input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n        0,\n      );\n      trustedInputs.push({\n        trustedInput: false,\n        value: segwit\n          ? Buffer.from(trustedInput, \"hex\")\n          : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n        sequence,\n      });\n    }\n\n    const { outputs } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n  }\n\n  // Pre-build the target transaction\n  for (let i = 0; i < inputs.length; i++) {\n    const sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(\n      inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n        ? (inputs[i][3] as number)\n        : DEFAULT_SEQUENCE,\n      0,\n    );\n    targetTransaction.inputs.push({\n      script: nullScript,\n      prevout: nullPrevout,\n      sequence,\n    });\n  }\n\n  if (segwit) {\n    await startUntrustedHashTransactionInput(\n      transport,\n      true,\n      targetTransaction,\n      trustedInputs,\n      true,\n    );\n    await hashOutputFull(transport, outputScript);\n  }\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const script =\n      inputs[i].length >= 3 && typeof input[2] === \"string\"\n        ? Buffer.from(input[2], \"hex\")\n        : regularOutputs[i].script;\n    const pseudoTX = Object.assign({}, targetTransaction);\n    const pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n\n    if (segwit) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(\n      transport,\n      !segwit && firstRun,\n      pseudoTX,\n      pseudoTrustedInputs,\n      segwit,\n    );\n\n    if (!segwit) {\n      await hashOutputFull(transport, outputScript);\n    }\n\n    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType);\n    signatures.push(\n      segwit ? signature.toString(\"hex\") : signature.slice(0, signature.length - 1).toString(\"hex\"),\n    );\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  return signatures;\n}\n","import semver from \"semver\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BtcNew from \"./BtcNew\";\nimport BtcOld from \"./BtcOld\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { AppClient } from \"./newops/appClient\";\nimport { serializeTransactionOutputs } from \"./serializeTransaction\";\nimport type { SignP2SHTransactionArg } from \"./signP2SHTransaction\";\nimport { splitTransaction } from \"./splitTransaction\";\nimport type { Transaction } from \"./types\";\nexport type { AddressFormat };\nimport { signP2SHTransaction } from \"./signP2SHTransaction\";\nimport { checkIsBtcLegacy, getAppAndVersion } from \"./getAppAndVersion\";\n\n/**\n * @class Btc\n * @description Bitcoin API.\n * @param transport The transport layer used for communication.\n * @param scrambleKey This parameter is deprecated and no longer needed.\n * @param currency The currency to use, defaults to \"bitcoin\".\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc({ transport, currency: \"bitcoin\" });\n */\n\nexport default class Btc {\n  // Transport instance\n  private _transport: Transport;\n  // The specific implementation used, determined by the nano app and its version.\n  // It chooses between BtcNew (new interface) and BtcOld (old interface).\n  private _impl: BtcOld | BtcNew;\n  constructor({\n    transport,\n    scrambleKey = \"BTC\",\n    currency = \"bitcoin\",\n  }: {\n    transport: Transport;\n    scrambleKey?: string;\n    currency?: string;\n  }) {\n    this._transport = transport;\n    this._transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getWalletXpub\",\n        \"getWalletPublicKey\",\n        \"signP2SHTransaction\",\n        \"signMessage\",\n        \"createPaymentTransaction\",\n        \"getTrustedInput\",\n        \"getTrustedInputBIP143\",\n      ],\n      scrambleKey,\n    );\n\n    this._impl = (() => {\n      switch (currency) {\n        case \"bitcoin\":\n        case \"bitcoin_testnet\":\n        case \"qtum\":\n          // new APDU (nano app API) for currencies using app-bitcoin-new implementation\n          return new BtcNew(new AppClient(this._transport));\n        default:\n          // old APDU (legacy API) for currencies using legacy bitcoin app implementation\n          return new BtcOld(this._transport);\n      }\n    })();\n  }\n\n  /**\n   * Get an XPUB with a ledger device\n   * @param arg derivation parameter\n   * - path: a BIP 32 path of the account level. (e.g. The derivation path `84'/0'/0'`\n   * follows the `purpose' / coin_type' / account'` standard, with purpose=84, coin_type=0, account=0)\n   * - xpubVersion: the XPUBVersion of the coin used. (refer to ledgerjs/packages/cryptoassets/src/currencies.ts\n   * for the XPUBVersion value if needed)\n   * @returns XPUB of the account\n   */\n  getWalletXpub(arg: { path: string; xpubVersion: number }): Promise<string> {\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.getWalletXpub(arg);\n    });\n  }\n\n  /**\n   * @param path a BIP 32 path (i.e. the `purpose’ / coin_type’ / account’ / change / address_index` standard)\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) whether ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 84' paths\n   *\n   * - bech32m format with 86' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    let options;\n    if (arguments.length > 2 || typeof opts === \"boolean\") {\n      console.warn(\n        \"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\",\n      );\n      options = {\n        verify: !!opts,\n        // eslint-disable-next-line prefer-rest-params\n        format: arguments[2] ? \"p2sh\" : \"legacy\",\n      };\n    } else {\n      options = opts || {};\n    }\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.getWalletPublicKey(path, options);\n    });\n  }\n\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessage(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n  signMessage(\n    path: string,\n    messageHex: string,\n  ): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.signMessage({\n        path,\n        messageHex,\n      });\n    });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign, including leading vararg voutCount\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not. This includes wrapped segwit.\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"bech32m\" for spending segwit v1+ outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"decred\" for decred\n   * - \"zcash\" for zcash\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions. If app version >= 1.4.0 this should be true.\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n  createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    if (arguments.length > 1) {\n      throw new Error(\n        \"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\",\n      );\n    }\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.createPaymentTransaction(arg);\n    });\n  }\n\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.signP2SHTransaction({\n  inputs: [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n  associatedKeysets: [\"0'/0/0\"],\n  outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(result => ...);\n   */\n  signP2SHTransaction(arg: SignP2SHTransactionArg): Promise<string[]> {\n    return signP2SHTransaction(this._transport, arg);\n  }\n\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @param transactionHex a raw hexadecimal serialized transaction\n   * @param isSegwitSupported is a boolean indicating if the segwit is supported\n   * @param hasTimestamp is a boolean (peercoin includes timestamp in their transactions, others don't)\n   * @param hasExtraData is a boolean (komodo, zencash and zcash include extraData in their transactions, others don't)\n   * @param additionals list of additionnal options\n   * @return the transaction object deserialized from the raw hexadecimal transaction\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n  splitTransaction(\n    transactionHex: string,\n    isSegwitSupported: boolean | null | undefined = false,\n    hasTimestamp = false,\n    hasExtraData = false,\n    additionals: Array<string> = [],\n  ): Transaction {\n    return splitTransaction(\n      transactionHex,\n      isSegwitSupported,\n      hasTimestamp,\n      hasExtraData,\n      additionals,\n    );\n  }\n\n  /**\n   * Serialize a transaction's outputs to hexadecimal\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n  const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n  serializeTransactionOutputs(t: Transaction): Buffer {\n    return serializeTransactionOutputs(t);\n  }\n\n  /**\n   * Trusted input is the hash of a UTXO that needs to be signed\n   * For Legacy transactions, the app has some APDUs flows that do the amount check for an UTXO,\n   * by parsing the transaction that created this UTXO\n   */\n  getTrustedInput(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = [],\n  ): Promise<string> {\n    return getTrustedInput(this._transport, indexLookup, transaction, additionals);\n  }\n\n  /**\n   * Trusted input is the hash of a UTXO that needs to be signed. BIP143 is used for Segwit inputs.\n   */\n  getTrustedInputBIP143(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = [],\n  ): string {\n    return getTrustedInputBIP143(this._transport, indexLookup, transaction, additionals);\n  }\n\n  async changeImplIfNecessary(): Promise<BtcOld | BtcNew> {\n    // if BtcOld was instantiated, stick with it\n    if (this._impl instanceof BtcOld) return this._impl;\n\n    const { name, version } = await getAppAndVersion(this._transport);\n\n    const isBtcLegacy = await (async () => {\n      switch (name) {\n        case \"Bitcoin\":\n        case \"Bitcoin Test\": {\n          // we use the legacy protocol for versions below 2.1.0 of the Bitcoin app.\n          return semver.lt(version, \"2.1.0\");\n        }\n        case \"Bitcoin Legacy\":\n        case \"Bitcoin Test Legacy\":\n          // the \"Bitcoin Legacy\" and \"Bitcoin Testnet Legacy\" app use the legacy protocol, regardless of the version\n          return true;\n        case \"Exchange\":\n          // We can't query the version of the Bitcoin app if we're coming from Exchange;\n          // therefore, we use a workaround to distinguish legacy and new versions.\n          // This can be removed once Ledger Live enforces minimum bitcoin version >= 2.1.0.\n          return await checkIsBtcLegacy(this._transport);\n        case \"Qtum\":\n          // we use the legacy protocol for versions below 3.0.0 of the Qtum app.\n          return semver.lt(version, \"3.0.0\");\n        default:\n          return true;\n      }\n    })();\n\n    if (isBtcLegacy) {\n      this._impl = new BtcOld(this._transport);\n    }\n    return this._impl;\n  }\n}\n","import { log } from \"@ledgerhq/logs\";\nimport type { Transaction, TransactionInput, TransactionOutput } from \"./types\";\nimport { getVarint } from \"./varint\";\nimport { formatTransactionDebug } from \"./debug\";\nexport function splitTransaction(\n  transactionHex: string,\n  isSegwitSupported: boolean | null | undefined = false,\n  hasTimestamp = false,\n  hasExtraData = false,\n  additionals: Array<string> = [],\n): Transaction {\n  const inputs: TransactionInput[] = [];\n  const outputs: TransactionOutput[] = [];\n  let witness = false;\n  let offset = 0;\n  let timestamp = Buffer.alloc(0);\n  let nExpiryHeight = Buffer.alloc(0);\n  let nVersionGroupId = Buffer.alloc(0);\n  let extraData = Buffer.alloc(0);\n  let witnessScript, locktime;\n  const isDecred = additionals.includes(\"decred\");\n  const isZencash = additionals.includes(\"zencash\");\n  const isZcash = additionals.includes(\"zcash\");\n  const transaction = Buffer.from(transactionHex, \"hex\");\n  const version = transaction.slice(offset, offset + 4);\n  const overwinter =\n    version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n    version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80])) ||\n    version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n  const isZcashv5 = isZcash && version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n  offset += 4;\n  if (\n    !hasTimestamp &&\n    isSegwitSupported &&\n    transaction[offset] === 0 &&\n    transaction[offset + 1] !== 0 &&\n    !isZencash\n  ) {\n    offset += 2;\n    witness = true;\n  }\n\n  if (hasTimestamp) {\n    timestamp = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n\n  if (overwinter) {\n    nVersionGroupId = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n  if (isZcashv5) {\n    locktime = transaction.slice(offset + 4, offset + 8);\n    nExpiryHeight = transaction.slice(offset + 8, offset + 12);\n    offset += 12;\n  }\n  let varint = getVarint(transaction, offset);\n  const numberInputs = varint[0];\n  offset += varint[1];\n\n  for (let i = 0; i < numberInputs; i++) {\n    const prevout = transaction.slice(offset, offset + 36);\n    offset += 36;\n    let script = Buffer.alloc(0);\n    let tree = Buffer.alloc(0);\n\n    //No script for decred, it has a witness\n    if (!isDecred) {\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n    } else {\n      //Tree field\n      tree = transaction.slice(offset, offset + 1);\n      offset += 1;\n    }\n\n    const sequence = transaction.slice(offset, offset + 4);\n    offset += 4;\n    inputs.push({\n      prevout,\n      script,\n      sequence,\n      tree,\n    });\n  }\n  varint = getVarint(transaction, offset);\n  const numberOutputs = varint[0];\n  offset += varint[1];\n  for (let i = 0; i < numberOutputs; i++) {\n    const amount = transaction.slice(offset, offset + 8);\n    offset += 8;\n\n    if (isDecred) {\n      //Script version\n      offset += 2;\n    }\n\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n    const script = transaction.slice(offset, offset + varint[0]);\n    offset += varint[0];\n    outputs.push({\n      amount,\n      script,\n    });\n  }\n\n  if (witness) {\n    witnessScript = transaction.slice(offset, -4);\n    locktime = transaction.slice(transaction.length - 4);\n  } else if (!isZcashv5) {\n    locktime = transaction.slice(offset, offset + 4);\n  }\n\n  offset += 4;\n\n  if ((overwinter || isDecred) && !isZcashv5) {\n    nExpiryHeight = transaction.slice(offset, offset + 4);\n    offset += 4;\n  }\n\n  if (hasExtraData) {\n    extraData = transaction.slice(offset);\n  }\n\n  //Get witnesses for Decred\n  if (isDecred) {\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n\n    if (varint[0] !== numberInputs) {\n      throw new Error(\"splitTransaction: incoherent number of witnesses\");\n    }\n\n    for (let i = 0; i < numberInputs; i++) {\n      //amount\n      offset += 8;\n      //block height\n      offset += 4;\n      //block index\n      offset += 4;\n      //Script size\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      inputs[i].script = script;\n    }\n  }\n\n  const t: Transaction = {\n    version,\n    inputs,\n    outputs,\n    locktime,\n    witness: witnessScript,\n    timestamp,\n    nVersionGroupId,\n    nExpiryHeight,\n    extraData,\n  };\n  log(\"btc\", `splitTransaction ${transactionHex}:\\n${formatTransactionDebug(t)}`);\n  return t;\n}\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types = require('./types');\nconst bech32 = require('bech32');\nconst bs58check = require('bs58check');\nconst typeforce = require('typeforce');\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst script_1 = require('./script');\nconst multisig = require('./templates/multisig');\nconst nullData = require('./templates/nulldata');\nconst pubKey = require('./templates/pubkey');\nconst pubKeyHash = require('./templates/pubkeyhash');\nconst scriptHash = require('./templates/scripthash');\nconst witnessCommitment = require('./templates/witnesscommitment');\nconst witnessPubKeyHash = require('./templates/witnesspubkeyhash');\nconst witnessScriptHash = require('./templates/witnessscripthash');\nconst types = {\n  P2MS: 'multisig',\n  NONSTANDARD: 'nonstandard',\n  NULLDATA: 'nulldata',\n  P2PK: 'pubkey',\n  P2PKH: 'pubkeyhash',\n  P2SH: 'scripthash',\n  P2WPKH: 'witnesspubkeyhash',\n  P2WSH: 'witnessscripthash',\n  WITNESS_COMMITMENT: 'witnesscommitment',\n};\nexports.types = types;\nfunction classifyOutput(script) {\n  if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;\n  if (witnessScriptHash.output.check(script)) return types.P2WSH;\n  if (pubKeyHash.output.check(script)) return types.P2PKH;\n  if (scriptHash.output.check(script)) return types.P2SH;\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (multisig.output.check(chunks)) return types.P2MS;\n  if (pubKey.output.check(chunks)) return types.P2PK;\n  if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;\n  if (nullData.output.check(chunks)) return types.NULLDATA;\n  return types.NONSTANDARD;\n}\nexports.output = classifyOutput;\nfunction classifyInput(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (pubKeyHash.input.check(chunks)) return types.P2PKH;\n  if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;\n  if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;\n  if (pubKey.input.check(chunks)) return types.P2PK;\n  return types.NONSTANDARD;\n}\nexports.input = classifyInput;\nfunction classifyWitness(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;\n  if (witnessScriptHash.input.check(chunks, allowIncomplete))\n    return types.P2WSH;\n  return types.NONSTANDARD;\n}\nexports.witness = classifyWitness;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst createHash = require('create-hash');\nfunction ripemd160(buffer) {\n  try {\n    return createHash('rmd160')\n      .update(buffer)\n      .digest();\n  } catch (err) {\n    return createHash('ripemd160')\n      .update(buffer)\n      .digest();\n  }\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return createHash('sha1')\n    .update(buffer)\n    .digest();\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return createHash('sha256')\n    .update(buffer)\n    .digest();\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexports.hash256 = hash256;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst NETWORKS = require('./networks');\nconst types = require('./types');\nconst ecc = require('tiny-secp256k1');\nconst randomBytes = require('randombytes');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst isOptions = typeforce.maybe(\n  typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed =\n      options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer))\n    throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version;\n  // list of networks?\n  if (types.Array(network)) {\n    network = network\n      .filter(x => {\n        return version === x.wif;\n      })\n      .pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network,\n  });\n}\nexports.fromWIF = fromWIF;\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n  return fromPrivateKey(d, options);\n}\nexports.makeRandom = makeRandom;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip32 = require('bip32');\nexports.bip32 = bip32;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst ECPair = require('./ecpair');\nexports.ECPair = ECPair;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nexports.Block = block_1.Block;\nvar psbt_1 = require('./psbt');\nexports.Psbt = psbt_1.Psbt;\nvar script_1 = require('./script');\nexports.opcodes = script_1.OPS;\nvar transaction_1 = require('./transaction');\nexports.Transaction = transaction_1.Transaction;\nvar transaction_builder_1 = require('./transaction_builder');\nexports.TransactionBuilder = transaction_builder_1.TransactionBuilder;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.bitcoin = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// output: OP_RETURN ...\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      data: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst embed_1 = require('./embed');\nexports.embed = embed_1.p2data;\nconst p2ms_1 = require('./p2ms');\nexports.p2ms = p2ms_1.p2ms;\nconst p2pk_1 = require('./p2pk');\nexports.p2pk = p2pk_1.p2pk;\nconst p2pkh_1 = require('./p2pkh');\nexports.p2pkh = p2pkh_1.p2pkh;\nconst p2sh_1 = require('./p2sh');\nexports.p2sh = p2sh_1.p2sh;\nconst p2wpkh_1 = require('./p2wpkh');\nexports.p2wpkh = p2wpkh_1.p2wpkh;\nconst p2wsh_1 = require('./p2wsh');\nexports.p2wsh = p2wsh_1.p2wsh;\n// TODO\n// witness commitment\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst typef = require('typeforce');\nconst ecc = require('tiny-secp256k1');\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      m: typef.maybe(typef.Number),\n      n: typef.maybe(typef.Number),\n      output: typef.maybe(typef.Buffer),\n      pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),\n      signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid');\n      if (!typef.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => ecc.isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!ecc.isPoint(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bs58check = require('bs58check');\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(25)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!ecc.isPoint(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst bs58check = require('bs58check');\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(23)),\n      redeem: typef.maybe({\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        input: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    return {\n      network,\n      output: chunks[chunks.length - 1],\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      input: typef.maybe(typef.BufferN(0)),\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.BufferN(22)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    ecc.isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(32)),\n      output: typef.maybe(typef.BufferN(34)),\n      redeem: typef.maybe({\n        input: typef.maybe(typef.Buffer),\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.BufferN(0)),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty?\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Old TransactionBuilder behavior was to not confirm input values\n      // before signing. Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n      });\n    });\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nconst isP2SHScript = isPaymentFactory(payments.p2sh);\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })\n      .output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          'to trick you into paying large fees. This behavior is the same as the old ' +\n          'TransactionBuilder class when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return input.witnessUtxo.script;\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction pubkeyInScript(pubkey, script) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst ecc = require('tiny-secp256k1');\nconst pushdata = require('pushdata-bitcoin');\nconst typeforce = require('typeforce');\nexports.OPS = require('bitcoin-ops');\nconst REVERSE_OPS = require('bitcoin-ops/map');\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === exports.OPS.OP_0 ||\n      (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||\n      value === exports.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\n// tslint:disable-next-line variable-name\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst typeforce = require('typeforce');\nconst ZERO = Buffer.alloc(1, 0);\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_0 [signatures ...]\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction partialSignature(value) {\n  return (\n    value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value)\n  );\n}\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 2) return false;\n  if (chunks[0] !== script_1.OPS.OP_0) return false;\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature);\n  }\n  return chunks.slice(1).every(bscript.isCanonicalScriptSignature);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multisig input';\n};\n","'use strict';\n// m [pubKeys ...] n OP_CHECKMULTISIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 4) return false;\n  if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;\n  if (!types.Number(chunks[0])) return false;\n  if (!types.Number(chunks[chunks.length - 2])) return false;\n  const m = chunks[0] - OP_INT_BASE;\n  const n = chunks[chunks.length - 2] - OP_INT_BASE;\n  if (m <= 0) return false;\n  if (n > 16) return false;\n  if (m > n) return false;\n  if (n !== chunks.length - 3) return false;\n  if (allowIncomplete) return true;\n  const keys = chunks.slice(1, -2);\n  return keys.every(bscript.isCanonicalPubKey);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multi-sig output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// OP_RETURN {data}\nconst bscript = require('../script');\nconst OPS = bscript.OPS;\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'null data output';\n};\nconst output = { check };\nexports.output = output;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey input';\n};\n","'use strict';\n// {pubKey} OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalPubKey(chunks[0]) &&\n    chunks[1] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    bscript.isCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash input';\n};\n","'use strict';\n// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 25 &&\n    buffer[0] === script_1.OPS.OP_DUP &&\n    buffer[1] === script_1.OPS.OP_HASH160 &&\n    buffer[2] === 0x14 &&\n    buffer[23] === script_1.OPS.OP_EQUALVERIFY &&\n    buffer[24] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nconst p2wpkho = require('../witnesspubkeyhash/output');\nconst p2wsho = require('../witnessscripthash/output');\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 1) return false;\n  const lastChunk = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(lastChunk)) return false;\n  const scriptSigChunks = bscript.decompile(\n    bscript.compile(chunks.slice(0, -1)),\n  );\n  const redeemScriptChunks = bscript.decompile(lastChunk);\n  // is redeemScript a valid script?\n  if (!redeemScriptChunks) return false;\n  // is redeemScriptSig push only?\n  if (!bscript.isPushOnly(scriptSigChunks)) return false;\n  // is witness?\n  if (chunks.length === 1) {\n    return (\n      p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks)\n    );\n  }\n  // match types\n  if (\n    p2pkh.input.check(scriptSigChunks) &&\n    p2pkh.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(scriptSigChunks, allowIncomplete) &&\n    p2ms.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(scriptSigChunks) &&\n    p2pk.output.check(redeemScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash input';\n};\n","'use strict';\n// OP_HASH160 {scriptHash} OP_EQUAL\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 23 &&\n    buffer[0] === script_1.OPS.OP_HASH160 &&\n    buffer[1] === 0x14 &&\n    buffer[22] === script_1.OPS.OP_EQUAL\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_RETURN {aa21a9ed} {commitment}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst typeforce = require('typeforce');\nconst HEADER = Buffer.from('aa21a9ed', 'hex');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length > 37 &&\n    buffer[0] === script_1.OPS.OP_RETURN &&\n    buffer[1] === 0x24 &&\n    buffer.slice(2, 6).equals(HEADER)\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness commitment output';\n};\nfunction encode(commitment) {\n  typeforce(types.Hash256bit, commitment);\n  const buffer = Buffer.allocUnsafe(36);\n  HEADER.copy(buffer, 0);\n  commitment.copy(buffer, 4);\n  return bscript.compile([script_1.OPS.OP_RETURN, buffer]);\n}\nexports.encode = encode;\nfunction decode(buffer) {\n  typeforce(check, buffer);\n  return bscript.decompile(buffer)[1].slice(4, 36);\n}\nexports.decode = decode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction isCompressedCanonicalPubKey(pubKey) {\n  return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;\n}\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    isCompressedCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessPubKeyHash input';\n};\n","'use strict';\n// OP_0 {pubKeyHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 22 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x14\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst typeforce = require('typeforce');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nfunction check(chunks, allowIncomplete) {\n  typeforce(typeforce.Array, chunks);\n  if (chunks.length < 1) return false;\n  const witnessScript = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(witnessScript)) return false;\n  const witnessScriptChunks = bscript.decompile(witnessScript);\n  // is witnessScript a valid script?\n  if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;\n  const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));\n  // match types\n  if (\n    p2pkh.input.check(witnessRawScriptSig) &&\n    p2pkh.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&\n    p2ms.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(witnessRawScriptSig) &&\n    p2pk.output.check(witnessScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessScriptHash input';\n};\n","'use strict';\n// OP_0 {scriptHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 34 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x20\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_SCRIPT,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst baddress = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst classify = require('./classify');\nconst bcrypto = require('./crypto');\nconst ECPair = require('./ecpair');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([\n  // Raw\n  'p2pkh',\n  'p2pk',\n  'p2wpkh',\n  'p2ms',\n  // P2SH wrapped\n  'p2sh-p2pkh',\n  'p2sh-p2pk',\n  'p2sh-p2wpkh',\n  'p2sh-p2ms',\n  // P2WSH wrapped\n  'p2wsh-p2pkh',\n  'p2wsh-p2pk',\n  'p2wsh-p2ms',\n  // P2SH-P2WSH wrapper\n  'p2sh-p2wsh-p2pkh',\n  'p2sh-p2wsh-p2pk',\n  'p2sh-p2wsh-p2ms',\n]);\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn(\n      'Deprecation Warning: TransactionBuilder will be removed in the future. ' +\n        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +\n        'are available in the transactions-psbt.js integration test file on our ' +\n        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +\n        'files as well.',\n    );\n  }\n  static fromTransaction(transaction, network) {\n    const txb = new TransactionBuilder(network);\n    // Copy transaction fields\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime);\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n      });\n    });\n    // fix some things not possible through the public API\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i);\n    });\n    return txb;\n  }\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n    if (setting === undefined) {\n      setting = true;\n    }\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(s => s !== undefined);\n      })\n    ) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    this.__TX.locktime = locktime;\n  }\n  setVersion(version) {\n    typeforce(types.UInt32, version);\n    // XXX: this might eventually become more complex depending on what the versions represent\n    this.__TX.version = version;\n  }\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    let value;\n    // is it a hex string?\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));\n      // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value,\n    });\n  }\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 or bech32 address string\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n  build() {\n    return this.__build(false);\n  }\n  buildIncomplete() {\n    return this.__build(true);\n  }\n  sign(\n    signParams,\n    keyPair,\n    redeemScript,\n    hashType,\n    witnessValue,\n    witnessScript,\n  ) {\n    trySign(\n      getSigningData(\n        this.network,\n        this.__INPUTS,\n        this.__needsOutputs.bind(this),\n        this.__TX,\n        signParams,\n        keyPair,\n        redeemScript,\n        hashType,\n        witnessValue,\n        witnessScript,\n        this.__USE_LOW_R,\n      ),\n    );\n  }\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined)\n      throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n      input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n        prevOutType = expanded.type;\n      }\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n    const vin = this.__TX.addInput(\n      txHash,\n      vout,\n      options.sequence,\n      options.scriptSig,\n    );\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n    const tx = this.__TX.clone();\n    // create script signatures from inputs\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete)\n        throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)\n          throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n    return tx;\n  }\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n        return (\n          (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0\n        );\n      });\n    });\n  }\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    }\n    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n    return (\n      this.__TX.outs.length === 0 &&\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(signature => {\n          if (!signature) return false; // no signature, no issue\n          const hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n          return true; // SIGHASH_* does care\n        });\n      })\n    );\n  }\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n        return false;\n      });\n    });\n  }\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n}\nexports.TransactionBuilder = TransactionBuilder;\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({\n        witness: witnessStack,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({\n        input: scriptSig,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig });\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms(\n        {\n          input: scriptSig,\n          output: scriptPubKey,\n        },\n        { allowIncomplete: true },\n      );\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys,\n        signatures,\n        maxSignatures: m,\n      };\n    }\n  }\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(\n      redeem.input,\n      redeem.witness,\n      outputType,\n      redeem.output,\n    );\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(\n        bscript.compile(redeem.witness),\n        [],\n        outputType,\n        redeem.output,\n      );\n    }\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig,\n  };\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)\n    return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match;\n    // check for a signature\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature);\n      const hash = transaction.hashForSignature(\n        vin,\n        input.redeemScript,\n        parsed.hashType,\n      );\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash;\n      const pkh2 = bcrypto.hash160(ourPubKey);\n      if (!pkh1.equals(pkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash;\n      const wpkh2 = bcrypto.hash160(ourPubKey);\n      if (!wpkh1.equals(wpkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script });\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script });\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m,\n      };\n    }\n  }\n  return { type };\n}\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: witnessScript },\n    });\n    const p2wshAlt = payments.p2wsh({ output: redeemScript });\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    const p2shAlt = payments.p2sh({ redeem: p2wsh });\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash))\n      throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash))\n      throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    if (input.prevOutScript) {\n      let p2shAlt;\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n      if (!p2sh.hash.equals(p2shAlt.hash))\n        throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as redeemScript (' +\n          bscript.toASM(redeemScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = redeemScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });\n      if (!p2wsh.hash.equals(p2wshAlt.hash))\n        throw new Error('Witness script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',\n      );\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',\n      );\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported (' +\n          bscript.toASM(input.prevOutScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = input.prevOutScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined],\n  };\n}\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pk({ signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures;\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || script_1.OPS.OP_0);\n      } else {\n        signatures = signatures.filter(x => x);\n      }\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || m === signatures.length;\n      return payments.p2ms(\n        { m, pubkeys, signatures },\n        { allowIncomplete, validate },\n      );\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n  }\n}\nfunction canSign(input) {\n  return (\n    input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (input.hasWitness === false || input.value !== undefined)\n  );\n}\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\n      `Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`,\n    );\n  }\n  tfMessage(\n    typeforce.Number,\n    signParams.vin,\n    `sign must include vin parameter as Number (input index)`,\n  );\n  tfMessage(\n    types.Signer,\n    signParams.keyPair,\n    `sign must include keyPair parameter as Signer interface`,\n  );\n  tfMessage(\n    typeforce.maybe(typeforce.Number),\n    signParams.hashType,\n    `sign hashType parameter must be a number`,\n  );\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessScript`,\n      );\n      break;\n  }\n}\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR,\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error(\n        'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',\n      );\n    }\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\nfunction getSigningData(\n  network,\n  inputs,\n  needsOutputs,\n  tx,\n  signParams,\n  keyPair,\n  redeemScript,\n  hashType,\n  witnessValue,\n  witnessScript,\n  useLowR,\n) {\n  let vin;\n  if (typeof signParams === 'number') {\n    console.warn(\n      'DEPRECATED: TransactionBuilder sign method arguments ' +\n        'will change in v6, please use the TxbSignArg interface',\n    );\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript,\n    } = signParams);\n  } else {\n    throw new TypeError(\n      'TransactionBuilder sign first arg must be TxbSignArg or number',\n    );\n  }\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  }\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== network)\n    throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (\n    input.redeemScript !== undefined &&\n    redeemScript &&\n    !input.redeemScript.equals(redeemScript)\n  ) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  const ourPubKey =\n    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue)\n        throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    if (!canSign(input)) {\n      const prepared = prepareInput(\n        input,\n        ourPubKey,\n        redeemScript,\n        witnessScript,\n      );\n      // updates inline\n      Object.assign(input, prepared);\n    }\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  let signatureHash;\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n    );\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR,\n  };\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeforce = require('typeforce');\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nexports.UInt31 = UInt31;\nfunction BIP32Path(value) {\n  return typeforce.String(value) && !!value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\nexports.BIP32Path = BIP32Path;\nBIP32Path.toJSON = () => {\n  return 'BIP32 derivation path';\n};\nfunction Signer(obj) {\n  return (\n    (typeforce.Buffer(obj.publicKey) ||\n      typeof obj.getPublicKey === 'function') &&\n    typeof obj.sign === 'function'\n  );\n}\nexports.Signer = Signer;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\n// external dependent types\nexports.ECPoint = typeforce.quacksLike('Point');\n// exposed, external API\nexports.Network = typeforce.compile({\n  messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32,\n  },\n  pubKeyHash: typeforce.UInt8,\n  scriptHash: typeforce.UInt8,\n  wif: typeforce.UInt8,\n});\nexports.Buffer256bit = typeforce.BufferN(32);\nexports.Hash160bit = typeforce.BufferN(20);\nexports.Hash256bit = typeforce.BufferN(32);\nexports.Number = typeforce.Number; // tslint:disable-line variable-name\nexports.Array = typeforce.Array;\nexports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name\nexports.String = typeforce.String; // tslint:disable-line variable-name\nexports.Buffer = typeforce.Buffer;\nexports.Hex = typeforce.Hex;\nexports.maybe = typeforce.maybe;\nexports.tuple = typeforce.tuple;\nexports.UInt8 = typeforce.UInt8;\nexports.UInt32 = typeforce.UInt32;\nexports.Function = typeforce.Function;\nexports.BufferN = typeforce.BufferN;\nexports.Null = typeforce.Null;\nexports.oneOf = typeforce.oneOf;\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { safeRe: re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","const SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = require('../internal/lrucache')\nconst cache = new LRU()\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (!identifier && identifierBase === false) {\n          throw new Error('invalid increment argument: identifier is empty')\n        }\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","const parse = require('./parse.js')\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // Otherwise it can be determined by checking the high version\n\n    if (highVersion.patch) {\n      // anything higher than a patch bump would result in the wrong version\n      return 'patch'\n    }\n\n    if (highVersion.minor) {\n      // anything higher than a minor bump would result in the wrong version\n      return 'minor'\n    }\n\n    // bumping major/minor/patch all have same result\n    return 'major'\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const SemVer = require('../classes/semver')\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nconst constants = require('./internal/constants')\nconst SemVer = require('./classes/semver')\nconst identifiers = require('./internal/identifiers')\nconst parse = require('./functions/parse')\nconst valid = require('./functions/valid')\nconst clean = require('./functions/clean')\nconst inc = require('./functions/inc')\nconst diff = require('./functions/diff')\nconst major = require('./functions/major')\nconst minor = require('./functions/minor')\nconst patch = require('./functions/patch')\nconst prerelease = require('./functions/prerelease')\nconst compare = require('./functions/compare')\nconst rcompare = require('./functions/rcompare')\nconst compareLoose = require('./functions/compare-loose')\nconst compareBuild = require('./functions/compare-build')\nconst sort = require('./functions/sort')\nconst rsort = require('./functions/rsort')\nconst gt = require('./functions/gt')\nconst lt = require('./functions/lt')\nconst eq = require('./functions/eq')\nconst neq = require('./functions/neq')\nconst gte = require('./functions/gte')\nconst lte = require('./functions/lte')\nconst cmp = require('./functions/cmp')\nconst coerce = require('./functions/coerce')\nconst Comparator = require('./classes/comparator')\nconst Range = require('./classes/range')\nconst satisfies = require('./functions/satisfies')\nconst toComparators = require('./ranges/to-comparators')\nconst maxSatisfying = require('./ranges/max-satisfying')\nconst minSatisfying = require('./ranges/min-satisfying')\nconst minVersion = require('./ranges/min-version')\nconst validRange = require('./ranges/valid')\nconst outside = require('./ranges/outside')\nconst gtr = require('./ranges/gtr')\nconst ltr = require('./ranges/ltr')\nconst intersects = require('./ranges/intersects')\nconst simplifyRange = require('./ranges/simplify')\nconst subset = require('./ranges/subset')\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n","class LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n","// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n","const {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n","/*\n * Bitcoin BIP32 path helpers\n * (C) 2016 Alex Beregszaszi\n */\n\nconst HARDENED = 0x80000000\n\nvar BIPPath = function (path) {\n  if (!Array.isArray(path)) {\n    throw new Error('Input must be an Array')\n  }\n  if (path.length === 0) {\n    throw new Error('Path must contain at least one level')\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (typeof path[i] !== 'number') {\n      throw new Error('Path element is not a number')\n    }\n  }\n  this.path = path\n}\n\nBIPPath.validatePathArray = function (path) {\n  try {\n    BIPPath.fromPathArray(path)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.validateString = function (text, reqRoot) {\n  try {\n    BIPPath.fromString(text, reqRoot)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.fromPathArray = function (path) {\n  return new BIPPath(path)\n}\n\nBIPPath.fromString = function (text, reqRoot) {\n  // skip the root\n  if (/^m\\//i.test(text)) {\n    text = text.slice(2)\n  } else if (reqRoot) {\n    throw new Error('Root element is required')\n  }\n\n  var path = text.split('/')\n  var ret = new Array(path.length)\n  for (var i = 0; i < path.length; i++) {\n    var tmp = /(\\d+)([hH\\']?)/.exec(path[i])\n    if (tmp === null) {\n      throw new Error('Invalid input')\n    }\n    ret[i] = parseInt(tmp[1], 10)\n\n    if (ret[i] >= HARDENED) {\n      throw new Error('Invalid child index')\n    }\n\n    if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\\'') {\n      ret[i] += HARDENED\n    } else if (tmp[2].length != 0) {\n      throw new Error('Invalid modifier')\n    }\n  }\n  return new BIPPath(ret)\n}\n\nBIPPath.prototype.toPathArray = function () {\n  return this.path\n}\n\nBIPPath.prototype.toString = function (noRoot, oldStyle) {\n  var ret = new Array(this.path.length)\n  for (var i = 0; i < this.path.length; i++) {\n    var tmp = this.path[i]\n    if (tmp & HARDENED) {\n      ret[i] = (tmp & ~HARDENED) + (oldStyle ? 'h' : '\\'')\n    } else {\n      ret[i] = tmp\n    }\n  }\n  return (noRoot ? '' : 'm/') + ret.join('/')\n}\n\nBIPPath.prototype.inspect = function () {\n  return 'BIPPath <' + this.toString() + '>'\n}\n\nmodule.exports = BIPPath\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require('create-hash');\nconst createHmac = require('create-hmac');\nfunction hash160(buffer) {\n    const sha256Hash = createHash('sha256')\n        .update(buffer)\n        .digest();\n    try {\n        return createHash('rmd160')\n            .update(sha256Hash)\n            .digest();\n    }\n    catch (err) {\n        return createHash('ripemd160')\n            .update(sha256Hash)\n            .digest();\n    }\n}\nexports.hash160 = hash160;\nfunction hmacSHA512(key, data) {\n    return createHmac('sha512', key)\n        .update(data)\n        .digest();\n}\nexports.hmacSHA512 = hmacSHA512;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bip32_1 = require(\"./bip32\");\nexports.fromSeed = bip32_1.fromSeed;\nexports.fromBase58 = bip32_1.fromBase58;\nexports.fromPublicKey = bip32_1.fromPublicKey;\nexports.fromPrivateKey = bip32_1.fromPrivateKey;\n","var OPS = require('./index.json')\n\nvar map = {}\nfor (var op in OPS) {\n  var code = OPS[op]\n  map[code] = op\n}\n\nmodule.exports = map\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var OPS = require('bitcoin-ops')\n\nfunction encodingLength (i) {\n  return i < OPS.OP_PUSHDATA1 ? 1\n  : i <= 0xff ? 2\n  : i <= 0xffff ? 3\n  : 5\n}\n\nfunction encode (buffer, number, offset) {\n  var size = encodingLength(number)\n\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(number, offset)\n\n  // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)\n    buffer.writeUInt8(number, offset + 1)\n\n  // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n\n  // 32 bit\n  } else {\n    buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n  }\n\n  return size\n}\n\nfunction decode (buffer, offset) {\n  var opcode = buffer.readUInt8(offset)\n  var number, size\n\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    number = opcode\n    size = 1\n\n  // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null\n    number = buffer.readUInt8(offset + 1)\n    size = 2\n\n  // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null\n    number = buffer.readUInt16LE(offset + 1)\n    size = 3\n\n  // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')\n\n    number = buffer.readUInt32LE(offset + 1)\n    size = 5\n  }\n\n  return {\n    opcode: opcode,\n    number: number,\n    size: size\n  }\n}\n\nmodule.exports = {\n  encodingLength: encodingLength,\n  encode: encode,\n  decode: decode\n}\n"],"names":["pathElementsToBuffer","paths","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE","bip32asBuffer","path","pathStringToArray","pathArrayToString","pathElements","bippath","toString","toPathArray","pubkeyFromXpub","xpub","xpubBuf","bs58check","slice","getXpubComponents","chaincode","pubkey","version","readUInt32BE","unsafeTo64bitLE","n","Number","MAX_SAFE_INTEGER","Error","byteArray","byte","unsafeFrom64bitLE","value","i","BufferWriter","constructor","bufs","write","fn","b","this","push","writeUInt8","writeInt32","writeInt32LE","writeUInt32","writeUInt32LE","writeUInt64","bytes","writeSlice","writeVarInt","varuint","from","writeVarSlice","concat","BufferReader","offset","available","readUInt8","result","readInt32","readInt32LE","readUInt32","readUInt32LE","readUInt64","readSlice","readVarInt","vi","readVarSlice","readVector","count","vector","MAX_SCRIPT_BLOCK","DEFAULT_SEQUENCE","hashPublicKey","RIPEMD160","update","sha","digest","BaseAccount","psbt","masterFp","SingleKeyAccount","spendingCondition","pubkeys","singleKeyCondition","setInput","inputTx","spentOutput","pathElems","setSingleKeyInput","setOwnOutput","cond","setSingleKeyOutput","p2pkh","buf","pubkeyHash","scriptPubKey","_spentOutput","setInputNonWitnessUtxo","setInputBip32Derivation","setOutputBip32Derivation","getDescriptorTemplate","p2tr","xonlyPubkey","outputKey","getTaprootOutputKey","_inputTx","xonly","setInputTapBip32Derivation","setInputWitnessUtxo","amount","setOutputTapBip32Derivation","hashTapTweak","x","h","crypto","sha256","internalPubkey","evenEcdsaPubkey","tweak","pointAddScalar","p2wpkhWrapped","redeemScript","createRedeemScript","scriptHash","userSuppliedRedeemScript","expectedRedeemScript","equals","setInputRedeemScript","setOutputRedeemScript","p2wpkh","Merkle","leaves","hasher","nodes","calculateRoot","rootNode","root","leafNodes","getRoot","hash","size","getLeaves","getLeafHash","getProof","proveNode","Node","undefined","newNode","leftCount","isPowerOf2","Math","floor","log2","highestPowerOf2LessThan","leftBranch","rightBranch","leftChild","rightChild","hashNode","node","parent","left","right","hashLeaf","hashFunction","bufA","bufB","hashConcat","isLeaf","WalletPolicy","descriptorTemplate","key","keys","getWalletId","serialize","keyBuffers","map","k","m","createKey","masterFingerprint","accountPath","substring","psbtGlobal","psbtIn","psbtOut","PSBT_MAGIC_BYTES","NoSuchEntry","PsbtV2","globalMap","Map","inputMaps","outputMaps","setGlobalTxVersion","setGlobal","TX_VERSION","uint32LE","getGlobalTxVersion","getGlobal","setGlobalFallbackLocktime","locktime","FALLBACK_LOCKTIME","getGlobalFallbackLocktime","_a","getGlobalOptional","setGlobalInputCount","inputCount","INPUT_COUNT","varint","getGlobalInputCount","fromVarint","setGlobalOutputCount","outputCount","OUTPUT_COUNT","getGlobalOutputCount","setGlobalTxModifiable","TX_MODIFIABLE","getGlobalTxModifiable","setGlobalPsbtVersion","psbtVersion","VERSION","getGlobalPsbtVersion","inputIndex","transaction","NON_WITNESS_UTXO","getInputNonWitnessUtxo","getInputOptional","WITNESS_UTXO","getInputWitnessUtxo","utxo","setInputPartialSig","signature","PARTIAL_SIG","getInputPartialSig","setInputSighashType","sigHashtype","SIGHASH_TYPE","getInputSighashType","REDEEM_SCRIPT","getInputRedeemScript","BIP32_DERIVATION","encodeBip32Derivation","getInputBip32Derivation","decodeBip32Derivation","setInputFinalScriptsig","scriptSig","FINAL_SCRIPTSIG","getInputFinalScriptsig","setInputFinalScriptwitness","scriptWitness","FINAL_SCRIPTWITNESS","getInputFinalScriptwitness","getInput","setInputPreviousTxId","txid","PREVIOUS_TXID","getInputPreviousTxid","setInputOutputIndex","outputIndex","OUTPUT_INDEX","getInputOutputIndex","setInputSequence","sequence","SEQUENCE","getInputSequence","_b","setInputTapKeySig","sig","TAP_KEY_SIG","getInputTapKeySig","hashes","encodeTapBip32Derivation","TAP_BIP32_DERIVATION","getInputTapBip32Derivation","decodeTapBip32Derivation","getInputKeyDatas","keyType","getKeyDatas","setOutput","getOutputRedeemScript","getOutput","BIP_32_DERIVATION","getOutputBip32Derivation","setOutputAmount","AMOUNT","getOutputAmount","setOutputScript","SCRIPT","getOutputScript","fingerprint","getOutputTapBip32Derivation","deleteInputEntries","keyTypes","_v","isKeyType","delete","copy","to","copyMap","copyMaps","to_index","v","set","serializeMap","deserialize","readKeyPair","keyLen","hexKey","some","Key","get","keyData","getMap","maps","writeBip32Derivation","readBip32Derivation","hashCount","deriv","Object","assign","acceptUndefined","toBuffer","KeyPair","clearFinalizedInput","witnessUtxoAvailable","nonWitnessUtxoAvailable","writePush","data","writeUInt16LE","getVarint","createVarint","serializeTransactionOutputs","outputs","outputBuffer","output","script","serializeTransaction","skipWitness","timestamp","additionals","isDecred","includes","isZcash","isBech32","inputBuffer","useWitness","inputs","input","prevout","witness","nExpiryHeight","extraData","nVersionGroupId","BtcNew","client","getWalletXpub","xpubVersion","getExtendedPubkey","xpubComponents","getWalletPublicKey","opts","validSingleSigPurposePathPartsSet","has","validCoinPathPartsSet","hard","change","soft","validMultiSigPurposePathPartsSet","isPathNormal","display","verify","address","getWalletAddress","addressFormat","descrTemplFrom","format","components","publicKey","pointCompress","bitcoinAddress","chainCode","descrTempl","hardenedPathOf","accountXpub","getMasterFingerprint","policy","changeAndIndex","createPaymentTransaction","arg","accountType","segwit","accountTypeFromArg","lockTime","notifyCount","progress","onDeviceStreaming","total","associatedKeysets","sigHashType","outputsConcat","outputScriptHex","outputsBufferReader","changeData","outputScriptAt","changePath","changeFound","outputScript","p","onDeviceSignatureRequested","firstSigned","signPsbt","progressCallback","onDeviceSignatureGranted","legacyPubkeys","taprootSig","isSegwitV0","isWrappedSegwit","witnessBuf","scriptSigBuf","finalize","serializedTx","tx","isSegwit","witnessWriter","extract","signMessage","messageHex","message","r","s","masterFP","spentOutputIndex","inputTxBuffer","inputTxid","hash256","spentTxOutput","walletPolicy","H","Set","t","addressFormatMap","legacy","p2sh","bech32","cashaddr","transport","options","p1","p2","response","send","publicKeyLength","addressLength","getTrustedInputRaw","transactionData","indexLookup","firstRound","prefix","trustedInput","getTrustedInput","transport_1","indexLookup_1","transaction_1","isXST","processScriptBlocks","__awaiter","seq","scriptBlocks","res","blockSize","scriptBlock","processWholeScriptBlock","block","isXSTV2","compare","treeField","tree","endData","extraPart","invariant","startUntrustedHashTransactionInputRaw","newTransaction","bip143","overwinter","startUntrustedHashTransactionInput","newTransaction_1","inputs_1","useTrustedInputForSegwit","inputValue","getTrustedInputBIP143","shajs","compressPublicKey","prefixBuffer","signTransaction","expiryHeight","pathsBuffer","lockTimeBuffer","then","provideOutputFullChangePath","hashOutputFull","outputScript_1","getAppAndVersion","nameLength","name","versionLength","flagLength","flags","defaultsSignTransaction","_e","createTransaction","signTx","initialTimestamp","semver","shouldUseTrustedInputForSegwit","e","statusCode","notify","loop","startTime","Date","now","sapling","useBip143","nullScript","nullPrevout","defaultVersion","trustedInputs","regularOutputs","signatures","publicKeys","firstRun","targetTransaction","getTrustedInputCall","log","idx","pseudoTX","pseudoTrustedInputs","signatureSize","keySize","tmpScriptData","decredWitness","BtcOld","derivationsCache","derivatePath","parentPath","parentDerivation","accountDerivation","compressedPubKey","ripemd160","makeFingerprint","compressPublicKeySECP256","depth","parentFingerprint","pubKey","indexBuffer","asBufferUInt32BE","extendedKeyBytes","checksum","bs58","makeXpub","arguments","maxChunkSize","chunkSize","writeUInt16BE","allocUnsafe","MerkleMap","values","keysTree","valuesTree","commitment","MerkelizedPsbt","super","inputMerkleMaps","outputMerkleMaps","globalMerkleMap","createMerkleMap","inputMapCommitments","outputMapCommitments","getGlobalSize","getGlobalKeysValuesRoot","sortedKeysStrings","sort","sortedKeys","ClientCommandCode","ClientCommand","YieldCommand","results","code","YIELD","execute","request","subarray","GetPreimageCommand","known_preimages","queue","GET_PREIMAGE","req","req_hash_hex","known_preimage","preimage_len_varint","max_payload_size","payload_size","min","GetMerkleLeafProofCommand","known_trees","GET_MERKLE_LEAF_PROOF","reqBuf","hash_hex","tree_size","leaf_index","mt","proof","n_response_elements","n_leftover_elements","GetMerkleLeafIndexCommand","GET_MERKLE_LEAF_INDEX","root_hash","root_hash_hex","leef_hash","leef_hash_hex","found","GetMoreElementsCommand","GET_MORE_ELEMENTS","element_len","el","max_elements","n_returned_elements","returned_elements","splice","ClientCommandInterpreter","roots","preimages","yielded","commands","cmd","getYielded","addKnownPreimage","preimage","addKnownList","elements","addKnownMapping","mm","cmdCode","BitcoinIns","FrameworkIns","AppClient","makeRequest","ins","cci","readUInt16BE","hwRequest","commandResponse","CONTINUE_INTERRUPTED","GET_PUBKEY","walletHMAC","addressIndex","isInteger","clientInterpreter","addressIndexBuffer","GET_WALLET_ADDRESS","merkelizedPsbt","inputMapsRoot","outputMapsRoot","SIGN_PSBT","ret","inputAndSig","GET_MASTER_FINGERPRINT","nChunks","ceil","chunks","chunksRoot","SIGN_MESSAGE","formatTransactionDebug","str","defaultArg","transactionVersion","Btc","scrambleKey","currency","_transport","decorateAppAPIMethods","_impl","changeImplIfNecessary","impl","console","warn","signP2SHTransaction","splitTransaction","transactionHex","isSegwitSupported","hasTimestamp","hasExtraData","witnessScript","isZencash","isZcashv5","numberInputs","numberOutputs","ALPHABET","ALPHABET_MAP","z","charAt","TypeError","polymodStep","pre","prefixChk","chk","c","charCodeAt","__decode","LIMIT","lowered","toLowerCase","uppered","toUpperCase","split","lastIndexOf","wordChars","words","convert","inBits","outBits","pad","bits","maxV","module","exports","decodeUnsafe","apply","decode","encode","toWordsUnsafe","Array","isArray","toWords","fromWordsUnsafe","fromWords","defineProperty","networks","require","payments","bscript","types","typeforce","fromBase58Check","payload","fromBech32","toBase58Check","tuple","Hash160bit","UInt8","toBech32","unshift","fromOutputScript","network","bitcoin","p2wsh","toASM","toOutputScript","decodeBase58","decodeBech32","pubKeyHash","bufferutils_1","bcrypto","fastMerkleRoot","errorMerkleNoTxes","errorWitnessNotSegwit","Block","prevHash","merkleRoot","witnessCommit","nonce","transactions","fromBuffer","bufferReader","readTransaction","Transaction","byteLength","nTransactions","getWitnessCommit","fromHex","hex","calculateTarget","exponent","mantissa","target","writeUIntBE","calculateMerkleRoot","forWitness","getHash","Function","txesHaveWitnessCommit","rootHash","witnessCommits","outs","filter","out","hasWitnessCommit","hasWitness","weight","headersOnly","allowWitness","encodingLength","reduce","a","getId","reverseBuffer","getUTCDate","date","setUTCSeconds","bufferWriter","txSize","toHex","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","actualMerkleRoot","actualWitnessCommit","verifuint","max","readUInt64LE","writeUInt64LE","j","tmp","cloneBuffer","clone","UInt32","writeVector","script_1","multisig","nullData","witnessCommitment","witnessPubKeyHash","witnessScriptHash","P2MS","NONSTANDARD","NULLDATA","P2PK","P2PKH","P2SH","P2WPKH","P2WSH","WITNESS_COMMITMENT","check","decompile","allowIncomplete","createHash","err","sha1","hash160","NETWORKS","ecc","randomBytes","wif","isOptions","maybe","compile","compressed","Boolean","Network","ECPair","__D","__Q","lowR","privateKey","pointFromScalar","toWIF","sign","counter","writeUIntLE","signWithEntropy","fromPrivateKey","Buffer256bit","isPrivate","fromPublicKey","isPoint","fromWIF","wifString","decoded","pop","makeRandom","rng","d","Psbt","OPS","TransactionBuilder","messagePrefix","bip32","public","private","regtest","testnet","networks_1","lazy","typef","p2data","validate","arrayOf","o","prop","OP_RETURN","every","stacksEqual","embed_1","embed","p2ms_1","p2ms","p2pk_1","p2pk","p2pkh_1","p2sh_1","p2wpkh_1","p2wsh_1","object","f","configurable","enumerable","_value","call","writable","OP_INT_BASE","OP_RESERVED","isAcceptableSignature","isCanonicalScriptSignature","OP_0","OP_CHECKMULTISIG","_chunks","OP_CHECKSIG","String","BufferN","_address","OP_DUP","OP_HASH160","OP_EQUALVERIFY","hash2","pkh","redeem","_redeem","OP_EQUAL","nameParts","join","checkRedeem","hasInput","richunks","isPushOnly","isBuffer","EMPTY_BUFFER","shift","chunkHasUncompressedPubkey","chunk","_rchunks","stack","toStack","wScript","bip174_1","utils_1","address_1","crypto_1","ecpair_1","DEFAULT_OPTS","maximumFeeRate","PsbtTransaction","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","unsignedTx","__UNSAFE_SIGN_NONSEGWIT","setVersion","dpew","obj","attr","fromBase64","psbtBase","transactionFromBuffer","cache","checkTxInputCache","setLocktime","txInputs","txOutputs","_","combine","those","JSON","parse","stringify","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","__EXTRACTED_TX","addInputs","inputDatas","inputData","addInput","checkInvalidP2WSH","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","outputData","addOutput","extractTransaction","disableFeeCheck","isFinalized","feeRate","getFeeRate","vsize","virtualSize","satoshis","toFixed","checkFees","inputFinalizeGetAmts","getTxCacheValue","getFee","finalizeAllInputs","checkForInput","range","finalizeInput","finalScriptsFunc","getFinalScripts","isP2SH","isP2WSH","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutIndex","witnessUtxo","isP2WPKH","getScriptFromInput","sighashType","partialSig","pSig","hashType","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","getInputType","getMeaningfulScript","getScriptFromUtxo","finalScript","decomp","lastItem","isPubkeyLike","redeemFromFinalScriptSig","scriptWitnessToWitnessStack","redeemFromFinalWitnessScript","type","classifyScript","meaningfulScript","inputHasPubkey","pubkeyInScript","pubkeyInInput","inputHasHDKey","derivationIsMine","bip32DerivationIsMine","bip32Derivation","outputHasPubkey","pubkeyInOutput","checkForOutput","outputHasHDKey","validateSignaturesOfAllInputs","validateSignaturesOfInput","final","mySigs","hashCache","scriptCache","sighashCache","getHashForSig","checkScriptForPubkey","keypair","signAllInputsHD","hdKeyPair","sighashTypes","SIGHASH_ALL","signInputHD","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","all","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","entries","getHashAndSighashType","checkCache","toBase64","updateGlobal","updateData","updateOutput","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","hasSigs","neededSigs","sigs","pkey","find","isPaymentFactory","payment","isP2MS","isP2PK","isP2PKH","isP2WSHScript","isP2SHScript","derivePath","num","action","throws","pSigs","scriptItems","witnessItems","item","getPsigsFromInputFinalScripts","whitelist","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","indexOf","scriptCheckerFactory","paymentScriptName","ioType","redeemScriptOutput","checkRedeemScript","checkWitnessScript","mustFinalize","scriptType","canFinalize","pk","ps","getSortedSigs","getPayment","witnessStackToScriptWitness","prepareFinalScripts","forValidate","text","sighashTypeToString","prevoutHash","utxoHash","hashForWitnessV0","signingScript","hashForSignature","myDerivations","bipDv","currentLen","varintLen","self","selfIndex","txCache","newBuf","inputAmount","nwTx","vout","outputAmount","fee","isCanonicalPubKey","isP2SHP2WSH","decompiled","scriptNumber","scriptSignature","bip66","pushdata","REVERSE_OPS","isPushOnlyChunk","OP_1","OP_16","OP_1NEGATE","isOPInt","asMinimalOP","chunksIsBuffer","singleChunkIsBuffer","bufferSize","accum","opcode","OP_PUSHDATA4","number","op","isDefinedHashType","hashTypeMod","fromASM","asm","chunkStr","Hex","maxLength","minimal","_number","abs","negative","ZERO","toDER","fromDER","bstart","hashTypeBuffer","partialSignature","toJSON","p2wpkho","p2wsho","lastChunk","scriptSigChunks","redeemScriptChunks","HEADER","Hash256bit","witnessScriptChunks","witnessRawScriptSig","varSliceSize","someScript","EMPTY_SCRIPT","EMPTY_WITNESS","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","valueBuffer","_NO_STRICT","marker","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","vinLen","voutLen","isCoinbaseHash","isCoinbase","Null","Satoshi","_ALLOW_WITNESS","sum","someVector","vectorSize","newTx","txIn","txOut","inIndex","prevOutScript","ourScript","OP_CODESEPARATOR","txTmp","y","__toBuffer","tbuffer","hashOutputs","hashPrevouts","hashSequence","txOutsSize","initialOffset","setInputScript","setWitness","baddress","classify","SCRIPT_TYPES","PREVOUT_TYPES","tfMessage","__PREV_TX_SET","__INPUTS","__USE_LOW_R","fromTransaction","txb","setLockTime","__addInputUnsafe","vin","redeemScriptType","unmatched","match","parsed","fixMultisigOrder","setLowR","setting","txHash","__canModifyInputs","txIsTransaction","__canModifyOutputs","build","__build","buildIncomplete","signParams","witnessValue","ourPubKey","signatureHash","useLowR","signed","trySign","needsOutputs","prevOutScriptType","Signer","prevOutType","posType","checkSignArgs","getPublicKey","canSign","prepared","p2wshAlt","p2shAlt","expanded","expandOutput","signScript","witnessScriptType","signType","maxSignatures","prepareInput","getSigningData","__needsOutputs","bind","prevTxOut","expandInput","__overMaximumFees","signatureHashType","signingHashType","nInputs","nOutputs","witnessStack","ssType","wsType","outputType","pkh1","pkh2","wpkh1","wpkh2","UINT31_MAX","pow","BIP32Path","UInt31","UInt53","ECPoint","quacksLike","oneOf","base58","checksumFn","decodeRaw","newChecksum","string","bs58checkBase","ANY","Symbol","Comparator","comp","parseOptions","loose","trim","debug","operator","re","COMPARATORLOOSE","COMPARATOR","SemVer","test","er","cmp","intersects","Range","includePrerelease","startsWith","safeRe","SPACE_CHARACTERS","raw","formatted","replace","parseRange","first","isNullSet","isAny","comps","memoKey","FLAG_INCLUDE_PRERELEASE","FLAG_LOOSE","cached","hr","HYPHENRANGELOOSE","HYPHENRANGE","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","rangeList","parseComparator","replaceGTE0","rangeMap","comparators","thisComparators","isSatisfiable","rangeComparators","thisComparator","rangeComparator","testSet","remainingComparators","testComparator","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","id","replaceTilde","TILDELOOSE","TILDE","M","pr","replaceCaret","CARETLOOSE","CARET","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","prerelease","allowed","major","minor","patch","MAX_LENGTH","compareIdentifiers","LOOSE","FULL","other","compareMain","comparePre","compareBuild","inc","release","identifier","identifierBase","base","isNaN","clean","eq","neq","gt","gte","lt","lte","coerce","rtl","coerceRtlRegex","COERCERTLFULL","COERCERTL","next","exec","lastIndex","COERCEFULL","COERCE","versionA","versionB","compareLoose","diff","version1","version2","v1","v2","comparison","v1Higher","highVersion","lowVersion","highHasPre","throwErrors","rcompare","rsort","list","satisfies","valid","internalRe","constants","identifiers","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","src","tokens","SEMVER_SPEC_VERSION","RELEASE_TYPES","rcompareIdentifiers","MAX_SAFE_COMPONENT_LENGTH","MAX_SAFE_BUILD_LENGTH","process","NODE_DEBUG","args","error","numeric","anum","bnum","firstKey","looseOption","freeze","emptyOpts","R","LETTERDASHNUMBER","safeRegexReplacements","createToken","isGlobal","safe","token","makeSafeRegex","RegExp","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCEPLAIN","LONETILDE","LONECARET","r1","r2","versions","maxSV","rangeObj","minSV","minver","setMin","comparator","compver","hilo","gtfn","ltefn","ltfn","ecomp","high","low","prev","ranges","simplified","original","minimumVersionWithPreRelease","minimumVersion","simpleSubset","sub","dom","eqSet","gtltComp","higher","lower","hasDomLT","hasDomGT","higherGT","lowerLT","add","needDomLTPre","needDomGTPre","sawNonNull","OUTER","simpleSub","simpleDom","isSub","subscribers","dispatch","LocalTracer","context","trace","getContext","setContext","updateContext","contextToAdd","getType","setType","withType","withContext","withUpdatedContext","listen","cb","window","__ledgerLogsListen","HARDENED","BIPPath","validatePathArray","fromPathArray","validateString","reqRoot","fromString","parseInt","prototype","noRoot","oldStyle","inspect","UINT256_TYPE","NETWORK_TYPE","BITCOIN","HIGHEST_BIT","BIP32","__DEPTH","__INDEX","__PARENT_FINGERPRINT","isNeutered","neutered","fromPublicKeyLocal","toBase58","derive","isHardened","I","hmacSHA512","IL","IR","hd","Ki","ki","privateAdd","fromPrivateKeyLocal","deriveHardened","splitPath","prevHd","indexStr","fromBase58","inString","fromSeed","seed","createHmac","sha256Hash","bip32_1","condition","argIndex","framesToPop","OP_PUSHDATA1","OP_PUSHDATA2","readUInt16LE"],"sourceRoot":""}