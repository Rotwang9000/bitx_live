"use strict";(globalThis.webpackChunkwinbit32=globalThis.webpackChunkwinbit32||[]).push([[945],{12797:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.pubkeyToAddress=t.pubkeyToRawAddress=t.rawSecp256k1PubkeyToRawAddress=t.rawEd25519PubkeyToRawAddress=void 0;const n=r(13606),o=r(22074),i=r(896),s=r(58890);function a(e){if(32!==e.length)throw new Error(`Invalid Ed25519 pubkey length: ${e.length}`);return(0,n.sha256)(e).slice(0,20)}function u(e){if(33!==e.length)throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${e.length}`);return(0,n.ripemd160)((0,n.sha256)(e))}function c(e){if((0,s.isSecp256k1Pubkey)(e)){return u((0,o.fromBase64)(e.value))}if((0,s.isEd25519Pubkey)(e)){return a((0,o.fromBase64)(e.value))}if((0,s.isMultisigThresholdPubkey)(e)){const t=(0,i.encodeAminoPubkey)(e);return(0,n.sha256)(t).slice(0,20)}throw new Error("Unsupported public key type")}t.rawEd25519PubkeyToRawAddress=a,t.rawSecp256k1PubkeyToRawAddress=u,t.pubkeyToRawAddress=c,t.pubkeyToAddress=function(e,t){return(0,o.toBech32)(t,c(e))}},25223:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.addCoins=t.parseCoins=t.coins=t.coin=void 0;const n=r(54969);function o(e,t){let r;if("number"===typeof e)try{r=new n.Uint53(e).toString()}catch(o){throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.")}else{if(!e.match(/^[0-9]+$/))throw new Error("Invalid unsigned integer string format");r=e.replace(/^0*/,"")||"0"}return{amount:r,denom:t}}t.coin=o,t.coins=function(e,t){return[o(e,t)]},t.parseCoins=function(e){return e.replace(/\s/g,"").split(",").filter(Boolean).map((e=>{const t=e.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/]{2,127})$/);if(!t)throw new Error("Got an invalid coin string");return{amount:t[1].replace(/^0+/,"")||"0",denom:t[2]}}))},t.addCoins=function(e,t){if(e.denom!==t.denom)throw new Error("Trying to add two coins with different denoms");return{amount:n.Decimal.fromAtomics(e.amount,0).plus(n.Decimal.fromAtomics(t.amount,0)).atomics,denom:e.denom}}},896:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.encodeBech32Pubkey=t.encodeAminoPubkey=t.decodeBech32Pubkey=t.decodeAminoPubkey=t.encodeEd25519Pubkey=t.encodeSecp256k1Pubkey=void 0;const n=r(22074),o=r(54969),i=r(79946),s=r(58890);t.encodeSecp256k1Pubkey=function(e){if(33!==e.length||2!==e[0]&&3!==e[0])throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");return{type:s.pubkeyType.secp256k1,value:(0,n.toBase64)(e)}},t.encodeEd25519Pubkey=function(e){if(32!==e.length)throw new Error("Ed25519 public key must be 32 bytes long");return{type:s.pubkeyType.ed25519,value:(0,n.toBase64)(e)}};const a=(0,n.fromHex)("eb5ae98721"),u=(0,n.fromHex)("1624de6420"),c=(0,n.fromHex)("0dfb100520"),d=(0,n.fromHex)("22c1f7e2");function p(e){if((0,i.arrayContentStartsWith)(e,a)){const t=e.slice(a.length);if(33!==t.length)throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");return{type:s.pubkeyType.secp256k1,value:(0,n.toBase64)(t)}}if((0,i.arrayContentStartsWith)(e,u)){const t=e.slice(u.length);if(32!==t.length)throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");return{type:s.pubkeyType.ed25519,value:(0,n.toBase64)(t)}}if((0,i.arrayContentStartsWith)(e,c)){const t=e.slice(c.length);if(32!==t.length)throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");return{type:s.pubkeyType.sr25519,value:(0,n.toBase64)(t)}}if((0,i.arrayContentStartsWith)(e,d))return function(e){const t=Array.from(e),r=t.splice(0,d.length);if(!(0,i.arrayContentStartsWith)(r,d))throw new Error("Invalid multisig prefix.");if(8!=t.shift())throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");const[n,o]=y(t);t.splice(0,o);const a=[];for(;t.length>0;){if(18!=t.shift())throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");const[e,r]=y(t);if(t.splice(0,r),t.length<e)throw new Error("Invalid multisig data length.");const n=t.splice(0,e),o=p(Uint8Array.from(n));a.push(o)}return{type:s.pubkeyType.multisigThreshold,value:{threshold:n.toString(),pubkeys:a}}}(e);throw new Error("Unsupported public key type. Amino data starts with: "+(0,n.toHex)(e.slice(0,5)))}function y(e){if(e.length<1)throw new Error("Can't decode varint. EOF");if(e[0]>127)throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");return[e[0],1]}function l(e){const t=o.Uint53.fromString(e.toString()).toNumber();if(t>127)throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");return[t]}function f(e){if((0,s.isMultisigThresholdPubkey)(e)){const t=Array.from(d);t.push(8),t.push(...l(e.value.threshold));for(const r of e.value.pubkeys.map((e=>f(e))))t.push(18),t.push(...l(r.length)),t.push(...r);return new Uint8Array(t)}if((0,s.isEd25519Pubkey)(e))return new Uint8Array([...u,...(0,n.fromBase64)(e.value)]);if((0,s.isSecp256k1Pubkey)(e))return new Uint8Array([...a,...(0,n.fromBase64)(e.value)]);throw new Error("Unsupported pubkey type")}t.decodeAminoPubkey=p,t.decodeBech32Pubkey=function(e){const{data:t}=(0,n.fromBech32)(e);return p(t)},t.encodeAminoPubkey=f,t.encodeBech32Pubkey=function(e,t){return(0,n.toBech32)(t,f(e))}},1945:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.executeKdf=t.makeStdTx=t.isStdTx=t.serializeSignDoc=t.makeSignDoc=t.encodeSecp256k1Signature=t.decodeSignature=t.Secp256k1Wallet=t.Secp256k1HdWallet=t.extractKdfConfiguration=t.pubkeyType=t.isSinglePubkey=t.isSecp256k1Pubkey=t.isMultisigThresholdPubkey=t.isEd25519Pubkey=t.makeCosmoshubPath=t.omitDefault=t.createMultisigThresholdPubkey=t.encodeSecp256k1Pubkey=t.encodeEd25519Pubkey=t.encodeBech32Pubkey=t.encodeAminoPubkey=t.decodeBech32Pubkey=t.decodeAminoPubkey=t.parseCoins=t.coins=t.coin=t.addCoins=t.rawSecp256k1PubkeyToRawAddress=t.rawEd25519PubkeyToRawAddress=t.pubkeyToRawAddress=t.pubkeyToAddress=void 0;var n=r(12797);Object.defineProperty(t,"pubkeyToAddress",{enumerable:!0,get:function(){return n.pubkeyToAddress}}),Object.defineProperty(t,"pubkeyToRawAddress",{enumerable:!0,get:function(){return n.pubkeyToRawAddress}}),Object.defineProperty(t,"rawEd25519PubkeyToRawAddress",{enumerable:!0,get:function(){return n.rawEd25519PubkeyToRawAddress}}),Object.defineProperty(t,"rawSecp256k1PubkeyToRawAddress",{enumerable:!0,get:function(){return n.rawSecp256k1PubkeyToRawAddress}});var o=r(25223);Object.defineProperty(t,"addCoins",{enumerable:!0,get:function(){return o.addCoins}}),Object.defineProperty(t,"coin",{enumerable:!0,get:function(){return o.coin}}),Object.defineProperty(t,"coins",{enumerable:!0,get:function(){return o.coins}}),Object.defineProperty(t,"parseCoins",{enumerable:!0,get:function(){return o.parseCoins}});var i=r(896);Object.defineProperty(t,"decodeAminoPubkey",{enumerable:!0,get:function(){return i.decodeAminoPubkey}}),Object.defineProperty(t,"decodeBech32Pubkey",{enumerable:!0,get:function(){return i.decodeBech32Pubkey}}),Object.defineProperty(t,"encodeAminoPubkey",{enumerable:!0,get:function(){return i.encodeAminoPubkey}}),Object.defineProperty(t,"encodeBech32Pubkey",{enumerable:!0,get:function(){return i.encodeBech32Pubkey}}),Object.defineProperty(t,"encodeEd25519Pubkey",{enumerable:!0,get:function(){return i.encodeEd25519Pubkey}}),Object.defineProperty(t,"encodeSecp256k1Pubkey",{enumerable:!0,get:function(){return i.encodeSecp256k1Pubkey}});var s=r(13147);Object.defineProperty(t,"createMultisigThresholdPubkey",{enumerable:!0,get:function(){return s.createMultisigThresholdPubkey}});var a=r(81011);Object.defineProperty(t,"omitDefault",{enumerable:!0,get:function(){return a.omitDefault}});var u=r(65513);Object.defineProperty(t,"makeCosmoshubPath",{enumerable:!0,get:function(){return u.makeCosmoshubPath}});var c=r(58890);Object.defineProperty(t,"isEd25519Pubkey",{enumerable:!0,get:function(){return c.isEd25519Pubkey}}),Object.defineProperty(t,"isMultisigThresholdPubkey",{enumerable:!0,get:function(){return c.isMultisigThresholdPubkey}}),Object.defineProperty(t,"isSecp256k1Pubkey",{enumerable:!0,get:function(){return c.isSecp256k1Pubkey}}),Object.defineProperty(t,"isSinglePubkey",{enumerable:!0,get:function(){return c.isSinglePubkey}}),Object.defineProperty(t,"pubkeyType",{enumerable:!0,get:function(){return c.pubkeyType}});var d=r(31084);Object.defineProperty(t,"extractKdfConfiguration",{enumerable:!0,get:function(){return d.extractKdfConfiguration}}),Object.defineProperty(t,"Secp256k1HdWallet",{enumerable:!0,get:function(){return d.Secp256k1HdWallet}});var p=r(97192);Object.defineProperty(t,"Secp256k1Wallet",{enumerable:!0,get:function(){return p.Secp256k1Wallet}});var y=r(64479);Object.defineProperty(t,"decodeSignature",{enumerable:!0,get:function(){return y.decodeSignature}}),Object.defineProperty(t,"encodeSecp256k1Signature",{enumerable:!0,get:function(){return y.encodeSecp256k1Signature}});var l=r(72768);Object.defineProperty(t,"makeSignDoc",{enumerable:!0,get:function(){return l.makeSignDoc}}),Object.defineProperty(t,"serializeSignDoc",{enumerable:!0,get:function(){return l.serializeSignDoc}});var f=r(21484);Object.defineProperty(t,"isStdTx",{enumerable:!0,get:function(){return f.isStdTx}}),Object.defineProperty(t,"makeStdTx",{enumerable:!0,get:function(){return f.makeStdTx}});var h=r(25712);Object.defineProperty(t,"executeKdf",{enumerable:!0,get:function(){return h.executeKdf}})},13147:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createMultisigThresholdPubkey=t.compareArrays=void 0;const n=r(22074),o=r(54969),i=r(12797);function s(e,t){const r=(0,n.toHex)(e),o=(0,n.toHex)(t);return r===o?0:r<o?-1:1}t.compareArrays=s,t.createMultisigThresholdPubkey=function(e,t,r=!1){const n=new o.Uint53(t);if(n.toNumber()>e.length)throw new Error(`Threshold k = ${n.toNumber()} exceeds number of keys n = ${e.length}`);const a=r?e:Array.from(e).sort(((e,t)=>s((0,i.pubkeyToRawAddress)(e),(0,i.pubkeyToRawAddress)(t))));return{type:"tendermint/PubKeyMultisigThreshold",value:{threshold:n.toString(),pubkeys:a}}}},81011:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.omitDefault=void 0,t.omitDefault=function(e){switch(typeof e){case"string":return""===e?void 0:e;case"number":return 0===e?void 0:e;case"bigint":return e===BigInt(0)?void 0:e;case"boolean":return e||void 0;default:throw new Error(`Got unsupported type '${typeof e}'`)}}},65513:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.makeCosmoshubPath=void 0;const n=r(13606);t.makeCosmoshubPath=function(e){return[n.Slip10RawIndex.hardened(44),n.Slip10RawIndex.hardened(118),n.Slip10RawIndex.hardened(0),n.Slip10RawIndex.normal(0),n.Slip10RawIndex.normal(e)]}},58890:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isMultisigThresholdPubkey=t.isSinglePubkey=t.pubkeyType=t.isSecp256k1Pubkey=t.isEd25519Pubkey=void 0,t.isEd25519Pubkey=function(e){return"tendermint/PubKeyEd25519"===e.type},t.isSecp256k1Pubkey=function(e){return"tendermint/PubKeySecp256k1"===e.type},t.pubkeyType={secp256k1:"tendermint/PubKeySecp256k1",ed25519:"tendermint/PubKeyEd25519",sr25519:"tendermint/PubKeySr25519",multisigThreshold:"tendermint/PubKeyMultisigThreshold"},t.isSinglePubkey=function(e){return[t.pubkeyType.ed25519,t.pubkeyType.secp256k1,t.pubkeyType.sr25519].includes(e.type)},t.isMultisigThresholdPubkey=function(e){return"tendermint/PubKeyMultisigThreshold"===e.type}},31084:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Secp256k1HdWallet=t.extractKdfConfiguration=void 0;const n=r(13606),o=r(22074),i=r(79946),s=r(12797),a=r(65513),u=r(64479),c=r(72768),d=r(25712),p="secp256k1wallet-v1",y={algorithm:"argon2id",params:{outputLength:32,opsLimit:24,memLimitKib:12288}};t.extractKdfConfiguration=function(e){const t=JSON.parse(e);if(!(0,i.isNonNullObject)(t))throw new Error("Root document is not an object.");if(t.type===p)return t.kdf;throw new Error("Unsupported serialization type")};const l={bip39Password:"",hdPaths:[(0,a.makeCosmoshubPath)(0)],prefix:"cosmos"};class f{static async fromMnemonic(e,t={}){const r=new n.EnglishMnemonic(e),o=await n.Bip39.mnemonicToSeed(r,t.bip39Password);return new f(r,{...t,seed:o})}static async generate(e=12,t={}){const r=4*Math.floor(11*e/33),o=n.Random.getBytes(r),i=n.Bip39.encode(o);return f.fromMnemonic(i.toString(),t)}static async deserialize(e,t){const r=JSON.parse(e);if(!(0,i.isNonNullObject)(r))throw new Error("Root document is not an object.");if(r.type===p)return f.deserializeTypeV1(e,t);throw new Error("Unsupported serialization type")}static async deserializeWithEncryptionKey(e,t){const r=JSON.parse(e);if(!(0,i.isNonNullObject)(r))throw new Error("Root document is not an object.");const s=r;if(s.type===p){const e=await(0,d.decrypt)((0,o.fromBase64)(s.data),t,s.encryption),r=JSON.parse((0,o.fromUtf8)(e)),{mnemonic:a,accounts:u}=r;if((0,i.assert)("string"===typeof a),!Array.isArray(u))throw new Error("Property 'accounts' is not an array");if(!u.every((e=>{return t=e,!!(0,i.isNonNullObject)(t)&&"string"===typeof t.hdPath&&"string"===typeof t.prefix;var t})))throw new Error("Account is not in the correct format.");const c=u[0].prefix;if(!u.every((({prefix:e})=>e===c)))throw new Error("Accounts do not all have the same prefix");const p=u.map((({hdPath:e})=>(0,n.stringToPath)(e)));return f.fromMnemonic(a,{hdPaths:p,prefix:c})}throw new Error("Unsupported serialization type")}static async deserializeTypeV1(e,t){const r=JSON.parse(e);if(!(0,i.isNonNullObject)(r))throw new Error("Root document is not an object.");const n=await(0,d.executeKdf)(t,r.kdf);return f.deserializeWithEncryptionKey(e,n)}constructor(e,t){const r=t.hdPaths??l.hdPaths,n=t.prefix??l.prefix;this.secret=e,this.seed=t.seed,this.accounts=r.map((e=>({hdPath:e,prefix:n})))}get mnemonic(){return this.secret.toString()}async getAccounts(){return(await this.getAccountsWithPrivkeys()).map((({algo:e,pubkey:t,address:r})=>({algo:e,pubkey:t,address:r})))}async signAmino(e,t){const r=(await this.getAccountsWithPrivkeys()).find((({address:t})=>t===e));if(void 0===r)throw new Error(`Address ${e} not found in wallet`);const{privkey:o,pubkey:i}=r,s=(0,n.sha256)((0,c.serializeSignDoc)(t)),a=await n.Secp256k1.createSignature(s,o),d=new Uint8Array([...a.r(32),...a.s(32)]);return{signed:t,signature:(0,u.encodeSecp256k1Signature)(i,d)}}async serialize(e){const t=y,r=await(0,d.executeKdf)(e,t);return this.serializeWithEncryptionKey(r,t)}async serializeWithEncryptionKey(e,t){const r={mnemonic:this.mnemonic,accounts:this.accounts.map((({hdPath:e,prefix:t})=>({hdPath:(0,n.pathToString)(e),prefix:t})))},i=(0,o.toUtf8)(JSON.stringify(r)),s={algorithm:d.supportedAlgorithms.xchacha20poly1305Ietf},a=await(0,d.encrypt)(i,e,s),u={type:p,kdf:t,encryption:s,data:(0,o.toBase64)(a)};return JSON.stringify(u)}async getKeyPair(e){const{privkey:t}=n.Slip10.derivePath(n.Slip10Curve.Secp256k1,this.seed,e),{pubkey:r}=await n.Secp256k1.makeKeypair(t);return{privkey:t,pubkey:n.Secp256k1.compressPubkey(r)}}async getAccountsWithPrivkeys(){return Promise.all(this.accounts.map((async({hdPath:e,prefix:t})=>{const{privkey:r,pubkey:n}=await this.getKeyPair(e);return{algo:"secp256k1",privkey:r,pubkey:n,address:(0,o.toBech32)(t,(0,s.rawSecp256k1PubkeyToRawAddress)(n))}})))}}t.Secp256k1HdWallet=f},97192:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Secp256k1Wallet=void 0;const n=r(13606),o=r(22074),i=r(12797),s=r(64479),a=r(72768);class u{static async fromKey(e,t="cosmos"){const r=(await n.Secp256k1.makeKeypair(e)).pubkey;return new u(e,n.Secp256k1.compressPubkey(r),t)}constructor(e,t,r){this.privkey=e,this.pubkey=t,this.prefix=r}get address(){return(0,o.toBech32)(this.prefix,(0,i.rawSecp256k1PubkeyToRawAddress)(this.pubkey))}async getAccounts(){return[{algo:"secp256k1",address:this.address,pubkey:this.pubkey}]}async signAmino(e,t){if(e!==this.address)throw new Error(`Address ${e} not found in wallet`);const r=new n.Sha256((0,a.serializeSignDoc)(t)).digest(),o=await n.Secp256k1.createSignature(r,this.privkey),i=new Uint8Array([...o.r(32),...o.s(32)]);return{signed:t,signature:(0,s.encodeSecp256k1Signature)(this.pubkey,i)}}}t.Secp256k1Wallet=u},64479:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.decodeSignature=t.encodeSecp256k1Signature=void 0;const n=r(22074),o=r(896),i=r(58890);t.encodeSecp256k1Signature=function(e,t){if(64!==t.length)throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");return{pub_key:(0,o.encodeSecp256k1Pubkey)(e),signature:(0,n.toBase64)(t)}},t.decodeSignature=function(e){if(e.pub_key.type===i.pubkeyType.secp256k1)return{pubkey:(0,n.fromBase64)(e.pub_key.value),signature:(0,n.fromBase64)(e.signature)};throw new Error("Unsupported pubkey type")}},72768:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.serializeSignDoc=t.escapeCharacters=t.makeSignDoc=t.sortedJsonStringify=void 0;const n=r(22074),o=r(54969);function i(e){if("object"!==typeof e||null===e)return e;if(Array.isArray(e))return e.map(i);const t=Object.keys(e).sort(),r={};return t.forEach((t=>{r[t]=i(e[t])})),r}function s(e){return JSON.stringify(i(e))}function a(e){return e.replace(/&/g,"\\u0026").replace(/</g,"\\u003c").replace(/>/g,"\\u003e")}t.sortedJsonStringify=s,t.makeSignDoc=function(e,t,r,n,i,s,a){return{chain_id:r,account_number:o.Uint53.fromString(i.toString()).toString(),sequence:o.Uint53.fromString(s.toString()).toString(),fee:t,msgs:e,memo:n||"",...a&&{timeout_height:a.toString()}}},t.escapeCharacters=a,t.serializeSignDoc=function(e){const t=a(s(e));return(0,n.toUtf8)(t)}},21484:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.makeStdTx=t.isStdTx=void 0,t.isStdTx=function(e){const{memo:t,msg:r,fee:n,signatures:o}=e;return"string"===typeof t&&Array.isArray(r)&&"object"===typeof n&&Array.isArray(o)},t.makeStdTx=function(e,t){return{msg:e.msgs,fee:e.fee,memo:e.memo,signatures:Array.isArray(t)?t:[t]}}},25712:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.decrypt=t.encrypt=t.supportedAlgorithms=t.executeKdf=t.cosmjsSalt=void 0;const n=r(13606),o=r(22074);t.cosmjsSalt=(0,o.toAscii)("The CosmJS salt."),t.executeKdf=async function(e,r){if("argon2id"===r.algorithm){const o=r.params;if(!(0,n.isArgon2idOptions)(o))throw new Error("Invalid format of argon2id params");return n.Argon2id.execute(e,t.cosmjsSalt,o)}throw new Error("Unsupported KDF algorithm")},t.supportedAlgorithms={xchacha20poly1305Ietf:"xchacha20poly1305-ietf"},t.encrypt=async function(e,r,o){if(o.algorithm===t.supportedAlgorithms.xchacha20poly1305Ietf){const t=n.Random.getBytes(n.xchacha20NonceLength);return new Uint8Array([...t,...await n.Xchacha20poly1305Ietf.encrypt(e,r,t)])}throw new Error(`Unsupported encryption algorithm: '${o.algorithm}'`)},t.decrypt=async function(e,r,o){if(o.algorithm===t.supportedAlgorithms.xchacha20poly1305Ietf){const t=e.slice(0,n.xchacha20NonceLength);return n.Xchacha20poly1305Ietf.decrypt(e.slice(n.xchacha20NonceLength),r,t)}throw new Error(`Unsupported encryption algorithm: '${o.algorithm}'`)}}}]);
//# sourceMappingURL=945.898c9a27.chunk.js.map