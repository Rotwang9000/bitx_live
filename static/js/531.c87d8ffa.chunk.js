/*! For license information please see 531.c87d8ffa.chunk.js.LICENSE.txt */
"use strict";(globalThis.webpackChunkwinbit32=globalThis.webpackChunkwinbit32||[]).push([[531],{52531:(t,r,e)=>{var n=e(38173).Buffer,i=e(59513),o=e(11644),s=e(69321);function a(t){var r=Object.create(null);return t&&Object.keys(t).forEach((function(e){if("default"!==e){var n=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(r,e,n.get?n:{enumerable:!0,get:function(){return t[e]}})}})),r.default=t,Object.freeze(r)}var c=a(i);const f="Expected Private",u="Expected Point",h="Expected Tweak",l="Expected Signature",y="Expected Extra Data (32 bytes)",w="Expected Scalar";c.utils.hmacSha256Sync=(t,...r)=>o.hmac(s.sha256,t,c.utils.concatBytes(...r)),c.utils.sha256Sync=(...t)=>s.sha256(c.utils.concatBytes(...t));const d=c.utils._normalizePrivateKey,g=32,p=32,E=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,186,174,220,230,175,72,160,59,191,210,94,140,208,54,65,65]),m=32,x=new Uint8Array(32),b=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,69,81,35,25,80,183,95,196,64,45,161,114,47,201,186,238]);function v(t,r){for(let e=0;e<32;++e)if(t[e]!==r[e])return t[e]<r[e]?-1:1;return 0}function S(t){return 0===v(t,x)}function A(t){return t instanceof Uint8Array&&t.length===p&&!(v(t,E)>=0)}function B(t){return t instanceof Uint8Array&&64===t.length&&v(t.subarray(0,32),E)<0&&v(t.subarray(32,64),E)<0}function P(t){return t instanceof Uint8Array&&64===t.length&&v(t.subarray(0,32),b)<0}function I(t){return t instanceof Uint8Array&&t.length===g}function R(t){return void 0===t||t instanceof Uint8Array&&t.length===m}function U(t){if("string"!==typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function H(t){let r;if("bigint"===typeof t)r=t;else if("number"===typeof t&&Number.isSafeInteger(t)&&t>=0)r=BigInt(t);else if("string"===typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private scalar");r=U(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private scalar");if(32!==t.length)throw new Error("Expected 32 bytes of private scalar");e=t,r=U(c.utils.bytesToHex(e))}var e;if(r<0)throw new Error("Expected private scalar >= 0");return r}const k=(t,r,e)=>{const n=c.Point.fromHex(t),i=H(r),o=c.Point.BASE.multiplyAndAddUnsafe(n,i,BigInt(1));if(!o)throw new Error("Tweaked point at infinity");return o.toRawBytes(e)};function T(t,r){return void 0===t?void 0===r||$(r):!!t}function z(t){try{return t()}catch(r){return null}}function C(t,r){if(32===t.length!==r)return!1;try{return!!c.Point.fromHex(t)}catch(e){return!1}}function O(t){return C(t,!1)}function $(t){return C(t,!1)&&33===t.length}function N(t){return c.utils.isValidPrivateKey(t)}function V(t){return C(t,!0)}function K(t){if(!O(t))throw new Error(u);return t.slice(1,33)}function Z(t,r){if(!N(t))throw new Error(f);return z((()=>c.getPublicKey(t,T(r))))}r.isPoint=O,r.isPointCompressed=$,r.isPrivate=N,r.isXOnlyPoint=V,r.pointAdd=function(t,r,e){if(!O(t)||!O(r))throw new Error(u);return z((()=>{const n=c.Point.fromHex(t),i=c.Point.fromHex(r);return n.equals(i.negate())?null:n.add(i).toRawBytes(T(e,t))}))},r.pointAddScalar=function(t,r,e){if(!O(t))throw new Error(u);if(!A(r))throw new Error(h);return z((()=>k(t,r,T(e,t))))},r.pointCompress=function(t,r){if(!O(t))throw new Error(u);return c.Point.fromHex(t).toRawBytes(T(r,t))},r.pointFromScalar=Z,r.pointMultiply=function(t,r,e){if(!O(t))throw new Error(u);if(!A(r))throw new Error(h);return z((()=>((t,r,e)=>{const n=c.Point.fromHex(t),i="string"===typeof r?r:c.utils.bytesToHex(r),o=BigInt(`0x${i}`);return n.multiply(o).toRawBytes(e)})(t,r,T(e,t))))},r.privateAdd=function(t,r){if(!1===N(t))throw new Error(f);if(!1===A(r))throw new Error(h);return z((()=>((t,r)=>{const e=d(t),n=H(r),i=c.utils._bigintTo32Bytes(c.utils.mod(e+n,c.CURVE.n));return c.utils.isValidPrivateKey(i)?i:null})(t,r)))},r.privateNegate=function(t){if(!1===N(t))throw new Error(f);return(t=>{const r=d(t),e=c.utils._bigintTo32Bytes(c.CURVE.n-r);return c.utils.isValidPrivateKey(e)?e:null})(t)},r.privateSub=function(t,r){if(!1===N(t))throw new Error(f);if(!1===A(r))throw new Error(h);return z((()=>((t,r)=>{const e=d(t),n=H(r),i=c.utils._bigintTo32Bytes(c.utils.mod(e-n,c.CURVE.n));return c.utils.isValidPrivateKey(i)?i:null})(t,r)))},r.recover=function(t,r,e,n){if(!I(t))throw new Error("Expected Hash");if(!B(r)||!function(t){return!(S(t.subarray(0,32))||S(t.subarray(32,64)))}(r))throw new Error(l);if(2&e&&!P(r))throw new Error("Bad Recovery Id");if(!V(r.subarray(0,32)))throw new Error(l);return c.recoverPublicKey(t,r,e,T(n))},r.sign=function(t,r,e){if(!N(r))throw new Error(f);if(!I(t))throw new Error(w);if(!R(e))throw new Error(y);return c.signSync(t,r,{der:!1,extraEntropy:e})},r.signRecoverable=function(t,r,e){if(!N(r))throw new Error(f);if(!I(t))throw new Error(w);if(!R(e))throw new Error(y);const[n,i]=c.signSync(t,r,{der:!1,extraEntropy:e,recovered:!0});return{signature:n,recoveryId:i}},r.signSchnorr=function(t,r,e=n.alloc(32,0)){if(!N(r))throw new Error(f);if(!I(t))throw new Error(w);if(!R(e))throw new Error(y);return c.schnorr.signSync(t,r,e)},r.verify=function(t,r,e,n){if(!O(r))throw new Error(u);if(!B(e))throw new Error(l);if(!I(t))throw new Error(w);return c.verify(e,t,r,{strict:n})},r.verifySchnorr=function(t,r,e){if(!V(r))throw new Error(u);if(!B(e))throw new Error(l);if(!I(t))throw new Error(w);return c.schnorr.verifySync(e,t,r)},r.xOnlyPointAddTweak=function(t,r){if(!V(t))throw new Error(u);if(!A(r))throw new Error(h);return z((()=>{const e=k(t,r,!0);return{parity:e[0]%2===1?1:0,xOnlyPubkey:e.slice(1)}}))},r.xOnlyPointFromPoint=K,r.xOnlyPointFromScalar=function(t){if(!N(t))throw new Error(f);return K(Z(t))}},59513:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.utils=r.schnorr=r.verify=r.signSync=r.sign=r.getSharedSecret=r.recoverPublicKey=r.getPublicKey=r.Signature=r.Point=r.CURVE=void 0;const n=e(69159),i=BigInt(0),o=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),f=Object.freeze({a:i,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:o,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});r.CURVE=f;const u=(t,r)=>(t+r/s)/r,h={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:r}=f,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-o*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,a=BigInt("0x100000000000000000000000000000000"),c=u(s*t,r),h=u(-n*t,r);let l=K(t-c*e-h*i,r),y=K(-c*n-h*s,r);const w=l>a,d=y>a;if(w&&(l=r-l),d&&(y=r-y),l>a||y>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:w,k1:l,k2neg:d,k2:y}}},l=32,y=32,w=l+1,d=2*l+1;function g(t){const{a:r,b:e}=f,n=K(t*t),i=K(n*t);return K(i+r*t+e)}const p=f.a===i;class E extends Error{constructor(t){super(t)}}function m(t){if(!(t instanceof x))throw new TypeError("JacobianPoint expected")}class x{constructor(t,r,e){this.x=t,this.y=r,this.z=e}static fromAffine(t){if(!(t instanceof S))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(S.ZERO)?x.ZERO:new x(t.x,t.y,o)}static toAffineBatch(t){const r=function(t,r=f.P){const e=new Array(t.length),n=_(t.reduce(((t,n,o)=>n===i?t:(e[o]=t,K(t*n,r))),o),r);return t.reduceRight(((t,n,o)=>n===i?t:(e[o]=K(t*e[o],r),K(t*n,r))),n),e}(t.map((t=>t.z)));return t.map(((t,e)=>t.toAffine(r[e])))}static normalizeZ(t){return x.toAffineBatch(t).map(x.fromAffine)}equals(t){m(t);const{x:r,y:e,z:n}=this,{x:i,y:o,z:s}=t,a=K(n*n),c=K(s*s),f=K(r*c),u=K(i*a),h=K(K(e*s)*c),l=K(K(o*n)*a);return f===u&&h===l}negate(){return new x(this.x,K(-this.y),this.z)}double(){const{x:t,y:r,z:e}=this,n=K(t*t),i=K(r*r),o=K(i*i),f=t+i,u=K(s*(K(f*f)-n-o)),h=K(a*n),l=K(h*h),y=K(l-s*u),w=K(h*(u-y)-c*o),d=K(s*r*e);return new x(y,w,d)}add(t){m(t);const{x:r,y:e,z:n}=this,{x:o,y:a,z:c}=t;if(o===i||a===i)return this;if(r===i||e===i)return t;const f=K(n*n),u=K(c*c),h=K(r*u),l=K(o*f),y=K(K(e*c)*u),w=K(K(a*n)*f),d=K(l-h),g=K(w-y);if(d===i)return g===i?this.double():x.ZERO;const p=K(d*d),E=K(d*p),b=K(h*p),v=K(g*g-E-s*b),S=K(g*(b-v)-y*E),A=K(n*c*d);return new x(v,S,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const r=x.ZERO;if("bigint"===typeof t&&t===i)return r;let e=V(t);if(e===o)return this;if(!p){let t=r,n=this;for(;e>i;)e&o&&(t=t.add(n)),n=n.double(),e>>=o;return t}let{k1neg:n,k1:s,k2neg:a,k2:c}=h.splitScalar(e),f=r,u=r,l=this;for(;s>i||c>i;)s&o&&(f=f.add(l)),c&o&&(u=u.add(l)),l=l.double(),s>>=o,c>>=o;return n&&(f=f.negate()),a&&(u=u.negate()),u=new x(K(u.x*h.beta),u.y,u.z),f.add(u)}precomputeWindow(t){const r=p?128/t+1:256/t+1,e=[];let n=this,i=n;for(let o=0;o<r;o++){i=n,e.push(i);for(let r=1;r<2**(t-1);r++)i=i.add(n),e.push(i);n=i.double()}return e}wNAF(t,r){!r&&this.equals(x.BASE)&&(r=S.BASE);const e=r&&r._WINDOW_SIZE||1;if(256%e)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=r&&v.get(r);n||(n=this.precomputeWindow(e),r&&1!==e&&(n=x.normalizeZ(n),v.set(r,n)));let i=x.ZERO,s=x.BASE;const a=1+(p?128/e:256/e),c=2**(e-1),f=BigInt(2**e-1),u=2**e,h=BigInt(e);for(let l=0;l<a;l++){const r=l*c;let e=Number(t&f);t>>=h,e>c&&(e-=u,t+=o);const a=r,y=r+Math.abs(e)-1,w=l%2!==0,d=e<0;0===e?s=s.add(b(w,n[a])):i=i.add(b(d,n[y]))}return{p:i,f:s}}multiply(t,r){let e,n,i=V(t);if(p){const{k1neg:t,k1:o,k2neg:s,k2:a}=h.splitScalar(i);let{p:c,f:f}=this.wNAF(o,r),{p:u,f:l}=this.wNAF(a,r);c=b(t,c),u=b(s,u),u=new x(K(u.x*h.beta),u.y,u.z),e=c.add(u),n=f.add(l)}else{const{p:t,f:o}=this.wNAF(i,r);e=t,n=o}return x.normalizeZ([e,n])[0]}toAffine(t){const{x:r,y:e,z:n}=this,i=this.equals(x.ZERO);null==t&&(t=i?c:_(n));const s=t,a=K(s*s),f=K(a*s),u=K(r*a),h=K(e*f),l=K(n*s);if(i)return S.ZERO;if(l!==o)throw new Error("invZ was invalid");return new S(u,h)}}function b(t,r){const e=r.negate();return t?e:r}x.BASE=new x(f.Gx,f.Gy,o),x.ZERO=new x(i,o,i);const v=new WeakMap;class S{constructor(t,r){this.x=t,this.y=r}_setWindowSize(t){this._WINDOW_SIZE=t,v.delete(this)}hasEvenY(){return this.y%s===i}static fromCompressedHex(t){const r=32===t.length,e=$(r?t:t.subarray(1));if(!X(e))throw new Error("Point is not on curve");let n=function(t){const{P:r}=f,e=BigInt(6),n=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),u=BigInt(88),h=t*t*t%r,l=h*h*t%r,y=Z(l,a)*l%r,w=Z(y,a)*l%r,d=Z(w,s)*h%r,g=Z(d,n)*d%r,p=Z(g,i)*g%r,E=Z(p,c)*p%r,m=Z(E,u)*E%r,x=Z(m,c)*p%r,b=Z(x,a)*l%r,v=Z(b,o)*g%r,S=Z(v,e)*h%r,A=Z(S,s);if(A*A%r!==t)throw new Error("Cannot find square root");return A}(g(e));const i=(n&o)===o;if(r)i&&(n=K(-n));else{1===(1&t[0])!==i&&(n=K(-n))}const c=new S(e,n);return c.assertValidity(),c}static fromUncompressedHex(t){const r=$(t.subarray(1,l+1)),e=$(t.subarray(l+1,2*l+1)),n=new S(r,e);return n.assertValidity(),n}static fromHex(t){const r=N(t),e=r.length,n=r[0];if(e===l)return this.fromCompressedHex(r);if(e===w&&(2===n||3===n))return this.fromCompressedHex(r);if(e===d&&4===n)return this.fromUncompressedHex(r);throw new Error(`Point.fromHex: received invalid point. Expected 32-${w} compressed bytes or ${d} uncompressed bytes, not ${e}`)}static fromPrivateKey(t){return S.BASE.multiply(L(t))}static fromSignature(t,r,e){const{r:n,s:i}=Y(r);if(![0,1,2,3].includes(e))throw new Error("Cannot recover: invalid recovery bit");const o=D(N(t)),{n:s}=f,a=2===e||3===e?n+s:n,c=_(a,s),u=K(-o*c,s),h=K(i*c,s),l=1&e?"03":"02",y=S.fromHex(l+k(a)),w=S.BASE.multiplyAndAddUnsafe(y,u,h);if(!w)throw new Error("Cannot recover signature: point at infinify");return w.assertValidity(),w}toRawBytes(t=!1){return O(this.toHex(t))}toHex(t=!1){const r=k(this.x);if(t){return`${this.hasEvenY()?"02":"03"}${r}`}return`04${r}${k(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:r,y:e}=this;if(!X(r)||!X(e))throw new Error(t);const n=K(e*e);if(K(n-g(r))!==i)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new S(this.x,K(-this.y))}double(){return x.fromAffine(this).double().toAffine()}add(t){return x.fromAffine(this).add(x.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return x.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,r,e){const n=x.fromAffine(this),s=r===i||r===o||this!==S.BASE?n.multiplyUnsafe(r):n.multiply(r),a=x.fromAffine(t).multiplyUnsafe(e),c=s.add(a);return c.equals(x.ZERO)?void 0:c.toAffine()}}function A(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function B(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${U(t)}`);const r=t[1],e=t.subarray(2,r+2);if(!r||e.length!==r)throw new Error("Invalid signature integer: wrong length");if(0===e[0]&&e[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:$(e),left:t.subarray(r+2)}}r.Point=S,S.BASE=new S(f.Gx,f.Gy),S.ZERO=new S(i,i);class P{constructor(t,r){this.r=t,this.s=r,this.assertValidity()}static fromCompact(t){const r=t instanceof Uint8Array,e="Signature.fromCompact";if("string"!==typeof t&&!r)throw new TypeError(`${e}: Expected string or Uint8Array`);const n=r?U(t):t;if(128!==n.length)throw new Error(`${e}: Expected 64-byte hex`);return new P(C(n.slice(0,64)),C(n.slice(64,128)))}static fromDER(t){const r=t instanceof Uint8Array;if("string"!==typeof t&&!r)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:e,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${U(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:r,left:e}=B(t.subarray(2)),{data:n,left:i}=B(e);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${U(i)}`);return{r:r,s:n}}(r?t:O(t));return new P(e,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:r}=this;if(!F(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!F(r))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=f.n>>o;return this.s>t}normalizeS(){return this.hasHighS()?new P(this.r,K(-this.s,f.n)):this}toDERRawBytes(){return O(this.toDERHex())}toDERHex(){const t=A(z(this.s)),r=A(z(this.r)),e=t.length/2,n=r.length/2,i=z(e),o=z(n);return`30${z(n+e+4)}02${o}${r}02${i}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return O(this.toCompactHex())}toCompactHex(){return k(this.r)+k(this.s)}}function I(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const r=t.reduce(((t,r)=>t+r.length),0),e=new Uint8Array(r);for(let n=0,i=0;n<t.length;n++){const r=t[n];e.set(r,i),i+=r.length}return e}r.Signature=P;const R=Array.from({length:256},((t,r)=>r.toString(16).padStart(2,"0")));function U(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let r="";for(let e=0;e<t.length;e++)r+=R[t[e]];return r}const H=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function k(t){if("bigint"!==typeof t)throw new Error("Expected bigint");if(!(i<=t&&t<H))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function T(t){const r=O(k(t));if(32!==r.length)throw new Error("Error: expected 32 bytes");return r}function z(t){const r=t.toString(16);return 1&r.length?`0${r}`:r}function C(t){if("string"!==typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function O(t){if("string"!==typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const r=new Uint8Array(t.length/2);for(let e=0;e<r.length;e++){const n=2*e,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[e]=o}return r}function $(t){return C(U(t))}function N(t){return t instanceof Uint8Array?Uint8Array.from(t):O(t)}function V(t){if("number"===typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"===typeof t&&F(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function K(t,r=f.P){const e=t%r;return e>=i?e:r+e}function Z(t,r){const{P:e}=f;let n=t;for(;r-- >i;)n*=n,n%=e;return n}function _(t,r=f.P){if(t===i||r<=i)throw new Error(`invert: expected positive integers, got n=${t} mod=${r}`);let e=K(t,r),n=r,s=i,a=o,c=o,u=i;for(;e!==i;){const t=n/e,r=n%e,i=s-c*t,o=a-u*t;n=e,e=r,s=c,a=u,c=i,u=o}if(n!==o)throw new Error("invert: does not exist");return K(s,r)}function D(t,r=!1){const e=function(t){const r=8*t.length-8*y,e=$(t);return r>0?e>>BigInt(r):e}(t);if(r)return e;const{n:n}=f;return e>=n?e-n:e}let q,j;class W{constructor(t,r){if(this.hashLen=t,this.qByteLen=r,"number"!==typeof t||t<2)throw new Error("hashLen must be a number");if("number"!==typeof r||r<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return r.utils.hmacSha256(this.k,...t)}hmacSync(...t){return j(this.k,...t)}checkSync(){if("function"!==typeof j)throw new E("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0;const r=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);const e=this.v.slice();r.push(e),t+=this.v.length}return I(...r)}generateSync(){this.checkSync(),this.incr();let t=0;const r=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);const e=this.v.slice();r.push(e),t+=this.v.length}return I(...r)}}function F(t){return i<t&&t<f.n}function X(t){return i<t&&t<f.P}function G(t,r,e,n=!0){const{n:s}=f,a=D(t,!0);if(!F(a))return;const c=_(a,s),u=S.BASE.multiply(a),h=K(u.x,s);if(h===i)return;const l=K(c*K(r+e*h,s),s);if(l===i)return;let y=new P(h,l),w=(u.x===y.r?0:2)|Number(u.y&o);return n&&y.hasHighS()&&(y=y.normalizeS(),w^=1),{sig:y,recovery:w}}function L(t){let r;if("bigint"===typeof t)r=t;else if("number"===typeof t&&Number.isSafeInteger(t)&&t>0)r=BigInt(t);else if("string"===typeof t){if(t.length!==2*y)throw new Error("Expected 32 bytes of private key");r=C(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(t.length!==y)throw new Error("Expected 32 bytes of private key");r=$(t)}if(!F(r))throw new Error("Expected private key: 0 < key < n");return r}function M(t){return t instanceof S?(t.assertValidity(),t):S.fromHex(t)}function Y(t){if(t instanceof P)return t.assertValidity(),t;try{return P.fromDER(t)}catch(r){return P.fromCompact(t)}}function J(t){const r=t instanceof Uint8Array,e="string"===typeof t,n=(r||e)&&t.length;return r?n===w||n===d:e?n===2*w||n===2*d:t instanceof S}function Q(t){return $(t.length>l?t.slice(0,l):t)}function tt(t){const r=Q(t),e=K(r,f.n);return rt(e<i?r:e)}function rt(t){return T(t)}function et(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const i=N(t),o=L(e),s=[rt(o),tt(i)];if(null!=n){!0===n&&(n=r.utils.randomBytes(l));const t=N(n);if(t.length!==l)throw new Error(`sign: Expected ${l} bytes of extra data`);s.push(t)}return{seed:I(...s),m:Q(i),d:o}}function nt(t,r){const{sig:e,recovery:n}=t,{der:i,recovered:o}=Object.assign({canonical:!0,der:!0},r),s=i?e.toDERRawBytes():e.toCompactRawBytes();return o?[s,n]:s}r.getPublicKey=function(t,r=!1){return S.fromPrivateKey(t).toRawBytes(r)},r.recoverPublicKey=function(t,r,e,n=!1){return S.fromSignature(t,r,e).toRawBytes(n)},r.getSharedSecret=function(t,r,e=!1){if(J(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!J(r))throw new TypeError("getSharedSecret: second arg must be public key");const n=M(r);return n.assertValidity(),n.multiply(L(t)).toRawBytes(e)},r.sign=async function(t,r,e={}){const{seed:n,m:i,d:o}=et(t,r,e.extraEntropy),s=new W(32,y);let a;for(await s.reseed(n);!(a=G(await s.generate(),i,o,e.canonical));)await s.reseed();return nt(a,e)},r.signSync=function(t,r,e={}){const{seed:n,m:i,d:o}=et(t,r,e.extraEntropy),s=new W(32,y);let a;for(s.reseedSync(n);!(a=G(s.generateSync(),i,o,e.canonical));)s.reseedSync();return nt(a,e)};const it={strict:!0};function ot(t){return K($(t),f.n)}r.verify=function(t,r,e,n=it){let i;try{i=Y(t),r=N(r)}catch(d){return!1}const{r:o,s:s}=i;if(n.strict&&i.hasHighS())return!1;const a=D(r);let c;try{c=M(e)}catch(d){return!1}const{n:u}=f,h=_(s,u),l=K(a*h,u),y=K(o*h,u),w=S.BASE.multiplyAndAddUnsafe(c,l,y);return!!w&&K(w.x,u)===o};class st{constructor(t,r){this.r=t,this.s=r,this.assertValidity()}static fromHex(t){const r=N(t);if(64!==r.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${r.length}`);const e=$(r.subarray(0,32)),n=$(r.subarray(32,64));return new st(e,n)}assertValidity(){const{r:t,s:r}=this;if(!X(t)||!F(r))throw new Error("Invalid signature")}toHex(){return k(this.r)+k(this.s)}toRawBytes(){return O(this.toHex())}}class at{constructor(t,e,n=r.utils.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=N(t);const{x:i,scalar:o}=this.getScalar(L(e));if(this.px=i,this.d=o,this.rand=N(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const r=S.fromPrivateKey(t),e=r.hasEvenY()?t:f.n-t;return{point:r,scalar:e,x:r.toRawX()}}initNonce(t,r){return T(t^$(r))}finalizeNonce(t){const r=K($(t),f.n);if(r===i)throw new Error("sign: Creation of signature failed. k is zero");const{point:e,x:n,scalar:o}=this.getScalar(r);return{R:e,rx:n,k:o}}finalizeSig(t,r,e,n){return new st(t.x,K(r+e*n,f.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:e,px:n,rand:i}=this,o=r.utils.taggedHash,s=this.initNonce(e,await o(yt.aux,i)),{R:a,rx:c,k:f}=this.finalizeNonce(await o(yt.nonce,s,n,t)),u=ot(await o(yt.challenge,c,n,t)),h=this.finalizeSig(a,f,u,e);return await ut(h,t,n)||this.error(),h}calcSync(){const{m:t,d:e,px:n,rand:i}=this,o=r.utils.taggedHashSync,s=this.initNonce(e,o(yt.aux,i)),{R:a,rx:c,k:f}=this.finalizeNonce(o(yt.nonce,s,n,t)),u=ot(o(yt.challenge,c,n,t)),h=this.finalizeSig(a,f,u,e);return ht(h,t,n)||this.error(),h}}function ct(t,r,e){const n=t instanceof st,i=n?t:st.fromHex(t);return n&&i.assertValidity(),{...i,m:N(r),P:M(e)}}function ft(t,r,e,n){const i=S.BASE.multiplyAndAddUnsafe(r,L(e),K(-n,f.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function ut(t,e,n){try{const{r:i,s:o,m:s,P:a}=ct(t,e,n),c=ot(await r.utils.taggedHash(yt.challenge,T(i),a.toRawX(),s));return ft(i,a,o,c)}catch(i){return!1}}function ht(t,e,n){try{const{r:i,s:o,m:s,P:a}=ct(t,e,n),c=ot(r.utils.taggedHashSync(yt.challenge,T(i),a.toRawX(),s));return ft(i,a,o,c)}catch(i){if(i instanceof E)throw i;return!1}}r.schnorr={Signature:st,getPublicKey:function(t){return S.fromPrivateKey(t).toRawX()},sign:async function(t,r,e){return new at(t,r,e).calc()},verify:ut,signSync:function(t,r,e){return new at(t,r,e).calcSync()},verifySync:ht},S.BASE._setWindowSize(8);const lt={node:n,web:"object"===typeof self&&"crypto"in self?self.crypto:void 0},yt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},wt={};r.utils={bytesToHex:U,hexToBytes:O,concatBytes:I,mod:K,invert:_,isValidPrivateKey(t){try{return L(t),!0}catch(r){return!1}},_bigintTo32Bytes:T,_normalizePrivateKey:L,hashToPrivateKey:t=>{t=N(t);const r=y+8;if(t.length<r||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return T(K($(t),f.n-o)+o)},randomBytes:(t=32)=>{if(lt.web)return lt.web.getRandomValues(new Uint8Array(t));if(lt.node){const{randomBytes:r}=lt.node;return Uint8Array.from(r(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>r.utils.hashToPrivateKey(r.utils.randomBytes(y+8)),precompute(t=8,r=S.BASE){const e=r===S.BASE?r:new S(r.x,r.y);return e._setWindowSize(t),e.multiply(a),e},sha256:async(...t)=>{if(lt.web){const r=await lt.web.subtle.digest("SHA-256",I(...t));return new Uint8Array(r)}if(lt.node){const{createHash:r}=lt.node,e=r("sha256");return t.forEach((t=>e.update(t))),Uint8Array.from(e.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...r)=>{if(lt.web){const e=await lt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=I(...r),i=await lt.web.subtle.sign("HMAC",e,n);return new Uint8Array(i)}if(lt.node){const{createHmac:e}=lt.node,n=e("sha256",t);return r.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=wt[t];if(void 0===n){const e=await r.utils.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=I(e,e),wt[t]=n}return r.utils.sha256(n,...e)},taggedHashSync:(t,...r)=>{if("function"!==typeof q)throw new E("sha256Sync is undefined, you need to set it");let e=wt[t];if(void 0===e){const r=q(Uint8Array.from(t,(t=>t.charCodeAt(0))));e=I(r,r),wt[t]=e}return q(e,...r)},_JacobianPoint:x},Object.defineProperties(r.utils,{sha256Sync:{configurable:!1,get:()=>q,set(t){q||(q=t)}},hmacSha256Sync:{configurable:!1,get:()=>j,set(t){j||(j=t)}}})}}]);
//# sourceMappingURL=531.c87d8ffa.chunk.js.map