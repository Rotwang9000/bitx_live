{"version":3,"file":"static/js/868.9696c268.chunk.js","mappings":"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","sources":["../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/crypto.js","../node_modules/.pnpm/tiny-secp256k1@1.1.6/node_modules/tiny-secp256k1/rfc6979.js","../node_modules/.pnpm/tiny-secp256k1@1.1.6/node_modules/tiny-secp256k1/js.js","../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/bip32.js","../node_modules/.pnpm/bip32@2.0.6/node_modules/bip32/src/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/networks.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/script_number.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/types.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/script_signature.js","../node_modules/.pnpm/pushdata-bitcoin@1.0.1/node_modules/pushdata-bitcoin/index.js","../node_modules/.pnpm/bitcoin-ops@1.4.1/node_modules/bitcoin-ops/map.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/script.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/lazy.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/embed.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/p2ms.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/p2pk.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/crypto.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/p2pkh.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/p2sh.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/p2wsh.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/payments/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/address.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/ecpair.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/bufferutils.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/transaction.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/block.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/typeFields.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/global/globalXpub.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/global/unsignedTx.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/finalScriptSig.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/finalScriptWitness.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/partialSig.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/porCommitment.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/sighashType.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/tapKeySig.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/tapLeafScript.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/tapScriptSig.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/varint.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/tools.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/input/witnessUtxo.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/output/tapTree.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/shared/bip32Derivation.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/shared/checkPubkey.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/shared/redeemScript.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/shared/tapInternalKey.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/shared/witnessScript.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/converter/index.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/parser/fromBuffer.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/parser/toBuffer.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/parser/index.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/combiner/index.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/utils.js","../node_modules/.pnpm/bip174@2.1.0/node_modules/bip174/src/lib/psbt.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/psbt.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/multisig/input.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/multisig/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/multisig/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/nulldata.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/pubkey/input.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/pubkey/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/pubkey/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/scripthash/input.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/scripthash/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/scripthash/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/classify.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/transaction_builder.js","../node_modules/.pnpm/bitcoinjs-lib@5.2.0/node_modules/bitcoinjs-lib/src/index.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/bip32.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/buffertools.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/constants.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/hashPublicKey.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/accounttype.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkle.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/policy.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtv2.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtFinalizer.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/varint.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/serializeTransaction.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/BtcNew.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/psbtExtractor.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/getWalletPublicKey.js","../node_modules/.pnpm/invariant@2.2.4/node_modules/invariant/browser.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/getTrustedInput.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/startUntrustedHashTransactionInput.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/getTrustedInputBIP143.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/compressPublicKey.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/signTransaction.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/finalizeInput.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/getAppAndVersion.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/createTransaction.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/shouldUseTrustedInputForSegwit.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/signMessage.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/BtcOld.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkleMap.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/merkelizedPsbt.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/clientCommands.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/newops/appClient.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/signP2SHTransaction.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/Btc.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/splitTransaction.js","../node_modules/.pnpm/@ledgerhq+hw-app-btc@10.2.2/node_modules/@ledgerhq/hw-app-btc/lib-es/debug.js","../node_modules/.pnpm/@ledgerhq+logs@6.12.0/node_modules/@ledgerhq/logs/lib-es/index.js","../node_modules/.pnpm/bip32-path@0.4.2/node_modules/bip32-path/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require('create-hash');\nconst createHmac = require('create-hmac');\nfunction hash160(buffer) {\n    const sha256Hash = createHash('sha256')\n        .update(buffer)\n        .digest();\n    try {\n        return createHash('rmd160')\n            .update(sha256Hash)\n            .digest();\n    }\n    catch (err) {\n        return createHash('ripemd160')\n            .update(sha256Hash)\n            .digest();\n    }\n}\nexports.hash160 = hash160;\nfunction hmacSHA512(key, data) {\n    return createHmac('sha512', key)\n        .update(data)\n        .digest();\n}\nexports.hmacSHA512 = hmacSHA512;\n","const createHmac = require('create-hmac')\n\nconst ONE1 = Buffer.alloc(1, 1)\nconst ZERO1 = Buffer.alloc(1, 0)\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0)\n  let v = Buffer.alloc(32, 1)\n\n  // Step D\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ZERO1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step F\n  k = createHmac('sha256', k)\n    .update(v)\n    .update(ONE1)\n    .update(x)\n    .update(hash)\n    .update(extraEntropy || '')\n    .digest()\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest()\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest()\n\n  let T = v\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k)\n      .update(v)\n      .update(ZERO1)\n      .digest()\n\n    v = createHmac('sha256', k).update(v).digest()\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest()\n    T = v\n  }\n\n  return T\n}\n\nmodule.exports = deterministicGenerateK\n","const BN = require('bn.js')\nconst EC = require('elliptic').ec\nconst secp256k1 = new EC('secp256k1')\nconst deterministicGenerateK = require('./rfc6979')\n\nconst ZERO32 = Buffer.alloc(32, 0)\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')\nconst EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')\n\nconst n = secp256k1.curve.n\nconst nDiv2 = n.shrn(1)\nconst G = secp256k1.curve.g\n\nconst THROW_BAD_PRIVATE = 'Expected Private'\nconst THROW_BAD_POINT = 'Expected Point'\nconst THROW_BAD_TWEAK = 'Expected Tweak'\nconst THROW_BAD_HASH = 'Expected Hash'\nconst THROW_BAD_SIGNATURE = 'Expected Signature'\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'\n\nfunction isScalar (x) {\n  return Buffer.isBuffer(x) && x.length === 32\n}\n\nfunction isOrderScalar (x) {\n  if (!isScalar(x)) return false\n  return x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isPoint (p) {\n  if (!Buffer.isBuffer(p)) return false\n  if (p.length < 33) return false\n\n  const t = p[0]\n  const x = p.slice(1, 33)\n  if (x.compare(ZERO32) === 0) return false\n  if (x.compare(EC_P) >= 0) return false\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary\n    return true\n  }\n\n  const y = p.slice(33)\n  if (y.compare(ZERO32) === 0) return false\n  if (y.compare(EC_P) >= 0) return false\n  if (t === 0x04 && p.length === 65) return true\n  return false\n}\n\nfunction __isPointCompressed (p) {\n  return p[0] !== 0x04\n}\n\nfunction isPointCompressed (p) {\n  if (!isPoint(p)) return false\n  return __isPointCompressed(p)\n}\n\nfunction isPrivate (x) {\n  if (!isScalar(x)) return false\n  return x.compare(ZERO32) > 0 && // > 0\n    x.compare(EC_GROUP_ORDER) < 0 // < G\n}\n\nfunction isSignature (value) {\n  const r = value.slice(0, 32)\n  const s = value.slice(32, 64)\n  return Buffer.isBuffer(value) && value.length === 64 &&\n    r.compare(EC_GROUP_ORDER) < 0 &&\n    s.compare(EC_GROUP_ORDER) < 0\n}\n\nfunction assumeCompression (value, pubkey) {\n  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)\n  if (value === undefined) return true\n  return value\n}\n\nfunction fromBuffer (d) { return new BN(d) }\nfunction toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }\nfunction decodeFrom (P) { return secp256k1.curve.decodePoint(P) }\nfunction getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }\n\nfunction pointAdd (pA, pB, __compressed) {\n  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)\n  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)\n\n  const a = decodeFrom(pA)\n  const b = decodeFrom(pB)\n  const pp = a.add(b)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed, pA)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointAddScalar (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)\n\n  const tt = fromBuffer(tweak)\n  const qq = G.mul(tt)\n  const uu = pp.add(qq)\n  if (uu.isInfinity()) return null\n\n  return getEncoded(uu, compressed)\n}\n\nfunction pointCompress (p, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n\n  const pp = decodeFrom(p)\n  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)\n\n  const compressed = assumeCompression(__compressed, p)\n\n  return getEncoded(pp, compressed)\n}\n\nfunction pointFromScalar (d, __compressed) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n\n  const dd = fromBuffer(d)\n  const pp = G.mul(dd)\n  if (pp.isInfinity()) return null\n\n  const compressed = assumeCompression(__compressed)\n  return getEncoded(pp, compressed)\n}\n\nfunction pointMultiply (p, tweak, __compressed) {\n  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const compressed = assumeCompression(__compressed, p)\n  const pp = decodeFrom(p)\n  const tt = fromBuffer(tweak)\n  const qq = pp.mul(tt)\n  if (qq.isInfinity()) return null\n\n  return getEncoded(qq, compressed)\n}\n\nfunction privateAdd (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.add(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction privateSub (d, tweak) {\n  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)\n\n  const dd = fromBuffer(d)\n  const tt = fromBuffer(tweak)\n  const dt = toBuffer(dd.sub(tt).umod(n))\n  if (!isPrivate(dt)) return null\n\n  return dt\n}\n\nfunction sign (hash, x) {\n  return __sign(hash, x)\n}\n\nfunction signWithEntropy (hash, x, addData) {\n  return __sign(hash, x, addData)\n}\n\nfunction __sign (hash, x, addData) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)\n  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)\n\n  const d = fromBuffer(x)\n  const e = fromBuffer(hash)\n\n  let r, s\n  const checkSig = function (k) {\n    const kI = fromBuffer(k)\n    const Q = G.mul(kI)\n\n    if (Q.isInfinity()) return false\n\n    r = Q.x.umod(n)\n    if (r.isZero() === 0) return false\n\n    s = kI\n      .invm(n)\n      .mul(e.add(d.mul(r)))\n      .umod(n)\n    if (s.isZero() === 0) return false\n\n    return true\n  }\n\n  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)\n\n  // enforce low S values, see bip62: 'low s values in signatures'\n  if (s.cmp(nDiv2) > 0) {\n    s = n.sub(s)\n  }\n\n  const buffer = Buffer.allocUnsafe(64)\n  toBuffer(r).copy(buffer, 0)\n  toBuffer(s).copy(buffer, 32)\n  return buffer\n}\n\nfunction verify (hash, q, signature, strict) {\n  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)\n  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')\n  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)\n\n  const Q = decodeFrom(q)\n  const r = fromBuffer(signature.slice(0, 32))\n  const s = fromBuffer(signature.slice(32, 64))\n\n  if (strict && s.cmp(nDiv2) > 0) {\n    return false\n  }\n\n  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')\n  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false\n  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false\n\n  // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n  const e = fromBuffer(hash)\n\n  // Compute s^-1\n  const sInv = s.invm(n)\n\n  // 1.4.4 Compute u1 = es^1 mod n\n  //               u2 = rs^1 mod n\n  const u1 = e.mul(sInv).umod(n)\n  const u2 = r.mul(sInv).umod(n)\n\n  // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n  const R = G.mulAdd(u1, Q, u2)\n\n  // 1.4.5 (cont.) Enforce R is not at infinity\n  if (R.isInfinity()) return false\n\n  // 1.4.6 Convert the field element R.x to an integer\n  const xR = R.x\n\n  // 1.4.7 Set v = xR mod n\n  const v = xR.umod(n)\n\n  // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n  return v.eq(r)\n}\n\nmodule.exports = {\n  isPoint,\n  isPointCompressed,\n  isPrivate,\n  pointAdd,\n  pointAddScalar,\n  pointCompress,\n  pointFromScalar,\n  pointMultiply,\n  privateAdd,\n  privateSub,\n  sign,\n  signWithEntropy,\n  verify\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bip32_1 = require(\"./bip32\");\nexports.fromSeed = bip32_1.fromSeed;\nexports.fromBase58 = bip32_1.fromBase58;\nexports.fromPublicKey = bip32_1.fromPublicKey;\nexports.fromPrivateKey = bip32_1.fromPrivateKey;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.bitcoin = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeforce = require('typeforce');\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nexports.UInt31 = UInt31;\nfunction BIP32Path(value) {\n  return typeforce.String(value) && !!value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\nexports.BIP32Path = BIP32Path;\nBIP32Path.toJSON = () => {\n  return 'BIP32 derivation path';\n};\nfunction Signer(obj) {\n  return (\n    (typeforce.Buffer(obj.publicKey) ||\n      typeof obj.getPublicKey === 'function') &&\n    typeof obj.sign === 'function'\n  );\n}\nexports.Signer = Signer;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\n// external dependent types\nexports.ECPoint = typeforce.quacksLike('Point');\n// exposed, external API\nexports.Network = typeforce.compile({\n  messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32,\n  },\n  pubKeyHash: typeforce.UInt8,\n  scriptHash: typeforce.UInt8,\n  wif: typeforce.UInt8,\n});\nexports.Buffer256bit = typeforce.BufferN(32);\nexports.Hash160bit = typeforce.BufferN(20);\nexports.Hash256bit = typeforce.BufferN(32);\nexports.Number = typeforce.Number; // tslint:disable-line variable-name\nexports.Array = typeforce.Array;\nexports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name\nexports.String = typeforce.String; // tslint:disable-line variable-name\nexports.Buffer = typeforce.Buffer;\nexports.Hex = typeforce.Hex;\nexports.maybe = typeforce.maybe;\nexports.tuple = typeforce.tuple;\nexports.UInt8 = typeforce.UInt8;\nexports.UInt32 = typeforce.UInt32;\nexports.Function = typeforce.Function;\nexports.BufferN = typeforce.BufferN;\nexports.Null = typeforce.Null;\nexports.oneOf = typeforce.oneOf;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst typeforce = require('typeforce');\nconst ZERO = Buffer.alloc(1, 0);\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n","var OPS = require('bitcoin-ops')\n\nfunction encodingLength (i) {\n  return i < OPS.OP_PUSHDATA1 ? 1\n  : i <= 0xff ? 2\n  : i <= 0xffff ? 3\n  : 5\n}\n\nfunction encode (buffer, number, offset) {\n  var size = encodingLength(number)\n\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(number, offset)\n\n  // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)\n    buffer.writeUInt8(number, offset + 1)\n\n  // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n\n  // 32 bit\n  } else {\n    buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n  }\n\n  return size\n}\n\nfunction decode (buffer, offset) {\n  var opcode = buffer.readUInt8(offset)\n  var number, size\n\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    number = opcode\n    size = 1\n\n  // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null\n    number = buffer.readUInt8(offset + 1)\n    size = 2\n\n  // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null\n    number = buffer.readUInt16LE(offset + 1)\n    size = 3\n\n  // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')\n\n    number = buffer.readUInt32LE(offset + 1)\n    size = 5\n  }\n\n  return {\n    opcode: opcode,\n    number: number,\n    size: size\n  }\n}\n\nmodule.exports = {\n  encodingLength: encodingLength,\n  encode: encode,\n  decode: decode\n}\n","var OPS = require('./index.json')\n\nvar map = {}\nfor (var op in OPS) {\n  var code = OPS[op]\n  map[code] = op\n}\n\nmodule.exports = map\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst ecc = require('tiny-secp256k1');\nconst pushdata = require('pushdata-bitcoin');\nconst typeforce = require('typeforce');\nexports.OPS = require('bitcoin-ops');\nconst REVERSE_OPS = require('bitcoin-ops/map');\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === exports.OPS.OP_0 ||\n      (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||\n      value === exports.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\n// tslint:disable-next-line variable-name\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// output: OP_RETURN ...\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      data: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst typef = require('typeforce');\nconst ecc = require('tiny-secp256k1');\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      m: typef.maybe(typef.Number),\n      n: typef.maybe(typef.Number),\n      output: typef.maybe(typef.Buffer),\n      pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),\n      signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid');\n      if (!typef.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => ecc.isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!ecc.isPoint(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst createHash = require('create-hash');\nfunction ripemd160(buffer) {\n  try {\n    return createHash('rmd160')\n      .update(buffer)\n      .digest();\n  } catch (err) {\n    return createHash('ripemd160')\n      .update(buffer)\n      .digest();\n  }\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return createHash('sha1')\n    .update(buffer)\n    .digest();\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return createHash('sha256')\n    .update(buffer)\n    .digest();\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexports.hash256 = hash256;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bs58check = require('bs58check');\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(25)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!ecc.isPoint(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst bs58check = require('bs58check');\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(23)),\n      redeem: typef.maybe({\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        input: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    return {\n      network,\n      output: chunks[chunks.length - 1],\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      input: typef.maybe(typef.BufferN(0)),\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.BufferN(22)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    ecc.isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(32)),\n      output: typef.maybe(typef.BufferN(34)),\n      redeem: typef.maybe({\n        input: typef.maybe(typef.Buffer),\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.BufferN(0)),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty?\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst embed_1 = require('./embed');\nexports.embed = embed_1.p2data;\nconst p2ms_1 = require('./p2ms');\nexports.p2ms = p2ms_1.p2ms;\nconst p2pk_1 = require('./p2pk');\nexports.p2pk = p2pk_1.p2pk;\nconst p2pkh_1 = require('./p2pkh');\nexports.p2pkh = p2pkh_1.p2pkh;\nconst p2sh_1 = require('./p2sh');\nexports.p2sh = p2sh_1.p2sh;\nconst p2wpkh_1 = require('./p2wpkh');\nexports.p2wpkh = p2wpkh_1.p2wpkh;\nconst p2wsh_1 = require('./p2wsh');\nexports.p2wsh = p2wsh_1.p2wsh;\n// TODO\n// witness commitment\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types = require('./types');\nconst bech32 = require('bech32');\nconst bs58check = require('bs58check');\nconst typeforce = require('typeforce');\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst NETWORKS = require('./networks');\nconst types = require('./types');\nconst ecc = require('tiny-secp256k1');\nconst randomBytes = require('randombytes');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst isOptions = typeforce.maybe(\n  typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed =\n      options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer))\n    throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version;\n  // list of networks?\n  if (types.Array(network)) {\n    network = network\n      .filter(x => {\n        return version === x.wif;\n      })\n      .pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network,\n  });\n}\nexports.fromWIF = fromWIF;\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n  return fromPrivateKey(d, options);\n}\nexports.makeRandom = makeRandom;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_SCRIPT,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));\nexports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nvar InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));\nexports.INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nvar OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));\nexports.OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst range = n => [...Array(n).keys()];\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = keyVal.value.readUInt32LE(i * 4 + 4);\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n  const key = Buffer.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = Buffer.allocUnsafe(splitPath.length * 4);\n  data.masterFingerprint.copy(value, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    value.writeUInt32LE(num, offset);\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\nfunction check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    Buffer.isBuffer(epk) &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    Buffer.isBuffer(mfp) &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.extendedPubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.signature) &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.toString('utf8');\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: Buffer.from(data, 'utf8'),\n  };\n}\nexports.encode = encode;\nexports.expected = 'string';\nfunction check(data) {\n  return typeof data === 'string';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n  return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexports.decode = decode;\nfunction encode(tScript) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Buffer.from([tScript.leafVersion]);\n  return {\n    key: Buffer.concat([head, tScript.controlBlock]),\n    value: Buffer.concat([tScript.script, verBuf]),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.controlBlock) &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    Buffer.isBuffer(data.script)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.controlBlock.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && data.length === 32;\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(tSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.leafHash) &&\n    Buffer.isBuffer(data.signature) &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString =\n    item.pubkey.toString('hex') + item.leafHash.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),\n    ).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// Number.MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n    throw new RangeError('value out of range');\n}\nfunction encode(_number, buffer, offset) {\n  checkUInt53(_number);\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  // 8 bit\n  if (_number < 0xfd) {\n    buffer.writeUInt8(_number, offset);\n    Object.assign(encode, { bytes: 1 });\n    // 16 bit\n  } else if (_number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset);\n    buffer.writeUInt16LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 3 });\n    // 32 bit\n  } else if (_number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset);\n    buffer.writeUInt32LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 5 });\n    // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset);\n    buffer.writeUInt32LE(_number >>> 0, offset + 1);\n    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);\n    Object.assign(encode, { bytes: 9 });\n  }\n  return buffer;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  const first = buffer.readUInt8(offset);\n  // 8 bit\n  if (first < 0xfd) {\n    Object.assign(decode, { bytes: 1 });\n    return first;\n    // 16 bit\n  } else if (first === 0xfd) {\n    Object.assign(decode, { bytes: 3 });\n    return buffer.readUInt16LE(offset + 1);\n    // 32 bit\n  } else if (first === 0xfe) {\n    Object.assign(decode, { bytes: 5 });\n    return buffer.readUInt32LE(offset + 1);\n    // 64 bit\n  } else {\n    Object.assign(decode, { bytes: 9 });\n    const lo = buffer.readUInt32LE(offset + 1);\n    const hi = buffer.readUInt32LE(offset + 5);\n    const _number = hi * 0x0100000000 + lo;\n    checkUInt53(_number);\n    return _number;\n  }\n}\nexports.decode = decode;\nfunction encodingLength(_number) {\n  checkUInt53(_number);\n  return _number < 0xfd\n    ? 1\n    : _number <= 0xffff\n    ? 3\n    : _number <= 0xffffffff\n    ? 5\n    : 9;\n}\nexports.encodingLength = encodingLength;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('./varint');\nexports.range = n => [...Array(n).keys()];\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(\n    keyVarIntLen + keyLen + valVarIntLen + valLen,\n  );\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst tools_1 = require('../tools');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexports.decode = decode;\nfunction encode(data) {\n  const { script, value } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const scriptLen = varuint.decode(keyVal.value, _offset);\n    _offset += varuint.encodingLength(scriptLen);\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexports.decode = decode;\nfunction encode(tree) {\n  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(tapLeaf.script.length),\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: Buffer.concat(bufs),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';\nfunction check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        Buffer.isBuffer(tapLeaf.script),\n    )\n  );\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\nexports.canAdd = canAdd;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\nexports.makeChecker = makeChecker;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('../varint');\nconst bip32Derivation = require('./bip32Derivation');\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nfunction makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const nHashes = varuint.decode(keyVal.value);\n    const nHashesLen = varuint.encodingLength(nHashes);\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + nHashes * 32),\n    });\n    const leafHashes = new Array(nHashes);\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return Object.assign({}, base, { leafHashes });\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return Object.assign({}, base, { value });\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Buffer; ' +\n    'pubkey: Buffer; ' +\n    'path: string; ' +\n    'leafHashes: Buffer[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data) && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../typeFields');\nconst globalXpub = require('./global/globalXpub');\nconst unsignedTx = require('./global/unsignedTx');\nconst finalScriptSig = require('./input/finalScriptSig');\nconst finalScriptWitness = require('./input/finalScriptWitness');\nconst nonWitnessUtxo = require('./input/nonWitnessUtxo');\nconst partialSig = require('./input/partialSig');\nconst porCommitment = require('./input/porCommitment');\nconst sighashType = require('./input/sighashType');\nconst tapKeySig = require('./input/tapKeySig');\nconst tapLeafScript = require('./input/tapLeafScript');\nconst tapMerkleRoot = require('./input/tapMerkleRoot');\nconst tapScriptSig = require('./input/tapScriptSig');\nconst witnessUtxo = require('./input/witnessUtxo');\nconst tapTree = require('./output/tapTree');\nconst bip32Derivation = require('./shared/bip32Derivation');\nconst checkPubkey = require('./shared/checkPubkey');\nconst redeemScript = require('./shared/redeemScript');\nconst tapBip32Derivation = require('./shared/tapBip32Derivation');\nconst tapInternalKey = require('./shared/tapInternalKey');\nconst witnessScript = require('./shared/witnessScript');\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nexports.globals = globals;\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.InputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.InputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.InputTypes.PARTIAL_SIG,\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n  ),\n  tapMerkleRoot,\n};\nexports.inputs = inputs;\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.OutputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.OutputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n  ),\n};\nexports.outputs = outputs;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n","'use strict';\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, '__esModule', { value: true });\n__export(require('./fromBuffer'));\n__export(require('./toBuffer'));\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst parser_1 = require('../parser');\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst converter = require('./converter');\nfunction checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexports.checkForInput = checkForInput;\nfunction checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexports.checkForOutput = checkForOutput;\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);\n  }\n}\nexports.checkHasKey = checkHasKey;\nfunction getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexports.getEnumLength = getEnumLength;\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\nfunction addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  exports.updateInput(data, input);\n}\nexports.addInputAttributes = addInputAttributes;\nfunction addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  exports.updateOutput(data, output);\n}\nexports.addOutputAttributes = addOutputAttributes;\nfunction defaultVersionSetter(version, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(version, 0);\n  return txBuf;\n}\nexports.defaultVersionSetter = defaultVersionSetter;\nfunction defaultLocktimeSetter(locktime, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n  return txBuf;\n}\nexports.defaultLocktimeSetter = defaultLocktimeSetter;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst combiner_1 = require('./combiner');\nconst parser_1 = require('./parser');\nconst typeFields_1 = require('./typeFields');\nconst utils_1 = require('./utils');\nclass Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return buffer.toString('base64');\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return buffer.toString('hex');\n  }\n  toBuffer() {\n    return parser_1.psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    utils_1.updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    utils_1.checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      input.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.InputTypes),\n    );\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      output.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.OutputTypes),\n    );\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    utils_1.addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(outputIndex, keyVal),\n    );\n    utils_1.addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combiner_1.combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexports.Psbt = Psbt;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Old TransactionBuilder behavior was to not confirm input values\n      // before signing. Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n      });\n    });\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nconst isP2SHScript = isPaymentFactory(payments.p2sh);\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })\n      .output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          'to trick you into paying large fees. This behavior is the same as the old ' +\n          'TransactionBuilder class when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return input.witnessUtxo.script;\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction pubkeyInScript(pubkey, script) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n","'use strict';\n// OP_0 [signatures ...]\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction partialSignature(value) {\n  return (\n    value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value)\n  );\n}\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 2) return false;\n  if (chunks[0] !== script_1.OPS.OP_0) return false;\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature);\n  }\n  return chunks.slice(1).every(bscript.isCanonicalScriptSignature);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multisig input';\n};\n","'use strict';\n// m [pubKeys ...] n OP_CHECKMULTISIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 4) return false;\n  if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;\n  if (!types.Number(chunks[0])) return false;\n  if (!types.Number(chunks[chunks.length - 2])) return false;\n  const m = chunks[0] - OP_INT_BASE;\n  const n = chunks[chunks.length - 2] - OP_INT_BASE;\n  if (m <= 0) return false;\n  if (n > 16) return false;\n  if (m > n) return false;\n  if (n !== chunks.length - 3) return false;\n  if (allowIncomplete) return true;\n  const keys = chunks.slice(1, -2);\n  return keys.every(bscript.isCanonicalPubKey);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multi-sig output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// OP_RETURN {data}\nconst bscript = require('../script');\nconst OPS = bscript.OPS;\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'null data output';\n};\nconst output = { check };\nexports.output = output;\n","'use strict';\n// {signature}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey input';\n};\n","'use strict';\n// {pubKey} OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalPubKey(chunks[0]) &&\n    chunks[1] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    bscript.isCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash input';\n};\n","'use strict';\n// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 25 &&\n    buffer[0] === script_1.OPS.OP_DUP &&\n    buffer[1] === script_1.OPS.OP_HASH160 &&\n    buffer[2] === 0x14 &&\n    buffer[23] === script_1.OPS.OP_EQUALVERIFY &&\n    buffer[24] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_0 {pubKeyHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 22 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x14\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness pubKeyHash output';\n};\n","'use strict';\n// OP_0 {scriptHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 34 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x20\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness scriptHash output';\n};\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nconst p2wpkho = require('../witnesspubkeyhash/output');\nconst p2wsho = require('../witnessscripthash/output');\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 1) return false;\n  const lastChunk = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(lastChunk)) return false;\n  const scriptSigChunks = bscript.decompile(\n    bscript.compile(chunks.slice(0, -1)),\n  );\n  const redeemScriptChunks = bscript.decompile(lastChunk);\n  // is redeemScript a valid script?\n  if (!redeemScriptChunks) return false;\n  // is redeemScriptSig push only?\n  if (!bscript.isPushOnly(scriptSigChunks)) return false;\n  // is witness?\n  if (chunks.length === 1) {\n    return (\n      p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks)\n    );\n  }\n  // match types\n  if (\n    p2pkh.input.check(scriptSigChunks) &&\n    p2pkh.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(scriptSigChunks, allowIncomplete) &&\n    p2ms.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(scriptSigChunks) &&\n    p2pk.output.check(redeemScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash input';\n};\n","'use strict';\n// OP_HASH160 {scriptHash} OP_EQUAL\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 23 &&\n    buffer[0] === script_1.OPS.OP_HASH160 &&\n    buffer[1] === 0x14 &&\n    buffer[22] === script_1.OPS.OP_EQUAL\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_RETURN {aa21a9ed} {commitment}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst typeforce = require('typeforce');\nconst HEADER = Buffer.from('aa21a9ed', 'hex');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length > 37 &&\n    buffer[0] === script_1.OPS.OP_RETURN &&\n    buffer[1] === 0x24 &&\n    buffer.slice(2, 6).equals(HEADER)\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness commitment output';\n};\nfunction encode(commitment) {\n  typeforce(types.Hash256bit, commitment);\n  const buffer = Buffer.allocUnsafe(36);\n  HEADER.copy(buffer, 0);\n  commitment.copy(buffer, 4);\n  return bscript.compile([script_1.OPS.OP_RETURN, buffer]);\n}\nexports.encode = encode;\nfunction decode(buffer) {\n  typeforce(check, buffer);\n  return bscript.decompile(buffer)[1].slice(4, 36);\n}\nexports.decode = decode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction isCompressedCanonicalPubKey(pubKey) {\n  return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;\n}\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    isCompressedCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessPubKeyHash input';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst typeforce = require('typeforce');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nfunction check(chunks, allowIncomplete) {\n  typeforce(typeforce.Array, chunks);\n  if (chunks.length < 1) return false;\n  const witnessScript = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(witnessScript)) return false;\n  const witnessScriptChunks = bscript.decompile(witnessScript);\n  // is witnessScript a valid script?\n  if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;\n  const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));\n  // match types\n  if (\n    p2pkh.input.check(witnessRawScriptSig) &&\n    p2pkh.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&\n    p2ms.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(witnessRawScriptSig) &&\n    p2pk.output.check(witnessScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessScriptHash input';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst script_1 = require('./script');\nconst multisig = require('./templates/multisig');\nconst nullData = require('./templates/nulldata');\nconst pubKey = require('./templates/pubkey');\nconst pubKeyHash = require('./templates/pubkeyhash');\nconst scriptHash = require('./templates/scripthash');\nconst witnessCommitment = require('./templates/witnesscommitment');\nconst witnessPubKeyHash = require('./templates/witnesspubkeyhash');\nconst witnessScriptHash = require('./templates/witnessscripthash');\nconst types = {\n  P2MS: 'multisig',\n  NONSTANDARD: 'nonstandard',\n  NULLDATA: 'nulldata',\n  P2PK: 'pubkey',\n  P2PKH: 'pubkeyhash',\n  P2SH: 'scripthash',\n  P2WPKH: 'witnesspubkeyhash',\n  P2WSH: 'witnessscripthash',\n  WITNESS_COMMITMENT: 'witnesscommitment',\n};\nexports.types = types;\nfunction classifyOutput(script) {\n  if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;\n  if (witnessScriptHash.output.check(script)) return types.P2WSH;\n  if (pubKeyHash.output.check(script)) return types.P2PKH;\n  if (scriptHash.output.check(script)) return types.P2SH;\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (multisig.output.check(chunks)) return types.P2MS;\n  if (pubKey.output.check(chunks)) return types.P2PK;\n  if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;\n  if (nullData.output.check(chunks)) return types.NULLDATA;\n  return types.NONSTANDARD;\n}\nexports.output = classifyOutput;\nfunction classifyInput(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (pubKeyHash.input.check(chunks)) return types.P2PKH;\n  if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;\n  if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;\n  if (pubKey.input.check(chunks)) return types.P2PK;\n  return types.NONSTANDARD;\n}\nexports.input = classifyInput;\nfunction classifyWitness(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;\n  if (witnessScriptHash.input.check(chunks, allowIncomplete))\n    return types.P2WSH;\n  return types.NONSTANDARD;\n}\nexports.witness = classifyWitness;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst baddress = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst classify = require('./classify');\nconst bcrypto = require('./crypto');\nconst ECPair = require('./ecpair');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([\n  // Raw\n  'p2pkh',\n  'p2pk',\n  'p2wpkh',\n  'p2ms',\n  // P2SH wrapped\n  'p2sh-p2pkh',\n  'p2sh-p2pk',\n  'p2sh-p2wpkh',\n  'p2sh-p2ms',\n  // P2WSH wrapped\n  'p2wsh-p2pkh',\n  'p2wsh-p2pk',\n  'p2wsh-p2ms',\n  // P2SH-P2WSH wrapper\n  'p2sh-p2wsh-p2pkh',\n  'p2sh-p2wsh-p2pk',\n  'p2sh-p2wsh-p2ms',\n]);\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn(\n      'Deprecation Warning: TransactionBuilder will be removed in the future. ' +\n        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +\n        'are available in the transactions-psbt.js integration test file on our ' +\n        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +\n        'files as well.',\n    );\n  }\n  static fromTransaction(transaction, network) {\n    const txb = new TransactionBuilder(network);\n    // Copy transaction fields\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime);\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n      });\n    });\n    // fix some things not possible through the public API\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i);\n    });\n    return txb;\n  }\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n    if (setting === undefined) {\n      setting = true;\n    }\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(s => s !== undefined);\n      })\n    ) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    this.__TX.locktime = locktime;\n  }\n  setVersion(version) {\n    typeforce(types.UInt32, version);\n    // XXX: this might eventually become more complex depending on what the versions represent\n    this.__TX.version = version;\n  }\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    let value;\n    // is it a hex string?\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));\n      // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value,\n    });\n  }\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 or bech32 address string\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n  build() {\n    return this.__build(false);\n  }\n  buildIncomplete() {\n    return this.__build(true);\n  }\n  sign(\n    signParams,\n    keyPair,\n    redeemScript,\n    hashType,\n    witnessValue,\n    witnessScript,\n  ) {\n    trySign(\n      getSigningData(\n        this.network,\n        this.__INPUTS,\n        this.__needsOutputs.bind(this),\n        this.__TX,\n        signParams,\n        keyPair,\n        redeemScript,\n        hashType,\n        witnessValue,\n        witnessScript,\n        this.__USE_LOW_R,\n      ),\n    );\n  }\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined)\n      throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n      input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n        prevOutType = expanded.type;\n      }\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n    const vin = this.__TX.addInput(\n      txHash,\n      vout,\n      options.sequence,\n      options.scriptSig,\n    );\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n    const tx = this.__TX.clone();\n    // create script signatures from inputs\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete)\n        throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)\n          throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n    return tx;\n  }\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n        return (\n          (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0\n        );\n      });\n    });\n  }\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    }\n    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n    return (\n      this.__TX.outs.length === 0 &&\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(signature => {\n          if (!signature) return false; // no signature, no issue\n          const hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n          return true; // SIGHASH_* does care\n        });\n      })\n    );\n  }\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n        return false;\n      });\n    });\n  }\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n}\nexports.TransactionBuilder = TransactionBuilder;\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({\n        witness: witnessStack,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({\n        input: scriptSig,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig });\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms(\n        {\n          input: scriptSig,\n          output: scriptPubKey,\n        },\n        { allowIncomplete: true },\n      );\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys,\n        signatures,\n        maxSignatures: m,\n      };\n    }\n  }\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(\n      redeem.input,\n      redeem.witness,\n      outputType,\n      redeem.output,\n    );\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(\n        bscript.compile(redeem.witness),\n        [],\n        outputType,\n        redeem.output,\n      );\n    }\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig,\n  };\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)\n    return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match;\n    // check for a signature\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature);\n      const hash = transaction.hashForSignature(\n        vin,\n        input.redeemScript,\n        parsed.hashType,\n      );\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash;\n      const pkh2 = bcrypto.hash160(ourPubKey);\n      if (!pkh1.equals(pkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash;\n      const wpkh2 = bcrypto.hash160(ourPubKey);\n      if (!wpkh1.equals(wpkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script });\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script });\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m,\n      };\n    }\n  }\n  return { type };\n}\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: witnessScript },\n    });\n    const p2wshAlt = payments.p2wsh({ output: redeemScript });\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    const p2shAlt = payments.p2sh({ redeem: p2wsh });\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash))\n      throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash))\n      throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    if (input.prevOutScript) {\n      let p2shAlt;\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n      if (!p2sh.hash.equals(p2shAlt.hash))\n        throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as redeemScript (' +\n          bscript.toASM(redeemScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = redeemScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });\n      if (!p2wsh.hash.equals(p2wshAlt.hash))\n        throw new Error('Witness script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',\n      );\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',\n      );\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported (' +\n          bscript.toASM(input.prevOutScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = input.prevOutScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined],\n  };\n}\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pk({ signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures;\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || script_1.OPS.OP_0);\n      } else {\n        signatures = signatures.filter(x => x);\n      }\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || m === signatures.length;\n      return payments.p2ms(\n        { m, pubkeys, signatures },\n        { allowIncomplete, validate },\n      );\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n  }\n}\nfunction canSign(input) {\n  return (\n    input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (input.hasWitness === false || input.value !== undefined)\n  );\n}\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\n      `Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`,\n    );\n  }\n  tfMessage(\n    typeforce.Number,\n    signParams.vin,\n    `sign must include vin parameter as Number (input index)`,\n  );\n  tfMessage(\n    types.Signer,\n    signParams.keyPair,\n    `sign must include keyPair parameter as Signer interface`,\n  );\n  tfMessage(\n    typeforce.maybe(typeforce.Number),\n    signParams.hashType,\n    `sign hashType parameter must be a number`,\n  );\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessScript`,\n      );\n      break;\n  }\n}\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR,\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error(\n        'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',\n      );\n    }\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\nfunction getSigningData(\n  network,\n  inputs,\n  needsOutputs,\n  tx,\n  signParams,\n  keyPair,\n  redeemScript,\n  hashType,\n  witnessValue,\n  witnessScript,\n  useLowR,\n) {\n  let vin;\n  if (typeof signParams === 'number') {\n    console.warn(\n      'DEPRECATED: TransactionBuilder sign method arguments ' +\n        'will change in v6, please use the TxbSignArg interface',\n    );\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript,\n    } = signParams);\n  } else {\n    throw new TypeError(\n      'TransactionBuilder sign first arg must be TxbSignArg or number',\n    );\n  }\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  }\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== network)\n    throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (\n    input.redeemScript !== undefined &&\n    redeemScript &&\n    !input.redeemScript.equals(redeemScript)\n  ) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  const ourPubKey =\n    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue)\n        throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    if (!canSign(input)) {\n      const prepared = prepareInput(\n        input,\n        ourPubKey,\n        redeemScript,\n        witnessScript,\n      );\n      // updates inline\n      Object.assign(input, prepared);\n    }\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  let signatureHash;\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n    );\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR,\n  };\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip32 = require('bip32');\nexports.bip32 = bip32;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst ECPair = require('./ecpair');\nexports.ECPair = ECPair;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nexports.Block = block_1.Block;\nvar psbt_1 = require('./psbt');\nexports.Psbt = psbt_1.Psbt;\nvar script_1 = require('./script');\nexports.opcodes = script_1.OPS;\nvar transaction_1 = require('./transaction');\nexports.Transaction = transaction_1.Transaction;\nvar transaction_builder_1 = require('./transaction_builder');\nexports.TransactionBuilder = transaction_builder_1.TransactionBuilder;\n","/**\n * @file bip32.ts\n * @description BIP32 Path Handling for Bitcoin Wallets\n *\n * This file provides utility functions to handle BIP32 paths,\n * which are commonly used in hierarchical deterministic (HD) wallets.\n * It includes functions to convert BIP32 paths to and from different formats,\n * extract components from extended public keys (xpubs), and manipulate path elements.\n */\nimport bippath from \"bip32-path\";\nimport bs58check from \"bs58check\";\nexport function pathElementsToBuffer(paths) {\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return buffer;\n}\nexport function bip32asBuffer(path) {\n    const pathElements = !path ? [] : pathStringToArray(path);\n    return pathElementsToBuffer(pathElements);\n}\nexport function pathArrayToString(pathElements) {\n    // Limitation: bippath can't handle and empty path. It shouldn't affect us\n    // right now, but might in the future.\n    // TODO: Fix support for empty path.\n    return bippath.fromPathArray(pathElements).toString();\n}\nexport function pathStringToArray(path) {\n    return bippath.fromString(path).toPathArray();\n}\nexport function pubkeyFromXpub(xpub) {\n    const xpubBuf = bs58check.decode(xpub);\n    return xpubBuf.slice(xpubBuf.length - 33);\n}\nexport function getXpubComponents(xpub) {\n    const xpubBuf = bs58check.decode(xpub);\n    return {\n        chaincode: xpubBuf.slice(13, 13 + 32),\n        pubkey: xpubBuf.slice(xpubBuf.length - 33),\n        version: xpubBuf.readUInt32BE(0),\n    };\n}\nexport function hardenedPathOf(pathElements) {\n    for (let i = pathElements.length - 1; i >= 0; i--) {\n        if (pathElements[i] >= 0x80000000) {\n            return pathElements.slice(0, i + 1);\n        }\n    }\n    return [];\n}\n//# sourceMappingURL=bip32.js.map","import varuint from \"varuint-bitcoin\";\nexport function unsafeTo64bitLE(n) {\n    // we want to represent the input as a 8-bytes array\n    if (n > Number.MAX_SAFE_INTEGER) {\n        throw new Error(\"Can't convert numbers > MAX_SAFE_INT\");\n    }\n    const byteArray = Buffer.alloc(8, 0);\n    for (let index = 0; index < byteArray.length; index++) {\n        const byte = n & 0xff;\n        byteArray[index] = byte;\n        n = (n - byte) / 256;\n    }\n    return byteArray;\n}\nexport function unsafeFrom64bitLE(byteArray) {\n    let value = 0;\n    if (byteArray.length != 8) {\n        throw new Error(\"Expected Bufffer of lenght 8\");\n    }\n    if (byteArray[7] != 0) {\n        throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n    }\n    if (byteArray[6] > 0x1f) {\n        throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n    }\n    for (let i = byteArray.length - 1; i >= 0; i--) {\n        value = value * 256 + byteArray[i];\n    }\n    return value;\n}\nexport class BufferWriter {\n    constructor() {\n        this.bufs = [];\n    }\n    write(alloc, fn) {\n        const b = Buffer.alloc(alloc);\n        fn(b);\n        this.bufs.push(b);\n    }\n    writeUInt8(i) {\n        this.write(1, b => b.writeUInt8(i, 0));\n    }\n    writeInt32(i) {\n        this.write(4, b => b.writeInt32LE(i, 0));\n    }\n    writeUInt32(i) {\n        this.write(4, b => b.writeUInt32LE(i, 0));\n    }\n    writeUInt64(i) {\n        const bytes = unsafeTo64bitLE(i);\n        this.writeSlice(bytes);\n    }\n    writeVarInt(i) {\n        this.bufs.push(varuint.encode(i));\n    }\n    writeSlice(slice) {\n        this.bufs.push(Buffer.from(slice));\n    }\n    writeVarSlice(slice) {\n        this.writeVarInt(slice.length);\n        this.writeSlice(slice);\n    }\n    buffer() {\n        return Buffer.concat(this.bufs);\n    }\n}\nexport class BufferReader {\n    constructor(buffer, offset = 0) {\n        this.buffer = buffer;\n        this.offset = offset;\n    }\n    available() {\n        return this.buffer.length - this.offset;\n    }\n    readUInt8() {\n        const result = this.buffer.readUInt8(this.offset);\n        this.offset++;\n        return result;\n    }\n    readInt32() {\n        const result = this.buffer.readInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt32() {\n        const result = this.buffer.readUInt32LE(this.offset);\n        this.offset += 4;\n        return result;\n    }\n    readUInt64() {\n        const buf = this.readSlice(8);\n        const n = unsafeFrom64bitLE(buf);\n        return n;\n    }\n    readVarInt() {\n        const vi = varuint.decode(this.buffer, this.offset);\n        this.offset += varuint.decode.bytes;\n        return vi;\n    }\n    readSlice(n) {\n        if (this.buffer.length < this.offset + n) {\n            throw new Error(\"Cannot read slice out of bounds\");\n        }\n        const result = this.buffer.slice(this.offset, this.offset + n);\n        this.offset += n;\n        return result;\n    }\n    readVarSlice() {\n        return this.readSlice(this.readVarInt());\n    }\n    readVector() {\n        const count = this.readVarInt();\n        const vector = [];\n        for (let i = 0; i < count; i++)\n            vector.push(this.readVarSlice());\n        return vector;\n    }\n}\n//# sourceMappingURL=buffertools.js.map","// the maximum number of bytes allowed in a single chunk when processing bitcoin script data.\n// if the Bitcoin script is too large, we will process it in several chunks.\nexport const MAX_SCRIPT_BLOCK = 50;\nexport const DEFAULT_VERSION = 1;\nexport const DEFAULT_LOCKTIME = 0;\n// input sequence for non-rbf transactions\nexport const DEFAULT_SEQUENCE = 0xffffffff;\n// SIGHASH flags(Sign all inputs and outputs)\n// refer to https://wiki.bitcoinsv.io/index.php/SIGHASH_flags for more details\nexport const SIGHASH_ALL = 1;\n// refer to https://en.bitcoin.it/wiki/Script for Opcodes(OP_DUP, OP_HASH160...) that are used in bitcoin script\nexport const OP_DUP = 0x76;\nexport const OP_HASH160 = 0xa9;\nexport const HASH_SIZE = 0x14;\nexport const OP_EQUAL = 0x87;\nexport const OP_EQUALVERIFY = 0x88;\nexport const OP_CHECKSIG = 0xac;\nexport const OP_RETURN = 0x6a;\n//# sourceMappingURL=constants.js.map","import RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nexport function hashPublicKey(buffer) {\n    return new RIPEMD160().update(sha(\"sha256\").update(buffer).digest()).digest();\n}\n//# sourceMappingURL=hashPublicKey.js.map","import { crypto } from \"bitcoinjs-lib\";\nimport { pointAddScalar } from \"tiny-secp256k1\";\nimport { BufferWriter } from \"../buffertools\";\nimport { HASH_SIZE, OP_CHECKSIG, OP_DUP, OP_EQUAL, OP_EQUALVERIFY, OP_HASH160 } from \"../constants\";\nimport { hashPublicKey } from \"../hashPublicKey\";\nclass BaseAccount {\n    constructor(psbt, masterFp) {\n        this.psbt = psbt;\n        this.masterFp = masterFp;\n    }\n}\n/**\n * Superclass for single signature accounts. This will make sure that the pubkey\n * arrays and path arrays in the method arguments contains exactly one element\n * and calls an abstract method to do the actual work.\n */\nclass SingleKeyAccount extends BaseAccount {\n    spendingCondition(pubkeys) {\n        if (pubkeys.length != 1) {\n            throw new Error(\"Expected single key, got \" + pubkeys.length);\n        }\n        return this.singleKeyCondition(pubkeys[0]);\n    }\n    setInput(i, inputTx, spentOutput, pubkeys, pathElems) {\n        if (pubkeys.length != 1) {\n            throw new Error(\"Expected single key, got \" + pubkeys.length);\n        }\n        if (pathElems.length != 1) {\n            throw new Error(\"Expected single path, got \" + pathElems.length);\n        }\n        this.setSingleKeyInput(i, inputTx, spentOutput, pubkeys[0], pathElems[0]);\n    }\n    setOwnOutput(i, cond, pubkeys, paths) {\n        if (pubkeys.length != 1) {\n            throw new Error(\"Expected single key, got \" + pubkeys.length);\n        }\n        if (paths.length != 1) {\n            throw new Error(\"Expected single path, got \" + paths.length);\n        }\n        this.setSingleKeyOutput(i, cond, pubkeys[0], paths[0]);\n    }\n}\nexport class p2pkh extends SingleKeyAccount {\n    singleKeyCondition(pubkey) {\n        const buf = new BufferWriter();\n        const pubkeyHash = hashPublicKey(pubkey);\n        buf.writeSlice(Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]));\n        buf.writeSlice(pubkeyHash);\n        buf.writeSlice(Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]));\n        return { scriptPubKey: buf.buffer() };\n    }\n    setSingleKeyInput(i, inputTx, _spentOutput, pubkey, path) {\n        if (!inputTx) {\n            throw new Error(\"Full input base transaction required\");\n        }\n        this.psbt.setInputNonWitnessUtxo(i, inputTx);\n        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n    }\n    setSingleKeyOutput(i, cond, pubkey, path) {\n        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n    }\n    getDescriptorTemplate() {\n        return \"pkh(@0)\";\n    }\n}\nexport class p2tr extends SingleKeyAccount {\n    singleKeyCondition(pubkey) {\n        const xonlyPubkey = pubkey.slice(1); // x-only pubkey\n        const buf = new BufferWriter();\n        const outputKey = this.getTaprootOutputKey(xonlyPubkey);\n        buf.writeSlice(Buffer.from([0x51, 32])); // push1, pubkeylen\n        buf.writeSlice(outputKey);\n        return { scriptPubKey: buf.buffer() };\n    }\n    setSingleKeyInput(i, _inputTx, spentOutput, pubkey, path) {\n        const xonly = pubkey.slice(1);\n        this.psbt.setInputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n    }\n    setSingleKeyOutput(i, cond, pubkey, path) {\n        const xonly = pubkey.slice(1);\n        this.psbt.setOutputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n    }\n    getDescriptorTemplate() {\n        return \"tr(@0)\";\n    }\n    /*\n    The following two functions are copied from wallet-btc and adapted.\n    They should be moved to a library to avoid code reuse.\n    */\n    hashTapTweak(x) {\n        // hash_tag(x) = SHA256(SHA256(tag) || SHA256(tag) || x), see BIP340\n        // See https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification\n        const h = crypto.sha256(Buffer.from(\"TapTweak\", \"utf-8\"));\n        return crypto.sha256(Buffer.concat([h, h, x]));\n    }\n    /**\n     * Calculates a taproot output key from an internal key. This output key will be\n     * used as witness program in a taproot output. The internal key is tweaked\n     * according to recommendation in BIP341:\n     * https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-22-0\n     *\n     * @param internalPubkey A 32 byte x-only taproot internal key\n     * @returns The output key\n     */\n    getTaprootOutputKey(internalPubkey) {\n        if (internalPubkey.length != 32) {\n            throw new Error(\"Expected 32 byte pubkey. Got \" + internalPubkey.length);\n        }\n        // A BIP32 derived key can be converted to a schnorr pubkey by dropping\n        // the first byte, which represent the oddness/evenness. In schnorr all\n        // pubkeys are even.\n        // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#public-key-conversion\n        const evenEcdsaPubkey = Buffer.concat([Buffer.from([0x02]), internalPubkey]);\n        const tweak = this.hashTapTweak(internalPubkey);\n        // Q = P + int(hash_TapTweak(bytes(P)))G\n        const outputEcdsaKey = Buffer.from(pointAddScalar(evenEcdsaPubkey, tweak));\n        // Convert to schnorr.\n        const outputSchnorrKey = outputEcdsaKey.slice(1);\n        // Create address\n        return outputSchnorrKey;\n    }\n}\nexport class p2wpkhWrapped extends SingleKeyAccount {\n    singleKeyCondition(pubkey) {\n        const buf = new BufferWriter();\n        const redeemScript = this.createRedeemScript(pubkey);\n        const scriptHash = hashPublicKey(redeemScript);\n        buf.writeSlice(Buffer.from([OP_HASH160, HASH_SIZE]));\n        buf.writeSlice(scriptHash);\n        buf.writeUInt8(OP_EQUAL);\n        return { scriptPubKey: buf.buffer(), redeemScript: redeemScript };\n    }\n    setSingleKeyInput(i, inputTx, spentOutput, pubkey, path) {\n        if (!inputTx) {\n            throw new Error(\"Full input base transaction required\");\n        }\n        this.psbt.setInputNonWitnessUtxo(i, inputTx);\n        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n        const userSuppliedRedeemScript = spentOutput.cond.redeemScript;\n        const expectedRedeemScript = this.createRedeemScript(pubkey);\n        if (userSuppliedRedeemScript && !expectedRedeemScript.equals(userSuppliedRedeemScript)) {\n            // At what point might a user set the redeemScript on its own?\n            throw new Error(`User-supplied redeemScript ${userSuppliedRedeemScript.toString(\"hex\")} doesn't\n       match expected ${expectedRedeemScript.toString(\"hex\")} for input ${i}`);\n        }\n        this.psbt.setInputRedeemScript(i, expectedRedeemScript);\n        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n    }\n    setSingleKeyOutput(i, cond, pubkey, path) {\n        this.psbt.setOutputRedeemScript(i, cond.redeemScript);\n        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n    }\n    getDescriptorTemplate() {\n        return \"sh(wpkh(@0))\";\n    }\n    createRedeemScript(pubkey) {\n        const pubkeyHash = hashPublicKey(pubkey);\n        return Buffer.concat([Buffer.from(\"0014\", \"hex\"), pubkeyHash]);\n    }\n}\nexport class p2wpkh extends SingleKeyAccount {\n    singleKeyCondition(pubkey) {\n        const buf = new BufferWriter();\n        const pubkeyHash = hashPublicKey(pubkey);\n        buf.writeSlice(Buffer.from([0, HASH_SIZE]));\n        buf.writeSlice(pubkeyHash);\n        return { scriptPubKey: buf.buffer() };\n    }\n    setSingleKeyInput(i, inputTx, spentOutput, pubkey, path) {\n        if (!inputTx) {\n            throw new Error(\"Full input base transaction required\");\n        }\n        this.psbt.setInputNonWitnessUtxo(i, inputTx);\n        this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n        this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n    }\n    setSingleKeyOutput(i, cond, pubkey, path) {\n        this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n    }\n    getDescriptorTemplate() {\n        return \"wpkh(@0)\";\n    }\n}\n//# sourceMappingURL=accounttype.js.map","import { crypto } from \"bitcoinjs-lib\";\n/**\n * This class implements the merkle tree used by Ledger Bitcoin app v2+,\n * which is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md\n */\nexport class Merkle {\n    constructor(leaves, hasher = crypto.sha256) {\n        this.leaves = leaves;\n        this.h = hasher;\n        const nodes = this.calculateRoot(leaves);\n        this.rootNode = nodes.root;\n        this.leafNodes = nodes.leaves;\n    }\n    getRoot() {\n        return this.rootNode.hash;\n    }\n    size() {\n        return this.leaves.length;\n    }\n    getLeaves() {\n        return this.leaves;\n    }\n    getLeafHash(index) {\n        return this.leafNodes[index].hash;\n    }\n    getProof(index) {\n        if (index >= this.leaves.length)\n            throw Error(\"Index out of bounds\");\n        return proveNode(this.leafNodes[index]);\n    }\n    calculateRoot(leaves) {\n        const n = leaves.length;\n        if (n == 0) {\n            return {\n                root: new Node(undefined, undefined, Buffer.alloc(32, 0)),\n                leaves: [],\n            };\n        }\n        if (n == 1) {\n            const newNode = new Node(undefined, undefined, leaves[0]);\n            return { root: newNode, leaves: [newNode] };\n        }\n        const leftCount = highestPowerOf2LessThan(n);\n        const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));\n        const rightBranch = this.calculateRoot(leaves.slice(leftCount));\n        const leftChild = leftBranch.root;\n        const rightChild = rightBranch.root;\n        const hash = this.hashNode(leftChild.hash, rightChild.hash);\n        const node = new Node(leftChild, rightChild, hash);\n        leftChild.parent = node;\n        rightChild.parent = node;\n        return { root: node, leaves: leftBranch.leaves.concat(rightBranch.leaves) };\n    }\n    hashNode(left, right) {\n        return this.h(Buffer.concat([Buffer.from([1]), left, right]));\n    }\n}\nexport function hashLeaf(buf, hashFunction = crypto.sha256) {\n    return hashConcat(Buffer.from([0]), buf, hashFunction);\n}\nfunction hashConcat(bufA, bufB, hashFunction) {\n    return hashFunction(Buffer.concat([bufA, bufB]));\n}\nclass Node {\n    constructor(left, right, hash) {\n        this.leftChild = left;\n        this.rightChild = right;\n        this.hash = hash;\n    }\n    isLeaf() {\n        return this.leftChild == undefined;\n    }\n}\nfunction proveNode(node) {\n    if (!node.parent) {\n        return [];\n    }\n    if (node.parent.leftChild == node) {\n        if (!node.parent.rightChild) {\n            throw new Error(\"Expected right child to exist\");\n        }\n        return [node.parent.rightChild.hash, ...proveNode(node.parent)];\n    }\n    else {\n        if (!node.parent.leftChild) {\n            throw new Error(\"Expected left child to exist\");\n        }\n        return [node.parent.leftChild.hash, ...proveNode(node.parent)];\n    }\n}\nfunction highestPowerOf2LessThan(n) {\n    if (n < 2) {\n        throw Error(\"Expected n >= 2\");\n    }\n    if (isPowerOf2(n)) {\n        return n / 2;\n    }\n    return 1 << Math.floor(Math.log2(n));\n}\nfunction isPowerOf2(n) {\n    return (n & (n - 1)) == 0;\n}\n//# sourceMappingURL=merkle.js.map","import { crypto } from \"bitcoinjs-lib\";\nimport { pathArrayToString } from \"../bip32\";\nimport { BufferWriter } from \"../buffertools\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n/**\n * The Bitcon hardware app uses a descriptors-like thing to describe\n * how to construct output scripts from keys. A \"Wallet Policy\" consists\n * of a \"Descriptor Template\" and a list of \"keys\". A key is basically\n * a serialized BIP32 extended public key with some added derivation path\n * information. This is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/wallet.md\n */\nexport class WalletPolicy {\n    /**\n     * For now, we only support default descriptor templates.\n     */\n    constructor(descriptorTemplate, key) {\n        this.descriptorTemplate = descriptorTemplate;\n        this.keys = [key];\n    }\n    getWalletId() {\n        // wallet_id (sha256 of the wallet serialization),\n        return crypto.sha256(this.serialize());\n    }\n    serialize() {\n        const keyBuffers = this.keys.map(k => {\n            return Buffer.from(k, \"ascii\");\n        });\n        const m = new Merkle(keyBuffers.map(k => hashLeaf(k)));\n        const buf = new BufferWriter();\n        buf.writeUInt8(0x01); // wallet type (policy map)\n        buf.writeUInt8(0); // length of wallet name (empty string for default wallets)\n        buf.writeVarSlice(Buffer.from(this.descriptorTemplate, \"ascii\"));\n        buf.writeVarInt(this.keys.length), buf.writeSlice(m.getRoot());\n        return buf.buffer();\n    }\n}\nexport function createKey(masterFingerprint, path, xpub) {\n    const accountPath = pathArrayToString(path);\n    return `[${masterFingerprint.toString(\"hex\")}${accountPath.substring(1)}]${xpub}/**`;\n}\n//# sourceMappingURL=policy.js.map","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { BufferReader, BufferWriter, unsafeFrom64bitLE, unsafeTo64bitLE } from \"../buffertools\";\nexport var psbtGlobal;\n(function (psbtGlobal) {\n    psbtGlobal[psbtGlobal[\"TX_VERSION\"] = 2] = \"TX_VERSION\";\n    psbtGlobal[psbtGlobal[\"FALLBACK_LOCKTIME\"] = 3] = \"FALLBACK_LOCKTIME\";\n    psbtGlobal[psbtGlobal[\"INPUT_COUNT\"] = 4] = \"INPUT_COUNT\";\n    psbtGlobal[psbtGlobal[\"OUTPUT_COUNT\"] = 5] = \"OUTPUT_COUNT\";\n    psbtGlobal[psbtGlobal[\"TX_MODIFIABLE\"] = 6] = \"TX_MODIFIABLE\";\n    psbtGlobal[psbtGlobal[\"VERSION\"] = 251] = \"VERSION\";\n})(psbtGlobal || (psbtGlobal = {}));\nexport var psbtIn;\n(function (psbtIn) {\n    psbtIn[psbtIn[\"NON_WITNESS_UTXO\"] = 0] = \"NON_WITNESS_UTXO\";\n    psbtIn[psbtIn[\"WITNESS_UTXO\"] = 1] = \"WITNESS_UTXO\";\n    psbtIn[psbtIn[\"PARTIAL_SIG\"] = 2] = \"PARTIAL_SIG\";\n    psbtIn[psbtIn[\"SIGHASH_TYPE\"] = 3] = \"SIGHASH_TYPE\";\n    psbtIn[psbtIn[\"REDEEM_SCRIPT\"] = 4] = \"REDEEM_SCRIPT\";\n    psbtIn[psbtIn[\"BIP32_DERIVATION\"] = 6] = \"BIP32_DERIVATION\";\n    psbtIn[psbtIn[\"FINAL_SCRIPTSIG\"] = 7] = \"FINAL_SCRIPTSIG\";\n    psbtIn[psbtIn[\"FINAL_SCRIPTWITNESS\"] = 8] = \"FINAL_SCRIPTWITNESS\";\n    psbtIn[psbtIn[\"PREVIOUS_TXID\"] = 14] = \"PREVIOUS_TXID\";\n    psbtIn[psbtIn[\"OUTPUT_INDEX\"] = 15] = \"OUTPUT_INDEX\";\n    psbtIn[psbtIn[\"SEQUENCE\"] = 16] = \"SEQUENCE\";\n    psbtIn[psbtIn[\"TAP_KEY_SIG\"] = 19] = \"TAP_KEY_SIG\";\n    psbtIn[psbtIn[\"TAP_BIP32_DERIVATION\"] = 22] = \"TAP_BIP32_DERIVATION\";\n})(psbtIn || (psbtIn = {}));\nexport var psbtOut;\n(function (psbtOut) {\n    psbtOut[psbtOut[\"REDEEM_SCRIPT\"] = 0] = \"REDEEM_SCRIPT\";\n    psbtOut[psbtOut[\"BIP_32_DERIVATION\"] = 2] = \"BIP_32_DERIVATION\";\n    psbtOut[psbtOut[\"AMOUNT\"] = 3] = \"AMOUNT\";\n    psbtOut[psbtOut[\"SCRIPT\"] = 4] = \"SCRIPT\";\n    psbtOut[psbtOut[\"TAP_BIP32_DERIVATION\"] = 7] = \"TAP_BIP32_DERIVATION\";\n})(psbtOut || (psbtOut = {}));\nconst PSBT_MAGIC_BYTES = Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]);\nexport class NoSuchEntry extends Error {\n}\n/**\n * Implements Partially Signed Bitcoin Transaction version 2, BIP370, as\n * documented at https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki\n * and https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki\n *\n * A psbt is a data structure that can carry all relevant information about a\n * transaction through all stages of the signing process. From constructing an\n * unsigned transaction to extracting the final serialized transaction ready for\n * broadcast.\n *\n * This implementation is limited to what's needed in ledgerjs to carry out its\n * duties, which means that support for features like multisig or taproot script\n * path spending are not implemented. Specifically, it supports p2pkh,\n * p2wpkhWrappedInP2sh, p2wpkh and p2tr key path spending.\n *\n * This class is made purposefully dumb, so it's easy to add support for\n * complemantary fields as needed in the future.\n */\nexport class PsbtV2 {\n    constructor() {\n        this.globalMap = new Map();\n        this.inputMaps = [];\n        this.outputMaps = [];\n    }\n    setGlobalTxVersion(version) {\n        this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));\n    }\n    getGlobalTxVersion() {\n        return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);\n    }\n    setGlobalFallbackLocktime(locktime) {\n        this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));\n    }\n    getGlobalFallbackLocktime() {\n        var _a;\n        return (_a = this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)) === null || _a === void 0 ? void 0 : _a.readUInt32LE(0);\n    }\n    setGlobalInputCount(inputCount) {\n        this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));\n    }\n    getGlobalInputCount() {\n        return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));\n    }\n    setGlobalOutputCount(outputCount) {\n        this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));\n    }\n    getGlobalOutputCount() {\n        return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));\n    }\n    setGlobalTxModifiable(byte) {\n        this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);\n    }\n    getGlobalTxModifiable() {\n        return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);\n    }\n    setGlobalPsbtVersion(psbtVersion) {\n        this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));\n    }\n    getGlobalPsbtVersion() {\n        return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);\n    }\n    setInputNonWitnessUtxo(inputIndex, transaction) {\n        this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);\n    }\n    getInputNonWitnessUtxo(inputIndex) {\n        return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());\n    }\n    setInputWitnessUtxo(inputIndex, amount, scriptPubKey) {\n        const buf = new BufferWriter();\n        buf.writeSlice(amount);\n        buf.writeVarSlice(scriptPubKey);\n        this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());\n    }\n    getInputWitnessUtxo(inputIndex) {\n        const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());\n        if (!utxo)\n            return undefined;\n        const buf = new BufferReader(utxo);\n        return { amount: buf.readSlice(8), scriptPubKey: buf.readVarSlice() };\n    }\n    setInputPartialSig(inputIndex, pubkey, signature) {\n        this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);\n    }\n    getInputPartialSig(inputIndex, pubkey) {\n        return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);\n    }\n    setInputSighashType(inputIndex, sigHashtype) {\n        this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));\n    }\n    getInputSighashType(inputIndex) {\n        const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());\n        if (!result)\n            return undefined;\n        return result.readUInt32LE(0);\n    }\n    setInputRedeemScript(inputIndex, redeemScript) {\n        this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);\n    }\n    getInputRedeemScript(inputIndex) {\n        return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());\n    }\n    setInputBip32Derivation(inputIndex, pubkey, masterFingerprint, path) {\n        if (pubkey.length != 33)\n            throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n        this.setInput(inputIndex, psbtIn.BIP32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));\n    }\n    getInputBip32Derivation(inputIndex, pubkey) {\n        const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);\n        if (!buf)\n            return undefined;\n        return this.decodeBip32Derivation(buf);\n    }\n    setInputFinalScriptsig(inputIndex, scriptSig) {\n        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);\n    }\n    getInputFinalScriptsig(inputIndex) {\n        return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());\n    }\n    setInputFinalScriptwitness(inputIndex, scriptWitness) {\n        this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);\n    }\n    getInputFinalScriptwitness(inputIndex) {\n        return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());\n    }\n    setInputPreviousTxId(inputIndex, txid) {\n        this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);\n    }\n    getInputPreviousTxid(inputIndex) {\n        return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());\n    }\n    setInputOutputIndex(inputIndex, outputIndex) {\n        this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));\n    }\n    getInputOutputIndex(inputIndex) {\n        return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);\n    }\n    setInputSequence(inputIndex, sequence) {\n        this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));\n    }\n    getInputSequence(inputIndex) {\n        var _a, _b;\n        return (_b = (_a = this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())) === null || _a === void 0 ? void 0 : _a.readUInt32LE(0)) !== null && _b !== void 0 ? _b : 0xffffffff;\n    }\n    setInputTapKeySig(inputIndex, sig) {\n        this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);\n    }\n    getInputTapKeySig(inputIndex) {\n        return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());\n    }\n    setInputTapBip32Derivation(inputIndex, pubkey, hashes, masterFingerprint, path) {\n        if (pubkey.length != 32)\n            throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n        const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);\n        this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);\n    }\n    getInputTapBip32Derivation(inputIndex, pubkey) {\n        const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);\n        return this.decodeTapBip32Derivation(buf);\n    }\n    getInputKeyDatas(inputIndex, keyType) {\n        return this.getKeyDatas(this.inputMaps[inputIndex], keyType);\n    }\n    setOutputRedeemScript(outputIndex, redeemScript) {\n        this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);\n    }\n    getOutputRedeemScript(outputIndex) {\n        return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());\n    }\n    setOutputBip32Derivation(outputIndex, pubkey, masterFingerprint, path) {\n        this.setOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey, this.encodeBip32Derivation(masterFingerprint, path));\n    }\n    getOutputBip32Derivation(outputIndex, pubkey) {\n        const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);\n        return this.decodeBip32Derivation(buf);\n    }\n    setOutputAmount(outputIndex, amount) {\n        this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));\n    }\n    getOutputAmount(outputIndex) {\n        const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());\n        return unsafeFrom64bitLE(buf);\n    }\n    setOutputScript(outputIndex, scriptPubKey) {\n        this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);\n    }\n    getOutputScript(outputIndex) {\n        return this.getOutput(outputIndex, psbtOut.SCRIPT, b());\n    }\n    setOutputTapBip32Derivation(outputIndex, pubkey, hashes, fingerprint, path) {\n        const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);\n        this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);\n    }\n    getOutputTapBip32Derivation(outputIndex, pubkey) {\n        const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);\n        return this.decodeTapBip32Derivation(buf);\n    }\n    deleteInputEntries(inputIndex, keyTypes) {\n        const map = this.inputMaps[inputIndex];\n        map.forEach((_v, k, m) => {\n            if (this.isKeyType(k, keyTypes)) {\n                m.delete(k);\n            }\n        });\n    }\n    copy(to) {\n        this.copyMap(this.globalMap, to.globalMap);\n        this.copyMaps(this.inputMaps, to.inputMaps);\n        this.copyMaps(this.outputMaps, to.outputMaps);\n    }\n    copyMaps(from, to) {\n        from.forEach((m, index) => {\n            const to_index = new Map();\n            this.copyMap(m, to_index);\n            to[index] = to_index;\n        });\n    }\n    copyMap(from, to) {\n        from.forEach((v, k) => to.set(k, Buffer.from(v)));\n    }\n    serialize() {\n        const buf = new BufferWriter();\n        buf.writeSlice(Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]));\n        serializeMap(buf, this.globalMap);\n        this.inputMaps.forEach(map => {\n            serializeMap(buf, map);\n        });\n        this.outputMaps.forEach(map => {\n            serializeMap(buf, map);\n        });\n        return buf.buffer();\n    }\n    deserialize(psbt) {\n        const buf = new BufferReader(psbt);\n        if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) {\n            throw new Error(\"Invalid magic bytes\");\n        }\n        while (this.readKeyPair(this.globalMap, buf))\n            ;\n        for (let i = 0; i < this.getGlobalInputCount(); i++) {\n            this.inputMaps[i] = new Map();\n            while (this.readKeyPair(this.inputMaps[i], buf))\n                ;\n        }\n        for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n            this.outputMaps[i] = new Map();\n            while (this.readKeyPair(this.outputMaps[i], buf))\n                ;\n        }\n    }\n    readKeyPair(map, buf) {\n        const keyLen = buf.readVarInt();\n        if (keyLen == 0) {\n            return false;\n        }\n        const keyType = buf.readUInt8();\n        const keyData = buf.readSlice(keyLen - 1);\n        const value = buf.readVarSlice();\n        set(map, keyType, keyData, value);\n        return true;\n    }\n    getKeyDatas(map, keyType) {\n        const result = [];\n        map.forEach((_v, k) => {\n            if (this.isKeyType(k, [keyType])) {\n                result.push(Buffer.from(k.substring(2), \"hex\"));\n            }\n        });\n        return result;\n    }\n    isKeyType(hexKey, keyTypes) {\n        const keyType = Buffer.from(hexKey.substring(0, 2), \"hex\").readUInt8(0);\n        return keyTypes.some(k => k == keyType);\n    }\n    setGlobal(keyType, value) {\n        const key = new Key(keyType, Buffer.from([]));\n        this.globalMap.set(key.toString(), value);\n    }\n    getGlobal(keyType) {\n        return get(this.globalMap, keyType, b(), false);\n    }\n    getGlobalOptional(keyType) {\n        return get(this.globalMap, keyType, b(), true);\n    }\n    setInput(index, keyType, keyData, value) {\n        set(this.getMap(index, this.inputMaps), keyType, keyData, value);\n    }\n    getInput(index, keyType, keyData) {\n        return get(this.inputMaps[index], keyType, keyData, false);\n    }\n    getInputOptional(index, keyType, keyData) {\n        return get(this.inputMaps[index], keyType, keyData, true);\n    }\n    setOutput(index, keyType, keyData, value) {\n        set(this.getMap(index, this.outputMaps), keyType, keyData, value);\n    }\n    getOutput(index, keyType, keyData) {\n        return get(this.outputMaps[index], keyType, keyData, false);\n    }\n    getMap(index, maps) {\n        if (maps[index]) {\n            return maps[index];\n        }\n        return (maps[index] = new Map());\n    }\n    encodeBip32Derivation(masterFingerprint, path) {\n        const buf = new BufferWriter();\n        this.writeBip32Derivation(buf, masterFingerprint, path);\n        return buf.buffer();\n    }\n    decodeBip32Derivation(buffer) {\n        const buf = new BufferReader(buffer);\n        return this.readBip32Derivation(buf);\n    }\n    writeBip32Derivation(buf, masterFingerprint, path) {\n        buf.writeSlice(masterFingerprint);\n        path.forEach(element => {\n            buf.writeUInt32(element);\n        });\n    }\n    readBip32Derivation(buf) {\n        const masterFingerprint = buf.readSlice(4);\n        const path = [];\n        while (buf.offset < buf.buffer.length) {\n            path.push(buf.readUInt32());\n        }\n        return { masterFingerprint, path };\n    }\n    encodeTapBip32Derivation(hashes, masterFingerprint, path) {\n        const buf = new BufferWriter();\n        buf.writeVarInt(hashes.length);\n        hashes.forEach(h => {\n            buf.writeSlice(h);\n        });\n        this.writeBip32Derivation(buf, masterFingerprint, path);\n        return buf.buffer();\n    }\n    decodeTapBip32Derivation(buffer) {\n        const buf = new BufferReader(buffer);\n        const hashCount = buf.readVarInt();\n        const hashes = [];\n        for (let i = 0; i < hashCount; i++) {\n            hashes.push(buf.readSlice(32));\n        }\n        const deriv = this.readBip32Derivation(buf);\n        return Object.assign({ hashes }, deriv);\n    }\n}\nfunction get(map, keyType, keyData, acceptUndefined) {\n    if (!map)\n        throw Error(\"No such map\");\n    const key = new Key(keyType, keyData);\n    const value = map.get(key.toString());\n    if (!value) {\n        if (acceptUndefined) {\n            return undefined;\n        }\n        throw new NoSuchEntry(key.toString());\n    }\n    // Make sure to return a copy, to protect the underlying data.\n    return Buffer.from(value);\n}\nclass Key {\n    constructor(keyType, keyData) {\n        this.keyType = keyType;\n        this.keyData = keyData;\n    }\n    toString() {\n        const buf = new BufferWriter();\n        this.toBuffer(buf);\n        return buf.buffer().toString(\"hex\");\n    }\n    serialize(buf) {\n        buf.writeVarInt(1 + this.keyData.length);\n        this.toBuffer(buf);\n    }\n    toBuffer(buf) {\n        buf.writeUInt8(this.keyType);\n        buf.writeSlice(this.keyData);\n    }\n}\nclass KeyPair {\n    constructor(key, value) {\n        this.key = key;\n        this.value = value;\n    }\n    serialize(buf) {\n        this.key.serialize(buf);\n        buf.writeVarSlice(this.value);\n    }\n}\nfunction createKey(buf) {\n    return new Key(buf.readUInt8(0), buf.slice(1));\n}\nfunction serializeMap(buf, map) {\n    for (const k of map.keys()) {\n        const value = map.get(k);\n        const keyPair = new KeyPair(createKey(Buffer.from(k, \"hex\")), value);\n        keyPair.serialize(buf);\n    }\n    buf.writeUInt8(0);\n}\nfunction b() {\n    return Buffer.from([]);\n}\nfunction set(map, keyType, keyData, value) {\n    const key = new Key(keyType, keyData);\n    map.set(key.toString(), value);\n}\nfunction uint32LE(n) {\n    const b = Buffer.alloc(4);\n    b.writeUInt32LE(n, 0);\n    return b;\n}\nfunction uint64LE(n) {\n    return unsafeTo64bitLE(n);\n}\nfunction varint(n) {\n    const b = new BufferWriter();\n    b.writeVarInt(n);\n    return b.buffer();\n}\nfunction fromVarint(buf) {\n    return new BufferReader(buf).readVarInt();\n}\n//# sourceMappingURL=psbtv2.js.map","import { BufferWriter } from \"../buffertools\";\nimport { psbtIn } from \"./psbtv2\";\n/**\n * This roughly implements the \"input finalizer\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki). However\n * the role is documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki).\n *\n * Verify that all inputs have a signature, and set inputFinalScriptwitness\n * and/or inputFinalScriptSig depending on the type of the spent outputs. Clean\n * fields that aren't useful anymore, partial signatures, redeem script and\n * derivation paths.\n *\n * @param psbt The psbt with all signatures added as partial sigs, either\n * through PSBT_IN_PARTIAL_SIG or PSBT_IN_TAP_KEY_SIG\n */\nexport function finalize(psbt) {\n    // First check that each input has a signature\n    const inputCount = psbt.getGlobalInputCount();\n    for (let i = 0; i < inputCount; i++) {\n        const legacyPubkeys = psbt.getInputKeyDatas(i, psbtIn.PARTIAL_SIG);\n        const taprootSig = psbt.getInputTapKeySig(i);\n        if (legacyPubkeys.length == 0 && !taprootSig) {\n            throw Error(`No signature for input ${i} present`);\n        }\n        if (legacyPubkeys.length > 0) {\n            if (legacyPubkeys.length > 1) {\n                throw Error(`Expected exactly one signature, got ${legacyPubkeys.length}`);\n            }\n            if (taprootSig) {\n                throw Error(\"Both taproot and non-taproot signatures present.\");\n            }\n            const isSegwitV0 = !!psbt.getInputWitnessUtxo(i);\n            const redeemScript = psbt.getInputRedeemScript(i);\n            const isWrappedSegwit = !!redeemScript;\n            const signature = psbt.getInputPartialSig(i, legacyPubkeys[0]);\n            if (!signature)\n                throw new Error(\"Expected partial signature for input \" + i);\n            if (isSegwitV0) {\n                const witnessBuf = new BufferWriter();\n                witnessBuf.writeVarInt(2);\n                witnessBuf.writeVarInt(signature.length);\n                witnessBuf.writeSlice(signature);\n                witnessBuf.writeVarInt(legacyPubkeys[0].length);\n                witnessBuf.writeSlice(legacyPubkeys[0]);\n                psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n                if (isWrappedSegwit) {\n                    if (!redeemScript || redeemScript.length == 0) {\n                        throw new Error(\"Expected non-empty redeemscript. Can't finalize intput \" + i);\n                    }\n                    const scriptSigBuf = new BufferWriter();\n                    // Push redeemScript length\n                    scriptSigBuf.writeUInt8(redeemScript.length);\n                    scriptSigBuf.writeSlice(redeemScript);\n                    psbt.setInputFinalScriptsig(i, scriptSigBuf.buffer());\n                }\n            }\n            else {\n                // Legacy input\n                const scriptSig = new BufferWriter();\n                writePush(scriptSig, signature);\n                writePush(scriptSig, legacyPubkeys[0]);\n                psbt.setInputFinalScriptsig(i, scriptSig.buffer());\n            }\n        }\n        else {\n            // Taproot input\n            const signature = psbt.getInputTapKeySig(i);\n            if (!signature) {\n                throw Error(\"No taproot signature found\");\n            }\n            if (signature.length != 64 && signature.length != 65) {\n                throw Error(\"Unexpected length of schnorr signature.\");\n            }\n            const witnessBuf = new BufferWriter();\n            witnessBuf.writeVarInt(1);\n            witnessBuf.writeVarSlice(signature);\n            psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n        }\n        clearFinalizedInput(psbt, i);\n    }\n}\n/**\n * Deletes fields that are no longer neccesary from the psbt.\n *\n * Note, the spec doesn't say anything about removing ouput fields\n * like PSBT_OUT_BIP32_DERIVATION_PATH and others, so we keep them\n * without actually knowing why. I think we should remove them too.\n */\nfunction clearFinalizedInput(psbt, inputIndex) {\n    const keyTypes = [\n        psbtIn.BIP32_DERIVATION,\n        psbtIn.PARTIAL_SIG,\n        psbtIn.TAP_BIP32_DERIVATION,\n        psbtIn.TAP_KEY_SIG,\n    ];\n    const witnessUtxoAvailable = !!psbt.getInputWitnessUtxo(inputIndex);\n    const nonWitnessUtxoAvailable = !!psbt.getInputNonWitnessUtxo(inputIndex);\n    if (witnessUtxoAvailable && nonWitnessUtxoAvailable) {\n        // Remove NON_WITNESS_UTXO for segwit v0 as it's only needed while signing.\n        // Segwit v1 doesn't have NON_WITNESS_UTXO set.\n        // See https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#cite_note-7\n        keyTypes.push(psbtIn.NON_WITNESS_UTXO);\n    }\n    psbt.deleteInputEntries(inputIndex, keyTypes);\n}\n/**\n * Writes a script push operation to buf, which looks different\n * depending on the size of the data. See\n * https://en.bitcoin.it/wiki/Script#Constants\n *\n * @param buf the BufferWriter to write to\n * @param data the Buffer to be pushed.\n */\nfunction writePush(buf, data) {\n    if (data.length <= 75) {\n        buf.writeUInt8(data.length);\n    }\n    else if (data.length <= 256) {\n        buf.writeUInt8(76);\n        buf.writeUInt8(data.length);\n    }\n    else if (data.length <= 256 * 256) {\n        buf.writeUInt8(77);\n        const b = Buffer.alloc(2);\n        b.writeUInt16LE(data.length, 0);\n        buf.writeSlice(b);\n    }\n    buf.writeSlice(data);\n}\n//# sourceMappingURL=psbtFinalizer.js.map","export function getVarint(data, offset) {\n    if (data[offset] < 0xfd) {\n        return [data[offset], 1];\n    }\n    if (data[offset] === 0xfd) {\n        return [(data[offset + 2] << 8) + data[offset + 1], 3];\n    }\n    if (data[offset] === 0xfe) {\n        return [\n            (data[offset + 4] << 24) +\n                (data[offset + 3] << 16) +\n                (data[offset + 2] << 8) +\n                data[offset + 1],\n            5,\n        ];\n    }\n    throw new Error(\"getVarint called with unexpected parameters\");\n}\nexport function createVarint(value) {\n    if (value < 0xfd) {\n        const buffer = Buffer.alloc(1);\n        buffer[0] = value;\n        return buffer;\n    }\n    if (value <= 0xffff) {\n        const buffer = Buffer.alloc(3);\n        buffer[0] = 0xfd;\n        buffer[1] = value & 0xff;\n        buffer[2] = (value >> 8) & 0xff;\n        return buffer;\n    }\n    const buffer = Buffer.alloc(5);\n    buffer[0] = 0xfe;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    buffer[3] = (value >> 16) & 0xff;\n    buffer[4] = (value >> 24) & 0xff;\n    return buffer;\n}\n//# sourceMappingURL=varint.js.map","import { createVarint } from \"./varint\";\n/**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\nexport function serializeTransactionOutputs({ outputs }) {\n    let outputBuffer = Buffer.alloc(0);\n    if (typeof outputs !== \"undefined\") {\n        outputBuffer = Buffer.concat([outputBuffer, createVarint(outputs.length)]);\n        outputs.forEach(output => {\n            outputBuffer = Buffer.concat([\n                outputBuffer,\n                output.amount,\n                createVarint(output.script.length),\n                output.script,\n            ]);\n        });\n    }\n    return outputBuffer;\n}\nexport function serializeTransaction(transaction, skipWitness, timestamp, additionals = []) {\n    const isDecred = additionals.includes(\"decred\");\n    const isZcash = additionals.includes(\"zcash\");\n    const isBech32 = additionals.includes(\"bech32\");\n    let inputBuffer = Buffer.alloc(0);\n    const useWitness = typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n    transaction.inputs.forEach(input => {\n        inputBuffer =\n            isDecred || isBech32\n                ? Buffer.concat([\n                    inputBuffer,\n                    input.prevout,\n                    Buffer.from([0x00]),\n                    input.sequence,\n                ])\n                : Buffer.concat([\n                    inputBuffer,\n                    input.prevout,\n                    createVarint(input.script.length),\n                    input.script,\n                    input.sequence,\n                ]);\n    });\n    let outputBuffer = serializeTransactionOutputs(transaction);\n    if (typeof transaction.outputs !== \"undefined\" && typeof transaction.locktime !== \"undefined\") {\n        outputBuffer = Buffer.concat([\n            outputBuffer,\n            (useWitness && transaction.witness) || Buffer.alloc(0),\n            transaction.locktime,\n            transaction.nExpiryHeight || Buffer.alloc(0),\n            transaction.extraData || Buffer.alloc(0),\n        ]);\n    }\n    // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n    if (isZcash) {\n        return Buffer.concat([\n            transaction.version,\n            transaction.nVersionGroupId || Buffer.alloc(0),\n            Buffer.from([0xb4, 0xd0, 0xd6, 0xc2]),\n            transaction.locktime || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n            transaction.nExpiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n            useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n            createVarint(transaction.inputs.length),\n            inputBuffer,\n            outputBuffer,\n        ]);\n    }\n    return Buffer.concat([\n        transaction.version,\n        timestamp ? timestamp : Buffer.alloc(0),\n        transaction.nVersionGroupId || Buffer.alloc(0),\n        useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n        createVarint(transaction.inputs.length),\n        inputBuffer,\n        outputBuffer,\n    ]);\n}\n//# sourceMappingURL=serializeTransaction.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { crypto } from \"bitcoinjs-lib\";\nimport { pointCompress } from \"tiny-secp256k1\";\nimport { getXpubComponents, hardenedPathOf, pathArrayToString, pathStringToArray, pubkeyFromXpub, } from \"./bip32\";\nimport { BufferReader } from \"./buffertools\";\nimport { p2pkh, p2tr, p2wpkh, p2wpkhWrapped, } from \"./newops/accounttype\";\nimport { createKey, WalletPolicy } from \"./newops/policy\";\nimport { extract } from \"./newops/psbtExtractor\";\nimport { finalize } from \"./newops/psbtFinalizer\";\nimport { psbtIn, PsbtV2 } from \"./newops/psbtv2\";\nimport { serializeTransaction } from \"./serializeTransaction\";\n/**\n * @class BtcNew\n * @description This class implements the same interface as BtcOld (formerly\n * named Btc), but interacts with Bitcoin hardware app version 2.1.0+\n * which uses a totally new APDU protocol. This new\n * protocol is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n *\n * Since the interface must remain compatible with BtcOld, the methods\n * of this class are quite clunky, because it needs to adapt legacy\n * input data into the PSBT process. In the future, a new interface should\n * be developed that exposes PSBT to the outer world, which would render\n * a much cleaner implementation.\n *\n */\nexport default class BtcNew {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * This is a new method that allow users to get an xpub at a standard path.\n     * Standard paths are described at\n     * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#description\n     *\n     * This boils down to paths (N=0 for Bitcoin, N=1 for Testnet):\n     * M/44'/N'/x'/**\n     * M/48'/N'/x'/y'/**\n     * M/49'/N'/x'/**\n     * M/84'/N'/x'/**\n     * M/86'/N'/x'/**\n     *\n     * The method was added because of added security in the hardware app v2+. The\n     * new hardware app will allow export of any xpub up to and including the\n     * deepest hardened key of standard derivation paths, whereas the old app\n     * would allow export of any key.\n     *\n     * This caused an issue for callers of this class, who only had\n     * getWalletPublicKey() to call which means they have to constuct xpub\n     * themselves:\n     *\n     * Suppose a user of this class wants to create an account xpub on a standard\n     * path, M/44'/0'/Z'. The user must get the parent key fingerprint (see BIP32)\n     * by requesting the parent key M/44'/0'. The new app won't allow that, because\n     * it only allows exporting deepest level hardened path. So the options are to\n     * allow requesting M/44'/0' from the app, or to add a new function\n     * \"getWalletXpub\".\n     *\n     * We opted for adding a new function, which can greatly simplify client code.\n     */\n    getWalletXpub({ path, xpubVersion, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pathElements = pathStringToArray(path);\n            const xpub = yield this.client.getExtendedPubkey(false, pathElements);\n            const xpubComponents = getXpubComponents(xpub);\n            if (xpubComponents.version != xpubVersion) {\n                throw new Error(`Expected xpub version ${xpubVersion} doesn't match the xpub version from the device ${xpubComponents.version}`);\n            }\n            return xpub;\n        });\n    }\n    /**\n     * This method returns a public key, a bitcoin address, and and a chaincode\n     * for a specific derivation path.\n     *\n     * Limitation: If the path is not a leaf node of a standard path, the address\n     * will be the empty string \"\", see this.getWalletAddress() for details.\n     */\n    getWalletPublicKey(path, opts) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!isPathNormal(path)) {\n                throw Error(`non-standard path: ${path}`);\n            }\n            const pathElements = pathStringToArray(path);\n            const xpub = yield this.client.getExtendedPubkey(false, pathElements);\n            const display = (_a = opts === null || opts === void 0 ? void 0 : opts.verify) !== null && _a !== void 0 ? _a : false;\n            const address = yield this.getWalletAddress(pathElements, descrTemplFrom((_b = opts === null || opts === void 0 ? void 0 : opts.format) !== null && _b !== void 0 ? _b : \"legacy\"), display);\n            const components = getXpubComponents(xpub);\n            const uncompressedPubkey = Buffer.from(pointCompress(components.pubkey, false));\n            return {\n                publicKey: uncompressedPubkey.toString(\"hex\"),\n                bitcoinAddress: address,\n                chainCode: components.chaincode.toString(\"hex\"),\n            };\n        });\n    }\n    /**\n     * Get an address for the specified path.\n     *\n     * If display is true, we must get the address from the device, which would require\n     * us to determine WalletPolicy. This requires two *extra* queries to the device, one\n     * for the account xpub and one for master key fingerprint.\n     *\n     * If display is false we *could* generate the address ourselves, but chose to\n     * get it from the device to save development time. However, it shouldn't take\n     * too much time to implement local address generation.\n     *\n     * Moreover, if the path is not for a leaf, ie accountPath+/X/Y, there is no\n     * way to get the address from the device. In this case we have to create it\n     * ourselves, but we don't at this time, and instead return an empty (\"\") address.\n     */\n    getWalletAddress(pathElements, descrTempl, display) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accountPath = hardenedPathOf(pathElements);\n            if (accountPath.length + 2 != pathElements.length) {\n                return \"\";\n            }\n            const accountXpub = yield this.client.getExtendedPubkey(false, accountPath);\n            const masterFingerprint = yield this.client.getMasterFingerprint();\n            const policy = new WalletPolicy(descrTempl, createKey(masterFingerprint, accountPath, accountXpub));\n            const changeAndIndex = pathElements.slice(-2, pathElements.length);\n            return this.client.getWalletAddress(policy, Buffer.alloc(32, 0), changeAndIndex[0], changeAndIndex[1], display);\n        });\n    }\n    /**\n     * Build and sign a transaction. See Btc.createPaymentTransaction for\n     * details on how to use this method.\n     *\n     * This method will convert the legacy arguments, CreateTransactionArg, into\n     * a psbt which is finally signed and finalized, and the extracted fully signed\n     * transaction is returned.\n     */\n    createPaymentTransaction(arg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const inputCount = arg.inputs.length;\n            if (inputCount == 0) {\n                throw Error(\"No inputs\");\n            }\n            const psbt = new PsbtV2();\n            // The master fingerprint is needed when adding BIP32 derivation paths on\n            // the psbt.\n            const masterFp = yield this.client.getMasterFingerprint();\n            const accountType = accountTypeFromArg(arg, psbt, masterFp);\n            if (arg.lockTime != undefined) {\n                // The signer will assume locktime 0 if unset\n                psbt.setGlobalFallbackLocktime(arg.lockTime);\n            }\n            psbt.setGlobalInputCount(inputCount);\n            psbt.setGlobalPsbtVersion(2);\n            psbt.setGlobalTxVersion(2);\n            let notifyCount = 0;\n            const progress = () => {\n                if (!arg.onDeviceStreaming)\n                    return;\n                arg.onDeviceStreaming({\n                    total: 2 * inputCount,\n                    index: notifyCount,\n                    progress: ++notifyCount / (2 * inputCount),\n                });\n            };\n            let accountXpub = \"\";\n            let accountPath = [];\n            for (let i = 0; i < inputCount; i++) {\n                progress();\n                const pathElems = pathStringToArray(arg.associatedKeysets[i]);\n                if (accountXpub == \"\") {\n                    // We assume all inputs belong to the same account so we set\n                    // the account xpub and path based on the first input.\n                    accountPath = pathElems.slice(0, -2);\n                    accountXpub = yield this.client.getExtendedPubkey(false, accountPath);\n                }\n                yield this.setInput(psbt, i, arg.inputs[i], pathElems, accountType, masterFp, arg.sigHashType);\n            }\n            const outputsConcat = Buffer.from(arg.outputScriptHex, \"hex\");\n            const outputsBufferReader = new BufferReader(outputsConcat);\n            const outputCount = outputsBufferReader.readVarInt();\n            psbt.setGlobalOutputCount(outputCount);\n            const changeData = yield this.outputScriptAt(accountPath, accountType, arg.changePath);\n            // If the caller supplied a changePath, we must make sure there actually is\n            // a change output. If no change output found, we'll throw an error.\n            let changeFound = !changeData;\n            for (let i = 0; i < outputCount; i++) {\n                const amount = Number(outputsBufferReader.readUInt64());\n                const outputScript = outputsBufferReader.readVarSlice();\n                psbt.setOutputAmount(i, amount);\n                psbt.setOutputScript(i, outputScript);\n                // We won't know if we're paying to ourselves, because there's no\n                // information in arg to support multiple \"change paths\". One exception is\n                // if there are multiple outputs to the change address.\n                const isChange = changeData && outputScript.equals(changeData === null || changeData === void 0 ? void 0 : changeData.cond.scriptPubKey);\n                if (isChange) {\n                    changeFound = true;\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    const changePath = pathStringToArray(arg.changePath);\n                    const pubkey = changeData.pubkey;\n                    accountType.setOwnOutput(i, changeData.cond, [pubkey], [changePath]);\n                }\n            }\n            if (!changeFound) {\n                throw new Error(\"Change script not found among outputs! \" + (changeData === null || changeData === void 0 ? void 0 : changeData.cond.scriptPubKey.toString(\"hex\")));\n            }\n            const key = createKey(masterFp, accountPath, accountXpub);\n            const p = new WalletPolicy(accountType.getDescriptorTemplate(), key);\n            // This is cheating, because it's not actually requested on the\n            // device yet, but it will be, soonish.\n            if (arg.onDeviceSignatureRequested)\n                arg.onDeviceSignatureRequested();\n            let firstSigned = false;\n            // This callback will be called once for each signature yielded.\n            const progressCallback = () => {\n                if (!firstSigned) {\n                    firstSigned = true;\n                    arg.onDeviceSignatureGranted && arg.onDeviceSignatureGranted();\n                }\n                progress();\n            };\n            yield this.signPsbt(psbt, p, progressCallback);\n            finalize(psbt);\n            const serializedTx = extract(psbt);\n            return serializedTx.toString(\"hex\");\n        });\n    }\n    /**\n     * Signs an arbitrary hex-formatted message with the private key at\n     * the provided derivation path according to the Bitcoin Signature format\n     * and returns v, r, s.\n     */\n    signMessage({ path, messageHex }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pathElements = pathStringToArray(path);\n            const message = Buffer.from(messageHex, \"hex\");\n            const sig = yield this.client.signMessage(message, pathElements);\n            const buf = Buffer.from(sig, \"base64\");\n            const v = buf.readUInt8() - 27 - 4;\n            const r = buf.slice(1, 33).toString(\"hex\");\n            const s = buf.slice(33, 65).toString(\"hex\");\n            return {\n                v,\n                r,\n                s,\n            };\n        });\n    }\n    /**\n     * Calculates an output script along with public key and possible redeemScript\n     * from a path and accountType. The accountPath must be a prefix of path.\n     *\n     * @returns an object with output script (property \"script\"), redeemScript (if\n     * wrapped p2wpkh), and pubkey at provided path. The values of these three\n     * properties depend on the accountType used.\n     */\n    outputScriptAt(accountPath, accountType, path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!path)\n                return undefined;\n            const pathElems = pathStringToArray(path);\n            // Make sure path is in our account, otherwise something fishy is probably\n            // going on.\n            for (let i = 0; i < accountPath.length; i++) {\n                if (accountPath[i] != pathElems[i]) {\n                    throw new Error(`Path ${path} not in account ${pathArrayToString(accountPath)}`);\n                }\n            }\n            const xpub = yield this.client.getExtendedPubkey(false, pathElems);\n            const pubkey = pubkeyFromXpub(xpub);\n            const cond = accountType.spendingCondition([pubkey]);\n            return { cond, pubkey };\n        });\n    }\n    /**\n     * Adds relevant data about an input to the psbt. This includes sequence,\n     * previous txid, output index, spent UTXO, redeem script for wrapped p2wpkh,\n     * public key and its derivation path.\n     */\n    setInput(psbt, i, input, pathElements, accountType, masterFP, sigHashType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const inputTx = input[0];\n            const spentOutputIndex = input[1];\n            // redeemScript will be null for wrapped p2wpkh, we need to create it\n            // ourselves. But if set, it should be used.\n            const redeemScript = input[2] ? Buffer.from(input[2], \"hex\") : undefined;\n            const sequence = input[3];\n            if (sequence != undefined) {\n                psbt.setInputSequence(i, sequence);\n            }\n            if (sigHashType != undefined) {\n                psbt.setInputSighashType(i, sigHashType);\n            }\n            const inputTxBuffer = serializeTransaction(inputTx, true);\n            const inputTxid = crypto.hash256(inputTxBuffer);\n            const xpubBase58 = yield this.client.getExtendedPubkey(false, pathElements);\n            const pubkey = pubkeyFromXpub(xpubBase58);\n            if (!inputTx.outputs)\n                throw Error(\"Missing outputs array in transaction to sign\");\n            const spentTxOutput = inputTx.outputs[spentOutputIndex];\n            const spendCondition = {\n                scriptPubKey: spentTxOutput.script,\n                redeemScript: redeemScript,\n            };\n            const spentOutput = { cond: spendCondition, amount: spentTxOutput.amount };\n            accountType.setInput(i, inputTxBuffer, spentOutput, [pubkey], [pathElements]);\n            psbt.setInputPreviousTxId(i, inputTxid);\n            psbt.setInputOutputIndex(i, spentOutputIndex);\n        });\n    }\n    /**\n     * This implements the \"Signer\" role of the BIP370 transaction signing\n     * process.\n     *\n     * It ssks the hardware device to sign the a psbt using the specified wallet\n     * policy. This method assumes BIP32 derived keys are used for all inputs, see\n     * comment in-line. The signatures returned from the hardware device is added\n     * to the appropriate input fields of the PSBT.\n     */\n    signPsbt(psbt, walletPolicy, progressCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sigs = yield this.client.signPsbt(psbt, walletPolicy, Buffer.alloc(32, 0), progressCallback);\n            sigs.forEach((v, k) => {\n                // Note: Looking at BIP32 derivation does not work in the generic case,\n                // since some inputs might not have a BIP32-derived pubkey.\n                const pubkeys = psbt.getInputKeyDatas(k, psbtIn.BIP32_DERIVATION);\n                let pubkey;\n                if (pubkeys.length != 1) {\n                    // No legacy BIP32_DERIVATION, assume we're using taproot.\n                    pubkey = psbt.getInputKeyDatas(k, psbtIn.TAP_BIP32_DERIVATION);\n                    if (pubkey.length == 0) {\n                        throw Error(`Missing pubkey derivation for input ${k}`);\n                    }\n                    psbt.setInputTapKeySig(k, v);\n                }\n                else {\n                    pubkey = pubkeys[0];\n                    psbt.setInputPartialSig(k, pubkey, v);\n                }\n            });\n        });\n    }\n}\n/**\n * This function returns a descriptor template based on the address format.\n * See https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md for details of\n * the bitcoin descriptor template.\n */\nfunction descrTemplFrom(addressFormat) {\n    if (addressFormat == \"legacy\")\n        return \"pkh(@0)\";\n    if (addressFormat == \"p2sh\")\n        return \"sh(wpkh(@0))\";\n    if (addressFormat == \"bech32\")\n        return \"wpkh(@0)\";\n    if (addressFormat == \"bech32m\")\n        return \"tr(@0)\";\n    throw new Error(\"Unsupported address format \" + addressFormat);\n}\nfunction accountTypeFromArg(arg, psbt, masterFp) {\n    if (arg.additionals.includes(\"bech32m\"))\n        return new p2tr(psbt, masterFp);\n    if (arg.additionals.includes(\"bech32\"))\n        return new p2wpkh(psbt, masterFp);\n    if (arg.segwit)\n        return new p2wpkhWrapped(psbt, masterFp);\n    return new p2pkh(psbt, masterFp);\n}\n/*\n  The new protocol only allows standard path.\n  Standard paths are (currently):\n  M/44'/(1|0|88)'/X'\n  M/49'/(1|0|88)'/X'\n  M/84'/(1|0|88)'/X'\n  M/86'/(1|0|88)'/X'\n  M/48'/(1|0|88)'/X'/Y'\n  followed by \"\", \"(0|1)\", or \"(0|1)/b\", where a and b are\n  non-hardened. For example, the following paths are standard\n  M/48'/1'/99'/7'\n  M/86'/1'/99'/0\n  M/48'/0'/99'/7'/1/17\n  The following paths are non-standard\n  M/48'/0'/99'           // Not deepest hardened path\n  M/48'/0'/99'/7'/1/17/2 // Too many non-hardened derivation steps\n  M/199'/0'/1'/0/88      // Not a known purpose 199\n  M/86'/1'/99'/2         // Change path item must be 0 or 1\n\n  Useful resource on derivation paths: https://learnmeabitcoin.com/technical/derivation-paths\n*/\n//path is not deepest hardened node of a standard path or deeper, use BtcOld\nconst H = 0x80000000; //HARDENED from bip32\nconst VALID_COIN_TYPES = [\n    0,\n    1,\n    88, // Qtum\n];\nconst VALID_SINGLE_SIG_PURPOSES = [\n    44,\n    49,\n    84,\n    86, // BIP86 - https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki\n];\nconst VALID_MULTISIG_PURPOSES = [\n    48, // BIP48 - https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki\n];\nconst hard = (n) => n >= H;\nconst soft = (n) => n === undefined || n < H;\nconst change = (n) => n === undefined || n === 0 || n === 1;\nconst validCoinPathPartsSet = new Set(VALID_COIN_TYPES.map(t => t + H));\nconst validSingleSigPurposePathPartsSet = new Set(VALID_SINGLE_SIG_PURPOSES.map(t => t + H));\nconst validMultiSigPurposePathPartsSet = new Set(VALID_MULTISIG_PURPOSES.map(t => t + H));\nexport function isPathNormal(path) {\n    const pathElems = pathStringToArray(path);\n    // Single sig\n    if (pathElems.length >= 3 &&\n        pathElems.length <= 5 &&\n        validSingleSigPurposePathPartsSet.has(pathElems[0]) &&\n        validCoinPathPartsSet.has(pathElems[1]) &&\n        hard(pathElems[2]) &&\n        change(pathElems[3]) &&\n        soft(pathElems[4])) {\n        return true;\n    }\n    // Multi sig\n    if (pathElems.length >= 4 &&\n        pathElems.length <= 6 &&\n        validMultiSigPurposePathPartsSet.has(pathElems[0]) &&\n        validCoinPathPartsSet.has(pathElems[1]) &&\n        hard(pathElems[2]) &&\n        hard(pathElems[3]) &&\n        change(pathElems[4]) &&\n        soft(pathElems[5])) {\n        return true;\n    }\n    return false;\n}\n//# sourceMappingURL=BtcNew.js.map","import { BufferWriter } from \"../buffertools\";\n/**\n * This implements the \"Transaction Extractor\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#transaction-extractor). However\n * the role is partially documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#transaction-extractor).\n */\nexport function extract(psbt) {\n    var _a, _b;\n    const tx = new BufferWriter();\n    tx.writeUInt32(psbt.getGlobalTxVersion());\n    const isSegwit = !!psbt.getInputWitnessUtxo(0);\n    if (isSegwit) {\n        tx.writeSlice(Buffer.from([0, 1]));\n    }\n    const inputCount = psbt.getGlobalInputCount();\n    tx.writeVarInt(inputCount);\n    const witnessWriter = new BufferWriter();\n    for (let i = 0; i < inputCount; i++) {\n        tx.writeSlice(psbt.getInputPreviousTxid(i));\n        tx.writeUInt32(psbt.getInputOutputIndex(i));\n        tx.writeVarSlice((_a = psbt.getInputFinalScriptsig(i)) !== null && _a !== void 0 ? _a : Buffer.from([]));\n        tx.writeUInt32(psbt.getInputSequence(i));\n        if (isSegwit) {\n            witnessWriter.writeSlice(psbt.getInputFinalScriptwitness(i));\n        }\n    }\n    const outputCount = psbt.getGlobalOutputCount();\n    tx.writeVarInt(outputCount);\n    for (let i = 0; i < outputCount; i++) {\n        tx.writeUInt64(psbt.getOutputAmount(i));\n        tx.writeVarSlice(psbt.getOutputScript(i));\n    }\n    tx.writeSlice(witnessWriter.buffer());\n    tx.writeUInt32((_b = psbt.getGlobalFallbackLocktime()) !== null && _b !== void 0 ? _b : 0);\n    return tx.buffer();\n}\n//# sourceMappingURL=psbtExtractor.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { bip32asBuffer } from \"./bip32\";\nconst addressFormatMap = {\n    legacy: 0,\n    p2sh: 1,\n    bech32: 2,\n    cashaddr: 3,\n};\nexport function getWalletPublicKey(transport, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { path, verify, format } = Object.assign({ verify: false, format: \"legacy\" }, options);\n        if (!(format in addressFormatMap)) {\n            throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n        }\n        const buffer = bip32asBuffer(path);\n        const p1 = verify ? 1 : 0;\n        const p2 = addressFormatMap[format];\n        const response = yield transport.send(0xe0, 0x40, p1, p2, buffer);\n        const publicKeyLength = response[0];\n        const addressLength = response[1 + publicKeyLength];\n        const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n        const bitcoinAddress = response\n            .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n            .toString(\"ascii\");\n        const chainCode = response\n            .slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32)\n            .toString(\"hex\");\n        return {\n            publicKey,\n            bitcoinAddress,\n            chainCode,\n        };\n    });\n}\n//# sourceMappingURL=getWalletPublicKey.js.map","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport invariant from \"invariant\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nimport { createVarint } from \"./varint\";\nexport function getTrustedInputRaw(transport, transactionData, indexLookup) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let data;\n        let firstRound = false;\n        if (typeof indexLookup === \"number\") {\n            firstRound = true;\n            const prefix = Buffer.alloc(4);\n            prefix.writeUInt32BE(indexLookup, 0);\n            data = Buffer.concat([prefix, transactionData], transactionData.length + 4);\n        }\n        else {\n            data = transactionData;\n        }\n        const trustedInput = yield transport.send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data);\n        const res = trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\");\n        return res;\n    });\n}\nexport function getTrustedInput(transport, indexLookup, transaction, additionals = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { version, inputs, outputs, locktime, nExpiryHeight, extraData } = transaction;\n        if (!outputs || !locktime) {\n            throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n        }\n        const isDecred = additionals.includes(\"decred\");\n        const isXST = additionals.includes(\"stealthcoin\");\n        const processScriptBlocks = (script, sequence) => __awaiter(this, void 0, void 0, function* () {\n            const seq = sequence || Buffer.alloc(0);\n            const scriptBlocks = [];\n            let offset = 0;\n            while (offset !== script.length) {\n                const blockSize = script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : script.length - offset;\n                if (offset + blockSize !== script.length) {\n                    scriptBlocks.push(script.slice(offset, offset + blockSize));\n                }\n                else {\n                    scriptBlocks.push(Buffer.concat([script.slice(offset, offset + blockSize), seq]));\n                }\n                offset += blockSize;\n            }\n            // Handle case when no script length: we still want to pass the sequence\n            // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n            if (script.length === 0) {\n                scriptBlocks.push(seq);\n            }\n            let res;\n            for (const scriptBlock of scriptBlocks) {\n                res = yield getTrustedInputRaw(transport, scriptBlock);\n            }\n            return res;\n        });\n        const processWholeScriptBlock = block => getTrustedInputRaw(transport, block);\n        yield getTrustedInputRaw(transport, Buffer.concat([\n            transaction.version,\n            transaction.timestamp || Buffer.alloc(0),\n            transaction.nVersionGroupId || Buffer.alloc(0),\n            createVarint(inputs.length),\n        ]), indexLookup);\n        for (const input of inputs) {\n            const isXSTV2 = isXST && Buffer.compare(version, Buffer.from([0x02, 0x00, 0x00, 0x00])) === 0;\n            const treeField = isDecred ? input.tree || Buffer.from([0x00]) : Buffer.alloc(0);\n            const data = Buffer.concat([\n                input.prevout,\n                treeField,\n                isXSTV2 ? Buffer.from([0x00]) : createVarint(input.script.length),\n            ]);\n            yield getTrustedInputRaw(transport, data);\n            // iteration (eachSeries) ended\n            // TODO notify progress\n            // deferred.notify(\"input\");\n            // Reference: https://github.com/StealthSend/Stealth/commit/5be35d6c2c500b32ed82e5d6913d66d18a4b0a7f#diff-e8db9b851adc2422aadfffca88f14c91R566\n            yield (isDecred\n                ? processWholeScriptBlock(Buffer.concat([input.script, input.sequence]))\n                : isXSTV2\n                    ? processWholeScriptBlock(input.sequence)\n                    : processScriptBlocks(input.script, input.sequence));\n        }\n        yield getTrustedInputRaw(transport, createVarint(outputs.length));\n        for (const output of outputs) {\n            const data = Buffer.concat([\n                output.amount,\n                isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0),\n                createVarint(output.script.length),\n                output.script,\n            ]);\n            yield getTrustedInputRaw(transport, data);\n        }\n        const endData = [];\n        if (nExpiryHeight && nExpiryHeight.length > 0) {\n            endData.push(nExpiryHeight);\n        }\n        if (extraData && extraData.length > 0) {\n            endData.push(extraData);\n        }\n        let extraPart;\n        if (endData.length) {\n            const data = Buffer.concat(endData);\n            extraPart = isDecred ? data : Buffer.concat([createVarint(data.length), data]);\n        }\n        const res = yield processScriptBlocks(Buffer.concat([locktime, extraPart || Buffer.alloc(0)]));\n        invariant(res, \"missing result in processScriptBlocks\");\n        return res;\n    });\n}\n//# sourceMappingURL=getTrustedInput.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createVarint } from \"./varint\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function startUntrustedHashTransactionInputRaw(transport, newTransaction, firstRound, transactionData, bip143 = false, overwinter = false, additionals = []) {\n    const p2 = additionals.includes(\"cashaddr\")\n        ? 0x03\n        : bip143\n            ? additionals.includes(\"sapling\")\n                ? 0x05\n                : overwinter\n                    ? 0x04\n                    : 0x02\n            : 0x00;\n    return transport.send(0xe0, 0x44, firstRound ? 0x00 : 0x80, newTransaction ? p2 : 0x80, transactionData);\n}\nexport function startUntrustedHashTransactionInput(transport, newTransaction, transaction, inputs, bip143 = false, overwinter = false, additionals = [], useTrustedInputForSegwit = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let data = Buffer.concat([\n            transaction.version,\n            transaction.timestamp || Buffer.alloc(0),\n            transaction.nVersionGroupId || Buffer.alloc(0),\n            createVarint(transaction.inputs.length),\n        ]);\n        yield startUntrustedHashTransactionInputRaw(transport, newTransaction, true, data, bip143, overwinter, additionals);\n        let i = 0;\n        const isDecred = additionals.includes(\"decred\");\n        for (const input of transaction.inputs) {\n            let prefix;\n            const inputValue = inputs[i].value;\n            if (bip143) {\n                if (useTrustedInputForSegwit && inputs[i].trustedInput) {\n                    prefix = Buffer.from([0x01, inputValue.length]);\n                }\n                else {\n                    prefix = Buffer.from([0x02]);\n                }\n            }\n            else {\n                if (inputs[i].trustedInput) {\n                    prefix = Buffer.from([0x01, inputs[i].value.length]);\n                }\n                else {\n                    prefix = Buffer.from([0x00]);\n                }\n            }\n            data = Buffer.concat([\n                prefix,\n                inputValue,\n                isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n                createVarint(input.script.length),\n            ]);\n            yield startUntrustedHashTransactionInputRaw(transport, newTransaction, false, data, bip143, overwinter, additionals);\n            const scriptBlocks = [];\n            let offset = 0;\n            if (input.script.length === 0) {\n                scriptBlocks.push(input.sequence);\n            }\n            else {\n                while (offset !== input.script.length) {\n                    const blockSize = input.script.length - offset > MAX_SCRIPT_BLOCK\n                        ? MAX_SCRIPT_BLOCK\n                        : input.script.length - offset;\n                    if (offset + blockSize !== input.script.length) {\n                        scriptBlocks.push(input.script.slice(offset, offset + blockSize));\n                    }\n                    else {\n                        scriptBlocks.push(Buffer.concat([input.script.slice(offset, offset + blockSize), input.sequence]));\n                    }\n                    offset += blockSize;\n                }\n            }\n            for (const scriptBlock of scriptBlocks) {\n                yield startUntrustedHashTransactionInputRaw(transport, newTransaction, false, scriptBlock, bip143, overwinter, additionals);\n            }\n            i++;\n        }\n    });\n}\n//# sourceMappingURL=startUntrustedHashTransactionInput.js.map","import shajs from \"sha.js\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nexport function getTrustedInputBIP143(transport, indexLookup, transaction, additionals = []) {\n    if (!transaction) {\n        throw new Error(\"getTrustedInputBIP143: missing tx\");\n    }\n    const isDecred = additionals.includes(\"decred\");\n    if (isDecred) {\n        throw new Error(\"Decred does not implement BIP143\");\n    }\n    let hash = shajs(\"sha256\")\n        .update(shajs(\"sha256\").update(serializeTransaction(transaction, true)).digest())\n        .digest();\n    const data = Buffer.alloc(4);\n    data.writeUInt32LE(indexLookup, 0);\n    const { outputs, locktime } = transaction;\n    if (!outputs || !locktime) {\n        throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n    }\n    if (!outputs[indexLookup]) {\n        throw new Error(\"getTrustedInputBIP143: wrong index\");\n    }\n    hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n    return hash.toString(\"hex\");\n}\n//# sourceMappingURL=getTrustedInputBIP143.js.map","export function compressPublicKey(publicKey) {\n    const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n    const prefixBuffer = Buffer.alloc(1);\n    prefixBuffer[0] = prefix;\n    return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n}\n//# sourceMappingURL=compressPublicKey.js.map","import { bip32asBuffer } from \"./bip32\";\nexport function signTransaction(transport, path, lockTime, sigHashType, expiryHeight, additionals = []) {\n    const isDecred = additionals.includes(\"decred\");\n    const pathsBuffer = bip32asBuffer(path);\n    const lockTimeBuffer = Buffer.alloc(4);\n    lockTimeBuffer.writeUInt32BE(lockTime, 0);\n    let buffer = isDecred\n        ? Buffer.concat([\n            pathsBuffer,\n            lockTimeBuffer,\n            expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n            Buffer.from([sigHashType]),\n        ])\n        : Buffer.concat([pathsBuffer, Buffer.from([0x00]), lockTimeBuffer, Buffer.from([sigHashType])]);\n    if (expiryHeight && !isDecred) {\n        buffer = Buffer.concat([buffer, expiryHeight]);\n    }\n    return transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n        if (result.length > 0) {\n            result[0] = 0x30;\n            return result.slice(0, result.length - 2);\n        }\n        return result;\n    });\n}\n//# sourceMappingURL=signTransaction.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { bip32asBuffer } from \"./bip32\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function provideOutputFullChangePath(transport, path) {\n    const buffer = bip32asBuffer(path);\n    return transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n}\nexport function hashOutputFull(transport, outputScript, additionals = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let offset = 0;\n        const p1 = Number(0x80);\n        const isDecred = additionals.includes(\"decred\");\n        ///WARNING: Decred works only with one call (without chunking)\n        //TODO: test without this for Decred\n        if (isDecred) {\n            return transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n        }\n        while (offset < outputScript.length) {\n            const blockSize = offset + MAX_SCRIPT_BLOCK >= outputScript.length\n                ? outputScript.length - offset\n                : MAX_SCRIPT_BLOCK;\n            const p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n            const data = outputScript.slice(offset, offset + blockSize);\n            yield transport.send(0xe0, 0x4a, p1, 0x00, data);\n            offset += blockSize;\n        }\n    });\n}\n//# sourceMappingURL=finalizeInput.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport invariant from \"invariant\";\nexport const getAppAndVersion = (transport) => __awaiter(void 0, void 0, void 0, function* () {\n    const r = yield transport.send(0xb0, 0x01, 0x00, 0x00);\n    let i = 0;\n    const format = r[i++];\n    invariant(format === 1, \"getAppAndVersion: format not supported\");\n    const nameLength = r[i++];\n    const name = r.slice(i, (i += nameLength)).toString(\"ascii\");\n    const versionLength = r[i++];\n    const version = r.slice(i, (i += versionLength)).toString(\"ascii\");\n    const flagLength = r[i++];\n    const flags = r.slice(i, (i += flagLength));\n    return {\n        name,\n        version,\n        flags,\n    };\n});\nexport const checkIsBtcLegacy = (transport) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        // Call old btc API, it will throw an exception with new btc app. It is a workaround to differentiate new/old btc nano app\n        yield transport.send(0xe0, 0xc4, 0, 0);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n});\n//# sourceMappingURL=getAppAndVersion.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { log } from \"@ledgerhq/logs\";\nimport { hashPublicKey } from \"./hashPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { compressPublicKey } from \"./compressPublicKey\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull, provideOutputFullChangePath } from \"./finalizeInput\";\nimport { getAppAndVersion } from \"./getAppAndVersion\";\nimport { DEFAULT_LOCKTIME, DEFAULT_SEQUENCE, SIGHASH_ALL, OP_DUP, OP_HASH160, HASH_SIZE, OP_EQUALVERIFY, OP_CHECKSIG, } from \"./constants\";\nimport { shouldUseTrustedInputForSegwit } from \"./shouldUseTrustedInputForSegwit\";\nconst defaultsSignTransaction = {\n    lockTime: DEFAULT_LOCKTIME,\n    sigHashType: SIGHASH_ALL,\n    segwit: false,\n    additionals: [],\n    onDeviceStreaming: _e => { },\n    onDeviceSignatureGranted: () => { },\n    onDeviceSignatureRequested: () => { },\n};\nexport function createTransaction(transport, arg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const signTx = Object.assign(Object.assign({}, defaultsSignTransaction), arg);\n        const { inputs, associatedKeysets, changePath, outputScriptHex, lockTime, sigHashType, segwit, initialTimestamp, additionals, expiryHeight, onDeviceStreaming, onDeviceSignatureGranted, onDeviceSignatureRequested, } = signTx;\n        let useTrustedInputForSegwit = signTx.useTrustedInputForSegwit;\n        if (useTrustedInputForSegwit === undefined) {\n            try {\n                const a = yield getAppAndVersion(transport);\n                useTrustedInputForSegwit = shouldUseTrustedInputForSegwit(a);\n            }\n            catch (e) {\n                if (e.statusCode === 0x6d00) {\n                    useTrustedInputForSegwit = false;\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        // loop: 0 or 1 (before and after)\n        // i: index of the input being streamed\n        // i goes on 0...n, inluding n. in order for the progress value to go to 1\n        // we normalize the 2 loops to make a global percentage\n        const notify = (loop, i) => {\n            const { length } = inputs;\n            if (length < 3)\n                return; // there is not enough significant event to worth notifying (aka just use a spinner)\n            const index = length * loop + i;\n            const total = 2 * length;\n            const progress = index / total;\n            onDeviceStreaming({\n                progress,\n                total,\n                index,\n            });\n        };\n        const isDecred = additionals.includes(\"decred\");\n        const isZcash = additionals.includes(\"zcash\");\n        const isXST = additionals.includes(\"stealthcoin\");\n        const startTime = Date.now();\n        const sapling = additionals.includes(\"sapling\");\n        const bech32 = segwit && additionals.includes(\"bech32\");\n        const useBip143 = segwit ||\n            (!!additionals &&\n                (additionals.includes(\"abc\") ||\n                    additionals.includes(\"gold\") ||\n                    additionals.includes(\"bip143\"))) ||\n            (!!expiryHeight && !isDecred);\n        // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n        // associatedKeysets are provided as arrays of [path]\n        const lockTimeBuffer = Buffer.alloc(4);\n        lockTimeBuffer.writeUInt32LE(lockTime, 0);\n        const nullScript = Buffer.alloc(0);\n        const nullPrevout = Buffer.alloc(0);\n        const defaultVersion = Buffer.alloc(4);\n        !!expiryHeight && !isDecred\n            ? defaultVersion.writeUInt32LE(isZcash ? 0x80000005 : sapling ? 0x80000004 : 0x80000003, 0) // v5 format for zcash refer to https://zips.z.cash/zip-0225\n            : isXST\n                ? defaultVersion.writeUInt32LE(2, 0)\n                : defaultVersion.writeUInt32LE(1, 0);\n        // Default version to 2 for XST not to have timestamp\n        const trustedInputs = [];\n        const regularOutputs = [];\n        const signatures = [];\n        const publicKeys = [];\n        let firstRun = true;\n        const resuming = false;\n        const targetTransaction = {\n            inputs: [],\n            version: defaultVersion,\n            timestamp: Buffer.alloc(0),\n        };\n        const getTrustedInputCall = useBip143 && !useTrustedInputForSegwit ? getTrustedInputBIP143 : getTrustedInput;\n        const outputScript = Buffer.from(outputScriptHex, \"hex\");\n        notify(0, 0);\n        // first pass on inputs to get trusted inputs\n        for (const input of inputs) {\n            if (!resuming) {\n                const trustedInput = yield getTrustedInputCall(transport, input[1], input[0], additionals);\n                log(\"hw\", \"got trustedInput=\" + trustedInput);\n                const sequence = Buffer.alloc(4);\n                sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE, 0);\n                trustedInputs.push({\n                    trustedInput: true,\n                    value: Buffer.from(trustedInput, \"hex\"),\n                    sequence,\n                });\n            }\n            const { outputs } = input[0];\n            const index = input[1];\n            if (outputs && index <= outputs.length - 1) {\n                regularOutputs.push(outputs[index]);\n            }\n            if (expiryHeight && !isDecred) {\n                targetTransaction.nVersionGroupId = Buffer.from(\n                // nVersionGroupId is 0x26A7270A for zcash NU5 upgrade\n                // refer to https://github.com/zcash/zcash/blob/master/src/primitives/transaction.h\n                isZcash\n                    ? [0x0a, 0x27, 0xa7, 0x26]\n                    : sapling\n                        ? [0x85, 0x20, 0x2f, 0x89]\n                        : [0x70, 0x82, 0xc4, 0x03]);\n                targetTransaction.nExpiryHeight = expiryHeight;\n                // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n                // Overwinter : use nJoinSplit (1)\n                targetTransaction.extraData = Buffer.from(sapling ? [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] : [0x00]);\n            }\n            else if (isDecred) {\n                targetTransaction.nExpiryHeight = expiryHeight;\n            }\n        }\n        targetTransaction.inputs = inputs.map((input, idx) => {\n            const sequence = Buffer.alloc(4);\n            sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE, 0);\n            return {\n                script: isZcash ? regularOutputs[idx].script : nullScript,\n                prevout: nullPrevout,\n                sequence,\n            };\n        });\n        if (!resuming) {\n            // Collect public keys\n            const result = [];\n            for (let i = 0; i < inputs.length; i++) {\n                const r = yield getWalletPublicKey(transport, {\n                    path: associatedKeysets[i],\n                });\n                notify(0, i + 1);\n                result.push(r);\n            }\n            for (let i = 0; i < result.length; i++) {\n                publicKeys.push(compressPublicKey(Buffer.from(result[i].publicKey, \"hex\")));\n            }\n        }\n        if (initialTimestamp !== undefined) {\n            targetTransaction.timestamp = Buffer.alloc(4);\n            targetTransaction.timestamp.writeUInt32LE(Math.floor(initialTimestamp + (Date.now() - startTime) / 1000), 0);\n        }\n        onDeviceSignatureRequested();\n        if (useBip143) {\n            // Do the first run with all inputs\n            yield startUntrustedHashTransactionInput(transport, true, targetTransaction, trustedInputs, true, !!expiryHeight, additionals, useTrustedInputForSegwit);\n            if (!resuming && changePath) {\n                yield provideOutputFullChangePath(transport, changePath);\n            }\n            yield hashOutputFull(transport, outputScript);\n        }\n        if (!!expiryHeight && !isDecred) {\n            yield signTransaction(transport, \"\", lockTime, SIGHASH_ALL, expiryHeight);\n        }\n        // Do the second run with the individual transaction\n        for (let i = 0; i < inputs.length; i++) {\n            const input = inputs[i];\n            const script = inputs[i].length >= 3 && typeof input[2] === \"string\"\n                ? Buffer.from(input[2], \"hex\")\n                : !segwit\n                    ? regularOutputs[i].script\n                    : Buffer.concat([\n                        Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n                        hashPublicKey(publicKeys[i]),\n                        Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]),\n                    ]);\n            const pseudoTX = Object.assign({}, targetTransaction);\n            const pseudoTrustedInputs = useBip143 ? [trustedInputs[i]] : trustedInputs;\n            if (useBip143) {\n                pseudoTX.inputs = [Object.assign(Object.assign({}, pseudoTX.inputs[i]), { script })];\n            }\n            else {\n                pseudoTX.inputs[i].script = script;\n            }\n            yield startUntrustedHashTransactionInput(transport, !useBip143 && firstRun, pseudoTX, pseudoTrustedInputs, useBip143, !!expiryHeight && !isDecred, additionals, useTrustedInputForSegwit);\n            if (!useBip143) {\n                if (!resuming && changePath) {\n                    yield provideOutputFullChangePath(transport, changePath);\n                }\n                yield hashOutputFull(transport, outputScript, additionals);\n            }\n            if (firstRun) {\n                onDeviceSignatureGranted();\n                notify(1, 0);\n            }\n            const signature = yield signTransaction(transport, associatedKeysets[i], lockTime, sigHashType, expiryHeight, additionals);\n            notify(1, i + 1);\n            signatures.push(signature);\n            targetTransaction.inputs[i].script = nullScript;\n            if (firstRun) {\n                firstRun = false;\n            }\n        }\n        // Populate the final input scripts\n        for (let i = 0; i < inputs.length; i++) {\n            if (segwit) {\n                targetTransaction.witness = Buffer.alloc(0);\n                if (!bech32) {\n                    targetTransaction.inputs[i].script = Buffer.concat([\n                        Buffer.from(\"160014\", \"hex\"),\n                        hashPublicKey(publicKeys[i]),\n                    ]);\n                }\n            }\n            else {\n                const signatureSize = Buffer.alloc(1);\n                const keySize = Buffer.alloc(1);\n                signatureSize[0] = signatures[i].length;\n                keySize[0] = publicKeys[i].length;\n                targetTransaction.inputs[i].script = Buffer.concat([\n                    signatureSize,\n                    signatures[i],\n                    keySize,\n                    publicKeys[i],\n                ]);\n            }\n            const offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;\n            targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 0x24);\n        }\n        targetTransaction.locktime = lockTimeBuffer;\n        let result = Buffer.concat([\n            serializeTransaction(targetTransaction, false, targetTransaction.timestamp, additionals),\n            outputScript,\n        ]);\n        if (segwit && !isDecred) {\n            let witness = Buffer.alloc(0);\n            for (let i = 0; i < inputs.length; i++) {\n                const tmpScriptData = Buffer.concat([\n                    Buffer.from(\"02\", \"hex\"),\n                    Buffer.from([signatures[i].length]),\n                    signatures[i],\n                    Buffer.from([publicKeys[i].length]),\n                    publicKeys[i],\n                ]);\n                witness = Buffer.concat([witness, tmpScriptData]);\n            }\n            result = Buffer.concat([result, witness]);\n        }\n        // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n        if (!isZcash) {\n            result = Buffer.concat([result, lockTimeBuffer]);\n            if (expiryHeight) {\n                result = Buffer.concat([\n                    result,\n                    targetTransaction.nExpiryHeight || Buffer.alloc(0),\n                    targetTransaction.extraData || Buffer.alloc(0),\n                ]);\n            }\n        }\n        if (isDecred) {\n            let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n            inputs.forEach((input, inputIndex) => {\n                decredWitness = Buffer.concat([\n                    decredWitness,\n                    Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n                    Buffer.from([0x00, 0x00, 0x00, 0x00]),\n                    Buffer.from([0xff, 0xff, 0xff, 0xff]),\n                    Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n                    targetTransaction.inputs[inputIndex].script,\n                ]);\n            });\n            result = Buffer.concat([result, decredWitness]);\n        }\n        if (isZcash) {\n            result = Buffer.concat([result, Buffer.from([0x00, 0x00, 0x00])]);\n        }\n        return result.toString(\"hex\");\n    });\n}\n//# sourceMappingURL=createTransaction.js.map","import semver from \"semver\";\nexport function shouldUseTrustedInputForSegwit({ version, name, }) {\n    if (name === \"Decred\")\n        return false;\n    if (name === \"Exchange\")\n        return true;\n    return semver.gte(version, \"1.4.0\");\n}\n//# sourceMappingURL=shouldUseTrustedInputForSegwit.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport bippath from \"bip32-path\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function signMessage(transport, { path, messageHex, }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const paths = bippath.fromString(path).toPathArray();\n        const message = Buffer.from(messageHex, \"hex\");\n        let offset = 0;\n        while (offset !== message.length) {\n            const maxChunkSize = offset === 0 ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4 : MAX_SCRIPT_BLOCK;\n            const chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n            const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);\n            if (offset === 0) {\n                buffer[0] = paths.length;\n                paths.forEach((element, index) => {\n                    buffer.writeUInt32BE(element, 1 + 4 * index);\n                });\n                buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n                message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);\n            }\n            else {\n                message.copy(buffer, 0, offset, offset + chunkSize);\n            }\n            yield transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n            offset += chunkSize;\n        }\n        const res = yield transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n        const v = res[0] - 0x30;\n        let r = res.slice(4, 4 + res[3]);\n        if (r[0] === 0) {\n            r = r.slice(1);\n        }\n        r = r.toString(\"hex\");\n        offset = 4 + res[3] + 2;\n        let s = res.slice(offset, offset + res[offset - 1]);\n        if (s[0] === 0) {\n            s = s.slice(1);\n        }\n        s = s.toString(\"hex\");\n        return {\n            v,\n            r,\n            s,\n        };\n    });\n}\n//# sourceMappingURL=signMessage.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport bs58 from \"bs58\";\nimport RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nimport { createTransaction } from \"./createTransaction\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport { pathArrayToString, pathStringToArray } from \"./bip32\";\nimport { signMessage } from \"./signMessage\";\n/**\n * @class BtcOld\n * @description This Bitcoin old API is compatible with versions of the Bitcoin nano app that are earlier than 2.1.0\n *\n */\nexport default class BtcOld {\n    constructor(transport) {\n        this.transport = transport;\n        this.derivationsCache = {};\n    }\n    derivatePath(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.derivationsCache[path])\n                return this.derivationsCache[path];\n            const res = yield getWalletPublicKey(this.transport, {\n                path,\n            });\n            this.derivationsCache[path] = res;\n            return res;\n        });\n    }\n    getWalletXpub({ path, xpubVersion, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pathElements = pathStringToArray(path);\n            const parentPath = pathElements.slice(0, -1);\n            const parentDerivation = yield this.derivatePath(pathArrayToString(parentPath));\n            const accountDerivation = yield this.derivatePath(path);\n            const fingerprint = makeFingerprint(compressPublicKeySECP256(Buffer.from(parentDerivation.publicKey, \"hex\")));\n            const xpub = makeXpub(xpubVersion, pathElements.length, fingerprint, pathElements[pathElements.length - 1], Buffer.from(accountDerivation.chainCode, \"hex\"), compressPublicKeySECP256(Buffer.from(accountDerivation.publicKey, \"hex\")));\n            return xpub;\n        });\n    }\n    /**\n     * @param path a BIP 32 path\n     * @param options an object with optional these fields:\n     *\n     * - verify (boolean) will ask user to confirm the address on the device\n     *\n     * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n     *\n     * NB The normal usage is to use:\n     *\n     * - legacy format with 44' paths\n     *\n     * - p2sh format with 49' paths\n     *\n     * - bech32 format with 84' paths\n     *\n     * - bech32m format with 86' paths\n     *\n     * - cashaddr in case of Bitcoin Cash\n     *\n     * @example\n     * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n     * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n     */\n    getWalletPublicKey(path, opts) {\n        if ((opts === null || opts === void 0 ? void 0 : opts.format) === \"bech32m\") {\n            throw new Error(\"Unsupported address format bech32m\");\n        }\n        return getWalletPublicKey(this.transport, Object.assign(Object.assign({}, opts), { path }));\n    }\n    /**\n     * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n     * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n     *\n     * * transaction is the previously computed transaction object for this UTXO\n     * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n     * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n     * * sequence is the sequence number to use for this input (when using RBF), or non present\n     * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n     * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n     * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n     * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n     * @param sigHashType is the hash type of the transaction to sign, or default (all)\n     * @param segwit is an optional boolean indicating wether to use segwit or not\n     * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n     * @param additionals list of additionnal options\n     *\n     * - \"bech32\" for spending native segwit outputs\n     * - \"abc\" for bch\n     * - \"gold\" for btg\n     * - \"decred\" for decred\n     * - \"zcash\" for zcash\n     * - \"bipxxx\" for using BIPxxx\n     * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n     * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n     * @param useTrustedInputForSegwit trust inputs for segwit transactions\n     * @return the signed transaction ready to be broadcast\n     * @example\n    btc.createTransaction({\n     inputs: [ [tx1, 1] ],\n     associatedKeysets: [\"0'/0/0\"],\n     outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n    }).then(res => ...);\n     */\n    createPaymentTransaction(arg) {\n        if (arguments.length > 1) {\n            throw new Error(\"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\");\n        }\n        return createTransaction(this.transport, arg);\n    }\n    signMessage({ path, messageHex }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return signMessage(this.transport, {\n                path,\n                messageHex,\n            });\n        });\n    }\n}\nfunction makeFingerprint(compressedPubKey) {\n    return hash160(compressedPubKey).slice(0, 4);\n}\nfunction asBufferUInt32BE(n) {\n    const buf = Buffer.allocUnsafe(4);\n    buf.writeUInt32BE(n, 0);\n    return buf;\n}\nconst compressPublicKeySECP256 = (publicKey) => Buffer.concat([Buffer.from([0x02 + (publicKey[64] & 0x01)]), publicKey.slice(1, 33)]);\nfunction makeXpub(version, depth, parentFingerprint, index, chainCode, pubKey) {\n    const indexBuffer = asBufferUInt32BE(index);\n    indexBuffer[0] |= 0x80;\n    const extendedKeyBytes = Buffer.concat([\n        asBufferUInt32BE(version),\n        Buffer.from([depth]),\n        parentFingerprint,\n        indexBuffer,\n        chainCode,\n        pubKey,\n    ]);\n    const checksum = hash256(extendedKeyBytes).slice(0, 4);\n    return bs58.encode(Buffer.concat([extendedKeyBytes, checksum]));\n}\nfunction sha256(buffer) {\n    return sha(\"sha256\").update(buffer).digest();\n}\nfunction hash256(buffer) {\n    return sha256(sha256(buffer));\n}\nfunction ripemd160(buffer) {\n    return new RIPEMD160().update(buffer).digest();\n}\nfunction hash160(buffer) {\n    return ripemd160(sha256(buffer));\n}\n//# sourceMappingURL=BtcOld.js.map","import { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n/**\n * This implements \"Merkelized Maps\", documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md#merkleized-maps\n *\n * A merkelized map consist of two merkle trees, one for the keys of\n * a map and one for the values of the same map, thus the two merkle\n * trees have the same shape. The commitment is the number elements\n * in the map followed by the keys' merkle root followed by the\n * values' merkle root.\n */\nexport class MerkleMap {\n    /**\n     * @param keys Sorted list of (unhashed) keys\n     * @param values values, in corresponding order as the keys, and of equal length\n     */\n    constructor(keys, values) {\n        if (keys.length != values.length) {\n            throw new Error(\"keys and values should have the same length\");\n        }\n        // Sanity check: verify that keys are actually sorted and with no duplicates\n        for (let i = 0; i < keys.length - 1; i++) {\n            if (keys[i].toString(\"hex\") >= keys[i + 1].toString(\"hex\")) {\n                throw new Error(\"keys must be in strictly increasing order\");\n            }\n        }\n        this.keys = keys;\n        this.keysTree = new Merkle(keys.map(k => hashLeaf(k)));\n        this.values = values;\n        this.valuesTree = new Merkle(values.map(v => hashLeaf(v)));\n    }\n    commitment() {\n        // returns a buffer between 65 and 73 (included) bytes long\n        return Buffer.concat([\n            createVarint(this.keys.length),\n            this.keysTree.getRoot(),\n            this.valuesTree.getRoot(),\n        ]);\n    }\n}\n//# sourceMappingURL=merkleMap.js.map","import { MerkleMap } from \"./merkleMap\";\nimport { PsbtV2 } from \"./psbtv2\";\n/**\n * This class merkelizes a PSBTv2, by merkelizing the different\n * maps of the psbt. This is used during the transaction signing process,\n * where the hardware app can request specific parts of the psbt from the\n * client code and be sure that the response data actually belong to the psbt.\n * The reason for this is the limited amount of memory available to the app,\n * so it can't always store the full psbt in memory.\n *\n * The signing process is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#sign_psbt\n */\nexport class MerkelizedPsbt extends PsbtV2 {\n    constructor(psbt) {\n        super();\n        this.inputMerkleMaps = [];\n        this.outputMerkleMaps = [];\n        psbt.copy(this);\n        this.globalMerkleMap = MerkelizedPsbt.createMerkleMap(this.globalMap);\n        for (let i = 0; i < this.getGlobalInputCount(); i++) {\n            this.inputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));\n        }\n        this.inputMapCommitments = [...this.inputMerkleMaps.values()].map(v => v.commitment());\n        for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n            this.outputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));\n        }\n        this.outputMapCommitments = [...this.outputMerkleMaps.values()].map(v => v.commitment());\n    }\n    // These public functions are for MerkelizedPsbt.\n    getGlobalSize() {\n        return this.globalMap.size;\n    }\n    getGlobalKeysValuesRoot() {\n        return this.globalMerkleMap.commitment();\n    }\n    static createMerkleMap(map) {\n        const sortedKeysStrings = [...map.keys()].sort();\n        const values = sortedKeysStrings.map(k => {\n            const v = map.get(k);\n            if (!v) {\n                throw new Error(\"No value for key \" + k);\n            }\n            return v;\n        });\n        const sortedKeys = sortedKeysStrings.map(k => Buffer.from(k, \"hex\"));\n        const merkleMap = new MerkleMap(sortedKeys, values);\n        return merkleMap;\n    }\n}\n//# sourceMappingURL=merkelizedPsbt.js.map","import { crypto } from \"bitcoinjs-lib\";\nimport { BufferReader } from \"../buffertools\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\nvar ClientCommandCode;\n(function (ClientCommandCode) {\n    ClientCommandCode[ClientCommandCode[\"YIELD\"] = 16] = \"YIELD\";\n    ClientCommandCode[ClientCommandCode[\"GET_PREIMAGE\"] = 64] = \"GET_PREIMAGE\";\n    ClientCommandCode[ClientCommandCode[\"GET_MERKLE_LEAF_PROOF\"] = 65] = \"GET_MERKLE_LEAF_PROOF\";\n    ClientCommandCode[ClientCommandCode[\"GET_MERKLE_LEAF_INDEX\"] = 66] = \"GET_MERKLE_LEAF_INDEX\";\n    ClientCommandCode[ClientCommandCode[\"GET_MORE_ELEMENTS\"] = 160] = \"GET_MORE_ELEMENTS\";\n})(ClientCommandCode || (ClientCommandCode = {}));\nclass ClientCommand {\n}\nexport class YieldCommand extends ClientCommand {\n    constructor(results, progressCallback) {\n        super();\n        this.progressCallback = progressCallback;\n        this.code = ClientCommandCode.YIELD;\n        this.results = results;\n    }\n    execute(request) {\n        this.results.push(Buffer.from(request.subarray(1)));\n        this.progressCallback();\n        return Buffer.from(\"\");\n    }\n}\nexport class GetPreimageCommand extends ClientCommand {\n    constructor(known_preimages, queue) {\n        super();\n        this.code = ClientCommandCode.GET_PREIMAGE;\n        this.known_preimages = known_preimages;\n        this.queue = queue;\n    }\n    execute(request) {\n        const req = Buffer.from(request.subarray(1));\n        // we expect no more data to read\n        if (req.length != 1 + 32) {\n            throw new Error(\"Invalid request, unexpected trailing data\");\n        }\n        if (req[0] != 0) {\n            throw new Error(\"Unsupported request, the first byte should be 0\");\n        }\n        // read the hash\n        const hash = Buffer.alloc(32);\n        for (let i = 0; i < 32; i++) {\n            hash[i] = req[1 + i];\n        }\n        const req_hash_hex = hash.toString(\"hex\");\n        const known_preimage = this.known_preimages.get(req_hash_hex);\n        if (known_preimage != undefined) {\n            const preimage_len_varint = createVarint(known_preimage.length);\n            // We can send at most 255 - len(preimage_len_out) - 1 bytes in a single message;\n            // the rest will be stored in the queue for GET_MORE_ELEMENTS\n            const max_payload_size = 255 - preimage_len_varint.length - 1;\n            const payload_size = Math.min(max_payload_size, known_preimage.length);\n            if (payload_size < known_preimage.length) {\n                for (let i = payload_size; i < known_preimage.length; i++) {\n                    this.queue.push(Buffer.from([known_preimage[i]]));\n                }\n            }\n            return Buffer.concat([\n                preimage_len_varint,\n                Buffer.from([payload_size]),\n                Buffer.from(known_preimage.subarray(0, payload_size)),\n            ]);\n        }\n        throw Error(`Requested unknown preimage for: ${req_hash_hex}`);\n    }\n}\nexport class GetMerkleLeafProofCommand extends ClientCommand {\n    constructor(known_trees, queue) {\n        super();\n        this.code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;\n        this.known_trees = known_trees;\n        this.queue = queue;\n    }\n    execute(request) {\n        const req = Buffer.from(request.subarray(1));\n        if (req.length < 32 + 1 + 1) {\n            throw new Error(\"Invalid request, expected at least 34 bytes\");\n        }\n        const reqBuf = new BufferReader(req);\n        const hash = reqBuf.readSlice(32);\n        const hash_hex = hash.toString(\"hex\");\n        let tree_size;\n        let leaf_index;\n        try {\n            tree_size = reqBuf.readVarInt();\n            leaf_index = reqBuf.readVarInt();\n        }\n        catch (e) {\n            throw new Error(\"Invalid request, couldn't parse tree_size or leaf_index\");\n        }\n        const mt = this.known_trees.get(hash_hex);\n        if (!mt) {\n            throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);\n        }\n        if (leaf_index >= tree_size || mt.size() != tree_size) {\n            throw Error(\"Invalid index or tree size.\");\n        }\n        if (this.queue.length != 0) {\n            throw Error(\"This command should not execute when the queue is not empty.\");\n        }\n        const proof = mt.getProof(leaf_index);\n        const n_response_elements = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), proof.length);\n        const n_leftover_elements = proof.length - n_response_elements;\n        // Add to the queue any proof elements that do not fit the response\n        if (n_leftover_elements > 0) {\n            this.queue.push(...proof.slice(-n_leftover_elements));\n        }\n        return Buffer.concat([\n            mt.getLeafHash(leaf_index),\n            Buffer.from([proof.length]),\n            Buffer.from([n_response_elements]),\n            ...proof.slice(0, n_response_elements),\n        ]);\n    }\n}\nexport class GetMerkleLeafIndexCommand extends ClientCommand {\n    constructor(known_trees) {\n        super();\n        this.code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;\n        this.known_trees = known_trees;\n    }\n    execute(request) {\n        const req = Buffer.from(request.subarray(1));\n        if (req.length != 32 + 32) {\n            throw new Error(\"Invalid request, unexpected trailing data\");\n        }\n        // read the root hash\n        const root_hash = Buffer.alloc(32);\n        for (let i = 0; i < 32; i++) {\n            root_hash[i] = req.readUInt8(i);\n        }\n        const root_hash_hex = root_hash.toString(\"hex\");\n        // read the leaf hash\n        const leef_hash = Buffer.alloc(32);\n        for (let i = 0; i < 32; i++) {\n            leef_hash[i] = req.readUInt8(32 + i);\n        }\n        const leef_hash_hex = leef_hash.toString(\"hex\");\n        const mt = this.known_trees.get(root_hash_hex);\n        if (!mt) {\n            throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);\n        }\n        let leaf_index = 0;\n        let found = 0;\n        for (let i = 0; i < mt.size(); i++) {\n            if (mt.getLeafHash(i).toString(\"hex\") == leef_hash_hex) {\n                found = 1;\n                leaf_index = i;\n                break;\n            }\n        }\n        return Buffer.concat([Buffer.from([found]), createVarint(leaf_index)]);\n    }\n}\nexport class GetMoreElementsCommand extends ClientCommand {\n    constructor(queue) {\n        super();\n        this.code = ClientCommandCode.GET_MORE_ELEMENTS;\n        this.queue = queue;\n    }\n    execute(request) {\n        if (request.length != 1) {\n            throw new Error(\"Invalid request, unexpected trailing data\");\n        }\n        if (this.queue.length === 0) {\n            throw new Error(\"No elements to get\");\n        }\n        // all elements should have the same length\n        const element_len = this.queue[0].length;\n        if (this.queue.some(el => el.length != element_len)) {\n            throw new Error(\"The queue contains elements with different byte length, which is not expected\");\n        }\n        const max_elements = Math.floor(253 / element_len);\n        const n_returned_elements = Math.min(max_elements, this.queue.length);\n        const returned_elements = this.queue.splice(0, n_returned_elements);\n        return Buffer.concat([\n            Buffer.from([n_returned_elements]),\n            Buffer.from([element_len]),\n            ...returned_elements,\n        ]);\n    }\n}\n/**\n * This class will dispatch a client command coming from the hardware device to\n * the appropriate client command implementation. Those client commands\n * typically requests data from a merkle tree or merkelized maps.\n *\n * A ClientCommandInterpreter is prepared by adding the merkle trees and\n * merkelized maps it should be able to serve to the hardware device. This class\n * doesn't know anything about the semantics of the data it holds, it just\n * serves merkle data. It doesn't even know in what context it is being\n * executed, ie SignPsbt, getWalletAddress, etc.\n *\n * If the command yelds results to the client, as signPsbt does, the yielded\n * data will be accessible after the command completed by calling getYielded(),\n * which will return the yields in the same order as they came in.\n */\nexport class ClientCommandInterpreter {\n    constructor(progressCallback) {\n        this.roots = new Map();\n        this.preimages = new Map();\n        this.yielded = [];\n        this.queue = [];\n        this.commands = new Map();\n        const commands = [\n            new YieldCommand(this.yielded, progressCallback),\n            new GetPreimageCommand(this.preimages, this.queue),\n            new GetMerkleLeafIndexCommand(this.roots),\n            new GetMerkleLeafProofCommand(this.roots, this.queue),\n            new GetMoreElementsCommand(this.queue),\n        ];\n        for (const cmd of commands) {\n            if (this.commands.has(cmd.code)) {\n                throw new Error(`Multiple commands with code ${cmd.code}`);\n            }\n            this.commands.set(cmd.code, cmd);\n        }\n    }\n    getYielded() {\n        return this.yielded;\n    }\n    addKnownPreimage(preimage) {\n        this.preimages.set(crypto.sha256(preimage).toString(\"hex\"), preimage);\n    }\n    addKnownList(elements) {\n        for (const el of elements) {\n            const preimage = Buffer.concat([Buffer.from([0]), el]);\n            this.addKnownPreimage(preimage);\n        }\n        const mt = new Merkle(elements.map(el => hashLeaf(el)));\n        this.roots.set(mt.getRoot().toString(\"hex\"), mt);\n    }\n    addKnownMapping(mm) {\n        this.addKnownList(mm.keys);\n        this.addKnownList(mm.values);\n    }\n    execute(request) {\n        if (request.length == 0) {\n            throw new Error(\"Unexpected empty command\");\n        }\n        const cmdCode = request[0];\n        const cmd = this.commands.get(cmdCode);\n        if (!cmd) {\n            throw new Error(`Unexpected command code ${cmdCode}`);\n        }\n        return cmd.execute(request);\n    }\n}\n//# sourceMappingURL=clientCommands.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { pathElementsToBuffer } from \"../bip32\";\nimport { MerkelizedPsbt } from \"./merkelizedPsbt\";\nimport { ClientCommandInterpreter } from \"./clientCommands\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\nconst CLA_BTC = 0xe1;\nconst CLA_FRAMEWORK = 0xf8;\nvar BitcoinIns;\n(function (BitcoinIns) {\n    BitcoinIns[BitcoinIns[\"GET_PUBKEY\"] = 0] = \"GET_PUBKEY\";\n    // GET_ADDRESS = 0x01, // Removed from app\n    BitcoinIns[BitcoinIns[\"REGISTER_WALLET\"] = 2] = \"REGISTER_WALLET\";\n    BitcoinIns[BitcoinIns[\"GET_WALLET_ADDRESS\"] = 3] = \"GET_WALLET_ADDRESS\";\n    BitcoinIns[BitcoinIns[\"SIGN_PSBT\"] = 4] = \"SIGN_PSBT\";\n    BitcoinIns[BitcoinIns[\"GET_MASTER_FINGERPRINT\"] = 5] = \"GET_MASTER_FINGERPRINT\";\n    BitcoinIns[BitcoinIns[\"SIGN_MESSAGE\"] = 16] = \"SIGN_MESSAGE\";\n})(BitcoinIns || (BitcoinIns = {}));\nvar FrameworkIns;\n(function (FrameworkIns) {\n    FrameworkIns[FrameworkIns[\"CONTINUE_INTERRUPTED\"] = 1] = \"CONTINUE_INTERRUPTED\";\n})(FrameworkIns || (FrameworkIns = {}));\n/**\n * This class encapsulates the APDU protocol documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n */\nexport class AppClient {\n    constructor(transport) {\n        this.transport = transport;\n    }\n    makeRequest(ins, data, cci) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let response = yield this.transport.send(CLA_BTC, ins, 0, 0, data, [0x9000, 0xe000]);\n            while (response.readUInt16BE(response.length - 2) === 0xe000) {\n                if (!cci) {\n                    throw new Error(\"Unexpected SW_INTERRUPTED_EXECUTION\");\n                }\n                const hwRequest = response.slice(0, -2);\n                const commandResponse = cci.execute(hwRequest);\n                response = yield this.transport.send(CLA_FRAMEWORK, FrameworkIns.CONTINUE_INTERRUPTED, 0, 0, commandResponse, [0x9000, 0xe000]);\n            }\n            return response.slice(0, -2); // drop the status word (can only be 0x9000 at this point)\n        });\n    }\n    getExtendedPubkey(display, pathElements) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (pathElements.length > 6) {\n                throw new Error(\"Path too long. At most 6 levels allowed.\");\n            }\n            const response = yield this.makeRequest(BitcoinIns.GET_PUBKEY, Buffer.concat([Buffer.from(display ? [1] : [0]), pathElementsToBuffer(pathElements)]));\n            return response.toString(\"ascii\");\n        });\n    }\n    getWalletAddress(walletPolicy, walletHMAC, change, addressIndex, display) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (change !== 0 && change !== 1)\n                throw new Error(\"Change can only be 0 or 1\");\n            if (addressIndex < 0 || !Number.isInteger(addressIndex))\n                throw new Error(\"Invalid address index\");\n            if (walletHMAC != null && walletHMAC.length != 32) {\n                throw new Error(\"Invalid HMAC length\");\n            }\n            const clientInterpreter = new ClientCommandInterpreter(() => { });\n            clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n            clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n            const addressIndexBuffer = Buffer.alloc(4);\n            addressIndexBuffer.writeUInt32BE(addressIndex, 0);\n            const response = yield this.makeRequest(BitcoinIns.GET_WALLET_ADDRESS, Buffer.concat([\n                Buffer.from(display ? [1] : [0]),\n                walletPolicy.getWalletId(),\n                walletHMAC || Buffer.alloc(32, 0),\n                Buffer.from([change]),\n                addressIndexBuffer,\n            ]), clientInterpreter);\n            return response.toString(\"ascii\");\n        });\n    }\n    signPsbt(psbt, walletPolicy, walletHMAC, progressCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const merkelizedPsbt = new MerkelizedPsbt(psbt);\n            if (walletHMAC != null && walletHMAC.length != 32) {\n                throw new Error(\"Invalid HMAC length\");\n            }\n            const clientInterpreter = new ClientCommandInterpreter(progressCallback);\n            // prepare ClientCommandInterpreter\n            clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n            clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n            clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);\n            for (const map of merkelizedPsbt.inputMerkleMaps) {\n                clientInterpreter.addKnownMapping(map);\n            }\n            for (const map of merkelizedPsbt.outputMerkleMaps) {\n                clientInterpreter.addKnownMapping(map);\n            }\n            clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);\n            const inputMapsRoot = new Merkle(merkelizedPsbt.inputMapCommitments.map(m => hashLeaf(m))).getRoot();\n            clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);\n            const outputMapsRoot = new Merkle(merkelizedPsbt.outputMapCommitments.map(m => hashLeaf(m))).getRoot();\n            yield this.makeRequest(BitcoinIns.SIGN_PSBT, Buffer.concat([\n                merkelizedPsbt.getGlobalKeysValuesRoot(),\n                createVarint(merkelizedPsbt.getGlobalInputCount()),\n                inputMapsRoot,\n                createVarint(merkelizedPsbt.getGlobalOutputCount()),\n                outputMapsRoot,\n                walletPolicy.getWalletId(),\n                walletHMAC || Buffer.alloc(32, 0),\n            ]), clientInterpreter);\n            const yielded = clientInterpreter.getYielded();\n            const ret = new Map();\n            for (const inputAndSig of yielded) {\n                ret.set(inputAndSig[0], inputAndSig.slice(1));\n            }\n            return ret;\n        });\n    }\n    getMasterFingerprint() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));\n        });\n    }\n    signMessage(message, pathElements) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (pathElements.length > 6) {\n                throw new Error(\"Path too long. At most 6 levels allowed.\");\n            }\n            const clientInterpreter = new ClientCommandInterpreter(() => { });\n            // prepare ClientCommandInterpreter\n            const nChunks = Math.ceil(message.length / 64);\n            const chunks = [];\n            for (let i = 0; i < nChunks; i++) {\n                chunks.push(message.subarray(64 * i, 64 * i + 64));\n            }\n            clientInterpreter.addKnownList(chunks);\n            const chunksRoot = new Merkle(chunks.map(m => hashLeaf(m))).getRoot();\n            const response = yield this.makeRequest(BitcoinIns.SIGN_MESSAGE, Buffer.concat([pathElementsToBuffer(pathElements), createVarint(message.length), chunksRoot]), clientInterpreter);\n            return response.toString(\"base64\");\n        });\n    }\n}\n//# sourceMappingURL=appClient.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull } from \"./finalizeInput\";\nimport { DEFAULT_LOCKTIME, DEFAULT_VERSION, DEFAULT_SEQUENCE, SIGHASH_ALL } from \"./constants\";\nconst defaultArg = {\n    lockTime: DEFAULT_LOCKTIME,\n    sigHashType: SIGHASH_ALL,\n    segwit: false,\n    transactionVersion: DEFAULT_VERSION,\n};\nexport function signP2SHTransaction(transport, arg) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { inputs, associatedKeysets, outputScriptHex, lockTime, sigHashType, segwit, transactionVersion, } = Object.assign(Object.assign({}, defaultArg), arg);\n        // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n        // associatedKeysets are provided as arrays of [path]\n        const nullScript = Buffer.alloc(0);\n        const nullPrevout = Buffer.alloc(0);\n        const defaultVersion = Buffer.alloc(4);\n        defaultVersion.writeUInt32LE(transactionVersion, 0);\n        const trustedInputs = [];\n        const regularOutputs = [];\n        const signatures = [];\n        let firstRun = true;\n        const resuming = false;\n        const targetTransaction = {\n            inputs: [],\n            version: defaultVersion,\n        };\n        const getTrustedInputCall = segwit ? getTrustedInputBIP143 : getTrustedInput;\n        const outputScript = Buffer.from(outputScriptHex, \"hex\");\n        for (const input of inputs) {\n            if (!resuming) {\n                const trustedInput = yield getTrustedInputCall(transport, input[1], input[0]);\n                const sequence = Buffer.alloc(4);\n                sequence.writeUInt32LE(input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE, 0);\n                trustedInputs.push({\n                    trustedInput: false,\n                    value: segwit\n                        ? Buffer.from(trustedInput, \"hex\")\n                        : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n                    sequence,\n                });\n            }\n            const { outputs } = input[0];\n            const index = input[1];\n            if (outputs && index <= outputs.length - 1) {\n                regularOutputs.push(outputs[index]);\n            }\n        }\n        // Pre-build the target transaction\n        for (let i = 0; i < inputs.length; i++) {\n            const sequence = Buffer.alloc(4);\n            sequence.writeUInt32LE(inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n                ? inputs[i][3]\n                : DEFAULT_SEQUENCE, 0);\n            targetTransaction.inputs.push({\n                script: nullScript,\n                prevout: nullPrevout,\n                sequence,\n            });\n        }\n        if (segwit) {\n            yield startUntrustedHashTransactionInput(transport, true, targetTransaction, trustedInputs, true);\n            yield hashOutputFull(transport, outputScript);\n        }\n        for (let i = 0; i < inputs.length; i++) {\n            const input = inputs[i];\n            const script = inputs[i].length >= 3 && typeof input[2] === \"string\"\n                ? Buffer.from(input[2], \"hex\")\n                : regularOutputs[i].script;\n            const pseudoTX = Object.assign({}, targetTransaction);\n            const pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n            if (segwit) {\n                pseudoTX.inputs = [Object.assign(Object.assign({}, pseudoTX.inputs[i]), { script })];\n            }\n            else {\n                pseudoTX.inputs[i].script = script;\n            }\n            yield startUntrustedHashTransactionInput(transport, !segwit && firstRun, pseudoTX, pseudoTrustedInputs, segwit);\n            if (!segwit) {\n                yield hashOutputFull(transport, outputScript);\n            }\n            const signature = yield signTransaction(transport, associatedKeysets[i], lockTime, sigHashType);\n            signatures.push(segwit ? signature.toString(\"hex\") : signature.slice(0, signature.length - 1).toString(\"hex\"));\n            targetTransaction.inputs[i].script = nullScript;\n            if (firstRun) {\n                firstRun = false;\n            }\n        }\n        return signatures;\n    });\n}\n//# sourceMappingURL=signP2SHTransaction.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport semver from \"semver\";\nimport BtcNew from \"./BtcNew\";\nimport BtcOld from \"./BtcOld\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { AppClient } from \"./newops/appClient\";\nimport { serializeTransactionOutputs } from \"./serializeTransaction\";\nimport { splitTransaction } from \"./splitTransaction\";\nimport { signP2SHTransaction } from \"./signP2SHTransaction\";\nimport { checkIsBtcLegacy, getAppAndVersion } from \"./getAppAndVersion\";\n/**\n * @class Btc\n * @description Bitcoin API.\n * @param transport The transport layer used for communication.\n * @param scrambleKey This parameter is deprecated and no longer needed.\n * @param currency The currency to use, defaults to \"bitcoin\".\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc({ transport, currency: \"bitcoin\" });\n */\nexport default class Btc {\n    constructor({ transport, scrambleKey = \"BTC\", currency = \"bitcoin\", }) {\n        this._transport = transport;\n        this._transport.decorateAppAPIMethods(this, [\n            \"getWalletXpub\",\n            \"getWalletPublicKey\",\n            \"signP2SHTransaction\",\n            \"signMessage\",\n            \"createPaymentTransaction\",\n            \"getTrustedInput\",\n            \"getTrustedInputBIP143\",\n        ], scrambleKey);\n        this._impl = (() => {\n            switch (currency) {\n                case \"bitcoin\":\n                case \"bitcoin_testnet\":\n                case \"qtum\":\n                    // new APDU (nano app API) for currencies using app-bitcoin-new implementation\n                    return new BtcNew(new AppClient(this._transport));\n                default:\n                    // old APDU (legacy API) for currencies using legacy bitcoin app implementation\n                    return new BtcOld(this._transport);\n            }\n        })();\n    }\n    /**\n     * Get an XPUB with a ledger device\n     * @param arg derivation parameter\n     * - path: a BIP 32 path of the account level. (e.g. The derivation path `84'/0'/0'`\n     * follows the `purpose' / coin_type' / account'` standard, with purpose=84, coin_type=0, account=0)\n     * - xpubVersion: the XPUBVersion of the coin used. (refer to ledgerjs/packages/cryptoassets/src/currencies.ts\n     * for the XPUBVersion value if needed)\n     * @returns XPUB of the account\n     */\n    getWalletXpub(arg) {\n        return this.changeImplIfNecessary().then(impl => {\n            return impl.getWalletXpub(arg);\n        });\n    }\n    /**\n     * @param path a BIP 32 path (i.e. the `purpose / coin_type / account / change / address_index` standard)\n     * @param options an object with optional these fields:\n     *\n     * - verify (boolean) whether ask user to confirm the address on the device\n     *\n     * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n     *\n     * NB The normal usage is to use:\n     *\n     * - legacy format with 44' paths\n     *\n     * - p2sh format with 49' paths\n     *\n     * - bech32 format with 84' paths\n     *\n     * - bech32m format with 86' paths\n     *\n     * - cashaddr in case of Bitcoin Cash\n     *\n     * @example\n     * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n     * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n     */\n    getWalletPublicKey(path, opts) {\n        let options;\n        if (arguments.length > 2 || typeof opts === \"boolean\") {\n            console.warn(\"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\");\n            options = {\n                verify: !!opts,\n                // eslint-disable-next-line prefer-rest-params\n                format: arguments[2] ? \"p2sh\" : \"legacy\",\n            };\n        }\n        else {\n            options = opts || {};\n        }\n        return this.changeImplIfNecessary().then(impl => {\n            return impl.getWalletPublicKey(path, options);\n        });\n    }\n    /**\n     * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n     * @example\n     btc.signMessage(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n       var v = result['v'] + 27 + 4;\n       var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n       console.log(\"Signature : \" + signature);\n     }).catch(function(ex) {console.log(ex);});\n     */\n    signMessage(path, messageHex) {\n        return this.changeImplIfNecessary().then(impl => {\n            return impl.signMessage({\n                path,\n                messageHex,\n            });\n        });\n    }\n    /**\n     * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n     * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n     *\n     * * transaction is the previously computed transaction object for this UTXO\n     * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n     * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n     * * sequence is the sequence number to use for this input (when using RBF), or non present\n     * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n     * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n     * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign, including leading vararg voutCount\n     * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n     * @param sigHashType is the hash type of the transaction to sign, or default (all)\n     * @param segwit is an optional boolean indicating wether to use segwit or not. This includes wrapped segwit.\n     * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n     * @param additionals list of additionnal options\n     *\n     * - \"bech32\" for spending native segwit outputs\n     * - \"bech32m\" for spending segwit v1+ outputs\n     * - \"abc\" for bch\n     * - \"gold\" for btg\n     * - \"decred\" for decred\n     * - \"zcash\" for zcash\n     * - \"bipxxx\" for using BIPxxx\n     * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n     * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n     * @param useTrustedInputForSegwit trust inputs for segwit transactions. If app version >= 1.4.0 this should be true.\n     * @return the signed transaction ready to be broadcast\n     * @example\n    btc.createTransaction({\n     inputs: [ [tx1, 1] ],\n     associatedKeysets: [\"0'/0/0\"],\n     outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n    }).then(res => ...);\n     */\n    createPaymentTransaction(arg) {\n        if (arguments.length > 1) {\n            throw new Error(\"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\");\n        }\n        return this.changeImplIfNecessary().then(impl => {\n            return impl.createPaymentTransaction(arg);\n        });\n    }\n    /**\n     * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n     * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n     * * transaction is the previously computed transaction object for this UTXO\n     * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n     * * redeem script is the mandatory redeem script associated to the current P2SH input\n     * * sequence is the sequence number to use for this input (when using RBF), or non present\n     * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n     * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n     * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n     * @param sigHashType is the hash type of the transaction to sign, or default (all)\n     * @return the signed transaction ready to be broadcast\n     * @example\n    btc.signP2SHTransaction({\n    inputs: [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n    associatedKeysets: [\"0'/0/0\"],\n    outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n    }).then(result => ...);\n     */\n    signP2SHTransaction(arg) {\n        return signP2SHTransaction(this._transport, arg);\n    }\n    /**\n     * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n     * @param transactionHex a raw hexadecimal serialized transaction\n     * @param isSegwitSupported is a boolean indicating if the segwit is supported\n     * @param hasTimestamp is a boolean (peercoin includes timestamp in their transactions, others don't)\n     * @param hasExtraData is a boolean (komodo, zencash and zcash include extraData in their transactions, others don't)\n     * @param additionals list of additionnal options\n     * @return the transaction object deserialized from the raw hexadecimal transaction\n     * @example\n    const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n     */\n    splitTransaction(transactionHex, isSegwitSupported = false, hasTimestamp = false, hasExtraData = false, additionals = []) {\n        return splitTransaction(transactionHex, isSegwitSupported, hasTimestamp, hasExtraData, additionals);\n    }\n    /**\n     * Serialize a transaction's outputs to hexadecimal\n     * @example\n    const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n    const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n    */\n    serializeTransactionOutputs(t) {\n        return serializeTransactionOutputs(t);\n    }\n    /**\n     * Trusted input is the hash of a UTXO that needs to be signed\n     * For Legacy transactions, the app has some APDUs flows that do the amount check for an UTXO,\n     * by parsing the transaction that created this UTXO\n     */\n    getTrustedInput(indexLookup, transaction, additionals = []) {\n        return getTrustedInput(this._transport, indexLookup, transaction, additionals);\n    }\n    /**\n     * Trusted input is the hash of a UTXO that needs to be signed. BIP143 is used for Segwit inputs.\n     */\n    getTrustedInputBIP143(indexLookup, transaction, additionals = []) {\n        return getTrustedInputBIP143(this._transport, indexLookup, transaction, additionals);\n    }\n    changeImplIfNecessary() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // if BtcOld was instantiated, stick with it\n            if (this._impl instanceof BtcOld)\n                return this._impl;\n            const { name, version } = yield getAppAndVersion(this._transport);\n            const isBtcLegacy = yield (() => __awaiter(this, void 0, void 0, function* () {\n                switch (name) {\n                    case \"Bitcoin\":\n                    case \"Bitcoin Test\": {\n                        // we use the legacy protocol for versions below 2.1.0 of the Bitcoin app.\n                        return semver.lt(version, \"2.1.0\");\n                    }\n                    case \"Bitcoin Legacy\":\n                    case \"Bitcoin Test Legacy\":\n                        // the \"Bitcoin Legacy\" and \"Bitcoin Testnet Legacy\" app use the legacy protocol, regardless of the version\n                        return true;\n                    case \"Exchange\":\n                        // We can't query the version of the Bitcoin app if we're coming from Exchange;\n                        // therefore, we use a workaround to distinguish legacy and new versions.\n                        // This can be removed once Ledger Live enforces minimum bitcoin version >= 2.1.0.\n                        return yield checkIsBtcLegacy(this._transport);\n                    case \"Qtum\":\n                        // we use the legacy protocol for versions below 3.0.0 of the Qtum app.\n                        return semver.lt(version, \"3.0.0\");\n                    default:\n                        return true;\n                }\n            }))();\n            if (isBtcLegacy) {\n                this._impl = new BtcOld(this._transport);\n            }\n            return this._impl;\n        });\n    }\n}\n//# sourceMappingURL=Btc.js.map","import { log } from \"@ledgerhq/logs\";\nimport { getVarint } from \"./varint\";\nimport { formatTransactionDebug } from \"./debug\";\nexport function splitTransaction(transactionHex, isSegwitSupported = false, hasTimestamp = false, hasExtraData = false, additionals = []) {\n    const inputs = [];\n    const outputs = [];\n    let witness = false;\n    let offset = 0;\n    let timestamp = Buffer.alloc(0);\n    let nExpiryHeight = Buffer.alloc(0);\n    let nVersionGroupId = Buffer.alloc(0);\n    let extraData = Buffer.alloc(0);\n    let witnessScript, locktime;\n    const isDecred = additionals.includes(\"decred\");\n    const isZencash = additionals.includes(\"zencash\");\n    const isZcash = additionals.includes(\"zcash\");\n    const transaction = Buffer.from(transactionHex, \"hex\");\n    const version = transaction.slice(offset, offset + 4);\n    const overwinter = version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n        version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80])) ||\n        version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n    const isZcashv5 = isZcash && version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n    offset += 4;\n    if (!hasTimestamp &&\n        isSegwitSupported &&\n        transaction[offset] === 0 &&\n        transaction[offset + 1] !== 0 &&\n        !isZencash) {\n        offset += 2;\n        witness = true;\n    }\n    if (hasTimestamp) {\n        timestamp = transaction.slice(offset, 4 + offset);\n        offset += 4;\n    }\n    if (overwinter) {\n        nVersionGroupId = transaction.slice(offset, 4 + offset);\n        offset += 4;\n    }\n    if (isZcashv5) {\n        locktime = transaction.slice(offset + 4, offset + 8);\n        nExpiryHeight = transaction.slice(offset + 8, offset + 12);\n        offset += 12;\n    }\n    let varint = getVarint(transaction, offset);\n    const numberInputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberInputs; i++) {\n        const prevout = transaction.slice(offset, offset + 36);\n        offset += 36;\n        let script = Buffer.alloc(0);\n        let tree = Buffer.alloc(0);\n        //No script for decred, it has a witness\n        if (!isDecred) {\n            varint = getVarint(transaction, offset);\n            offset += varint[1];\n            script = transaction.slice(offset, offset + varint[0]);\n            offset += varint[0];\n        }\n        else {\n            //Tree field\n            tree = transaction.slice(offset, offset + 1);\n            offset += 1;\n        }\n        const sequence = transaction.slice(offset, offset + 4);\n        offset += 4;\n        inputs.push({\n            prevout,\n            script,\n            sequence,\n            tree,\n        });\n    }\n    varint = getVarint(transaction, offset);\n    const numberOutputs = varint[0];\n    offset += varint[1];\n    for (let i = 0; i < numberOutputs; i++) {\n        const amount = transaction.slice(offset, offset + 8);\n        offset += 8;\n        if (isDecred) {\n            //Script version\n            offset += 2;\n        }\n        varint = getVarint(transaction, offset);\n        offset += varint[1];\n        const script = transaction.slice(offset, offset + varint[0]);\n        offset += varint[0];\n        outputs.push({\n            amount,\n            script,\n        });\n    }\n    if (witness) {\n        witnessScript = transaction.slice(offset, -4);\n        locktime = transaction.slice(transaction.length - 4);\n    }\n    else if (!isZcashv5) {\n        locktime = transaction.slice(offset, offset + 4);\n    }\n    offset += 4;\n    if ((overwinter || isDecred) && !isZcashv5) {\n        nExpiryHeight = transaction.slice(offset, offset + 4);\n        offset += 4;\n    }\n    if (hasExtraData) {\n        extraData = transaction.slice(offset);\n    }\n    //Get witnesses for Decred\n    if (isDecred) {\n        varint = getVarint(transaction, offset);\n        offset += varint[1];\n        if (varint[0] !== numberInputs) {\n            throw new Error(\"splitTransaction: incoherent number of witnesses\");\n        }\n        for (let i = 0; i < numberInputs; i++) {\n            //amount\n            offset += 8;\n            //block height\n            offset += 4;\n            //block index\n            offset += 4;\n            //Script size\n            varint = getVarint(transaction, offset);\n            offset += varint[1];\n            const script = transaction.slice(offset, offset + varint[0]);\n            offset += varint[0];\n            inputs[i].script = script;\n        }\n    }\n    const t = {\n        version,\n        inputs,\n        outputs,\n        locktime,\n        witness: witnessScript,\n        timestamp,\n        nVersionGroupId,\n        nExpiryHeight,\n        extraData,\n    };\n    log(\"btc\", `splitTransaction ${transactionHex}:\\n${formatTransactionDebug(t)}`);\n    return t;\n}\n//# sourceMappingURL=splitTransaction.js.map","export function formatTransactionDebug(transaction) {\n    let str = \"TX\";\n    str += \" version \" + transaction.version.toString(\"hex\");\n    if (transaction.locktime) {\n        str += \" locktime \" + transaction.locktime.toString(\"hex\");\n    }\n    if (transaction.witness) {\n        str += \" witness \" + transaction.witness.toString(\"hex\");\n    }\n    if (transaction.timestamp) {\n        str += \" timestamp \" + transaction.timestamp.toString(\"hex\");\n    }\n    if (transaction.nVersionGroupId) {\n        str += \" nVersionGroupId \" + transaction.nVersionGroupId.toString(\"hex\");\n    }\n    if (transaction.nExpiryHeight) {\n        str += \" nExpiryHeight \" + transaction.nExpiryHeight.toString(\"hex\");\n    }\n    if (transaction.extraData) {\n        str += \" extraData \" + transaction.extraData.toString(\"hex\");\n    }\n    transaction.inputs.forEach(({ prevout, script, sequence }, i) => {\n        str += `\\ninput ${i}:`;\n        str += ` prevout ${prevout.toString(\"hex\")}`;\n        str += ` script ${script.toString(\"hex\")}`;\n        str += ` sequence ${sequence.toString(\"hex\")}`;\n    });\n    (transaction.outputs || []).forEach(({ amount, script }, i) => {\n        str += `\\noutput ${i}:`;\n        str += ` amount ${amount.toString(\"hex\")}`;\n        str += ` script ${script.toString(\"hex\")}`;\n    });\n    return str;\n}\nexport function displayTransactionDebug(transaction) {\n    console.log(formatTransactionDebug(transaction));\n}\n//# sourceMappingURL=debug.js.map","let id = 0;\nconst subscribers = [];\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type, message, data) => {\n    const obj = {\n        type,\n        id: String(++id),\n        date: new Date(),\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    dispatch(obj);\n};\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({ type, message, data, context, }) => {\n    const obj = {\n        type,\n        id: String(++id),\n        date: new Date(),\n    };\n    if (message)\n        obj.message = message;\n    if (data)\n        obj.data = data;\n    if (context)\n        obj.context = context;\n    dispatch(obj);\n};\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n    constructor(type, context) {\n        this.type = type;\n        this.context = context;\n    }\n    trace(message, data) {\n        trace({\n            type: this.type,\n            message,\n            data,\n            context: this.context,\n        });\n    }\n    getContext() {\n        return this.context;\n    }\n    setContext(context) {\n        this.context = context;\n    }\n    updateContext(contextToAdd) {\n        this.context = Object.assign(Object.assign({}, this.context), contextToAdd);\n    }\n    getType() {\n        return this.type;\n    }\n    setType(type) {\n        this.type = type;\n    }\n    /**\n     * Create a new instance of the LocalTracer with an updated `type`\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     */\n    withType(type) {\n        return new LocalTracer(type, this.context);\n    }\n    /**\n     * Create a new instance of the LocalTracer with a new `context`\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     *\n     * @param context A TraceContext, that can undefined to reset the context\n     */\n    withContext(context) {\n        return new LocalTracer(this.type, context);\n    }\n    /**\n     * Create a new instance of the LocalTracer with an updated `context`,\n     * on which an additional context is merged with the existing one.\n     *\n     * It does not mutate the calling instance, but returns a new LocalTracer,\n     * following a simple builder pattern.\n     */\n    withUpdatedContext(contextToAdd) {\n        return new LocalTracer(this.type, Object.assign(Object.assign({}, this.context), contextToAdd));\n    }\n}\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb) => {\n    subscribers.push(cb);\n    return () => {\n        const i = subscribers.indexOf(cb);\n        if (i !== -1) {\n            // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n            subscribers[i] = subscribers[subscribers.length - 1];\n            subscribers.pop();\n        }\n    };\n};\nfunction dispatch(log) {\n    for (let i = 0; i < subscribers.length; i++) {\n        try {\n            subscribers[i](log);\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n}\nif (typeof window !== \"undefined\") {\n    window.__ledgerLogsListen = listen;\n}\n//# sourceMappingURL=index.js.map","/*\n * Bitcoin BIP32 path helpers\n * (C) 2016 Alex Beregszaszi\n */\n\nconst HARDENED = 0x80000000\n\nvar BIPPath = function (path) {\n  if (!Array.isArray(path)) {\n    throw new Error('Input must be an Array')\n  }\n  if (path.length === 0) {\n    throw new Error('Path must contain at least one level')\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (typeof path[i] !== 'number') {\n      throw new Error('Path element is not a number')\n    }\n  }\n  this.path = path\n}\n\nBIPPath.validatePathArray = function (path) {\n  try {\n    BIPPath.fromPathArray(path)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.validateString = function (text, reqRoot) {\n  try {\n    BIPPath.fromString(text, reqRoot)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.fromPathArray = function (path) {\n  return new BIPPath(path)\n}\n\nBIPPath.fromString = function (text, reqRoot) {\n  // skip the root\n  if (/^m\\//i.test(text)) {\n    text = text.slice(2)\n  } else if (reqRoot) {\n    throw new Error('Root element is required')\n  }\n\n  var path = text.split('/')\n  var ret = new Array(path.length)\n  for (var i = 0; i < path.length; i++) {\n    var tmp = /(\\d+)([hH\\']?)/.exec(path[i])\n    if (tmp === null) {\n      throw new Error('Invalid input')\n    }\n    ret[i] = parseInt(tmp[1], 10)\n\n    if (ret[i] >= HARDENED) {\n      throw new Error('Invalid child index')\n    }\n\n    if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\\'') {\n      ret[i] += HARDENED\n    } else if (tmp[2].length != 0) {\n      throw new Error('Invalid modifier')\n    }\n  }\n  return new BIPPath(ret)\n}\n\nBIPPath.prototype.toPathArray = function () {\n  return this.path\n}\n\nBIPPath.prototype.toString = function (noRoot, oldStyle) {\n  var ret = new Array(this.path.length)\n  for (var i = 0; i < this.path.length; i++) {\n    var tmp = this.path[i]\n    if (tmp & HARDENED) {\n      ret[i] = (tmp & ~HARDENED) + (oldStyle ? 'h' : '\\'')\n    } else {\n      ret[i] = tmp\n    }\n  }\n  return (noRoot ? '' : 'm/') + ret.join('/')\n}\n\nBIPPath.prototype.inspect = function () {\n  return 'BIPPath <' + this.toString() + '>'\n}\n\nmodule.exports = BIPPath\n"],"names":["Object","defineProperty","jn","value","Er","ko","Ac","Bo","hash160","t","e","update","digest","hmacSHA512","De","Rc","c","Buffer","alloc","fi","Hc","n","r","s","i","o","u","$c","bc","hs","Mc","Pc","ec","Kc","Bn","xn","from","ai","me","curve","Co","shrn","Yn","g","zn","lt","Qn","Ho","Dc","cn","isBuffer","length","Jn","compare","ze","slice","dt","$o","Qe","fn","we","An","toArrayLike","decodePoint","Wt","_encode","Mo","TypeError","p","a","h","mul","isInfinity","x","umod","isZero","invm","add","cmp","sub","f","allocUnsafe","copy","be","isPoint","isPointCompressed","isPrivate","pointAdd","pointAddScalar","pointCompress","pointFromScalar","pointMultiply","privateAdd","privateSub","sign","signWithEntropy","verify","Wc","gtn","mulAdd","eq","qt","jr","Ko","Xn","Oe","ie","Q","ef","xo","Yr","BufferN","tf","compile","wif","UInt8","bip32","public","UInt32","private","Zn","messagePrefix","bech32","pubKeyHash","scriptHash","pi","nf","Math","pow","rf","String","match","sf","Lo","constructor","this","__D","__Q","chainCode","network","__DEPTH","__INDEX","__PARENT_FINGERPRINT","lowR","depth","index","parentFingerprint","publicKey","privateKey","identifier","fingerprint","compressed","isNeutered","neutered","Nn","toBase58","writeUInt32BE","writeUInt8","encode","toWIF","derive","readUInt32BE","ls","deriveHardened","derivePath","split","reduce","parseInt","Error","writeUIntLE","Do","fromBase58","decode","readUInt8","fromPrivateKey","fromPublicKey","fromSeed","Vt","er","fe","bitcoin","regtest","testnet","tr","readUInt32LE","abs","af","U","hf","Fo","UInt31","BIP32Path","toJSON","Signer","getPublicKey","Satoshi","UInt53","ECPoint","quacksLike","Network","oneOf","Buffer256bit","Hash160bit","Hash256bit","Number","Array","Boolean","Hex","maybe","tuple","Function","Null","nr","hi","Wo","Ao","yf","li","di","concat","gi","max","signature","hashType","je","gs","Go","OP_PUSHDATA1","Np","encodingLength","OP_PUSHDATA2","writeUInt16LE","OP_PUSHDATA4","writeUInt32LE","readUInt16LE","opcode","number","size","wi","Vo","yi","Rp","OPS","OP_RESERVED","y","OP_0","OP_1","OP_16","OP_1NEGATE","l","every","d","w","E","k","D","te","$","q","forEach","S","_","Le","push","W","isPushOnly","decompile","toASM","map","toString","join","fromASM","toStack","isCanonicalPubKey","isDefinedHashType","isCanonicalScriptSignature","check","ke","prop","configurable","enumerable","get","call","set","writable","ds","$p","Pn","v","_i","Ae","Ei","p2data","data","output","assign","validate","arrayOf","name","OP_RETURN","equals","Mp","ws","Lp","$t","Fe","Mt","ne","Si","gn","mi","p2ms","input","pubkeys","m","signatures","allowIncomplete","OP_CHECKMULTISIG","ys","Fp","Kt","At","Ne","Ti","Ii","p2pk","pubkey","OP_CHECKSIG","ae","Un","qo","Rn","ripemd160","sha1","sha256","hash256","_s","Sr","Xp","Lt","Ue","de","We","Oi","Pi","p2pkh","address","hash","version","OP_DUP","OP_HASH160","OP_EQUALVERIFY","Es","bi","Yp","Ce","Ie","G","wn","vi","p2sh","redeem","witness","OP_EQUAL","zp","Ss","mr","Jp","bn","Ge","ce","ki","Tr","yn","fs","Zp","p2wpkh","words","shift","fromWords","prefix","toWords","unshift","ms","Bi","th","Xe","Re","V","xi","nh","_n","Ir","En","p2wsh","rh","some","Ee","ih","embed","oh","uh","ch","fh","ah","ph","ve","Xo","Ye","hh","Or","Cn","jo","lh","Yo","zo","fromBase58Check","fromBech32","toBase58Check","arguments","toBech32","fromOutputScript","toOutputScript","et","Qo","ut","$e","_h","vc","Je","Jo","Ts","Zo","Is","fromWIF","filter","pop","makeRandom","rng","Te","Ft","eu","Hn","as","tu","floor","nu","ru","writeInt32LE","readUInt64LE","writeUInt64LE","reverseBuffer","cloneBuffer","BufferWriter","buffer","offset","writeInt32","writeUInt32","writeUInt64","writeVarInt","bytes","writeSlice","writeVarSlice","writeVector","BufferReader","readInt32","readInt32LE","readUInt32","readUInt64","readVarInt","readSlice","readVarSlice","readVector","Xt","Ve","rt","Ai","bh","M","st","$n","Dt","zr","Ni","Pr","Ui","kh","Bh","script","valueBuffer","H","locktime","ins","outs","fromBuffer","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","sequence","hasWitnesses","fromHex","isCoinbaseHash","isCoinbase","addInput","DEFAULT_SEQUENCE","addOutput","weight","byteLength","virtualSize","ceil","vh","clone","hashForSignature","OP_CODESEPARATOR","SIGHASH_NONE","SIGHASH_SINGLE","SIGHASH_ANYONECANPAY","__toBuffer","hashForWitnessV0","getHash","getId","toBuffer","toHex","setInputScript","setWitness","SIGHASH_ALL","Transaction","Os","Sn","br","Ah","Nh","Uh","kc","Rh","vr","kr","Ri","it","prevHash","merkleRoot","timestamp","witnessCommit","bits","nonce","transactions","readTransaction","getWitnessCommit","calculateTarget","writeUIntBE","calculateMerkleRoot","Ci","hasWitnessCommit","hasWitness","getUTCDate","Date","setUTCSeconds","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","Block","GlobalTypes","UNSIGNED_TX","GLOBAL_XPUB","GLOBAL_TYPE_NAMES","NON_WITNESS_UTXO","WITNESS_UTXO","PARTIAL_SIG","SIGHASH_TYPE","REDEEM_SCRIPT","WITNESS_SCRIPT","BIP32_DERIVATION","FINAL_SCRIPTSIG","FINAL_SCRIPTWITNESS","POR_COMMITMENT","TAP_KEY_SIG","TAP_SCRIPT_SIG","TAP_LEAF_SCRIPT","TAP_BIP32_DERIVATION","TAP_INTERNAL_KEY","TAP_MERKLE_ROOT","InputTypes","INPUT_TYPE_NAMES","TAP_TREE","OutputTypes","OUTPUT_TYPE_NAMES","_t","su","ee","key","includes","masterFingerprint","extendedPubkey","path","keys","Hh","expected","indexOf","canAddToArray","has","Bs","Dh","Et","iu","canAdd","finalScriptSig","St","ou","finalScriptWitness","mt","uu","nonWitnessUtxo","Tt","cu","sl","It","fu","porCommitment","Ot","au","sighashType","Pt","pu","hu","tapKeySig","bt","lu","controlBlock","leafVersion","vt","du","gu","tapMerkleRoot","kt","wu","leafHash","xe","kl","xs","RangeError","yu","rn","sn","Be","mn","_u","Eu","range","keyValsToBuffer","keyValToBuffer","Bt","Su","mu","Mn","witnessUtxo","xt","Tu","Qr","leaves","of","isArray","tapTree","rr","Fl","makeConverter","Dl","As","makeChecker","Ns","redeemScript","Us","Tn","ql","Xl","leafHashes","Rs","tapInternalKey","Cs","witnessScript","yt","ge","Zl","ed","td","nd","rd","sd","id","od","ud","cd","fd","ad","Iu","Hs","Ou","Pu","bu","vu","pd","unsignedTx","globalXpub","checkPubkey","globals","hd","partialSig","bip32Derivation","tapScriptSig","tapLeafScript","tapBip32Derivation","inputs","ld","outputs","an","F","Kn","Hi","b","se","ku","globalMapKeyVals","inputKeyVals","outputKeyVals","unknownKeyVals","globalMap","psbtFromBuffer","inputCount","outputCount","getInputOutputCounts","I","checkKeyBuffer","psbtFromKeyVals","sr","Br","$i","psbtToBuffer","globalKeyVals","Bu","wd","sortKeyVals","xr","Set","entries","sort","psbtToKeyVals","hasOwnProperty","vs","Ar","ks","Nr","Mi","Nt","combine","JSON","stringify","A","Y","checkForInput","checkForOutput","checkHasKey","getEnumLength","isNaN","inputCheckUncleanFinalized","updateGlobal","updateInput","updateOutput","addInputAttributes","addOutputAttributes","defaultVersionSetter","defaultLocktimeSetter","bs","_d","Ki","Ur","re","$s","Psbt","fromBase64","toBase64","addUnknownKeyValToGlobal","addUnknownKeyValToInput","addUnknownKeyValToOutput","clearFinalizedInput","getTransaction","Ps","Li","Ln","Pe","Di","Dn","Sd","xu","oe","he","z","Td","maximumFeeRate","Fn","Au","opts","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","tx","__UNSAFE_SIGN_NONSEGWIT","setVersion","dpew","Id","Cu","Ad","setLocktime","txInputs","txOutputs","parse","setMaximumFeeRate","In","Zt","__EXTRACTED_TX","setInputSequence","addInputs","Wn","Jr","__FEE","__FEE_RATE","addOutputs","extractTransaction","Nu","getFeeRate","toFixed","kd","Ku","Xi","getFee","finalizeAllInputs","en","finalizeInput","Nd","isP2SH","isP2WSH","isSegwit","or","ir","Hd","Bd","getInputType","ur","Lu","Du","Wd","Dd","Mu","Fd","type","Fu","meaningfulScript","inputHasPubkey","Ms","Kd","inputHasHDKey","Gi","outputHasPubkey","Ld","outputHasHDKey","validateSignaturesOfAllInputs","validateSignaturesOfInput","$u","Ru","signAllInputsHD","signInputHD","signAllInputsHDAsync","Promise","signInputHDAsync","then","all","Yi","signInput","signInputAsync","catch","signAllInputs","signAllInputsAsync","ji","resolve","Rr","xd","Fi","find","jt","Pd","bd","vd","Wi","Uu","Cd","Hu","Vi","qi","Od","$d","Rd","zi","Ud","Md","console","warn","Ls","Zr","Wu","Gd","Gu","Ds","Qi","Vu","Ji","Zi","qu","zt","Vd","qd","cr","Xu","Xd","Fs","jd","Ws","eo","ju","Gs","to","Yd","Yu","Qt","zd","Qd","Vs","Cr","zu","qs","Jd","On","Qu","Jt","Zd","e0","ar","t0","n0","Ju","pr","r0","s0","Zu","Xs","tn","no","ro","so","i0","o0","js","u0","io","tc","fr","c0","f0","pn","zs","nc","a0","rc","sc","Qs","Ys","l0","Js","es","ic","d0","hr","g0","w0","Zs","oo","uo","co","fo","ao","oc","lr","y0","_0","Yt","ei","uc","E0","cc","fc","ac","S0","pc","hc","J","P2MS","NONSTANDARD","NULLDATA","P2PK","P2PKH","P2SH","P2WPKH","P2WSH","WITNESS_COMMITMENT","types","Ks","O0","P0","ct","po","b0","v0","L","ft","k0","He","Ke","N","P","B0","K","ti","__PREV_TX_SET","__INPUTS","__USE_LOW_R","fromTransaction","setLockTime","__addInputUnsafe","redeemScriptType","N0","setLowR","__canModifyInputs","A0","prevOutScript","__canModifyOutputs","build","__build","buildIncomplete","ourPubKey","keyPair","signatureHash","useLowR","C0","prevOutScriptType","vin","prevOutType","witnessValue","R0","Hr","on","witnessScriptType","signScript","signType","maxSignatures","U0","H0","__needsOutputs","bind","vn","scriptSig","ts","__overMaximumFees","$r","TransactionBuilder","ye","$0","M0","K0","gt","crypto","L0","ECPair","D0","networks","F0","payments","W0","G0","V0","q0","opcodes","X0","j0","ns","ni","Me","ri","ps","fromPathArray","fromString","toPathArray","ho","No","lo","chaincode","lc","MAX_SAFE_INTEGER","dc","ue","bufs","write","Xr","at","available","Ze","Gn","Gt","Uo","kn","J0","psbt","masterFp","gr","spendingCondition","singleKeyCondition","setInput","setSingleKeyInput","setOwnOutput","setSingleKeyOutput","Z0","scriptPubKey","setInputNonWitnessUtxo","setInputBip32Derivation","setOutputBip32Derivation","getDescriptorTemplate","eg","getTaprootOutputKey","setInputTapBip32Derivation","setInputWitnessUtxo","amount","cond","setOutputTapBip32Derivation","hashTapTweak","tg","createRedeemScript","setInputRedeemScript","setOutputRedeemScript","ng","pt","calculateRoot","rootNode","root","leafNodes","getRoot","getLeaves","getLeafHash","getProof","rs","Mr","ig","log2","sg","hashNode","parent","ht","rg","leftChild","rightChild","isLeaf","go","descriptorTemplate","getWalletId","serialize","wo","substring","pe","B","_e","TX_VERSION","FALLBACK_LOCKTIME","INPUT_COUNT","OUTPUT_COUNT","TX_MODIFIABLE","VERSION","PREVIOUS_TXID","OUTPUT_INDEX","SEQUENCE","BIP_32_DERIVATION","AMOUNT","SCRIPT","ug","cg","Ec","Map","inputMaps","outputMaps","setGlobalTxVersion","setGlobal","Ut","getGlobalTxVersion","getGlobal","setGlobalFallbackLocktime","getGlobalFallbackLocktime","getGlobalOptional","setGlobalInputCount","yo","getGlobalInputCount","_o","setGlobalOutputCount","getGlobalOutputCount","setGlobalTxModifiable","getGlobalTxModifiable","setGlobalPsbtVersion","getGlobalPsbtVersion","C","getInputNonWitnessUtxo","getInputOptional","getInputWitnessUtxo","setInputPartialSig","getInputPartialSig","setInputSighashType","getInputSighashType","getInputRedeemScript","encodeBip32Derivation","getInputBip32Derivation","decodeBip32Derivation","setInputFinalScriptsig","getInputFinalScriptsig","setInputFinalScriptwitness","getInputFinalScriptwitness","getInput","setInputPreviousTxId","getInputPreviousTxid","setInputOutputIndex","getInputOutputIndex","getInputSequence","setInputTapKeySig","getInputTapKeySig","encodeTapBip32Derivation","getInputTapBip32Derivation","decodeTapBip32Derivation","getInputKeyDatas","getKeyDatas","setOutput","getOutputRedeemScript","getOutput","getOutputBip32Derivation","setOutputAmount","pg","getOutputAmount","setOutputScript","getOutputScript","getOutputTapBip32Derivation","deleteInputEntries","isKeyType","delete","copyMap","copyMaps","Kr","deserialize","readKeyPair","Lr","wr","nn","getMap","writeBip32Derivation","readBip32Derivation","hashes","keyType","keyData","fg","ag","lg","Eo","Rt","Z","Sc","oi","prevout","nExpiryHeight","extraData","nVersionGroupId","qe","next","throw","done","apply","dg","client","getWalletXpub","xpubVersion","getExtendedPubkey","getWalletPublicKey","Sg","To","Dr","mo","So","mg","Tg","getWalletAddress","gg","format","bitcoinAddress","Y0","getMasterFingerprint","createPaymentTransaction","additionals","segwit","wg","lockTime","progress","onDeviceStreaming","total","associatedKeysets","sigHashType","outputScriptHex","outputScriptAt","changePath","O","onDeviceSignatureRequested","signPsbt","progressCallback","onDeviceSignatureGranted","hg","og","signMessage","messageHex","hn","Ig","Io","legacy","cashaddr","ss","send","Pg","process","env","NODE_ENV","replace","framesToPop","is","Ct","ui","processScriptBlocks","tree","mc","bg","Fr","Vn","trustedInput","ci","vg","os","kg","Oo","qn","Tc","Ic","flags","Ag","Ng","Ug","initialTimestamp","expiryHeight","useTrustedInputForSegwit","qr","gte","xg","T","statusCode","notify","R","j","le","nt","now","tt","dn","X","Oc","yr","Ro","_r","Se","Rg","Wr","Gr","transport","derivationsCache","derivatePath","Kg","us","Lg","Hg","bo","Po","Mg","xc","$g","writeUInt16BE","Cg","Dg","keysTree","values","valuesTree","commitment","un","super","inputMerkleMaps","outputMerkleMaps","globalMerkleMap","createMerkleMap","inputMapCommitments","outputMapCommitments","getGlobalSize","getGlobalKeysValuesRoot","wt","YIELD","GET_PREIMAGE","GET_MERKLE_LEAF_PROOF","GET_MERKLE_LEAF_INDEX","GET_MORE_ELEMENTS","ln","Fg","code","results","execute","subarray","Wg","known_preimages","queue","min","Gg","known_trees","Vg","qg","splice","Vr","roots","preimages","yielded","commands","getYielded","addKnownPreimage","addKnownList","addKnownMapping","Ht","ot","cs","GET_PUBKEY","REGISTER_WALLET","GET_WALLET_ADDRESS","SIGN_PSBT","GET_MASTER_FINGERPRINT","SIGN_MESSAGE","CONTINUE_INTERRUPTED","Yg","makeRequest","readUInt16BE","isInteger","Jg","Zg","transactionVersion","vo","fw","scrambleKey","currency","_transport","decorateAppAPIMethods","_impl","changeImplIfNecessary","signP2SHTransaction","ew","splitTransaction","zg","Qg","serializeTransactionOutputs","getTrustedInput","getTrustedInputBIP143","Bg","log","date","message","context","trace","getContext","setContext","updateContext","getType","setType","withType","withContext","withUpdatedContext","error","window","__ledgerLogsListen","validatePathArray","validateString","test","exec","prototype","inspect"],"sourceRoot":""}