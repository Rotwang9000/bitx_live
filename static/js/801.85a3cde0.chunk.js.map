{"version":3,"file":"static/js/801.85a3cde0.chunk.js","mappings":"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","sources":["../node_modules/@ledgerhq/evm-tools/src/selectors/index.ts","../node_modules/@ethersproject/logger/src.ts/index.ts","../node_modules/@ethersproject/logger/src.ts/_version.ts","../node_modules/@ethersproject/bytes/src.ts/_version.ts","../node_modules/@ethersproject/bytes/src.ts/index.ts","../node_modules/@ethersproject/rlp/src.ts/_version.ts","../node_modules/@ethersproject/rlp/src.ts/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/utils.ts","../node_modules/@ethersproject/bignumber/src.ts/bignumber.ts","../node_modules/@ethersproject/bignumber/src.ts/_version.ts","../node_modules/@ethersproject/keccak256/src.ts/index.ts","../node_modules/@ethersproject/address/src.ts/_version.ts","../node_modules/@ethersproject/address/src.ts/index.ts","../node_modules/@ethersproject/strings/src.ts/_version.ts","../node_modules/@ethersproject/strings/src.ts/utf8.ts","../node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@ethersproject/properties/src.ts/index.ts","../node_modules/@ethersproject/properties/src.ts/_version.ts","../node_modules/@ethersproject/abi/src.ts/_version.ts","../node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts","../node_modules/@ethersproject/abi/src.ts/coders/address.ts","../node_modules/@ethersproject/abi/src.ts/coders/anonymous.ts","../node_modules/@ethersproject/abi/src.ts/coders/array.ts","../node_modules/@ethersproject/abi/src.ts/coders/boolean.ts","../node_modules/@ethersproject/abi/src.ts/coders/bytes.ts","../node_modules/@ethersproject/abi/src.ts/coders/fixed-bytes.ts","../node_modules/@ethersproject/abi/src.ts/coders/null.ts","../node_modules/@ethersproject/constants/src.ts/bignumbers.ts","../node_modules/@ethersproject/abi/src.ts/coders/number.ts","../node_modules/@ethersproject/abi/src.ts/coders/string.ts","../node_modules/@ethersproject/abi/src.ts/coders/tuple.ts","../node_modules/@ethersproject/abi/src.ts/fragments.ts","../node_modules/@ethersproject/abi/src.ts/abi-coder.ts","../node_modules/@ethersproject/abi/src.ts/interface.ts","../node_modules/@ledgerhq/domain-service/src/registries/index.ts","../node_modules/@ledgerhq/domain-service/src/signers/index.ts","../node_modules/@ledgerhq/cryptoassets/src/data/evm/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/loadConfig.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/erc20.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/nfts.ts","../node_modules/@ledgerhq/hw-app-eth/src/services/ledger/contracts.ts","../node_modules/@ledgerhq/domain-service/src/utils/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/modules/Domains/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/errors.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/isFunction.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/createErrorClass.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/UnsubscriptionError.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/arrRemove.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/Subscription.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/config.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/scheduler/timeoutProvider.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/noop.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/NotificationFactories.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/errorContext.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/Subscriber.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/reportUnhandledError.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/symbol/observable.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/identity.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/pipe.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/Observable.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/util/ObjectUnsubscribedError.ts","../node_modules/@ledgerhq/live-env/node_modules/rxjs/src/internal/Subject.ts","../node_modules/@ledgerhq/live-env/src/env.ts","../node_modules/@ledgerhq/cryptoassets/src/data/eip712.ts","../node_modules/@ledgerhq/cryptoassets/src/data/eip712_v2.ts","../node_modules/@ledgerhq/evm-tools/src/message/EIP712/index.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ledgerhq/hw-app-eth/src/modules/EIP712/utils.ts","../node_modules/@ledgerhq/hw-app-eth/src/modules/EIP712/index.ts","../node_modules/@ledgerhq/hw-app-eth/src/Eth.ts","../node_modules/@ledgerhq/logs/src/index.ts","../node_modules/crypto-js/core.js","../node_modules/crypto-js/sha224.js","../node_modules/crypto-js/sha256.js","../node_modules/js-sha3/src/sha3.js"],"sourcesContent":["/* istanbul ignore file: pure exports */\n/**\n * List of selectors (hexadecimal representation of the used method's signature) related to\n * ERC20 (Tokens), ERC721/ERC1155 (NFT).\n * You can verify and/or get more info about them on http://4byte.directory\n */\n\nexport enum ERC20_CLEAR_SIGNED_SELECTORS {\n  APPROVE = \"0x095ea7b3\",\n  TRANSFER = \"0xa9059cbb\",\n}\n\nexport enum ERC721_CLEAR_SIGNED_SELECTORS {\n  APPROVE = \"0x095ea7b3\",\n  SET_APPROVAL_FOR_ALL = \"0xa22cb465\",\n  TRANSFER_FROM = \"0x23b872dd\",\n  SAFE_TRANSFER_FROM = \"0x42842e0e\",\n  SAFE_TRANSFER_FROM_WITH_DATA = \"0xb88d4fde\",\n}\n\nexport enum ERC1155_CLEAR_SIGNED_SELECTORS {\n  SET_APPROVAL_FOR_ALL = \"0xa22cb465\",\n  SAFE_TRANSFER_FROM = \"0xf242432a\",\n  SAFE_BATCH_TRANSFER_FROM = \"0x2eb2c2d6\",\n}\n\nexport default {\n  ERC20_CLEAR_SIGNED_SELECTORS,\n  ERC721_CLEAR_SIGNED_SELECTORS,\n  ERC1155_CLEAR_SIGNED_SELECTORS,\n};\n","\"use strict\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [ name: string ]: number } = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nimport { version } from \"./_version\";\n\nlet _globalLogger: Logger = null;\n\nfunction _checkNormalize(): string {\n    try {\n        const missing: Array<string> = [ ];\n\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                };\n            } catch(error) {\n                missing.push(form);\n            }\n        });\n\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\")\n        }\n    } catch (error) {\n        return error.message;\n    }\n\n    return null;\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n    DEBUG    = \"DEBUG\",\n    INFO     = \"INFO\",\n    WARNING  = \"WARNING\",\n    ERROR    = \"ERROR\",\n    OFF      = \"OFF\"\n}\n\n\nexport enum ErrorCode {\n\n    ///////////////////\n    // Generic Errors\n\n    // Unknown Error\n    UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n    // Not Implemented\n    NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n    // Unsupported Operation\n    //   - operation\n    UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    NETWORK_ERROR = \"NETWORK_ERROR\",\n\n    // Some sort of bad response from the server\n    SERVER_ERROR = \"SERVER_ERROR\",\n\n    // Timeout\n    TIMEOUT = \"TIMEOUT\",\n\n    ///////////////////\n    // Operational  Errors\n\n    // Buffer Overrun\n    BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n\n    ///////////////////\n    // Argument Errors\n\n    // Missing new operator to an object\n    //  - name: The name of the class\n    MISSING_NEW = \"MISSING_NEW\",\n\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n\n    ///////////////////\n    // Blockchain Errors\n\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    CALL_EXCEPTION = \"CALL_EXCEPTION\",\n\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    NONCE_EXPIRED = \"NONCE_EXPIRED\",\n\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    REPLACEMENT_UNDERPRICED = \"REPLACEMENT_UNDERPRICED\",\n\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    UNPREDICTABLE_GAS_LIMIT = \"UNPREDICTABLE_GAS_LIMIT\",\n\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    TRANSACTION_REPLACED = \"TRANSACTION_REPLACED\",\n\n\n    ///////////////////\n    // Interaction Errors\n\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ACTION_REJECTED = \"ACTION_REJECTED\",\n};\n\nconst HEX = \"0123456789abcdef\";\n\nexport class Logger {\n    readonly version: string;\n\n    static errors = ErrorCode;\n\n    static levels = LogLevel;\n\n    constructor(version: string) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n\n    _log(logLevel: LogLevel, args: Array<any>): void {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) { return; }\n        console.log.apply(console, args);\n    }\n\n    debug(...args: Array<any>): void {\n        this._log(Logger.levels.DEBUG, args);\n    }\n\n    info(...args: Array<any>): void {\n        this._log(Logger.levels.INFO, args);\n    }\n\n    warn(...args: Array<any>): void {\n        this._log(Logger.levels.WARNING, args);\n    }\n\n    makeError(message: string, code?: ErrorCode, params?: any): Error {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, { });\n        }\n\n        if (!code) { code = Logger.errors.UNKNOWN_ERROR; }\n        if (!params) { params = {}; }\n\n        const messageDetails: Array<string> = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                      hex += HEX[value[i] >> 4];\n                      hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                } else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            } catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${ code }`);\n        messageDetails.push(`version=${ this.version }`);\n\n        const reason = message;\n\n        let url = \"\";\n\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n\n                switch (fault) {\n                    case \"overflow\": case \"underflow\": case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\": case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n\n        // @TODO: Any??\n        const error: any = new Error(message);\n        error.reason = reason;\n        error.code = code\n\n        Object.keys(params).forEach(function(key) {\n            error[key] = params[key];\n        });\n\n        return error;\n    }\n\n    throwError(message: string, code?: ErrorCode, params?: any): never {\n        throw this.makeError(message, code, params);\n    }\n\n    throwArgumentError(message: string, name: string, value: any): never {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n\n    assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n        if (!!condition) { return; }\n        this.throwError(message, code, params);\n    }\n\n    assertArgument(condition: any, message: string, name: string, value: any): void {\n        if (!!condition) { return; }\n        this.throwArgumentError(message, name, value);\n    }\n\n    checkNormalize(message?: string): void {\n        if (message == null) { message = \"platform missing String.prototype.normalize\"; }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n\n    checkSafeUint53(value: number, message?: string): void {\n        if (typeof(value) !== \"number\") { return; }\n\n        if (message == null) { message = \"value not safe\"; }\n\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n\n    checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n        if (message) {\n            message = \": \" + message;\n        } else {\n            message = \"\";\n        }\n\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n\n    checkNew(target: any, kind: any): void {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    checkAbstract(target: any, kind: any): void {\n        if (target === kind) {\n            this.throwError(\n                \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { name: target.name, operation: \"new\" }\n            );\n        } else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n\n    static globalLogger(): Logger {\n        if (!_globalLogger) { _globalLogger = new Logger(version); }\n        return _globalLogger;\n    }\n\n    static setCensorship(censorship: boolean, permanent?: boolean): void {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        if (_permanentCensorErrors) {\n            if (!censorship) { return; }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n\n    static setLogLevel(logLevel: LogLevel): void {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n\n    static from(version: string): Logger {\n        return new Logger(version);\n    }\n}\n","export const version = \"logger/5.7.0\";\n","export const version = \"bytes/5.7.0\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\nexport type Bytes = ArrayLike<number>;\n\nexport type BytesLike = Bytes | string;\n\nexport type DataOptions = {\n    allowMissingPrefix?: boolean;\n    hexPad?: \"left\" | \"right\" | null;\n};\n\nexport interface Hexable {\n    toHexString(): string;\n}\n\n\n/*\nexport interface HexString {\n    length: number;\n    substring: (start: number, end?: number) => string;\n\n    [index: number]: string;\n}\n*/\n\nexport type SignatureLike  = {\n    r: string;\n    s?: string;\n    _vs?: string,\n    recoveryParam?: number;\n    v?: number;\n} | BytesLike;\n\nexport interface Signature {\n    r: string;\n\n    s: string;\n    _vs: string,\n\n    recoveryParam: number;\n    v: number;\n\n    yParityAndS: string\n    compact: string;\n}\n\n///////////////////////////////\n\n\nfunction isHexable(value: any): value is Hexable {\n    return !!(value.toHexString);\n}\n\nfunction addSlice(array: Uint8Array): Uint8Array {\n    if (array.slice) { return array; }\n\n    array.slice = function() {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    }\n\n    return array;\n}\n\nexport function isBytesLike(value: any): value is BytesLike {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\n\nfunction isInteger(value: number) {\n    return (typeof(value) === \"number\" && value == value && (value % 1) === 0);\n}\n\nexport function isBytes(value: any): value is Bytes {\n    if (value == null) { return false; }\n\n    if (value.constructor === Uint8Array) { return true; }\n    if (typeof(value) === \"string\") { return false; }\n    if (!isInteger(value.length) || value.length < 0) { return false; }\n\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) { return false; }\n    }\n    return true;\n}\n\n\nexport function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid arrayify value\");\n\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) { result.push(0); }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { value = value.toHexString(); }\n\n    if (isHexString(value)) {\n        let hex = (<string>value).substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            } else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n\n        return addSlice(new Uint8Array(result));\n    }\n\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n\n    return logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\n\nexport function concat(items: ReadonlyArray<BytesLike>): Uint8Array {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n\n    const result = new Uint8Array(length);\n\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n\n    return addSlice(result);\n}\n\nexport function stripZeros(value: BytesLike): Uint8Array {\n    let result: Uint8Array = arrayify(value);\n\n    if (result.length === 0) { return result; }\n\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) { start++ }\n\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n\n    return result;\n}\n\nexport function zeroPad(value: BytesLike, length: number): Uint8Array {\n    value = arrayify(value);\n\n    if (value.length > length) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\n\n\nexport function isHexString(value: any, length?: number): boolean {\n    if (typeof(value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false\n    }\n    if (length && value.length !== 2 + 2 * length) { return false; }\n    return true;\n}\n\nconst HexCharacters: string = \"0123456789abcdef\";\n\nexport function hexlify(value: BytesLike | Hexable | number | bigint, options?: DataOptions): string {\n    if (!options) { options = { }; }\n\n    if (typeof(value) === \"number\") {\n        logger.checkSafeUint53(value, \"invalid hexlify value\");\n\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n\n        if (hex.length) {\n            if (hex.length % 2) { hex = \"0\" + hex; }\n            return \"0x\" + hex;\n        }\n\n        return \"0x00\";\n    }\n\n    if (typeof(value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) { return (\"0x0\" + value); }\n        return \"0x\" + value;\n    }\n\n    if (options.allowMissingPrefix && typeof(value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n         value = \"0x\" + value;\n    }\n\n    if (isHexable(value)) { return value.toHexString(); }\n\n    if (isHexString(value)) {\n        if ((<string>value).length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + (<string>value).substring(2);\n            } else if (options.hexPad === \"right\") {\n                value += \"0\";\n            } else {\n                logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return (<string>value).toLowerCase();\n    }\n\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n             let v = value[i];\n             result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n\n    return logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nexport function hexDataLength(data: BytesLike) {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n\n    return (data.length - 2) / 2;\n}\n\nexport function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string {\n    if (typeof(data) !== \"string\") {\n        data = hexlify(data);\n    } else if (!isHexString(data) || (data.length % 2)) {\n        logger.throwArgumentError(\"invalid hexData\", \"value\", data );\n    }\n\n    offset = 2 + 2 * offset;\n\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n\n    return \"0x\" + data.substring(offset);\n}\n\nexport function hexConcat(items: ReadonlyArray<BytesLike>): string {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\n\nexport function hexValue(value: BytesLike | Hexable | number | bigint): string {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") { return \"0x0\"; }\n    return trimmed;\n}\n\nexport function hexStripZeros(value: BytesLike): string {\n    if (typeof(value) !== \"string\") { value = hexlify(value); }\n\n    if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") { offset++; }\n    return \"0x\" + value.substring(offset);\n}\n\nexport function hexZeroPad(value: BytesLike, length: number): string {\n    if (typeof(value) !== \"string\") {\n        value = hexlify(value);\n    } else if (!isHexString(value)) {\n        logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n\n    if (value.length > 2 * length + 2) {\n        logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n\n    return value;\n}\n\nexport function splitSignature(signature: SignatureLike): Signature {\n\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n\n    if (isBytesLike(signature)) {\n        let bytes: Uint8Array = arrayify(signature);\n\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n\n        } else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        } else {\n\n            logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n\n\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            } else {\n                logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) { bytes[32] |= 0x80; }\n        result._vs = hexlify(bytes.slice(32, 64))\n\n    } else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1: 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            } else if (result.recoveryParam !== recoveryParam) {\n                logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            } else if (result.s !== s) {\n                logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            } else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            } else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        } else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            } else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v :(1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n\n        if (result.r == null || !isHexString(result.r)) {\n            logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        } else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n\n        if (result.s == null || !isHexString(result.s)) {\n            logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        } else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) { vs[0] |= 0x80; }\n        const _vs = hexlify(vs);\n\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        } else if (result._vs !== _vs) {\n            logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n\n    return result;\n}\n\nexport function joinSignature(signature: SignatureLike): string {\n    signature = splitSignature(signature);\n\n    return hexlify(concat([\n         signature.r,\n         signature.s,\n         (signature.recoveryParam ? \"0x1c\": \"0x1b\")\n    ]));\n}\n\n","export const version = \"rlp/5.7.0\";\n","\"use strict\";\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, BytesLike, hexlify, isBytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value: number): Array<number> {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\n\nfunction unarrayifyInteger(data: Uint8Array, offset: number, length: number): number {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\n\nfunction _encode(object: Array<any> | string): Array<number> {\n    if (Array.isArray(object)) {\n        let payload: Array<number> = [];\n        object.forEach(function(child) {\n            payload = payload.concat(_encode(child));\n        });\n\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length)\n            return payload;\n        }\n\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n\n        return length.concat(payload);\n\n    }\n\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n\n    const data: Array<number> = Array.prototype.slice.call(arrayify(object));\n\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n\n    } else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n\n    return length.concat(data);\n}\n\nexport function encode(object: any): string {\n    return hexlify(_encode(object));\n}\n\ntype Decoded = {\n    result: any;\n    consumed: number;\n};\n\nfunction _decodeChildren(data: Uint8Array, offset: number, childOffset: number, length: number): Decoded {\n    const result = [];\n\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n\n        result.push(decoded.result);\n\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n    }\n\n    return {consumed: (1 + length), result: result};\n}\n\n// returns { consumed: number, result: Object }\nfunction _decode(data: Uint8Array, offset: number): { consumed: number, result: any } {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n    }\n\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n\n    } else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        return _decodeChildren(data, offset, offset + 1, length);\n\n    } else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result }\n\n    } else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, { });\n        }\n\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result }\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\n\nexport function decode(data: BytesLike): any {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n\n","import { BigNumber } from \"bignumber.js\";\nimport {\n  ERC20_CLEAR_SIGNED_SELECTORS,\n  ERC721_CLEAR_SIGNED_SELECTORS,\n  ERC1155_CLEAR_SIGNED_SELECTORS,\n} from \"@ledgerhq/evm-tools/selectors/index\";\nimport { encode, decode } from \"@ethersproject/rlp\";\nimport { LedgerEthTransactionResolution } from \"./services/types\";\n\nexport {\n  ERC20_CLEAR_SIGNED_SELECTORS,\n  ERC721_CLEAR_SIGNED_SELECTORS,\n  ERC1155_CLEAR_SIGNED_SELECTORS,\n};\n\nexport const padHexString = (str: string) => {\n  return str.length % 2 ? \"0\" + str : str;\n};\n\nexport function splitPath(path: string): number[] {\n  const result: number[] = [];\n  const components = path.split(\"/\");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n    if (isNaN(number)) {\n      return; // FIXME shouldn't it throws instead?\n    }\n    if (element.length > 1 && element[element.length - 1] === \"'\") {\n      number += 0x80000000;\n    }\n    result.push(number);\n  });\n  return result;\n}\n\nexport function hexBuffer(str: string): Buffer {\n  const strWithoutPrefix = str.startsWith(\"0x\") ? str.slice(2) : str;\n  return Buffer.from(padHexString(strWithoutPrefix), \"hex\");\n}\n\nexport function maybeHexBuffer(str: string | null | undefined): Buffer | null | undefined {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nexport const decodeTxInfo = (rawTx: Buffer) => {\n  const VALID_TYPES = [1, 2];\n  const txType = VALID_TYPES.includes(rawTx[0]) ? rawTx[0] : null;\n  const rlpData = txType === null ? rawTx : rawTx.slice(1);\n  const rlpTx = decode(rlpData).map(hex => Buffer.from(hex.slice(2), \"hex\"));\n  let chainIdTruncated = 0;\n  const rlpDecoded = decode(rlpData);\n\n  let decodedTx;\n  if (txType === 2) {\n    // EIP1559\n    decodedTx = {\n      data: rlpDecoded[7],\n      to: rlpDecoded[5],\n      chainId: rlpTx[0],\n    };\n  } else if (txType === 1) {\n    // EIP2930\n    decodedTx = {\n      data: rlpDecoded[6],\n      to: rlpDecoded[4],\n      chainId: rlpTx[0],\n    };\n  } else {\n    // Legacy tx\n    decodedTx = {\n      data: rlpDecoded[5],\n      to: rlpDecoded[3],\n      // Default to 1 for non EIP 155 txs\n      chainId: rlpTx.length > 6 ? rlpTx[6] : Buffer.from(\"0x01\", \"hex\"),\n    };\n  }\n\n  const chainIdSrc = decodedTx.chainId;\n  let chainId = new BigNumber(0);\n  if (chainIdSrc) {\n    // Using BigNumber because chainID could be any uint256.\n    chainId = new BigNumber(chainIdSrc.toString(\"hex\"), 16);\n    const chainIdTruncatedBuf = Buffer.alloc(4);\n    if (chainIdSrc.length > 4) {\n      chainIdSrc.copy(chainIdTruncatedBuf);\n    } else {\n      chainIdSrc.copy(chainIdTruncatedBuf, 4 - chainIdSrc.length);\n    }\n    chainIdTruncated = chainIdTruncatedBuf.readUInt32BE(0);\n  }\n\n  let vrsOffset = 0;\n  if (txType === null && rlpTx.length > 6) {\n    const rlpVrs = Buffer.from(encode(rlpTx.slice(-3)).slice(2), \"hex\");\n\n    vrsOffset = rawTx.length - (rlpVrs.length - 1);\n\n    // First byte > 0xf7 means the length of the list length doesn't fit in a single byte.\n    if (rlpVrs[0] > 0xf7) {\n      // Increment vrsOffset to account for that extra byte.\n      vrsOffset++;\n\n      // Compute size of the list length.\n      const sizeOfListLen = rlpVrs[0] - 0xf7;\n\n      // Increase rlpOffset by the size of the list length.\n      vrsOffset += sizeOfListLen - 1;\n    }\n  }\n\n  return {\n    decodedTx,\n    txType,\n    chainId,\n    chainIdTruncated,\n    vrsOffset,\n  };\n};\n\n/**\n * @ignore for the README\n *\n * Helper to convert an integer as a hexadecimal string with the right amount of digits\n * to respect the number of bytes given as parameter\n *\n * @param int Integer\n * @param bytes Number of bytes it should be represented as (1 byte = 2 caraters)\n * @returns The given integer as an hexa string padded with the right number of 0\n */\nexport const intAsHexBytes = (int: number, bytes: number): string =>\n  int.toString(16).padStart(2 * bytes, \"0\");\n\nexport const tokenSelectors = Object.values(ERC20_CLEAR_SIGNED_SELECTORS);\nexport const nftSelectors = [\n  ...Object.values(ERC721_CLEAR_SIGNED_SELECTORS),\n  ...Object.values(ERC1155_CLEAR_SIGNED_SELECTORS),\n];\n\nexport const mergeResolutions = (\n  resolutionsArray: Partial<LedgerEthTransactionResolution>[],\n): LedgerEthTransactionResolution => {\n  const mergedResolutions: LedgerEthTransactionResolution = {\n    nfts: [],\n    erc20Tokens: [],\n    externalPlugin: [],\n    plugin: [],\n    domains: [],\n  };\n\n  for (const resolutions of resolutionsArray) {\n    for (const key in resolutions) {\n      mergedResolutions[key].push(...resolutions[key]);\n    }\n  }\n\n  return mergedResolutions;\n};\n","\"use strict\";\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nimport _BN from \"bn.js\";\nimport BN = _BN.BN;\n\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst _constructorGuard = { };\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\n\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\n\nexport function isBigNumberish(value: any): value is BigNumberish {\n    return (value != null) && (\n        BigNumber.isBigNumber(value) ||\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof(value) === \"bigint\") ||\n        isBytes(value)\n    );\n}\n\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\n\nexport class BigNumber implements Hexable {\n    readonly _hex: string;\n    readonly _isBigNumber: boolean;\n\n    constructor(constructorGuard: any, hex: string) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n\n        this._hex = hex;\n        this._isBigNumber = true;\n\n        Object.freeze(this);\n    }\n\n    fromTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n\n    toTwos(value: number): BigNumber {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n\n    abs(): BigNumber {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n\n    add(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n\n    sub(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n\n    div(other: BigNumberish): BigNumber {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n\n    mul(other: BigNumberish): BigNumber {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n\n    mod(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n\n    pow(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n\n    and(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n\n    or(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n\n    xor(other: BigNumberish): BigNumber {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n\n    mask(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n\n    shl(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n\n    shr(value: number): BigNumber {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n\n    eq(other: BigNumberish): boolean {\n        return toBN(this).eq(toBN(other));\n    }\n\n    lt(other: BigNumberish): boolean {\n        return toBN(this).lt(toBN(other));\n    }\n\n    lte(other: BigNumberish): boolean {\n        return toBN(this).lte(toBN(other));\n    }\n\n    gt(other: BigNumberish): boolean {\n        return toBN(this).gt(toBN(other));\n   }\n\n    gte(other: BigNumberish): boolean {\n        return toBN(this).gte(toBN(other));\n    }\n\n    isNegative(): boolean {\n        return (this._hex[0] === \"-\");\n    }\n\n    isZero(): boolean {\n        return toBN(this).isZero();\n    }\n\n    toNumber(): number {\n        try {\n            return toBN(this).toNumber();\n        } catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n\n    toBigInt(): bigint {\n        try {\n            return BigInt(this.toString());\n        } catch (e) { }\n\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n\n    toString(): string {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            } else if (arguments[0] === 16) {\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            } else {\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\n            }\n        }\n        return toBN(this).toString(10);\n    }\n\n    toHexString(): string {\n        return this._hex;\n    }\n\n    toJSON(key?: string): any {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n\n    static from(value: any): BigNumber {\n        if (value instanceof BigNumber) { return value; }\n\n        if (typeof(value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n\n        if (typeof(value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n\n            return BigNumber.from(String(value));\n        }\n\n        const anyValue = <any>value;\n\n        if (typeof(anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n\n        if (anyValue) {\n\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof(hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n\n            } else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n\n                if (typeof(hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n\n    static isBigNumber(value: any): value is BigNumber {\n        return !!(value && value._isBigNumber);\n    }\n}\n\n// Normalize the hex string\nfunction toHex(value: string | BN): string {\n\n    // For BN, call on the hex string\n    if (typeof(value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\n\n        // Call toHex on the positive component\n        value = toHex(value);\n\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") { return value; }\n\n        // Negate the value\n        return \"-\" + value;\n    }\n\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n\n    // Normalize zero\n    if (value === \"0x\") { return \"0x00\"; }\n\n    // Make the string even length\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\n\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n\n    return value;\n}\n\nfunction toBigNumber(value: BN): BigNumber {\n    return BigNumber.from(toHex(value));\n}\n\nfunction toBN(value: BigNumberish): BN {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\n\nfunction throwFault(fault: string, operation: string, value?: any): never {\n    const params: any = { fault: fault, operation: operation };\n    if (value != null) { params.value = value; }\n\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n\n// value should have no prefix\nexport function _base36To16(value: string): string {\n    return (new BN(value, 36)).toString(16);\n}\n\n// value should have no prefix\nexport function _base16To36(value: string): string {\n    return (new BN(value, 16)).toString(36);\n}\n","export const version = \"bignumber/5.7.0\";\n","\"use strict\";\n\nimport sha3 from \"js-sha3\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function keccak256(data: BytesLike): string {\n    return '0x' + sha3.keccak_256(arrayify(data));\n}\n","export const version = \"address/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexDataLength, hexDataSlice, isHexString, stripZeros } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish, _base16To36, _base36To16 } from \"@ethersproject/bignumber\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { encode } from \"@ethersproject/rlp\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction getChecksumAddress(address: string): string {\n    if (!isHexString(address, 20)) {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    address = address.toLowerCase();\n\n    const chars = address.substring(2).split(\"\");\n\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n\n    const hashed = arrayify(keccak256(expanded));\n\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n\n    return \"0x\" + chars.join(\"\");\n}\n\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER: number = 0x1fffffffffffff;\n\nfunction log10(x: number): number {\n    if (Math.log10) { return Math.log10(x); }\n    return Math.log(x) / Math.LN10;\n}\n\n\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\n// Create lookup table\nconst ibanLookup: { [character: string]: string } = { };\nfor (let i = 0; i < 10; i++) { ibanLookup[String(i)] = String(i); }\nfor (let i = 0; i < 26; i++) { ibanLookup[String.fromCharCode(65 + i)] = String(10 + i); }\n\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\nfunction ibanChecksum(address: string): string {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits){\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) { checksum = \"0\" + checksum; }\n\n    return checksum;\n};\n\nexport function getAddress(address: string): string {\n    let result = null;\n\n    if (typeof(address) !== \"string\") {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") { address = \"0x\" + address; }\n\n        result = getChecksumAddress(address);\n\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n\n    // Maybe ICAP? (we only support direct mode)\n    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) { result = \"0\" + result; }\n        result = getChecksumAddress(\"0x\" + result);\n\n    } else {\n        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n\n    return result;\n}\n\nexport function isAddress(address: string): boolean {\n    try {\n        getAddress(address);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getIcapAddress(address: string): string {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) { base36 = \"0\" + base36; }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nexport function getContractAddress(transaction: { from: string, nonce: BigNumberish }) {\n    let from: string = null;\n    try {\n        from = getAddress(transaction.from);\n    } catch (error) {\n        logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n\n    return getAddress(hexDataSlice(keccak256(encode([ from, nonce ])), 12));\n}\n\nexport function getCreate2Address(from: string, salt: BytesLike, initCodeHash: BytesLike): string {\n    if (hexDataLength(salt) !== 32) {\n        logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([ \"0xff\", getAddress(from), salt, initCodeHash ])), 12))\n}\n","export const version = \"strings/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n\nexport enum UnicodeNormalizationForm {\n    current  = \"\",\n    NFC      = \"NFC\",\n    NFD      = \"NFD\",\n    NFKC     = \"NFKC\",\n    NFKD     = \"NFKD\"\n};\n\nexport enum Utf8ErrorReason {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    UNEXPECTED_CONTINUE   = \"unexpected continuation byte\",\n\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    BAD_PREFIX            = \"bad codepoint prefix\",\n\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    OVERRUN               = \"string overrun\",\n\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    MISSING_CONTINUE      = \"missing continuation byte\",\n\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    OUT_OF_RANGE          = \"out of UTF-8 range\",\n\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    UTF16_SURROGATE       = \"UTF-16 surrogate\",\n\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    OVERLONG              = \"overlong representation\",\n};\n\n\nexport type Utf8ErrorFunc = (reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number) => number;\n\nfunction errorFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n    return logger.throwArgumentError(`invalid codepoint at offset ${ offset }; ${ reason }`, \"bytes\", bytes);\n}\n\nfunction ignoreFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) { break; }\n            i++;\n        }\n        return i;\n    }\n\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n\n    // Nothing to skip\n    return 0;\n}\n\nfunction replaceFunc(reason: Utf8ErrorReason, offset: number, bytes: ArrayLike<number>, output: Array<number>, badCodepoint?: number): number {\n\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n\n    // Put the replacement character into the output\n    output.push(0xfffd);\n\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n\n// Common error handing strategies\nexport const Utf8ErrorFuncs: { [ name: string ]: Utf8ErrorFunc } = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes: BytesLike, onError?: Utf8ErrorFunc): Array<number> {\n    if (onError == null) { onError = Utf8ErrorFuncs.error; }\n\n    bytes = arrayify(bytes);\n\n    const result: Array<number> = [];\n    let i = 0;\n\n    // Invalid bytes are ignored\n    while(i < bytes.length) {\n\n        const c = bytes[i++];\n\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n\n        // 1110 xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n\n        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        } else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n\n        } else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            } else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            };\n\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n\n        // See above loop for invalid continuation byte\n        if (res === null) { continue; }\n\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n\n        result.push(res);\n    }\n\n    return result;\n}\n\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Uint8Array {\n\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n\n        if (c < 0x80) {\n            result.push(c);\n\n        } else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n\n        } else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n\n        } else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n\n    return arrayify(result);\n};\n\nfunction escapeChar(value: number) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\n\nexport function _toEscapedUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8:  return \"\\\\b\";\n                case 9:  return \"\\\\t\";\n                case 10: return \"\\\\n\"\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\n\nexport function _toUtf8String(codePoints: Array<number>): string {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode(\n            (((codePoint >> 10) & 0x3ff) + 0xd800),\n            ((codePoint & 0x3ff) + 0xdc00)\n        );\n    }).join(\"\");\n}\n\nexport function toUtf8String(bytes: BytesLike, onError?: Utf8ErrorFunc): string {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n\nexport function toUtf8CodePoints(str: string, form: UnicodeNormalizationForm = UnicodeNormalizationForm.current): Array<number> {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n\n// Crawl up the constructor chain to find a static method\nexport function getStatic<T>(ctor: any, key: string): T {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) { return ctor[key]; }\n        if (!ctor.prototype || typeof(ctor.prototype) !== \"object\") { break; }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\n\nexport type Deferrable<T> = {\n    [ K in keyof T ]: T[K] | Promise<T[K]>;\n}\n\n\ntype Result = { key: string, value: any};\n\nexport async function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T> {\n    const promises: Array<Promise<Result>> = Object.keys(object).map((key) => {\n        const value = object[<keyof Deferrable<T>>key];\n        return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n    });\n\n    const results = await Promise.all(promises);\n\n    return results.reduce((accum, result) => {\n        accum[<keyof T>(result.key)] = result.value;\n        return accum;\n    }, <T>{ });\n}\n\nexport function checkProperties(object: any, properties: { [ name: string ]: boolean }): void {\n    if (!object || typeof(object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\n\nexport function shallowCopy<T>(object: T): T {\n    const result: any = {};\n    for (const key in object) { result[key] = object[key]; }\n    return result;\n}\n\nconst opaque: { [key: string]: boolean } = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\n\nfunction _isFrozen(object: any): boolean {\n\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof(object)]) { return true; }\n\n    if (Array.isArray(object) || typeof(object) === \"object\") {\n        if (!Object.isFrozen(object)) { return false; }\n\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value: any = null;\n            try {\n                value = object[keys[i]];\n            } catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n\n            if (!_isFrozen(value)) { return false; }\n        }\n\n        return true;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object: any): any {\n\n    if (_isFrozen(object)) { return object; }\n\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n\n    if (typeof(object) === \"object\") {\n        const result: { [ key: string ]: any } = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) { continue; }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n\n        return result;\n    }\n\n    return logger.throwArgumentError(`Cannot deepCopy ${ typeof(object) }`, \"object\", object);\n}\n\nexport function deepCopy<T>(object: T): T {\n    return _deepCopy(object);\n}\n\nexport class Description<T = any> {\n    constructor(info: { [ K in keyof T ]: T[K] }) {\n        for (const key in info) {\n            (<any>this)[key] = deepCopy(info[key]);\n        }\n    }\n}\n","export const version = \"properties/5.7.0\";\n","export const version = \"abi/5.7.0\";\n","\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class AddressCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"address\", \"address\", localName, false);\n    }\n\n    defaultValue(): string {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n\n    encode(writer: Writer, value: string): number {\n        try {\n            value = getAddress(value)\n        } catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n\n    decode(reader: Reader): any {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    private coder: Coder;\n\n    constructor(coder: Coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n\n    defaultValue(): any {\n        return this.coder.defaultValue();\n    }\n\n    encode(writer: Writer, value: any): number {\n        return this.coder.encode(writer, value);\n    }\n\n    decode(reader: Reader): any {\n        return this.coder.decode(reader);\n    }\n}\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\n\nexport function pack(writer: Writer, coders: ReadonlyArray<Coder>, values: Array<any> | { [ name: string ]: any }): number {\n    let arrayValues: Array<any> = null;\n\n    if (Array.isArray(values)) {\n       arrayValues = values;\n\n    } else if (values && typeof(values) === \"object\") {\n        let unique: { [ name: string ]: boolean } = { };\n\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n\n            unique[name] = true;\n\n            return values[name];\n        });\n\n    } else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n\n    let updateFuncs: Array<(baseOffset: number) => void> = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset: number) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n\n        } else {\n            coder.encode(staticWriter, value);\n        }\n    });\n\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n\nexport function unpack(reader: Reader, coders: Array<Coder>): Result {\n    let values: any = [];\n\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n\n    coders.forEach((coder) => {\n        let value: any = null;\n\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n\n        } else {\n            try {\n                value = coder.decode(reader);\n            } catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) { throw error; }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) { accum[name] = 0; }\n            accum[name]++;\n        }\n        return accum;\n    }, <{ [ name: string ]: number }>{ });\n\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder: Coder, index: number) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) { return; }\n\n        if (name === \"length\") { name = \"_length\"; }\n\n        if (values[name] != null) { return; }\n\n        const value = values[index];\n\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        } else {\n            values[name] = value;\n        }\n    });\n\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n\n    return Object.freeze(values);\n}\n\n\nexport class ArrayCoder extends Coder {\n    readonly coder: Coder;\n    readonly length: number;\n\n    constructor(coder: Coder, length: number, localName: string) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length: \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n\n        this.coder = coder;\n        this.length = length;\n    }\n\n    defaultValue(): Array<any> {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n\n        const result: Array<any> = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n\n    encode(writer: Writer, value: Array<any>): number {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n\n        let count = this.length;\n\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName? (\" \"+ this.localName): \"\"));\n\n        let coders = [];\n        for (let i = 0; i < value.length; i++) { coders.push(this.coder); }\n\n        return pack(writer, coders, value);\n    }\n\n    decode(reader: Reader): any {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) { coders.push(new AnonymousCoder(this.coder)); }\n\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class BooleanCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n\n    defaultValue(): boolean {\n        return false;\n    }\n\n    encode(writer: Writer, value: boolean): number {\n        return writer.writeValue(value ? 1: 0);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n\n","\"use strict\";\n\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class DynamicBytesCoder extends Coder {\n    constructor(type: string, localName: string) {\n       super(type, type, localName, true);\n    }\n\n    defaultValue(): string {\n        return \"0x\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n\n    decode(reader: Reader): any {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\n\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName: string) {\n        super(\"bytes\", localName);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n\n\n","\"use strict\";\n\nimport { arrayify, BytesLike, hexlify } from \"@ethersproject/bytes\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    readonly size: number;\n\n    constructor(size: number, localName: string) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n\n    defaultValue(): string {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n\n    encode(writer: Writer, value: BytesLike): number {\n        let data = arrayify(value);\n        if (data.length !== this.size) { this._throwError(\"incorrect data length\", value); }\n        return writer.writeBytes(data);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NullCoder extends Coder {\n\n    constructor(localName: string) {\n        super(\"null\", \"\", localName, false);\n    }\n\n    defaultValue(): null {\n        return null;\n    }\n\n    encode(writer: Writer, value: any): number {\n        if (value != null) { this._throwError(\"not null\", value); }\n        return writer.writeBytes([ ]);\n    }\n\n    decode(reader: Reader): any {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n","import { BigNumber } from \"@ethersproject/bignumber\";\n\nconst NegativeOne: BigNumber = (/*#__PURE__*/BigNumber.from(-1));\nconst Zero: BigNumber = (/*#__PURE__*/BigNumber.from(0));\nconst One: BigNumber = (/*#__PURE__*/BigNumber.from(1));\nconst Two: BigNumber = (/*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther: BigNumber = (/*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst MaxUint256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nconst MinInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256: BigNumber = (/*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\nexport {\n    NegativeOne,\n    Zero,\n    One,\n    Two,\n    WeiPerEther,\n    MaxUint256,\n    MinInt256,\n    MaxInt256,\n};\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\n\nexport class NumberCoder extends Coder {\n    readonly size: number;\n    readonly signed: boolean;\n\n    constructor(size: number, signed: boolean, localName: string) {\n        const name = ((signed ? \"int\": \"uint\") + (size * 8));\n        super(name, name, localName, false);\n\n        this.size = size;\n        this.signed = signed;\n    }\n\n    defaultValue(): number {\n        return 0;\n    }\n\n    encode(writer: Writer, value: BigNumberish): number {\n        let v = BigNumber.from(value);\n\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        } else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n\n        return writer.writeValue(v);\n    }\n\n    decode(reader: Reader): any {\n        let value = reader.readValue().mask(this.size * 8);\n\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n\n        return reader.coerce(this.name, value);\n    }\n}\n\n","\"use strict\";\n\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Reader, Writer } from \"./abstract-coder\";\nimport { DynamicBytesCoder } from \"./bytes\";\n\nexport class StringCoder extends DynamicBytesCoder {\n\n    constructor(localName: string) {\n        super(\"string\", localName);\n    }\n\n    defaultValue(): string {\n        return \"\";\n    }\n\n    encode(writer: Writer, value: any): number {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n\n    decode(reader: Reader): any {\n        return toUtf8String(super.decode(reader));\n    }\n}\n","\"use strict\";\n\nimport { Coder, Reader, Writer } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\n\nexport class TupleCoder extends Coder {\n    readonly coders: Array<Coder>;\n\n    constructor(coders: Array<Coder>, localName: string) {\n        let dynamic = false;\n        const types: Array<string> = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) { dynamic = true; }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n\n    defaultValue(): any {\n        const values: any = [ ];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) { accum[name] = 0; }\n                accum[name]++;\n            }\n            return accum;\n        }, <{ [ name: string ]: number }>{ });\n\n        // Add named values\n        this.coders.forEach((coder: Coder, index: number) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) { return; }\n\n            if (name === \"length\") { name = \"_length\"; }\n\n            if (values[name] != null) { return; }\n\n            values[name] = values[index];\n        });\n\n        return Object.freeze(values);\n    }\n\n    encode(writer: Writer, value: Array<any> | { [ name: string ]: any }): number {\n        return pack(writer, this.coders, value);\n    }\n\n    decode(reader: Reader): any {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Coder, Reader, Result, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\n\nimport { ParamType } from \"./fragments\";\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport class AbiCoder {\n    readonly coerceFunc: CoerceFunc;\n\n    constructor(coerceFunc?: CoerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n\n    _getCoder(param: ParamType): Coder {\n\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n\n    _getWordSize(): number { return 32; }\n\n    _getReader(data: Uint8Array, allowLoose?: boolean): Reader {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n\n    _getWriter(): Writer {\n        return new Writer(this._getWordSize());\n    }\n\n    getDefaultValue(types: ReadonlyArray<string | ParamType>): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n\n    encode(types: ReadonlyArray<string | ParamType>, values: ReadonlyArray<any>): string {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n\n    decode(types: ReadonlyArray<string | ParamType>, data: BytesLike, loose?: boolean): Result {\n        const coders: Array<Coder> = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\n\nexport const defaultAbiCoder: AbiCoder = new AbiCoder();\n\n","\"use strict\";\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\"\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\n\nimport { AbiCoder, defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, JsonFragment, ParamType } from \"./fragments\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription extends Description<LogDescription> {\n    readonly eventFragment: EventFragment;\n    readonly name: string;\n    readonly signature: string;\n    readonly topic: string;\n    readonly args: Result\n}\n\nexport class TransactionDescription extends Description<TransactionDescription> {\n    readonly functionFragment: FunctionFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n    readonly value: BigNumber;\n}\n\nexport class ErrorDescription extends Description<ErrorDescription> {\n    readonly errorFragment: ErrorFragment;\n    readonly name: string;\n    readonly args: Result;\n    readonly signature: string;\n    readonly sighash: string;\n}\n\nexport class Indexed extends Description<Indexed> {\n    readonly hash: string;\n    readonly _isIndexed: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n}\n\nconst BuiltinErrors: Record<string, { signature: string, inputs: Array<string>, name: string, reason?: boolean }> = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [ \"string\" ], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [ \"uint256\" ] }\n}\n\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    readonly fragments: ReadonlyArray<Fragment>;\n\n    readonly errors: { [ name: string ]: ErrorFragment };\n    readonly events: { [ name: string ]: EventFragment };\n    readonly functions: { [ name: string ]: FunctionFragment };\n    readonly structs: { [ name: string ]: any };\n\n    readonly deploy: ConstructorFragment;\n\n    readonly _abiCoder: AbiCoder;\n\n    readonly _isInterface: boolean;\n\n    constructor(fragments: string | ReadonlyArray<Fragment | JsonFragment | string>) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n\n        defineReadOnly(this, \"_abiCoder\", getStatic<() => AbiCoder>(new.target, \"getAbiCoder\")());\n\n        defineReadOnly(this, \"functions\", { });\n        defineReadOnly(this, \"errors\", { });\n        defineReadOnly(this, \"events\", { });\n        defineReadOnly(this, \"structs\", { });\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket: { [ name: string ]: Fragment } = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", <ConstructorFragment>fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n\n            bucket[signature] = fragment;\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n\n    format(format?: string): string | Array<string> {\n        if (!format) { format = FormatTypes.full; }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n             return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n\n        return abi;\n    }\n\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder(): AbiCoder {\n        return defaultAbiCoder;\n    }\n\n    static getAddress(address: string): string {\n        return getAddress(address);\n    }\n\n    static getSighash(fragment: ErrorFragment | FunctionFragment): string {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n\n    static getEventTopic(eventFragment: EventFragment): string {\n        return id(eventFragment.format());\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash: string): FunctionFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n\n            return this.functions[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic: string): EventFragment {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n\n            return this.events[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash: string): ErrorFragment {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\"/* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            } else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n\n            return this.errors[matching[0]];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment: ErrorFragment | FunctionFragment | string): string {\n        if (typeof(fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            } catch (error) {\n                try {\n                    fragment = this.getError(<string>fragment);\n                } catch (_) {\n                    throw error;\n                }\n            }\n        }\n\n        return getStatic<(f: ErrorFragment | FunctionFragment) => string>(this.constructor, \"getSighash\")(fragment);\n    }\n\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment: EventFragment | string): string {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        return getStatic<(e: EventFragment) => string>(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this._abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this._abiCoder.encode(params, values)\n    }\n\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${ fragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        const bytes = arrayify(data);\n\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${ functionFragment.name }.`, \"data\", hexlify(bytes));\n        }\n\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [ ])\n        ]));\n    }\n\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        let bytes = arrayify(data);\n\n        let reason: string = null;\n        let message = \"\";\n        let errorArgs: Result = null;\n        let errorName: string = null;\n        let errorSignature: string = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                } catch (error) { }\n                break;\n\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) { reason = errorArgs[0]; }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${ JSON.stringify(errorArgs[0]) }`;\n                    } else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${ errorArgs[0] }`;\n                    }\n                } else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    } catch (error) { }\n                }\n                break;\n            }\n        }\n\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || [ ]));\n    }\n\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment: EventFragment | string, values: ReadonlyArray<any>): Array<string | Array<string>> {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            })\n        }\n\n        let topics: Array<string | Array<string>> = [];\n        if (!eventFragment.anonymous) { topics.push(this.getEventTopic(eventFragment)); }\n\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = BigNumber.from(value).toHexString();\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this._abiCoder.encode( [ \"address\" ], [ value ]); }\n            return hexZeroPad(hexlify(value), 32);\n        };\n\n        values.forEach((value, index) => {\n\n            let param = (<EventFragment>eventFragment).inputs[index];\n\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(eventFragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this._abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this._abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n\n        let indexed: Array<ParamType> = [];\n        let nonIndexed: Array<ParamType> = [];\n        let dynamic: Array<boolean> = [];\n\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)): null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\n        let result: (Array<any> & { [ key: string ]: any }) = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\n                } else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\n                } else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        result[index] = error;\n                    }\n                }\n            } else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    result[index] = error;\n                }\n            }\n\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${ JSON.stringify(param.name) }`, value); }\n                    });\n                } else {\n                    result[param.name] = value;\n                }\n            }\n        });\n\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${ i }`, value); }\n                });\n            }\n        }\n\n        return Object.freeze(result);\n    }\n\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx: { data: string, value?: BigNumberish }): TransactionDescription {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log: { topics: Array<string>, data: string}): LogDescription {\n        let fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n\n    parseError(data: BytesLike): ErrorDescription {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase())\n\n        if (!fragment) { return null; }\n\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n\n\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n\n    static isInterface(value: any): value is Interface {\n        return !!(value && value._isInterface);\n    }\n}\n\n","import { Registry } from \"../types\";\n\nconst REGISTRIES: Registry[] = [\n  {\n    name: \"ens\",\n    resolvers: {\n      forward: \"https://explorers.api.live.ledger.com/blockchain/v4/eth/ens/resolve/{name}\",\n      reverse:\n        \"https://explorers.api.live.ledger.com/blockchain/v4/eth/ens/reverse-resolve/{address}\",\n    },\n    signatures: {\n      forward: \"https://nft.api.live.ledger.com/v1/names/ens/forward/{name}?challenge={challenge}\",\n      reverse:\n        \"https://nft.api.live.ledger.com/v1/names/ens/reverse/{address}?challenge={challenge}\",\n    },\n    patterns: {\n      forward: new RegExp(\"\\\\.eth$\"),\n      reverse: new RegExp(\"^0x[0-9a-fA-F]{40}$\"),\n    },\n    coinTypes: [60],\n  },\n];\n\n/**\n * Method is voluntarly made async so it can be replaced by a backend call once implemented\n */\nexport const getRegistries = async (): Promise<Registry[]> => REGISTRIES;\n\n/**\n * Get an array of registries compatible with a given domain\n *\n * @param {string} domain\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const getRegistriesForDomain = async (domain: string): Promise<Registry[]> => {\n  const registries = await getRegistries();\n\n  return registries.filter(registry => registry.patterns.forward.test(domain));\n};\n\n/**\n * Get an array of registries compatible with a given address\n *\n * @param {string} address\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const getRegistriesForAddress = async (address: string): Promise<Registry[]> => {\n  const registries = await getRegistries();\n\n  return registries.filter(registry => registry.patterns.reverse.test(address));\n};\n","import axios from \"axios\";\nimport { log } from \"@ledgerhq/logs\";\nimport { SupportedRegistries } from \"../types\";\nimport { getRegistries } from \"../registries\";\nimport { validateDomain } from \"../utils\";\n\n/**\n * Get an APDU to sign a domain resolution on the nano\n *\n * @param {string} domain\n * @param {SupportedRegistries} registryName\n * @param {string} challenge\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const signDomainResolution = async (\n  domain: string,\n  registryName: SupportedRegistries,\n  challenge: string,\n): Promise<string | null> => {\n  if (!validateDomain(domain)) {\n    throw new Error(\n      `Domains with more than 255 caracters or with unicode are not supported on the nano. Domain: ${domain}`,\n    );\n  }\n  const registries = await getRegistries();\n  const registry = registries.find(r => r.name === registryName);\n  if (!registry) return null;\n\n  const url = registry.signatures.forward\n    .replace(\"{name}\", domain)\n    .replace(\"{challenge}\", challenge);\n\n  return axios\n    .request<{ payload: string }>({\n      method: \"GET\",\n      url,\n    })\n    .then(({ data }) => data.payload)\n    .catch(error => {\n      /* istanbul ignore next: don't test logs */\n      if (error.status !== 404) {\n        log(\"domain-service\", \"failed to get APDU for a domain\", {\n          domain,\n          error,\n        });\n      }\n      return null;\n    });\n};\n\n/**\n * Get an APDU to sign an address resolve resolution on the nano\n *\n * @param {string} address\n * @param {SupportedRegistries} registryName\n * @param {string} challenge\n * @returns {Promise<AddressResolutionResponse[]>}\n */\nexport const signAddressResolution = async (\n  address: string,\n  registryName: SupportedRegistries,\n  challenge: string,\n): Promise<string | null> => {\n  const registries = await getRegistries();\n  const registry = registries.find(r => r.name === registryName);\n  if (!registry) return null;\n\n  const url = registry.signatures.reverse\n    .replace(\"{address}\", address)\n    .replace(\"{challenge}\", challenge);\n\n  return axios\n    .request<{ payload: string }>({\n      method: \"GET\",\n      url,\n    })\n    .then(({ data }) => data.payload)\n    .catch(error => {\n      /* istanbul ignore next: don't test logs */\n      if (error.status !== 404) {\n        log(\"domain-service\", \"failed to get APDU for an address\", {\n          address,\n          error,\n        });\n      }\n      return null;\n    });\n};\n","import ethereum_tokens from \"./1/erc20.json\";\nimport optimism_tokens from \"./10/erc20.json\";\nimport cronos_tokens from \"./25/erc20.json\";\nimport rsk_tokens from \"./30/erc20.json\";\nimport telos_evm_tokens from \"./40/erc20.json\";\nimport bsc_tokens from \"./56/erc20.json\";\nimport syscoin_tokens from \"./57/erc20.json\";\nimport velas_evm_tokens from \"./106/erc20.json\";\nimport polygon_tokens from \"./137/erc20.json\";\nimport bittorrent_tokens from \"./199/erc20.json\";\nimport energy_web_tokens from \"./246/erc20.json\";\nimport fantom_tokens from \"./250/erc20.json\";\nimport astar_tokens from \"./592/erc20.json\";\nimport metis_tokens from \"./1088/erc20.json\";\nimport polygon_zk_evm_tokens from \"./1101/erc20.json\";\nimport moonbeam_tokens from \"./1284/erc20.json\";\nimport polygon_zk_evm_testnet_tokens from \"./1442/erc20.json\";\nimport klaytn_tokens from \"./8217/erc20.json\";\nimport base_tokens from \"./8453/erc20.json\";\nimport arbitrum_tokens from \"./42161/erc20.json\";\nimport avalanche_c_chain_tokens from \"./43114/erc20.json\";\nimport linea_tokens from \"./59144/erc20.json\";\nimport blast_tokens from \"./81457/erc20.json\";\nimport base_sepolia_tokens from \"./84532/erc20.json\";\nimport arbitrum_sepolia_tokens from \"./421614/erc20.json\";\nimport scroll_sepolia_tokens from \"./534351/erc20.json\";\nimport scroll_tokens from \"./534352/erc20.json\";\nimport ethereum_sepolia_tokens from \"./11155111/erc20.json\";\nimport optimism_sepolia_tokens from \"./11155420/erc20.json\";\nimport blast_sepolia_tokens from \"./168587773/erc20.json\";\nimport neon_evm_tokens from \"./245022934/erc20.json\";\n\nimport ethereum_tokens_hash from \"./1/erc20-hash.json\";\nimport optimism_tokens_hash from \"./10/erc20-hash.json\";\nimport cronos_tokens_hash from \"./25/erc20-hash.json\";\nimport rsk_tokens_hash from \"./30/erc20-hash.json\";\nimport telos_evm_tokens_hash from \"./40/erc20-hash.json\";\nimport bsc_tokens_hash from \"./56/erc20-hash.json\";\nimport syscoin_tokens_hash from \"./57/erc20-hash.json\";\nimport velas_evm_tokens_hash from \"./106/erc20-hash.json\";\nimport polygon_tokens_hash from \"./137/erc20-hash.json\";\nimport bittorrent_tokens_hash from \"./199/erc20-hash.json\";\nimport energy_web_tokens_hash from \"./246/erc20-hash.json\";\nimport fantom_tokens_hash from \"./250/erc20-hash.json\";\nimport astar_tokens_hash from \"./592/erc20-hash.json\";\nimport metis_tokens_hash from \"./1088/erc20-hash.json\";\nimport polygon_zk_evm_tokens_hash from \"./1101/erc20-hash.json\";\nimport moonbeam_tokens_hash from \"./1284/erc20-hash.json\";\nimport polygon_zk_evm_testnet_tokens_hash from \"./1442/erc20-hash.json\";\nimport klaytn_tokens_hash from \"./8217/erc20-hash.json\";\nimport base_tokens_hash from \"./8453/erc20-hash.json\";\nimport arbitrum_tokens_hash from \"./42161/erc20-hash.json\";\nimport avalanche_c_chain_tokens_hash from \"./43114/erc20-hash.json\";\nimport linea_tokens_hash from \"./59144/erc20-hash.json\";\nimport blast_tokens_hash from \"./81457/erc20-hash.json\";\nimport base_sepolia_tokens_hash from \"./84532/erc20-hash.json\";\nimport arbitrum_sepolia_tokens_hash from \"./421614/erc20-hash.json\";\nimport scroll_sepolia_tokens_hash from \"./534351/erc20-hash.json\";\nimport scroll_tokens_hash from \"./534352/erc20-hash.json\";\nimport ethereum_sepolia_tokens_hash from \"./11155111/erc20-hash.json\";\nimport optimism_sepolia_tokens_hash from \"./11155420/erc20-hash.json\";\nimport blast_sepolia_tokens_hash from \"./168587773/erc20-hash.json\";\nimport neon_evm_tokens_hash from \"./245022934/erc20-hash.json\";\n\nimport ethereum_signatures from \"./1/erc20-signatures.json\";\nimport optimism_signatures from \"./10/erc20-signatures.json\";\nimport cronos_signatures from \"./25/erc20-signatures.json\";\nimport rsk_signatures from \"./30/erc20-signatures.json\";\nimport telos_evm_signatures from \"./40/erc20-signatures.json\";\nimport bsc_signatures from \"./56/erc20-signatures.json\";\nimport syscoin_signatures from \"./57/erc20-signatures.json\";\nimport velas_evm_signatures from \"./106/erc20-signatures.json\";\nimport polygon_signatures from \"./137/erc20-signatures.json\";\nimport bittorrent_signatures from \"./199/erc20-signatures.json\";\nimport energy_web_signatures from \"./246/erc20-signatures.json\";\nimport fantom_signatures from \"./250/erc20-signatures.json\";\nimport astar_signatures from \"./592/erc20-signatures.json\";\nimport metis_signatures from \"./1088/erc20-signatures.json\";\nimport polygon_zk_evm_signatures from \"./1101/erc20-signatures.json\";\nimport moonbeam_signatures from \"./1284/erc20-signatures.json\";\nimport polygon_zk_evm_testnet_signatures from \"./1442/erc20-signatures.json\";\nimport klaytn_signatures from \"./8217/erc20-signatures.json\";\nimport base_signatures from \"./8453/erc20-signatures.json\";\nimport arbitrum_signatures from \"./42161/erc20-signatures.json\";\nimport avalanche_c_chain_signatures from \"./43114/erc20-signatures.json\";\nimport linea_signatures from \"./59144/erc20-signatures.json\";\nimport blast_signatures from \"./81457/erc20-signatures.json\";\nimport base_sepolia_signatures from \"./84532/erc20-signatures.json\";\nimport arbitrum_sepolia_signatures from \"./421614/erc20-signatures.json\";\nimport scroll_sepolia_signatures from \"./534351/erc20-signatures.json\";\nimport scroll_signatures from \"./534352/erc20-signatures.json\";\nimport ethereum_sepolia_signatures from \"./11155111/erc20-signatures.json\";\nimport optimism_sepolia_signatures from \"./11155420/erc20-signatures.json\";\nimport blast_sepolia_signatures from \"./168587773/erc20-signatures.json\";\nimport neon_evm_signatures from \"./245022934/erc20-signatures.json\";\n\nimport ethereum_signatures_hash from \"./1/erc20-signatures-hash.json\";\nimport optimism_signatures_hash from \"./10/erc20-signatures-hash.json\";\nimport cronos_signatures_hash from \"./25/erc20-signatures-hash.json\";\nimport rsk_signatures_hash from \"./30/erc20-signatures-hash.json\";\nimport telos_evm_signatures_hash from \"./40/erc20-signatures-hash.json\";\nimport bsc_signatures_hash from \"./56/erc20-signatures-hash.json\";\nimport syscoin_signatures_hash from \"./57/erc20-signatures-hash.json\";\nimport velas_evm_signatures_hash from \"./106/erc20-signatures-hash.json\";\nimport polygon_signatures_hash from \"./137/erc20-signatures-hash.json\";\nimport bittorrent_signatures_hash from \"./199/erc20-signatures-hash.json\";\nimport energy_web_signatures_hash from \"./246/erc20-signatures-hash.json\";\nimport fantom_signatures_hash from \"./250/erc20-signatures-hash.json\";\nimport astar_signatures_hash from \"./592/erc20-signatures-hash.json\";\nimport metis_signatures_hash from \"./1088/erc20-signatures-hash.json\";\nimport polygon_zk_evm_signatures_hash from \"./1101/erc20-signatures-hash.json\";\nimport moonbeam_signatures_hash from \"./1284/erc20-signatures-hash.json\";\nimport polygon_zk_evm_testnet_signatures_hash from \"./1442/erc20-signatures-hash.json\";\nimport klaytn_signatures_hash from \"./8217/erc20-signatures-hash.json\";\nimport base_signatures_hash from \"./8453/erc20-signatures-hash.json\";\nimport arbitrum_signatures_hash from \"./42161/erc20-signatures-hash.json\";\nimport avalanche_c_chain_signatures_hash from \"./43114/erc20-signatures-hash.json\";\nimport linea_signatures_hash from \"./59144/erc20-signatures-hash.json\";\nimport blast_signatures_hash from \"./81457/erc20-signatures-hash.json\";\nimport base_sepolia_signatures_hash from \"./84532/erc20-signatures-hash.json\";\nimport arbitrum_sepolia_signatures_hash from \"./421614/erc20-signatures-hash.json\";\nimport scroll_sepolia_signatures_hash from \"./534351/erc20-signatures-hash.json\";\nimport scroll_signatures_hash from \"./534352/erc20-signatures-hash.json\";\nimport ethereum_sepolia_signatures_hash from \"./11155111/erc20-signatures-hash.json\";\nimport optimism_sepolia_signatures_hash from \"./11155420/erc20-signatures-hash.json\";\nimport blast_sepolia_signatures_hash from \"./168587773/erc20-signatures-hash.json\";\nimport neon_evm_signatures_hash from \"./245022934/erc20-signatures-hash.json\";\n\nexport const tokens = {\n  1: ethereum_tokens,\n  10: optimism_tokens,\n  25: cronos_tokens,\n  30: rsk_tokens,\n  40: telos_evm_tokens,\n  56: bsc_tokens,\n  57: syscoin_tokens,\n  106: velas_evm_tokens,\n  137: polygon_tokens,\n  199: bittorrent_tokens,\n  246: energy_web_tokens,\n  250: fantom_tokens,\n  592: astar_tokens,\n  1088: metis_tokens,\n  1101: polygon_zk_evm_tokens,\n  1284: moonbeam_tokens,\n  1442: polygon_zk_evm_testnet_tokens,\n  8217: klaytn_tokens,\n  8453: base_tokens,\n  42161: arbitrum_tokens,\n  43114: avalanche_c_chain_tokens,\n  59144: linea_tokens,\n  81457: blast_tokens,\n  84532: base_sepolia_tokens,\n  421614: arbitrum_sepolia_tokens,\n  534351: scroll_sepolia_tokens,\n  534352: scroll_tokens,\n  11155111: ethereum_sepolia_tokens,\n  11155420: optimism_sepolia_tokens,\n  168587773: blast_sepolia_tokens,\n  245022934: neon_evm_tokens,\n};\n\nexport const signatures = {\n  1: ethereum_signatures,\n  10: optimism_signatures,\n  25: cronos_signatures,\n  30: rsk_signatures,\n  40: telos_evm_signatures,\n  56: bsc_signatures,\n  57: syscoin_signatures,\n  106: velas_evm_signatures,\n  137: polygon_signatures,\n  199: bittorrent_signatures,\n  246: energy_web_signatures,\n  250: fantom_signatures,\n  592: astar_signatures,\n  1088: metis_signatures,\n  1101: polygon_zk_evm_signatures,\n  1284: moonbeam_signatures,\n  1442: polygon_zk_evm_testnet_signatures,\n  8217: klaytn_signatures,\n  8453: base_signatures,\n  42161: arbitrum_signatures,\n  43114: avalanche_c_chain_signatures,\n  59144: linea_signatures,\n  81457: blast_signatures,\n  84532: base_sepolia_signatures,\n  421614: arbitrum_sepolia_signatures,\n  534351: scroll_sepolia_signatures,\n  534352: scroll_signatures,\n  11155111: ethereum_sepolia_signatures,\n  11155420: optimism_sepolia_signatures,\n  168587773: blast_sepolia_signatures,\n  245022934: neon_evm_signatures,\n};\n\nexport const hashes = {\n  1: ethereum_tokens_hash,\n  10: optimism_tokens_hash,\n  25: cronos_tokens_hash,\n  30: rsk_tokens_hash,\n  40: telos_evm_tokens_hash,\n  56: bsc_tokens_hash,\n  57: syscoin_tokens_hash,\n  106: velas_evm_tokens_hash,\n  137: polygon_tokens_hash,\n  199: bittorrent_tokens_hash,\n  246: energy_web_tokens_hash,\n  250: fantom_tokens_hash,\n  592: astar_tokens_hash,\n  1088: metis_tokens_hash,\n  1101: polygon_zk_evm_tokens_hash,\n  1284: moonbeam_tokens_hash,\n  1442: polygon_zk_evm_testnet_tokens_hash,\n  8217: klaytn_tokens_hash,\n  8453: base_tokens_hash,\n  42161: arbitrum_tokens_hash,\n  43114: avalanche_c_chain_tokens_hash,\n  59144: linea_tokens_hash,\n  81457: blast_tokens_hash,\n  84532: base_sepolia_tokens_hash,\n  421614: arbitrum_sepolia_tokens_hash,\n  534351: scroll_sepolia_tokens_hash,\n  534352: scroll_tokens_hash,\n  11155111: ethereum_sepolia_tokens_hash,\n  11155420: optimism_sepolia_tokens_hash,\n  168587773: blast_sepolia_tokens_hash,\n  245022934: neon_evm_tokens_hash,\n};\n\nexport const signatureHashes = {\n  1: ethereum_signatures_hash,\n  10: optimism_signatures_hash,\n  25: cronos_signatures_hash,\n  30: rsk_signatures_hash,\n  40: telos_evm_signatures_hash,\n  56: bsc_signatures_hash,\n  57: syscoin_signatures_hash,\n  106: velas_evm_signatures_hash,\n  137: polygon_signatures_hash,\n  199: bittorrent_signatures_hash,\n  246: energy_web_signatures_hash,\n  250: fantom_signatures_hash,\n  592: astar_signatures_hash,\n  1088: metis_signatures_hash,\n  1101: polygon_zk_evm_signatures_hash,\n  1284: moonbeam_signatures_hash,\n  1442: polygon_zk_evm_testnet_signatures_hash,\n  8217: klaytn_signatures_hash,\n  8453: base_signatures_hash,\n  42161: arbitrum_signatures_hash,\n  43114: avalanche_c_chain_signatures_hash,\n  59144: linea_signatures_hash,\n  81457: blast_signatures_hash,\n  84532: base_sepolia_signatures_hash,\n  421614: arbitrum_sepolia_signatures_hash,\n  534351: scroll_sepolia_signatures_hash,\n  534352: scroll_signatures_hash,\n  11155111: ethereum_sepolia_signatures_hash,\n  11155420: optimism_sepolia_signatures_hash,\n  168587773: blast_sepolia_signatures_hash,\n  245022934: neon_evm_signatures_hash,\n};\n\nexport default {\n  tokens,\n  signatures,\n  hashes,\n  signatureHashes,\n};\n","import type { LoadConfig } from \"../types\";\n\nconst defaultLoadConfig: Required<LoadConfig> = {\n  nftExplorerBaseURL: \"https://nft.api.live.ledger.com/v1/ethereum\",\n  pluginBaseURL: \"https://cdn.live.ledger.com\",\n  extraPlugins: null,\n  cryptoassetsBaseURL: \"https://cdn.live.ledger.com/cryptoassets\",\n};\n\nexport function getLoadConfig(userLoadConfig?: LoadConfig): LoadConfig {\n  return {\n    ...defaultLoadConfig,\n    ...userLoadConfig,\n  };\n}\n","import axios from \"axios\";\nimport { log } from \"@ledgerhq/logs\";\nimport { signatures as signaturesByChainId } from \"@ledgerhq/cryptoassets/data/evm/index\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport { LoadConfig } from \"../types\";\n\nconst asContractAddress = (addr: string) => {\n  const a = addr.toLowerCase();\n  return a.startsWith(\"0x\") ? a : \"0x\" + a;\n};\n\nexport const findERC20SignaturesInfo = async (\n  userLoadConfig: LoadConfig,\n  chainId: number,\n): Promise<string | null> => {\n  const { cryptoassetsBaseURL } = getLoadConfig(userLoadConfig);\n  if (!cryptoassetsBaseURL) return null;\n\n  const url = `${cryptoassetsBaseURL}/evm/${chainId}/erc20-signatures.json`;\n  const blob = await axios\n    .get<string>(url)\n    .then(({ data }) => {\n      if (!data || typeof data !== \"string\") {\n        throw new Error(`ERC20 signatures for chainId ${chainId} file is malformed ${url}`);\n      }\n      return data;\n    })\n    .catch(e => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n\n  return blob;\n};\n\n/**\n * Retrieve the token information by a given contract address if any\n */\nexport const byContractAddressAndChainId = (\n  contract: string,\n  chainId: number,\n  erc20SignaturesBlob?: string | null,\n): ReturnType<API[\"byContractAndChainId\"]> => {\n  // If we are able to fetch data from s3 bucket that contains dynamic CAL\n  if (erc20SignaturesBlob) {\n    try {\n      return parse(erc20SignaturesBlob).byContractAndChainId(asContractAddress(contract), chainId);\n    } catch (e) {\n      return get(chainId)?.byContractAndChainId(asContractAddress(contract), chainId);\n    }\n  }\n\n  // the static fallback when dynamic cal is not provided\n  return get(chainId)?.byContractAndChainId(asContractAddress(contract), chainId);\n};\n\nexport type TokenInfo = {\n  contractAddress: string;\n  ticker: string;\n  decimals: number;\n  chainId: number;\n  signature: Buffer;\n  data: Buffer;\n};\nexport type API = {\n  byContractAndChainId: (addr: string, id: number) => TokenInfo | null | undefined;\n  list: () => TokenInfo[];\n};\n\nconst parse = (erc20SignaturesBlob: string): API => {\n  const buf = Buffer.from(erc20SignaturesBlob, \"base64\");\n  const map = {};\n  const entries: TokenInfo[] = [];\n  let i = 0;\n\n  while (i < buf.length) {\n    const length = buf.readUInt32BE(i);\n    i += 4;\n    const item = buf.slice(i, i + length);\n    let j = 0;\n    const tickerLength = item.readUInt8(j);\n    j += 1;\n    const ticker = item.slice(j, j + tickerLength).toString(\"ascii\");\n    j += tickerLength;\n    const contractAddress = asContractAddress(item.slice(j, j + 20).toString(\"hex\"));\n    j += 20;\n    const decimals = item.readUInt32BE(j);\n    j += 4;\n    const chainId = item.readUInt32BE(j);\n    j += 4;\n    const signature = item.slice(j);\n    const entry: TokenInfo = {\n      ticker,\n      contractAddress,\n      decimals,\n      chainId,\n      signature,\n      data: item,\n    };\n    entries.push(entry);\n    map[String(chainId) + \":\" + contractAddress] = entry;\n    i += length;\n  }\n\n  return {\n    list: () => entries,\n    byContractAndChainId: (contractAddress, chainId) =>\n      map[String(chainId) + \":\" + contractAddress],\n  };\n};\n\n// this internal get() will lazy load and cache the data from the erc20 data blob\nconst get: (chainId: number) => API | null = (() => {\n  const cache: Record<number, API> = {};\n  return chainId => {\n    if (cache[chainId]) return cache[chainId];\n\n    const signatureBlob: string | undefined = signaturesByChainId[chainId];\n    if (!signatureBlob) return null;\n\n    const api = parse(signatureBlob);\n    cache[chainId] = api;\n    return api;\n  };\n})();\n","// This implements the resolution of a Transaction using Ledger's own API\nimport { log } from \"@ledgerhq/logs\";\nimport { Interface } from \"@ethersproject/abi\";\nimport {\n  signDomainResolution,\n  signAddressResolution,\n} from \"@ledgerhq/domain-service/signers/index\";\nimport { LedgerEthTransactionResolution, LedgerEthTransactionService, LoadConfig } from \"../types\";\nimport { byContractAddressAndChainId, findERC20SignaturesInfo } from \"./erc20\";\nimport { loadInfosForContractMethod } from \"./contracts\";\nimport { getNFTInfo, loadNftPlugin } from \"./nfts\";\nimport { decodeTxInfo, tokenSelectors, nftSelectors, mergeResolutions } from \"../../utils\";\n\ntype PotentialResolutions = {\n  token: boolean | undefined;\n  nft: boolean | undefined;\n  externalPlugins: boolean | undefined;\n};\n\n/**\n * @ignore for external documentation\n *\n * Providing additionnal data for some transactions (Token or NFT related) can enable clear signing\n * of initially impossible to decode data.\n * This method will add necessary APDUs to the resolution paramter in order to provide this data to the nano app\n */\nconst getAdditionalDataForContract = async (\n  contractAddress: string,\n  chainIdTruncated: number,\n  loadConfig: LoadConfig,\n  shouldResolve: PotentialResolutions,\n): Promise<Pick<LedgerEthTransactionResolution, \"nfts\" | \"erc20Tokens\">> => {\n  const resolution: Pick<LedgerEthTransactionResolution, \"nfts\" | \"erc20Tokens\"> = {\n    nfts: [],\n    erc20Tokens: [],\n  };\n\n  if (shouldResolve.nft) {\n    const nftInfo = await getNFTInfo(contractAddress, chainIdTruncated, loadConfig);\n\n    if (nftInfo) {\n      log(\n        \"ethereum\",\n        \"loaded nft info for \" + nftInfo.contractAddress + \" (\" + nftInfo.collectionName + \")\",\n      );\n      resolution.nfts.push(nftInfo.data);\n    } else {\n      log(\"ethereum\", \"couldn't load nft info for \" + contractAddress);\n    }\n  }\n\n  if (shouldResolve.token) {\n    const erc20SignaturesBlob = await findERC20SignaturesInfo(loadConfig, chainIdTruncated);\n    const erc20Info = byContractAddressAndChainId(\n      contractAddress,\n      chainIdTruncated,\n      erc20SignaturesBlob,\n    );\n\n    if (erc20Info) {\n      log(\n        \"ethereum\",\n        \"loaded erc20token info for \" + erc20Info.contractAddress + \" (\" + erc20Info.ticker + \")\",\n      );\n      resolution.erc20Tokens.push(erc20Info.data.toString(\"hex\"));\n    } else {\n      log(\"ethereum\", \"couldn't load erc20token info for \" + contractAddress);\n    }\n  }\n\n  return resolution;\n};\n\n/**\n * @ignore for external documentation\n *\n * Depending on the transaction, it might be necessary to load internal plugins in the nano app\n * in order to clear sign it.\n * This method will add necessary APDUs to the resolution parameter in order to load those internal plugins\n */\nconst loadNanoAppPlugins = async (\n  contractAddress: string,\n  selector: string,\n  decodedTx,\n  chainIdTruncated: number,\n  loadConfig: LoadConfig,\n  shouldResolve: PotentialResolutions,\n): Promise<LedgerEthTransactionResolution> => {\n  let resolution: LedgerEthTransactionResolution = {\n    externalPlugin: [],\n    plugin: [],\n    nfts: [],\n    erc20Tokens: [],\n    domains: [],\n  };\n\n  if (shouldResolve.nft) {\n    const nftPluginPayload = await loadNftPlugin(\n      contractAddress,\n      selector,\n      chainIdTruncated,\n      loadConfig,\n    );\n\n    if (nftPluginPayload) {\n      resolution.plugin.push(nftPluginPayload);\n    } else {\n      log(\n        \"ethereum\",\n        \"no NFT plugin payload for selector \" + selector + \" and address \" + contractAddress,\n      );\n    }\n  }\n\n  if (shouldResolve.externalPlugins) {\n    const contractMethodInfos = await loadInfosForContractMethod(\n      contractAddress,\n      selector,\n      chainIdTruncated,\n      loadConfig,\n    );\n\n    if (contractMethodInfos) {\n      const { plugin, payload, signature, erc20OfInterest, abi } = contractMethodInfos;\n\n      if (plugin) {\n        log(\"ethereum\", `found plugin (${plugin}) for selector: ${selector}`);\n        resolution.externalPlugin.push({ payload, signature });\n      }\n\n      if (erc20OfInterest && erc20OfInterest.length && abi) {\n        const contract = new Interface(abi);\n        const args = contract.parseTransaction(decodedTx).args;\n\n        for (const path of erc20OfInterest) {\n          const erc20ContractAddress = path.split(\".\").reduce((value, seg) => {\n            if (seg === \"-1\" && Array.isArray(value)) {\n              return value[value.length - 1];\n            }\n            return value[seg];\n          }, args) as unknown as string; // impossible(?) to type correctly as the initializer is different from the returned type\n\n          const externalPluginResolution = await getAdditionalDataForContract(\n            erc20ContractAddress,\n            chainIdTruncated,\n            loadConfig,\n            {\n              nft: false,\n              externalPlugins: false,\n              token: true, // enforcing resolution of tokens for external plugins that need info on assets (e.g. for a swap)\n            },\n          );\n          resolution = mergeResolutions([resolution, externalPluginResolution]);\n        }\n      }\n    } else {\n      log(\"ethereum\", \"no infos for selector \" + selector);\n    }\n  }\n\n  return resolution;\n};\n\n/**\n * @ignore for external documentation\n *\n * In charge of collecting the different APDUs necessary for clear signing\n * a transaction based on a specified configuration.\n */\nconst resolveTransaction: LedgerEthTransactionService[\"resolveTransaction\"] = async (\n  rawTxHex,\n  loadConfig,\n  resolutionConfig,\n) => {\n  const rawTx = Buffer.from(rawTxHex, \"hex\");\n  const { decodedTx, chainIdTruncated } = decodeTxInfo(rawTx);\n  const { domains } = resolutionConfig;\n\n  const contractAddress = decodedTx.to;\n  const selector = decodedTx.data.length >= 10 && decodedTx.data.substring(0, 10);\n\n  const resolutions: Partial<LedgerEthTransactionResolution>[] = [];\n  if (selector) {\n    const shouldResolve: PotentialResolutions = {\n      token: resolutionConfig.erc20 && tokenSelectors.includes(selector),\n      nft: resolutionConfig.nft && nftSelectors.includes(selector),\n      externalPlugins: resolutionConfig.externalPlugins,\n    };\n\n    const pluginsResolution = await loadNanoAppPlugins(\n      contractAddress,\n      selector,\n      decodedTx,\n      chainIdTruncated,\n      loadConfig,\n      shouldResolve,\n    );\n    if (pluginsResolution) {\n      resolutions.push(pluginsResolution);\n    }\n\n    const contractResolution = await getAdditionalDataForContract(\n      contractAddress,\n      chainIdTruncated,\n      loadConfig,\n      shouldResolve,\n    );\n    if (contractResolution) {\n      resolutions.push(contractResolution);\n    }\n  }\n\n  // Passthrough to be accessible to the Domains module\n  if (domains) {\n    const domainResolutions: Partial<LedgerEthTransactionResolution> = {\n      domains,\n    };\n    resolutions.push(domainResolutions);\n  }\n\n  return mergeResolutions(resolutions);\n};\n\nexport default {\n  resolveTransaction,\n  signDomainResolution,\n  signAddressResolution,\n} as LedgerEthTransactionService;\n","import axios from \"axios\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport type { LoadConfig } from \"../types\";\nimport { log } from \"@ledgerhq/logs\";\n\ntype NftInfo = {\n  contractAddress: string;\n  collectionName: string;\n  data: string;\n};\n\ntype BackendResponse = {\n  payload: string;\n};\n\nexport const getNFTInfo = async (\n  contractAddress: string,\n  chainId: number,\n  userLoadConfig: LoadConfig,\n): Promise<NftInfo | undefined> => {\n  const { nftExplorerBaseURL } = getLoadConfig(userLoadConfig);\n  if (!nftExplorerBaseURL) return;\n  const url = `${nftExplorerBaseURL}/${chainId}/contracts/${contractAddress}`;\n  const response = await axios\n    .get<BackendResponse>(url)\n    .then(r => r.data)\n    .catch(e => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n  if (!response) return;\n\n  // APDU response specification: https://ledgerhq.atlassian.net/wiki/spaces/WALLETCO/pages/3269984297/NFT-1+NFT+Backend+design#NFT-Metadata-BLOB\n  const payload = response[\"payload\"];\n  // Collection name length position: 3rd byte -> caracter 4 to 6\n  const collectionNameLength = parseInt(payload.slice(4, 6), 16);\n  const collectionNameHex = payload.substr(6, collectionNameLength * 2);\n  const collectionName = collectionNameHex\n    .match(/.{2}/g) // split every 2 characters\n    ?.reduce((acc, curr) => (acc += String.fromCharCode(parseInt(curr, 16))), \"\"); // convert hex to string\n\n  return {\n    contractAddress: contractAddress,\n    collectionName: collectionName || \"\",\n    data: payload,\n  };\n};\n\nexport const loadNftPlugin = async (\n  contractAddress: string,\n  selector: string,\n  chainId: number,\n  userLoadConfig: LoadConfig,\n): Promise<string | undefined> => {\n  const { nftExplorerBaseURL } = getLoadConfig(userLoadConfig);\n  if (!nftExplorerBaseURL) return;\n  const url = `${nftExplorerBaseURL}/${chainId}/contracts/${contractAddress}/plugin-selector/${selector}`;\n\n  const response = await axios\n    .get<BackendResponse>(url)\n    .then(r => r.data)\n    .catch(e => {\n      log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n      return null;\n    });\n  if (!response) return;\n\n  const payload = response[\"payload\"];\n  return payload;\n};\n","import axios from \"axios\";\nimport { getLoadConfig } from \"./loadConfig\";\nimport type { LoadConfig } from \"../types\";\nimport { log } from \"@ledgerhq/logs\";\n\ntype ContractMethod = {\n  payload: string;\n  signature: string;\n  plugin: string;\n  erc20OfInterest: string[];\n  abi: any;\n};\n\n/**\n * Retrieve the metadatas a given contract address and a method selector\n */\nexport const loadInfosForContractMethod = async (\n  contractAddress: string,\n  selector: string,\n  chainId: number,\n  userLoadConfig: LoadConfig,\n): Promise<ContractMethod | undefined> => {\n  const { pluginBaseURL, extraPlugins } = getLoadConfig(userLoadConfig);\n\n  let data = {};\n\n  if (pluginBaseURL) {\n    const url = `${pluginBaseURL}/plugins/ethereum.json`;\n    data = await axios\n      .get(`${pluginBaseURL}/plugins/ethereum.json`)\n      .then(r => r.data as any)\n      .catch(e => {\n        log(\"error\", \"could not fetch from \" + url + \": \" + String(e));\n        return null;\n      });\n  }\n\n  if (extraPlugins) {\n    data = { ...data, ...extraPlugins };\n  }\n\n  if (!data) return;\n\n  const lcSelector = selector.toLowerCase();\n  const lcContractAddress = contractAddress.toLowerCase();\n\n  if (lcContractAddress in data) {\n    const contractSelectors = data[lcContractAddress];\n\n    if (lcSelector in contractSelectors) {\n      return {\n        payload: contractSelectors[lcSelector][\"serialized_data\"],\n        signature: contractSelectors[lcSelector][\"signature\"],\n        plugin: contractSelectors[lcSelector][\"plugin\"],\n        erc20OfInterest: contractSelectors[lcSelector][\"erc20OfInterest\"],\n        abi: contractSelectors[\"abi\"],\n      };\n    }\n  }\n};\n","import { PromiseResult } from \"../types\";\n\n/**\n * Needed polyfill for Promise.allSettled as it doesn't exist on RN.\n */\nexport const allSettled = <T>(promises: Promise<T>[]): Promise<PromiseResult<T>[]> => {\n  return Promise.all(\n    promises.map(p => {\n      return p\n        .then(value => {\n          return {\n            status: \"fulfilled\" as const,\n            value,\n          };\n        })\n        .catch((reason: unknown) => {\n          return {\n            status: \"rejected\" as const,\n            reason,\n          };\n        });\n    }),\n  );\n};\n\n/**\n * Helper to know in advance if a domain is compatible with the nano\n *\n * @param domain string representing the domain\n * @returns {Boolean}\n */\nexport const validateDomain = (domain: string | undefined): boolean => {\n  if (typeof domain !== \"string\") {\n    return false;\n  }\n\n  const lengthIsValid = domain.length > 0 && Number(domain.length) < 30;\n  const containsOnlyValidChars = new RegExp(\"^[a-zA-Z0-9\\\\-\\\\_\\\\.]+$\").test(domain);\n\n  return lengthIsValid && containsOnlyValidChars;\n};\n","import type { DomainServiceResolution as DomainDescriptor } from \"@ledgerhq/domain-service/types\";\nimport ledgerService from \"../../services/ledger\";\nimport type Eth from \"../../Eth\";\n\n/**\n * @ignore for the README\n *\n * This method will execute the pipeline of actions necessary for clear signing domains.\n * Signature is provided by the backend used in @ledgerhq/domain-service\n */\nexport const domainResolutionFlow = async (\n  appBinding: Eth,\n  domainDescriptor: DomainDescriptor,\n): Promise<void> => {\n  if (!domainDescriptor) return;\n  const { domain, address, registry, type } = domainDescriptor;\n\n  const challenge = await appBinding.getChallenge();\n  const domainAPDU =\n    type === \"forward\"\n      ? await ledgerService.signDomainResolution(domain, registry, challenge)\n      : await ledgerService.signAddressResolution(address, registry, challenge);\n\n  if (domainAPDU) {\n    await appBinding.provideDomainName(domainAPDU);\n  }\n};\n","import { createCustomErrorClass } from \"@ledgerhq/errors\";\n\nexport const EthAppPleaseEnableContractData = createCustomErrorClass(\n  \"EthAppPleaseEnableContractData\",\n);\nexport const EthAppNftNotSupported = createCustomErrorClass(\"EthAppNftNotSupported\");\n","/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n","/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n","/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n","import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n","import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n","import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n","import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n","/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n","/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n","import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n","import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n","import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n","import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n","// set and get environment & config variables\nimport { Subject } from \"rxjs\";\nimport { $ElementType } from \"utility-types\";\n// type ExtractEnvValue = <V>(arg0: EnvDef<V>) => V;\ntype EnvDefs = typeof envDefinitions;\ntype Env = typeof env;\n\ntype EnvDef<T extends string> = T extends EnvName ? EnvDefs[T] : undefined;\n\nexport type EnvName = keyof EnvDefs;\nexport type EnvValue<Name extends EnvName> = $ElementType<Env, Name>;\n\nconst intParser = (v: any): number | undefined => {\n  if (!Number.isNaN(v)) return parseInt(v, 10);\n};\n\nconst floatParser = (v: any): number | undefined => {\n  if (!Number.isNaN(v)) return parseFloat(v);\n};\n\nconst boolParser = (v: unknown): boolean | undefined => {\n  if (typeof v === \"boolean\") return v;\n  return !(v === \"0\" || v === \"false\");\n};\n\nconst stringParser = (v: unknown): string | undefined => (typeof v === \"string\" ? v : undefined);\n\ntype JSONValue = string | number | boolean | { [x: string]: JSONValue } | Array<JSONValue>;\n\nconst jsonParser = (v: unknown): JSONValue | undefined => {\n  try {\n    if (typeof v !== \"string\") throw new Error();\n    return JSON.parse(v);\n  } catch (e) {\n    return undefined;\n  }\n};\n\nconst stringArrayParser = (v: unknown): string[] | undefined => {\n  const v_array = typeof v === \"string\" ? v.split(\",\") : null;\n  if (Array.isArray(v_array) && v_array.length > 0) return v_array;\n};\n\nconst envDefinitions = {\n  ADDRESS_POISONING_FAMILIES: {\n    def: \"evm,tron\",\n    parser: stringParser,\n    desc: \"List of families impacted by the address poisoning attack\",\n  },\n  ANALYTICS_CONSOLE: {\n    def: false,\n    parser: boolParser,\n    desc: \"Show tracking overlays on the app UI\",\n  },\n  DEBUG_THEME: {\n    def: false,\n    parser: boolParser,\n    desc: \"Show theme debug overlay UI\",\n  },\n  API_ICP_ENDPOINT: {\n    def: \"https://icp.coin.ledger.com/\",\n    parser: stringParser,\n    desc: \"Rosetta API for ICP\",\n  },\n  API_CASPER_INDEXER_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://casper.coin.ledger.com/indexer\",\n    desc: \"Casper API url indexer\",\n  },\n  API_CASPER_NODE_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://casper.coin.ledger.com/node/\",\n    desc: \"Casper API url node\",\n  },\n  API_ALGORAND_BLOCKCHAIN_EXPLORER_API_ENDPOINT: {\n    def: \"https://algorand.coin.ledger.com\",\n    parser: stringParser,\n    desc: \"Node API endpoint for algorand\",\n  },\n  API_CELO_INDEXER: {\n    def: \"https://celo.coin.ledger.com/indexer/\",\n    parser: stringParser,\n    desc: \"Explorer API for celo\",\n  },\n  API_CELO_NODE: {\n    def: \"https://celo.coin.ledger.com/archive/\",\n    parser: stringParser,\n    desc: \"Node endpoint for celo\",\n  },\n  COSMOS_GAS_AMPLIFIER: {\n    def: 1.3, // Same as Keplr\n    parser: intParser,\n    desc: \"Cosmos gas estimate multiplier\",\n  },\n  API_FILECOIN_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://filecoin.coin.ledger.com\",\n    desc: \"Filecoin API url\",\n  },\n  API_STACKS_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://stacks.coin.ledger.com\",\n    desc: \"Stacks API url\",\n  },\n  API_POLKADOT_INDEXER: {\n    parser: stringParser,\n    def: \"https://polkadot.coin.ledger.com\",\n    desc: \"Explorer API for polkadot\",\n  },\n  API_POLKADOT_SIDECAR: {\n    parser: stringParser,\n    def: \"https://polkadot-sidecar.coin.ledger.com\",\n    desc: \"Polkadot Sidecar API url\",\n  },\n  API_POLKADOT_SIDECAR_CREDENTIALS: {\n    parser: stringParser,\n    def: \"\",\n    desc: \"Polkadot Sidecar API credentials\",\n  },\n  API_POLKADOT_NODE: {\n    parser: stringParser,\n    def: \"https://polkadot-fullnodes.api.live.ledger.com\",\n    desc: \"Polkadot Node\",\n  },\n  ELROND_API_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://elrond.coin.ledger.com\",\n    desc: \"Elrond API url\",\n  },\n  ELROND_DELEGATION_API_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://delegations-elrond.coin.ledger.com\",\n    desc: \"Elrond DELEGATION API url\",\n  },\n  API_STELLAR_HORIZON: {\n    parser: stringParser,\n    def: \"https://stellar.coin.ledger.com\",\n    desc: \"Stellar Horizon API url\",\n  },\n  API_STELLAR_HORIZON_FETCH_LIMIT: {\n    parser: intParser,\n    def: 100,\n    desc: \"Limit of operation that Horizon will fetch per page\",\n  },\n  API_STELLAR_HORIZON_STATIC_FEE: {\n    def: false,\n    parser: boolParser,\n    desc: \"Static fee for Stellar account\",\n  },\n  API_TEZOS_BAKER: {\n    parser: stringParser,\n    def: \"https://tezos-bakers.api.live.ledger.com\",\n    desc: \"bakers API for tezos\",\n  },\n  API_TEZOS_BLOCKCHAIN_EXPLORER_API_ENDPOINT: {\n    def: \"https://xtz-explorer.api.live.ledger.com/explorer\",\n    parser: stringParser,\n    desc: \"Ledger explorer API for tezos\",\n  },\n  API_TEZOS_TZKT_API: {\n    def: \"https://xtz-tzkt-explorer.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"tzkt.io explorer\",\n  },\n  API_TEZOS_NODE: {\n    def: \"https://xtz-node.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"node API for tezos (for broadcast only)\",\n  },\n  API_TRONGRID_PROXY: {\n    parser: stringParser,\n    def: \"https://tron.coin.ledger.com\",\n    desc: \"proxy url for trongrid API\",\n  },\n  API_SOLANA_PROXY: {\n    parser: stringParser,\n    def: \"https://solana.coin.ledger.com\",\n    desc: \"proxy url for solana API\",\n  },\n  SOLANA_VALIDATORS_APP_BASE_URL: {\n    parser: stringParser,\n    def: \"https://earn.api.live.ledger.com/v0/network/solana/validator-details\",\n    desc: \"base url for validators.app validator list\",\n  },\n  SOLANA_TESTNET_VALIDATORS_APP_BASE_URL: {\n    parser: stringParser,\n    def: \"https://validators-solana.coin.ledger.com/api/v1/validators\",\n    desc: \"base url for testnet validators.app validator list\",\n  },\n  SOLANA_TX_CONFIRMATION_TIMEOUT: {\n    def: 100 * 1000,\n    parser: intParser,\n    desc: \"solana transaction broadcast confirmation timeout\",\n  },\n  API_HEDERA_MIRROR: {\n    def: \"https://hedera.coin.ledger.com\",\n    parser: stringParser,\n    desc: \"mirror node API for Hedera\",\n  },\n  API_VECHAIN_THOREST: {\n    def: \"https://vechain.coin.ledger.com\",\n    parser: stringParser,\n    desc: \"Thorest API for VeChain\",\n  },\n  BASE_SOCKET_URL: {\n    def: \"wss://scriptrunner.api.live.ledger.com/update\",\n    parser: stringParser,\n    desc: \"Ledger script runner API\",\n  },\n  BOT_TIMEOUT_SCAN_ACCOUNTS: {\n    def: 10 * 60 * 1000,\n    parser: intParser,\n    desc: \"bot's default timeout for scanAccounts\",\n  },\n  BOT_SPEC_DEFAULT_TIMEOUT: {\n    def: 30 * 60 * 1000,\n    parser: intParser,\n    desc: \"define the default value of spec.skipMutationsTimeout (if not overriden by spec)\",\n  },\n  BUY_API_BASE: {\n    def: \"https://buy.api.live.ledger.com/buy/v1\",\n    parser: stringParser,\n    desc: \"Buy crypto API base url - version 1\",\n  },\n  CARDANO_API_ENDPOINT: {\n    def: \"https://cardano.coin.ledger.com/api\",\n    parser: stringParser,\n    desc: \"Cardano API url\",\n  },\n  CARDANO_TESTNET_API_ENDPOINT: {\n    def: \"https://testnet-ledger.cardanoscan.io/api\",\n    parser: stringParser,\n    desc: \"Cardano API url\",\n  },\n  ICON_NODE_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://icon.coin.ledger.com/api/v3\",\n    desc: \"ICON RPC url\",\n  },\n  ICON_DEBUG_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://icon.coin.ledger.com/api/v3d\",\n    desc: \"ICON debug RPC url\",\n  },\n  ICON_INDEXER_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://icon.coin.ledger.com/api/v1\",\n    desc: \"ICON API url\",\n  },\n  ICON_TESTNET_NODE_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://berlin.net.solidwallet.io/api/v3\",\n    desc: \"ICON Berlin Testnet API url\",\n  },\n  ICON_TESTNET_DEBUG_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://berlin.net.solidwallet.io/api/v3d\",\n    desc: \"ICON Berlin Testnet debug\",\n  },\n  ICON_TESTNET_INDEXER_ENDPOINT: {\n    parser: stringParser,\n    def: \"https://tracker.berlin.icon.community/api/v1\",\n    desc: \"ICON Berlin Testnet API url\",\n  },\n  COINAPPS: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"(dev feature) defines the folder for speculos mode that contains Nano apps binaries (.elf) in a specific structure: <device>/<firmware>/<appName>/app_<appVersion>.elf\",\n  },\n  CRYPTO_ORG_INDEXER: {\n    def: \"https://cryptoorg-rpc-indexer.coin.ledger.com\",\n    parser: stringParser,\n    desc: \"location of the Cronos POS Chain (formerly Crypto.org) indexer API\",\n  },\n  CRYPTO_ORG_TESTNET_INDEXER: {\n    def: \"https://cronos-pos.org/explorer/croeseid4\",\n    parser: stringParser,\n    desc: \"location of the Cronos POS Chain (formerly Crypto.org) indexer testnet API\",\n  },\n  CRYPTO_ORG_RPC_URL: {\n    def: \"https://cryptoorg-rpc-node.coin.ledger.com\",\n    parser: stringParser,\n    desc: \"location of the Cronos POS Chain (formerly Crypto.org) chain node\",\n  },\n  CRYPTO_ORG_TESTNET_RPC_URL: {\n    def: \"https://rpc-testnet-croeseid-4.crypto.org\",\n    parser: stringParser,\n    desc: \"location of the Cronos POS Chain (formerly Crypto.org) chain testnet node\",\n  },\n  DEBUG_UTXO_DISPLAY: {\n    def: 4,\n    parser: intParser,\n    desc: \"define maximum number of utxos to display in CLI\",\n  },\n  DEBUG_HTTP_RESPONSE: {\n    def: false,\n    parser: boolParser,\n    desc: \"includes HTTP response body in logs\",\n  },\n  DEVICE_CANCEL_APDU_FLUSH_MECHANISM: {\n    def: true,\n    parser: boolParser,\n    desc: \"enable a mechanism that send a 0x00 apdu to force device to awake from its 'Processing' UI state\",\n  },\n  DEVICE_PROXY_URL: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"enable a proxy to use instead of a physical device\",\n  },\n  DEVICE_PROXY_MODEL: {\n    def: \"nanoS\",\n    parser: stringParser,\n    desc: \"allow to override the default model of a proxied device\",\n  },\n  DISABLE_TRANSACTION_BROADCAST: {\n    def: false,\n    parser: boolParser,\n    desc: \"disable broadcast of transactions\",\n  },\n  DISABLE_SYNC_TOKEN: {\n    def: true,\n    parser: boolParser,\n    desc: \"disable a problematic mechanism of our API\",\n  },\n  DISABLE_FW_UPDATE_VERSION_CHECK: {\n    def: false,\n    parser: boolParser,\n    desc: \"disable the version check for firmware update eligibility\",\n  },\n  EIP1559_MINIMUM_FEES_GATE: {\n    def: true,\n    parser: boolParser,\n    desc: \"prevents the user from doing an EIP1559 transaction with fees too low\",\n  },\n  EIP1559_PRIORITY_FEE_LOWER_GATE: {\n    def: 0.85,\n    parser: floatParser,\n    desc: \"minimum priority fee percents allowed compared to network conditions allowed when EIP1559_MINIMUM_FEES_GATE is activated\",\n  },\n  EIP1559_BASE_FEE_MULTIPLIER: {\n    def: 1.5,\n    parser: floatParser,\n    desc: \"mutiplier for the base fee that is composing the maxFeePerGas property\",\n  },\n  EXPERIMENTAL_BLE: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable experimental support of Bluetooth\",\n  },\n  EXPERIMENTAL_CURRENCIES: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"enable experimental support of currencies (comma separated)\",\n  },\n  EXPERIMENTAL_EXPLORERS: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable experimental explorer APIs\",\n  },\n  EXPERIMENTAL_LANGUAGES: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable experimental languages\",\n  },\n  EXPERIMENTAL_MANAGER: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable an experimental version of Manager\",\n  },\n  EXPERIMENTAL_ROI_CALCULATION: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable an experimental version of the portfolio percentage calculation\",\n  },\n  EXPERIMENTAL_SEND_MAX: {\n    def: false,\n    parser: boolParser,\n    desc: \"force enabling SEND MAX even if not yet stable\",\n  },\n  EXPERIMENTAL_USB: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable an experimental implementation of USB support\",\n  },\n  EXPERIMENTAL_SWAP: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable an experimental swap interface\",\n  },\n  EXPLORER: {\n    def: \"https://explorers.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"Ledger generic explorer API\",\n  },\n  EXPLORER_STAGING: {\n    def: \"https://explorers.api-01.live.ledger-stg.com\",\n    parser: stringParser,\n    desc: \"Ledger staging explorer API\",\n  },\n  EXPLORER_BETA: {\n    def: \"https://explorers.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"Ledger generic explorer beta API\",\n  },\n  EXPLORER_SATSTACK: {\n    def: \"http://localhost:20000\",\n    parser: stringParser,\n    desc: \"Ledger satstack Bitcoin explorer API\",\n  },\n  EXPORT_EXCLUDED_LOG_TYPES: {\n    def: \"ble-frame\",\n    parser: stringParser,\n    desc: \"comma-separated list of excluded log types for exported logs\",\n  },\n  EXPORT_MAX_LOGS: {\n    def: 5000,\n    parser: intParser,\n    desc: \"maximum logs to keep for export\",\n  },\n  DISABLE_APP_VERSION_REQUIREMENTS: {\n    def: false,\n    parser: boolParser,\n    desc: \"force an old application version to be accepted regardless of its version\",\n  },\n  FORCE_PROVIDER: {\n    def: 1,\n    parser: intParser,\n    desc: \"use a different provider for app store (for developers only)\",\n  },\n  FILTER_ZERO_AMOUNT_ERC20_EVENTS: {\n    def: true,\n    parser: boolParser,\n    desc: \"Remove filter of address poisoning\",\n  },\n  GET_CALLS_RETRY: {\n    def: 2,\n    parser: intParser,\n    desc: \"how many times to retry a GET http call\",\n  },\n  GET_CALLS_TIMEOUT: {\n    def: 60 * 1000,\n    parser: intParser,\n    desc: \"how much time to timeout a GET http call\",\n  },\n  HIDE_EMPTY_TOKEN_ACCOUNTS: {\n    def: false,\n    parser: boolParser,\n    desc: \"hide the sub accounts when they are empty\",\n  },\n  KEYCHAIN_OBSERVABLE_RANGE: {\n    def: 0,\n    parser: intParser,\n    desc: \"overrides the gap limit specified by BIP44 (default to 20)\",\n  },\n  LEDGER_CLIENT_VERSION: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"the 'X-Ledger-Client-Version' HTTP header to use for queries to Ledger APIs\",\n  },\n  LEDGER_COUNTERVALUES_API: {\n    def: \"https://countervalues.live.ledger.com\",\n    parser: stringParser,\n    desc: \"Ledger countervalues API\",\n  },\n  LEDGER_REST_API_BASE: {\n    def: \"https://explorers.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"DEPRECATED\",\n  },\n  LEGACY_KT_SUPPORT_TO_YOUR_OWN_RISK: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable sending to KT accounts. Not tested.\",\n  },\n  MANAGER_API_BASE: {\n    def: \"https://manager.api.live.ledger.com/api\",\n    parser: stringParser,\n    desc: \"Ledger Manager API\",\n  },\n  MANAGER_DEV_MODE: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable visibility of utility apps in Manager\",\n  },\n  MANAGER_INSTALL_DELAY: {\n    def: 1000,\n    parser: intParser,\n    desc: \"defines the time to wait before installing apps to prevent known glitch (<=1.5.5) when chaining installs\",\n  },\n  MAPPING_SERVICE: {\n    def: \"https://mapping-service.api.ledger.com\",\n    parser: stringParser,\n    desc: \"\",\n  },\n  MAX_ACCOUNT_NAME_SIZE: {\n    def: 50,\n    parser: intParser,\n    desc: \"maximum size of account names\",\n  },\n  MOCK: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"switch the app into a MOCK mode for test purpose, the value will be used as a seed for the rng. Avoid falsy values.\",\n  },\n  MOCK_COUNTERVALUES: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"switch the countervalues resolution into a MOCK mode for test purpose\",\n  },\n  /**\n   * Note: the mocked cryptoassets config and test partner are signed with the\n   * Ledger test private key\n   */\n  MOCK_EXCHANGE_TEST_CONFIG: {\n    def: false,\n    parser: boolParser,\n    desc: \"mock the cryptoassets config and test partner (in the context of app-exchange)\",\n  },\n  MOCK_REMOTE_LIVE_MANIFEST: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"mock remote live app manifest\",\n  },\n  MOCK_OS_VERSION: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"if defined, overrides the os and version. format: os@version. Example: Windows_NT@6.1.7601\",\n  },\n  MOCK_NO_BYPASS: {\n    def: false,\n    parser: boolParser,\n    desc: \"if defined, avoids bypass of the currentDevice in the store.\",\n  },\n  NFT_CURRENCIES: {\n    def: \"ethereum,polygon\",\n    parser: stringParser,\n    desc: \"set the currencies where NFT is active\",\n  },\n  NFT_ETH_METADATA_SERVICE: {\n    def: \"https://nft.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"service uri used to get the metadata of an nft\",\n  },\n  OPERATION_ADDRESSES_LIMIT: {\n    def: 100,\n    parser: intParser,\n    desc: \"limit the number of addresses in from/to of operations\",\n  },\n  OPERATION_OPTIMISTIC_RETENTION: {\n    def: 30 * 60 * 1000,\n    parser: intParser,\n    desc: \"timeout to keep an optimistic operation that was broadcasted but not yet visible from the coin implementation or the API\",\n  },\n  OPERATION_PAGE_SIZE_INITIAL: {\n    def: 100,\n    parser: intParser,\n    desc: \"defines the initial default operation length page to use\",\n  },\n  POLKADOT_ELECTION_STATUS_THRESHOLD: {\n    def: 25,\n    parser: intParser,\n    desc: \"in blocks - number of blocks before Polkadot election effectively opens to consider it as open and disable all staking features\",\n  },\n  SATSTACK: {\n    def: false,\n    parser: boolParser,\n    desc: \"Switch to satstack mode\",\n  },\n  SCAN_FOR_INVALID_PATHS: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable searching accounts in exotic derivation paths\",\n  },\n  SEED: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"(dev feature) seed to be used by speculos (device simulator)\",\n  },\n  SHOW_LEGACY_NEW_ACCOUNT: {\n    def: false,\n    parser: boolParser,\n    desc: \"allow the creation of legacy accounts\",\n  },\n  SIMPLE_HASH_API_BASE: {\n    def: \"https://simplehash.api.live.ledger.com/api/v0\",\n    parser: stringParser,\n    desc: \"SimpleHash API base url\",\n  },\n  SKIP_ONBOARDING: {\n    def: false,\n    parser: boolParser,\n    desc: \"dev flag to skip onboarding flow\",\n  },\n  SPECULOS_API_PORT: {\n    def: 0,\n    parser: intParser,\n    desc: \"API port for speculos\",\n  },\n  SPECULOS_PID_OFFSET: {\n    def: 0,\n    parser: intParser,\n    desc: \"offset to be added to the speculos pid and avoid collision with other instances\",\n  },\n  /**\n   * It's just here as a backup, the REST API is supposed to be the right mode\n   * We can always fallback on the previous method if we need to.\n   * The websocket option is harmless, we can remove it at some point but let's\n   * keep it for a while just in case.\n   * Introduced on June 27th 2023 by https://github.com/LedgerHQ/ledger-live/pull/3824\n   */\n  SPECULOS_USE_WEBSOCKET: {\n    def: false,\n    parser: boolParser,\n    desc: \"Use speculos websocket interface instead of Rest API\",\n  },\n  SWAP_API_BASE: {\n    def: \"https://swap.ledger.com/v5\",\n    parser: stringParser,\n    desc: \"Swap API base\",\n  },\n  SWAP_USER_IP: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"Swap IP\",\n  },\n  SYNC_ALL_INTERVAL: {\n    def: 8 * 60 * 1000,\n    parser: intParser,\n    desc: \"delay between successive sync\",\n  },\n  SYNC_BOOT_DELAY: {\n    def: 2 * 1000,\n    parser: intParser,\n    desc: \"delay before the sync starts\",\n  },\n  SYNC_PENDING_INTERVAL: {\n    def: 10 * 1000,\n    parser: intParser,\n    desc: \"delay between sync when an operation is still pending\",\n  },\n  SYNC_OUTDATED_CONSIDERED_DELAY: {\n    def: 10 * 60 * 1000,\n    parser: intParser,\n    desc: \"delay until Live consider a sync outdated\",\n  },\n  SYNC_MAX_CONCURRENT: {\n    def: 4,\n    parser: intParser,\n    desc: \"maximum limit to synchronize accounts concurrently to limit overload\",\n  },\n  BOT_MAX_CONCURRENT: {\n    def: 10,\n    parser: intParser,\n    desc: \"maximum limit to run bot spec in parallel\",\n  },\n  USER_ID: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"unique identifier of app instance. used to derivate dissociated ids for difference purposes (e.g. the firmware update incremental deployment).\",\n  },\n  WALLETCONNECT: {\n    def: false,\n    parser: boolParser,\n    desc: \"is walletconnect enabled\",\n  },\n  CLOUD_SYNC_API_STAGING: {\n    def: \"https://cloud-sync-backend.api.aws.stg.ldg-tech.com\",\n    parser: stringParser,\n    desc: \"wallet sync api staging base url\",\n  },\n  CLOUD_SYNC_API_PROD: {\n    def: \"https://cloud-sync.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"wallet sync api production base url\",\n  },\n  WITH_DEVICE_POLLING_DELAY: {\n    def: 500,\n    parser: floatParser,\n    desc: \"delay when polling device\",\n  },\n  ANNOUNCEMENTS_API_URL: {\n    def: \"https://cdn.live.ledger.com/announcements\",\n    parser: stringParser,\n    desc: \"url used to fetch new announcements\",\n  },\n  ANNOUNCEMENTS_API_VERSION: {\n    def: 1,\n    parser: intParser,\n    desc: \"version used for the announcements api\",\n  },\n  STATUS_API_URL: {\n    def: \"https://ledger.statuspage.io/api\",\n    parser: stringParser,\n    desc: \"url used to fetch ledger status\",\n  },\n  STATUS_API_VERSION: {\n    def: 2,\n    parser: intParser,\n    desc: \"version used for ledger status api\",\n  },\n  TEZOS_MAX_TX_QUERIES: {\n    def: 100,\n    parser: intParser,\n    desc: \"safe max on maximum number of queries to synchronize a tezos account\",\n  },\n  TRUSTCHAIN_API_STAGING: {\n    def: \"https://trustchain-backend.api.aws.stg.ldg-tech.com\",\n    parser: stringParser,\n    desc: \"Trustchain API Staging\",\n  },\n  TRUSTCHAIN_API_PROD: {\n    def: \"https://trustchain.api.live.ledger.com\",\n    parser: stringParser,\n    desc: \"Trustchain API Prod\",\n  },\n  PLATFORM_DEBUG: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable visibility of debug apps and tools in Platform Catalog\",\n  },\n  PLATFORM_EXPERIMENTAL_APPS: {\n    def: false,\n    parser: boolParser,\n    desc: \"enable visibility of experimental apps and tools in Platform Catalog\",\n  },\n  PLATFORM_MANIFEST_API_URL: {\n    def: \"https://live-app-catalog.ledger.com/api/v1/apps\",\n    parser: stringParser,\n    desc: \"url used to fetch platform app manifests\",\n  },\n  PLATFORM_LOCAL_MANIFEST_JSON: {\n    def: \"\",\n    parser: stringParser,\n    desc: 'json manifest for a local (test) platform app manifests. How to use: PLATFORM_LOCAL_MANIFEST_JSON=\"$(cat /path/to/file.json)\"',\n  },\n  PLATFORM_GLOBAL_CATALOG_API_URL: {\n    def: \"https://cdn.live.ledger.com/platform/catalog/v1/data.json\",\n    parser: stringParser,\n    desc: \"url used to fetch platform app manifests\",\n  },\n  PLATFORM_GLOBAL_CATALOG_STAGING_API_URL: {\n    def: \"https://cdn.live.ledger-stg.com/platform/catalog/v1/data.json\",\n    parser: stringParser,\n    desc: \"url used to fetch platform app manifests (staging)\",\n  },\n  PLATFORM_RAMP_CATALOG_API_URL: {\n    def: \"https://cdn.live.ledger.com/platform/trade/v1/data.json\",\n    parser: stringParser,\n    desc: \"url used to fetch platform app manifests\",\n  },\n  PLATFORM_RAMP_CATALOG_STAGING_API_URL: {\n    def: \"https://cdn.live.ledger-stg.com/platform/trade/v1/data.json\",\n    parser: stringParser,\n    desc: \"url used to fetch platform app manifests (staging)\",\n  },\n  PLATFORM_API_URL: {\n    def: \"\",\n    parser: stringParser,\n    desc: \"url used to fetch platform catalog\",\n  },\n  PLATFORM_API_VERSION: {\n    def: 1,\n    parser: intParser,\n    desc: \"version used for the platform api\",\n  },\n  PLAYWRIGHT_RUN: {\n    def: false,\n    parser: boolParser,\n    desc: \"true when launched for E2E testing\",\n  },\n  MARKET_API_URL: {\n    def: \"https://proxycg.api.live.ledger.com/api/v3\",\n    parser: stringParser,\n    desc: \"Market data api\",\n  },\n  USE_LEARN_STAGING_URL: {\n    def: false,\n    parser: boolParser,\n    desc: \"use the staging URL for the learn page\",\n  },\n  DYNAMIC_CAL_BASE_URL: {\n    def: \"https://cdn.live.ledger.com/cryptoassets\",\n    parser: stringParser,\n    desc: \"bucket S3 of the dynamic cryptoassets list\",\n  },\n  CAL_SERVICE_URL: {\n    def: \"https://crypto-assets-service.api.ledger.com\",\n    parser: stringParser,\n    desc: \"Cryptoassets list service url\",\n  },\n  FEATURE_FLAGS: {\n    def: \"{}\",\n    parser: jsonParser,\n    desc: \"key value map for feature flags: {[key in FeatureId]?: Feature]}\",\n  },\n  PERFORMANCE_CONSOLE: {\n    def: false,\n    parser: boolParser,\n    desc: \"Show a performance overlay on the app UI\",\n  },\n  ETHEREUM_STUCK_TRANSACTION_TIMEOUT: {\n    def: 5 * 60 * 1000,\n    parser: intParser,\n    desc: \"Time after which an optimisc operation is considered stuck\",\n  },\n  EVM_REPLACE_TX_LEGACY_GASPRICE_FACTOR: {\n    def: 1.3,\n    parser: floatParser,\n    desc: \"Replace transaction gasprice factor for legacy evm transaction. This value should be 1.1 minimum since this is the minimum increase required by most nodes\",\n  },\n  EVM_REPLACE_TX_EIP1559_MAXFEE_FACTOR: {\n    def: 1.3,\n    parser: floatParser,\n    desc: \"Replace transaction max fee factor for EIP1559 evm transaction. This value should be 1.1 minimum since this is the minimum increase required by most nodes\",\n  },\n  EVM_REPLACE_TX_EIP1559_MAXPRIORITYFEE_FACTOR: {\n    def: 1.1,\n    parser: floatParser,\n    desc: \"Replace transaction max priority fee factor for EIP1559 evm transaction. This value should be 1.1 minimum since this is the minimum increase required by most nodes\",\n  },\n  ENABLE_NETWORK_LOGS: {\n    def: false,\n    parser: boolParser,\n    desc: \"Enable network request and responses logs. Errors are always logged\",\n  },\n  CRYPTO_ASSET_SEARCH_KEYS: {\n    def: [\"ticker\", \"name\", \"keywords\"],\n    parser: stringArrayParser,\n    desc: \"Fuse search attributes to find a currency according to user input\",\n  },\n  VERBOSE: {\n    def: [] as Array<string>,\n    parser: stringArrayParser,\n    desc: 'Sets up debug console printing of logs. `VERBOSE=1` or `VERBOSE=true`: to print all logs | `VERBOSE=\"apdu,hw,transport,hid-verbose\"` : filtering on a list of log `type` separated by a `,`',\n  },\n  DEFAULT_TRANSACTION_POLLING_INTERVAL: {\n    def: 30 * 1000,\n    parser: intParser,\n    desc: \"Default interval to poll for transaction confirmation in speedup/cancel evm flow (in ms)\",\n  },\n  LOW_BATTERY_PERCENTAGE: {\n    def: 20,\n    parser: intParser,\n    desc: \"Configure the low battery percentage threshold\",\n  },\n  LOG_DRAWERS: {\n    def: false,\n    parser: boolParser,\n    desc: \"Enable logs for drawers\",\n  },\n};\n\nexport const getDefinition = (name: string): EnvDef<any> => {\n  if (name in envDefinitions) {\n    return envDefinitions[name];\n  }\n  return undefined;\n};\n\nconst defaults = Object.keys(envDefinitions).reduce<{ [Key in EnvName]: EnvDefs[Key][\"def\"] }>(\n  (acc, curr) => {\n    return {\n      ...acc,\n      [curr]: envDefinitions[curr].def,\n    };\n  },\n  {} as { [Key in EnvName]: EnvDefs[Key][\"def\"] },\n);\n\n// private local state\nconst env = { ...defaults };\nexport const getAllEnvNames = (): EnvName[] => Object.keys(envDefinitions) as EnvName[];\nexport const getAllEnvs = (): Env => ({ ...env });\n// Usage: you must use getEnv at runtime because the env might be settled over time. typically will allow us to dynamically change them on the interface (e.g. some sort of experimental flags system)\nexport const getEnv = <Name extends EnvName>(name: Name): EnvValue<Name> => env[name];\nexport const getEnvDefault = <Name extends EnvName>(name: Name): EnvValue<Name> => defaults[name];\nexport const isEnvDefault = <Name extends EnvName>(name: Name): boolean =>\n  env[name] === defaults[name];\nexport const getEnvDesc = <Name extends EnvName>(name: Name): string => envDefinitions[name].desc;\ntype ChangeValue<T extends EnvName> = {\n  name: EnvName;\n  value: EnvValue<T>;\n  oldValue: EnvValue<T>;\n};\nexport const changes: Subject<ChangeValue<any>> = new Subject();\n// change one environment\nexport const setEnv = <Name extends EnvName>(name: Name, value: EnvValue<Name>): void => {\n  const oldValue = env[name];\n\n  if (oldValue !== value) {\n    env[name] = value;\n    changes.next({\n      name,\n      value,\n      oldValue,\n    });\n  }\n};\n// change one environment with safety. returns true if it succeed\nexport const setEnvUnsafe = (name: string, unsafeValue: unknown): boolean => {\n  const definition = getDefinition(name);\n  if (!definition) return false;\n  const { parser } = definition;\n  const value = parser(unsafeValue);\n\n  if (value === undefined || value === null) {\n    console.warn(`Invalid ENV value for ${name}`);\n    return false;\n  }\n\n  setEnv(name as EnvName, value);\n  return true;\n};\n","import EIP712 from \"./eip712.json\";\nexport { default as hash } from \"./eip712-hash.json\";\nexport default EIP712;\n","import EIP712 from \"./eip712_v2.json\";\nexport { default as hash } from \"./eip712_v2-hash.json\";\nexport default EIP712;\n","import { ethers } from \"ethers\";\nimport axios from \"axios\";\nimport SHA224 from \"crypto-js/sha224\";\nimport { getEnv } from \"@ledgerhq/live-env\";\nimport { EIP712Message } from \"@ledgerhq/types-live\";\nimport EIP712CAL from \"@ledgerhq/cryptoassets/data/eip712\";\nimport EIP712CALV2 from \"@ledgerhq/cryptoassets/data/eip712_v2\";\nimport { CALServiceEIP712Response, MessageFilters } from \"./types\";\n\n// As defined in [spec](https://eips.ethereum.org/EIPS/eip-712), the properties below are all required.\nexport function isEIP712Message(message: unknown): message is EIP712Message {\n  return (\n    !!message &&\n    typeof message === \"object\" &&\n    \"types\" in message &&\n    \"primaryType\" in message &&\n    \"domain\" in message &&\n    \"message\" in message\n  );\n}\n\nexport const sortObjectAlphabetically = (obj: Record<string, unknown>): Record<string, unknown> => {\n  const keys = Object.keys(obj).sort();\n\n  return keys.reduce((acc, curr) => {\n    const value = (() => {\n      if (Array.isArray(obj[curr])) {\n        return (obj[curr] as unknown[]).map(field =>\n          sortObjectAlphabetically(field as Record<string, unknown>),\n        );\n      }\n      return obj[curr];\n    })();\n\n    (acc as Record<string, unknown>)[curr] = value;\n    return acc;\n  }, {});\n};\n\nexport const getSchemaHashForMessage = (message: EIP712Message): string => {\n  const { types } = message;\n  const sortedTypes = sortObjectAlphabetically(types);\n\n  return SHA224(JSON.stringify(sortedTypes).replace(\" \", \"\")).toString();\n};\n\n/**\n * Tries to find the proper filters for a given EIP712 message\n * in the CAL\n *\n * @param {EIP712Message} message\n * @returns {MessageFilters | undefined}\n */\nexport const getFiltersForMessage = async (\n  message: EIP712Message,\n  shouldUseV1Filters?: boolean,\n  calServiceURL?: string | null,\n): Promise<MessageFilters | undefined> => {\n  const schemaHash = getSchemaHashForMessage(message);\n  const verifyingContract =\n    message.domain?.verifyingContract?.toLowerCase() || ethers.constants.AddressZero;\n  try {\n    if (calServiceURL) {\n      const { data } = await axios.get<CALServiceEIP712Response>(`${calServiceURL}/v1/dapps`, {\n        params: {\n          output: \"eip712_signatures\",\n          eip712_signatures_version: shouldUseV1Filters ? \"v1\" : \"v2\",\n          chain_id: message.domain?.chainId,\n          contracts: verifyingContract,\n        },\n      });\n\n      const filters = data?.[0]?.eip712_signatures?.[verifyingContract]?.[schemaHash];\n      if (!filters) {\n        // Fallback to catch\n        throw new Error(\"Fallback to static file\");\n      }\n\n      return filters;\n    }\n    // Fallback to catch\n    throw new Error(\"Fallback to static file\");\n  } catch (e) {\n    const messageId = `${message.domain?.chainId ?? 0}:${verifyingContract}:${schemaHash}`;\n\n    if (shouldUseV1Filters) {\n      return EIP712CAL[messageId as keyof typeof EIP712CAL];\n    }\n    return EIP712CALV2[messageId as keyof typeof EIP712CALV2] as MessageFilters;\n  }\n};\n\n/**\n * Get the value at a specific path of an object and return it as a string or as an array of string\n * Used recursively by getValueFromPath\n *\n * @see getValueFromPath\n */\nconst getValue = (\n  path: string,\n  value: Record<string, any> | Array<any> | string,\n): Record<string, any> | Array<any> | string => {\n  if (typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      return value.map(v => getValue(path, v)).flat();\n    }\n\n    /* istanbul ignore if : unecessary test of a throw */\n    if (!(path in value)) {\n      throw new Error(`Could not find key ${path} in ${JSON.stringify(value)} `);\n    }\n    const result = value[path];\n    return typeof result === \"object\" ? result : result.toString();\n  }\n\n  return value.toString();\n};\n\n/**\n * Using a path as a string, returns the value(s) of a json key without worrying about depth or arrays\n * (e.g: 'to.wallets.[]' => [\"0x123\", \"0x456\"])\n */\nexport const getValueFromPath = (path: string, eip721Message: EIP712Message): string | string[] => {\n  const splittedPath = path.split(\".\");\n  const { message } = eip721Message;\n\n  let value: any = message;\n  for (let i = 0; i <= splittedPath.length - 1; i++) {\n    const subPath = splittedPath[i];\n    const isLastElement = i >= splittedPath.length - 1;\n    if (subPath === \"[]\" && !isLastElement) continue;\n\n    value = getValue(subPath, value);\n  }\n\n  /* istanbul ignore if : unecessary test of a throw */\n  if (value === message) {\n    throw new Error(\"getValueFromPath returned the whole original message\");\n  }\n\n  return value as string | string[];\n};\n\n/**\n * Gets the fields visible on the nano for a specific EIP712 message\n */\nexport const getEIP712FieldsDisplayedOnNano = async (\n  messageData: EIP712Message,\n  calServiceURL: string = getEnv(\"CAL_SERVICE_URL\"),\n): Promise<{ label: string; value: string | string[] }[] | null> => {\n  if (!isEIP712Message(messageData)) {\n    return null;\n  }\n\n  const { EIP712Domain, ...otherTypes } = messageData.types;\n  const displayedInfos: { label: string; value: string | string[] }[] = [];\n  const filters = await getFiltersForMessage(messageData, false, calServiceURL);\n\n  if (!filters) {\n    const { types } = messageData;\n    const domainFields = types[\"EIP712Domain\"].map(({ name }) => name);\n\n    if (domainFields.includes(\"name\") && messageData.domain.name) {\n      displayedInfos.push({\n        label: \"name\",\n        value: messageData.domain.name,\n      });\n    }\n\n    if (domainFields.includes(\"version\") && messageData.domain.version) {\n      displayedInfos.push({\n        label: \"version\",\n        value: messageData.domain.version,\n      });\n    }\n\n    if (domainFields.includes(\"chainId\") && messageData.domain.chainId) {\n      displayedInfos.push({\n        label: \"chainId\",\n        value: messageData.domain.chainId.toString(),\n      });\n    }\n\n    if (domainFields.includes(\"verifyingContract\") && messageData.domain.verifyingContract) {\n      displayedInfos.push({\n        label: \"verifyingContract\",\n        value: messageData.domain.verifyingContract.toString(),\n      });\n    }\n\n    if (domainFields.includes(\"salt\") && messageData.domain.salt) {\n      displayedInfos.push({\n        label: \"salt\",\n        value: messageData.domain.salt.toString(),\n      });\n    }\n\n    displayedInfos.push({\n      label: \"Message hash\",\n      value: ethers.utils._TypedDataEncoder.hashStruct(\n        messageData.primaryType,\n        otherTypes,\n        messageData.message,\n      ),\n    });\n\n    return displayedInfos;\n  }\n\n  const { contractName, fields } = filters;\n  if (contractName && contractName.label) {\n    displayedInfos.push({\n      label: \"Contract\",\n      value: contractName.label,\n    });\n  }\n\n  for (const field of fields) {\n    displayedInfos.push({\n      label: field.label,\n      value: getValueFromPath(field.path, messageData),\n    });\n  }\n\n  return displayedInfos;\n};\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","import BigNumber from \"bignumber.js\";\nimport { EIP712MessageTypesEntry } from \"@ledgerhq/types-live\";\nimport { hexBuffer, intAsHexBytes } from \"../../utils\";\n\n/**\n * @ignore for the README\n *\n * A Map of helpers to get the wanted binary value for\n * each type of array possible in a type definition\n */\nenum EIP712_ARRAY_TYPE_VALUE {\n  DYNAMIC = 0,\n  FIXED = 1,\n}\n\n/**\n * @ignore for the README\n *\n * A Map of helpers to get the id and size to return for each\n * type that can be used in EIP712\n */\nexport const EIP712_TYPE_PROPERTIES: Record<\n  string,\n  {\n    key: (size?: number) => number;\n    sizeInBits: (size?: number) => number | null;\n  }\n> = {\n  CUSTOM: {\n    key: () => 0,\n    sizeInBits: () => null,\n  },\n  INT: {\n    key: () => 1,\n    sizeInBits: size => Number(size) / 8,\n  },\n  UINT: {\n    key: () => 2,\n    sizeInBits: size => Number(size) / 8,\n  },\n  ADDRESS: {\n    key: () => 3,\n    sizeInBits: () => null,\n  },\n  BOOL: {\n    key: () => 4,\n    sizeInBits: () => null,\n  },\n  STRING: {\n    key: () => 5,\n    sizeInBits: () => null,\n  },\n  BYTES: {\n    key: size => (typeof size !== \"undefined\" ? 6 : 7),\n    sizeInBits: size => (typeof size !== \"undefined\" ? Number(size) : null),\n  },\n};\n\n/**\n * @ignore for the README\n *\n * A Map of encoders to transform a value to formatted buffer\n */\nexport const EIP712_TYPE_ENCODERS = {\n  INT(value: string | null, sizeInBits = 256): Buffer {\n    const failSafeValue = value ?? \"0\";\n\n    if (typeof failSafeValue === \"string\" && failSafeValue?.startsWith(\"0x\")) {\n      return hexBuffer(failSafeValue);\n    }\n\n    let valueAsBN = new BigNumber(failSafeValue);\n    // If negative we'll use `two's complement` method to\n    // \"reversibly convert a positive binary number into a negative binary number with equivalent (but negative) value\".\n    // thx wikipedia\n    if (valueAsBN.lt(0)) {\n      const sizeInBytes = sizeInBits / 8;\n      // Creates BN from a buffer serving as a mask filled by maximum value 0xff\n      const maskAsBN = new BigNumber(`0x${Buffer.alloc(sizeInBytes, 0xff).toString(\"hex\")}`);\n\n      // two's complement version of value\n      valueAsBN = maskAsBN.plus(valueAsBN).plus(1);\n    }\n\n    const paddedHexString =\n      valueAsBN.toString(16).length % 2 ? \"0\" + valueAsBN.toString(16) : valueAsBN.toString(16);\n\n    return Buffer.from(paddedHexString, \"hex\");\n  },\n\n  UINT(value: string): Buffer {\n    return this.INT(value);\n  },\n\n  BOOL(value: number | string | boolean | null): Buffer {\n    return this.INT(typeof value === \"boolean\" ? Number(value).toString() : value);\n  },\n\n  ADDRESS(value: string | null): Buffer {\n    // Only sending the first 10 bytes (why ?)\n    return hexBuffer(value ?? \"\").slice(0, 20);\n  },\n\n  STRING(value: string | null): Buffer {\n    return Buffer.from(value ?? \"\", \"utf-8\");\n  },\n\n  BYTES(value: string | null, sizeInBits?: number): Buffer {\n    const failSafeValue = value ?? \"\";\n    // Why slice again ?\n    return hexBuffer(failSafeValue).slice(0, sizeInBits ?? (failSafeValue?.length - 2) / 2);\n  },\n};\n\n/**\n * @ignore for the README\n *\n * Helper parsing an EIP712 Type name to return its type and size(s)\n * if it's an array or nested arrays\n *\n * @see EIP712MessageTypes\n *\n * @example \"uint8[2][][4]\" => [{name: \"uint\", bits: 8}, [2, null, 4]]\n * @example \"bool\" => [{name: \"bool\", bits: null}, []]\n *\n * @param {String} typeName\n * @returns {[{ name: string; bits: Number | null }, Array<Number | null | undefined>]}\n */\nexport const destructTypeFromString = (\n  typeName?: string,\n): [{ name: string; bits: number | undefined } | null, Array<number | null>] => {\n  // Will split \"any[][1][10]\" in \"any\", \"[][1][10]\"\n  const splitNameAndArraysRegex = new RegExp(/^([^[\\]]*)(\\[.*\\])*/g);\n  // Will match all numbers (or null) inside each array. [0][10][] => [0,10,null]\n  const splitArraysRegex = new RegExp(/\\[(\\d*)\\]/g);\n  // Will separate the the name from the potential bits allocation. uint8 => [uint,8]\n  const splitNameAndNumberRegex = new RegExp(/(\\D*)(\\d*)/);\n\n  const [, type, maybeArrays] = splitNameAndArraysRegex.exec(typeName || \"\") || [];\n  const [, name, bits] = splitNameAndNumberRegex.exec(type || \"\") || [];\n  const typeDescription = name ? { name, bits: bits ? Number(bits) : undefined } : null;\n\n  const arrays = maybeArrays ? [...maybeArrays.matchAll(splitArraysRegex)] : [];\n  // Parse each size to either a Number or null\n  const arraySizes = arrays.map(([, size]) => (size ? Number(size) : null));\n\n  return [typeDescription, arraySizes];\n};\n\n/**\n * @ignore for the README\n *\n * Helper to construct the hexadecimal ByteString for the description\n * of a field in an EIP712 Message\n *\n * @param isArray\n * @param typeSize\n * @param typeValue\n * @returns {String} HexByteString\n */\nexport const constructTypeDescByteString = (\n  isArray: boolean,\n  typeSize: number | null | undefined,\n  typeValue: number,\n): string => {\n  if (typeValue >= 16) {\n    throw new Error(\n      \"Eth utils - constructTypeDescByteString - Cannot accept a typeValue >= 16 because the typeValue can only be 4 bits in binary\" +\n        { isArray, typeSize, typeValue },\n    );\n  }\n  // 1 is array, 0 is not array\n  const isArrayBit = isArray ? \"1\" : \"0\";\n  // 1 has type size, 0 has no type size\n  const hasTypeSize = typeof typeSize === \"number\" ? \"1\" : \"0\";\n  // 2 unused bits\n  const unusedBits = \"00\";\n  // type key as 4 bits\n  const typeValueBits = typeValue.toString(2).padStart(4, \"0\");\n\n  return intAsHexBytes(parseInt(isArrayBit + hasTypeSize + unusedBits + typeValueBits, 2), 1);\n};\n\n/**\n * @ignore for the README\n *\n * Helper to create the buffer to describe an EIP712 types' entry structure\n *\n * @param {EIP712MessageTypesEntry} entry\n * @returns {Buffer}\n */\nexport const makeTypeEntryStructBuffer = ({ name, type }: EIP712MessageTypesEntry): Buffer => {\n  const [typeDescription, arrSizes] = destructTypeFromString(type as string);\n  const isTypeAnArray = Boolean(arrSizes.length);\n  const typeProperties =\n    EIP712_TYPE_PROPERTIES[typeDescription?.name?.toUpperCase() || \"\"] ||\n    EIP712_TYPE_PROPERTIES.CUSTOM;\n\n  const typeKey = typeProperties.key(typeDescription?.bits);\n  const typeSizeInBits = typeProperties.sizeInBits(typeDescription?.bits);\n\n  const typeDescData = constructTypeDescByteString(isTypeAnArray, typeSizeInBits, typeKey);\n\n  const bufferArray: Buffer[] = [Buffer.from(typeDescData, \"hex\")];\n\n  if (typeProperties === EIP712_TYPE_PROPERTIES.CUSTOM) {\n    bufferArray.push(Buffer.from(intAsHexBytes(typeDescription?.name?.length ?? 0, 1), \"hex\"));\n    bufferArray.push(Buffer.from(typeDescription?.name ?? \"\", \"utf-8\"));\n  }\n\n  if (typeof typeSizeInBits === \"number\") {\n    bufferArray.push(Buffer.from(intAsHexBytes(typeSizeInBits, 1), \"hex\"));\n  }\n\n  if (isTypeAnArray) {\n    bufferArray.push(Buffer.from(intAsHexBytes(arrSizes.length, 1), \"hex\"));\n\n    arrSizes.forEach(size => {\n      if (typeof size === \"number\") {\n        bufferArray.push(\n          Buffer.from(intAsHexBytes(EIP712_ARRAY_TYPE_VALUE.FIXED, 1), \"hex\"),\n          Buffer.from(intAsHexBytes(size, 1), \"hex\"),\n        );\n      } else {\n        bufferArray.push(Buffer.from(intAsHexBytes(EIP712_ARRAY_TYPE_VALUE.DYNAMIC, 1), \"hex\"));\n      }\n    });\n  }\n\n  bufferArray.push(Buffer.from(intAsHexBytes(name.length, 1), \"hex\"), Buffer.from(name, \"utf-8\"));\n\n  return Buffer.concat(bufferArray);\n};\n","/* eslint @typescript-eslint/no-duplicate-enum-values: 1 */\nimport {\n  FilteringInfoContractName,\n  FilteringInfoShowField,\n  StructImplemData,\n  StructDefData,\n} from \"./types\";\nimport type {\n  EIP712Message,\n  EIP712MessageTypes,\n  EIP712MessageTypesEntry,\n} from \"@ledgerhq/types-live\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport {\n  getFiltersForMessage,\n  sortObjectAlphabetically,\n} from \"@ledgerhq/evm-tools/message/EIP712/index\";\nimport { MessageFilters } from \"@ledgerhq/evm-tools/message/EIP712/types\";\nimport { hexBuffer, intAsHexBytes, splitPath } from \"../../utils\";\nimport { getLoadConfig } from \"../../services/ledger/loadConfig\";\nimport { LoadConfig } from \"../../services/types\";\nimport {\n  destructTypeFromString,\n  EIP712_TYPE_ENCODERS,\n  EIP712_TYPE_PROPERTIES,\n  makeTypeEntryStructBuffer,\n} from \"./utils\";\n\n/**\n * @ignore for the README\n *\n * Factory to create the recursive function that will pass on each\n * field level and APDUs to describe its structure implementation\n *\n * @param {Eth[\"sendStructImplem\"]} sendStructImplem\n * @param {EIP712MessageTypes} types\n * @returns {void}\n */\nconst makeRecursiveFieldStructImplem = (\n  transport: Transport,\n  types: EIP712MessageTypes,\n  filters?: MessageFilters,\n): ((\n  destructedType: ReturnType<typeof destructTypeFromString>,\n  data: unknown,\n  path?: string,\n) => Promise<void>) => {\n  const typesMap = {} as Record<string, Record<string, string>>;\n  for (const type in types) {\n    typesMap[type] = types[type]?.reduce((acc, curr) => ({ ...acc, [curr.name]: curr.type }), {});\n  }\n\n  // This recursion will call itself to handle each level of each field\n  // in order to send APDUs for each of them\n  const recursiveFieldStructImplem = async (\n    destructedType: ReturnType<typeof destructTypeFromString>,\n    data,\n    path = \"\",\n  ) => {\n    const [typeDescription, arrSizes] = destructedType;\n    const [currSize, ...restSizes] = arrSizes;\n    const isCustomType = !EIP712_TYPE_PROPERTIES[typeDescription?.name?.toUpperCase() || \"\"];\n\n    if (Array.isArray(data) && typeof currSize !== \"undefined\") {\n      await sendStructImplem(transport, {\n        structType: \"array\",\n        value: data.length,\n      });\n      for (const entry of data) {\n        await recursiveFieldStructImplem([typeDescription, restSizes], entry, `${path}.[]`);\n      }\n    } else if (isCustomType) {\n      for (const [fieldName, fieldValue] of Object.entries(data as EIP712Message[\"message\"])) {\n        const fieldType = typesMap[typeDescription?.name || \"\"]?.[fieldName];\n\n        if (fieldType) {\n          await recursiveFieldStructImplem(\n            destructTypeFromString(fieldType),\n            fieldValue,\n            `${path}.${fieldName}`,\n          );\n        }\n      }\n    } else {\n      const filter = filters?.fields.find(f => path === f.path);\n\n      if (filter) {\n        await sendFilteringInfo(transport, \"showField\", {\n          displayName: filter.label,\n          sig: filter.signature,\n        });\n      }\n\n      await sendStructImplem(transport, {\n        structType: \"field\",\n        value: {\n          data,\n          type: typeDescription?.name || \"\",\n          sizeInBits: typeDescription?.bits,\n        },\n      });\n    }\n  };\n\n  return recursiveFieldStructImplem;\n};\n\n/**\n * @ignore for the README\n *\n * This method is used to send the message definition with all its types.\n * This method should be used before the sendStructImplem one\n *\n * @param {String} structType\n * @param {String|Buffer} value\n * @returns {Promise<void>}\n */\nconst sendStructDef = (transport: Transport, structDef: StructDefData): Promise<Buffer> => {\n  enum APDU_FIELDS {\n    CLA = 0xe0,\n    INS = 0x1a,\n    P1_complete = 0x00,\n    P1_partial = 0x01,\n    P2_name = 0x00,\n    P2_field = 0xff,\n  }\n\n  const { structType, value } = structDef;\n  const data =\n    structType === \"name\" && typeof value === \"string\"\n      ? Buffer.from(value, \"utf-8\")\n      : (value as Buffer);\n\n  return transport.send(\n    APDU_FIELDS.CLA,\n    APDU_FIELDS.INS,\n    APDU_FIELDS.P1_complete,\n    structType === \"name\" ? APDU_FIELDS.P2_name : APDU_FIELDS.P2_field,\n    data,\n  );\n};\n\n/**\n * @ignore for the README\n *\n * This method provides a trusted new display name to use for the upcoming field.\n * This method should be used after the sendStructDef one.\n *\n * If the method describes an empty name (length of 0), the upcoming field will be taken\n * into account but won’t be shown on the device.\n *\n * The signature is computed on :\n * json key length || json key || display name length || display name\n *\n * signed by the following secp256k1 public key:\n * 0482bbf2f34f367b2e5bc21847b6566f21f0976b22d3388a9a5e446ac62d25cf725b62a2555b2dd464a4da0ab2f4d506820543af1d242470b1b1a969a27578f353\n *\n * @param {String} structType \"root\" | \"array\" | \"field\"\n * @param {string | number | StructFieldData} value\n * @returns {Promise<Buffer | void>}\n */\nconst sendStructImplem = async (\n  transport: Transport,\n  structImplem: StructImplemData,\n): Promise<Buffer | void> => {\n  enum APDU_FIELDS {\n    CLA = 0xe0,\n    INS = 0x1c,\n    P1_complete = 0x00,\n    P1_partial = 0x01,\n    P2_root = 0x00,\n    P2_array = 0x0f,\n    P2_field = 0xff,\n  }\n\n  const { structType, value } = structImplem;\n\n  if (structType === \"root\") {\n    return transport.send(\n      APDU_FIELDS.CLA,\n      APDU_FIELDS.INS,\n      APDU_FIELDS.P1_complete,\n      APDU_FIELDS.P2_root,\n      Buffer.from(value, \"utf-8\"),\n    );\n  }\n\n  if (structType === \"array\") {\n    return transport.send(\n      APDU_FIELDS.CLA,\n      APDU_FIELDS.INS,\n      APDU_FIELDS.P1_complete,\n      APDU_FIELDS.P2_array,\n      Buffer.from(intAsHexBytes(value, 1), \"hex\"),\n    );\n  }\n\n  if (structType === \"field\") {\n    const { data: rawData, type, sizeInBits } = value;\n    const encodedData: Buffer | null = EIP712_TYPE_ENCODERS[type.toUpperCase()]?.(\n      rawData,\n      sizeInBits,\n    );\n\n    if (encodedData) {\n      // const dataLengthPer16Bits = (encodedData.length & 0xff00) >> 8;\n      const dataLengthPer16Bits = Math.floor(encodedData.length / 256);\n      // const dataLengthModulo16Bits = encodedData.length & 0xff;\n      const dataLengthModulo16Bits = encodedData.length % 256;\n\n      const data = Buffer.concat([\n        Buffer.from(intAsHexBytes(dataLengthPer16Bits, 1), \"hex\"),\n        Buffer.from(intAsHexBytes(dataLengthModulo16Bits, 1), \"hex\"),\n        encodedData,\n      ]);\n\n      const bufferSlices = new Array(Math.ceil(data.length / 256))\n        .fill(null)\n        .map((_, i) => data.slice(i * 255, (i + 1) * 255));\n\n      for (const bufferSlice of bufferSlices) {\n        await transport.send(\n          APDU_FIELDS.CLA,\n          APDU_FIELDS.INS,\n          bufferSlice !== bufferSlices[bufferSlices.length - 1]\n            ? APDU_FIELDS.P1_partial\n            : APDU_FIELDS.P1_complete,\n          APDU_FIELDS.P2_field,\n          bufferSlice,\n        );\n      }\n    }\n  }\n\n  return Promise.resolve();\n};\n\nasync function sendFilteringInfo(transport: Transport, type: \"activate\"): Promise<Buffer>;\nasync function sendFilteringInfo(\n  transport: Transport,\n  type: \"contractName\",\n  data: FilteringInfoContractName,\n): Promise<Buffer>;\nasync function sendFilteringInfo(\n  transport: Transport,\n  type: \"showField\",\n  data: FilteringInfoShowField,\n): Promise<Buffer>;\nasync function sendFilteringInfo(\n  transport: Transport,\n  type: \"activate\" | \"contractName\" | \"showField\",\n  data?: FilteringInfoContractName | FilteringInfoShowField,\n): Promise<Buffer | void> {\n  enum APDU_FIELDS {\n    CLA = 0xe0,\n    INS = 0x1e,\n    P1 = 0x00,\n    P2_activate = 0x00,\n    P2_contract_name = 0x0f, // officially named \"message info\"\n    P2_show_field = 0xff,\n  }\n\n  switch (type) {\n    case \"activate\":\n      return transport.send(\n        APDU_FIELDS.CLA,\n        APDU_FIELDS.INS,\n        APDU_FIELDS.P1,\n        APDU_FIELDS.P2_activate,\n      );\n\n    case \"contractName\": {\n      const { displayName, filtersCount, sig } = data as FilteringInfoContractName;\n      const displayNameLengthBuffer = Buffer.from(intAsHexBytes(displayName.length, 1), \"hex\");\n      const displayNameBuffer = Buffer.from(displayName);\n      const filtersCountBuffer = Buffer.from(intAsHexBytes(filtersCount, 1), \"hex\");\n      const sigLengthBuffer = Buffer.from(intAsHexBytes(sig.length / 2, 1), \"hex\");\n      const sigBuffer = Buffer.from(sig, \"hex\");\n\n      const callData = Buffer.concat([\n        displayNameLengthBuffer,\n        displayNameBuffer,\n        filtersCountBuffer,\n        sigLengthBuffer,\n        sigBuffer,\n      ]);\n\n      return transport.send(\n        APDU_FIELDS.CLA,\n        APDU_FIELDS.INS,\n        APDU_FIELDS.P1,\n        APDU_FIELDS.P2_contract_name,\n        callData,\n      );\n    }\n\n    case \"showField\": {\n      const { displayName, sig } = data as FilteringInfoShowField;\n      const displayNameLengthBuffer = Buffer.from(intAsHexBytes(displayName.length, 1), \"hex\");\n      const displayNameBuffer = Buffer.from(displayName);\n      const sigLengthBuffer = Buffer.from(intAsHexBytes(sig.length / 2, 1), \"hex\");\n      const sigBuffer = Buffer.from(sig, \"hex\");\n\n      const callData = Buffer.concat([\n        displayNameLengthBuffer,\n        displayNameBuffer,\n        sigLengthBuffer,\n        sigBuffer,\n      ]);\n\n      return transport.send(\n        APDU_FIELDS.CLA,\n        APDU_FIELDS.INS,\n        APDU_FIELDS.P1,\n        APDU_FIELDS.P2_show_field,\n        callData,\n      );\n    }\n  }\n}\n\n/**\n * @ignore for the README\n *\n * Sign an EIP-721 formatted message following the specification here:\n * https://github.com/LedgerHQ/app-ethereum/blob/develop/doc/ethapp.asc#sign-eth-eip-712\n * @example\n  eth.signEIP721Message(\"44'/60'/0'/0/0\", {\n    domain: {\n      chainId: 69,\n      name: \"Da Domain\",\n      verifyingContract: \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\",\n      version: \"1\"\n    },\n    types: {\n      \"EIP712Domain\": [\n            { name: \"name\", type: \"string\" },\n            { name: \"version\", type: \"string\" },\n            { name: \"chainId\", type: \"uint256\" },\n            { name: \"verifyingContract\", type: \"address\" }\n        ],\n      \"Test\": [\n        { name: \"contents\", type: \"string\" }\n      ]\n    },\n    primaryType: \"Test\",\n    message: {contents: \"Hello, Bob!\"},\n  })\n *\n * @param {String} path derivationPath\n * @param {Object} jsonMessage message to sign\n * @param {Boolean} fullImplem use the legacy implementation\n * @returns {Promise}\n */\nexport const signEIP712Message = async (\n  transport: Transport,\n  path: string,\n  jsonMessage: EIP712Message,\n  fullImplem = false,\n  loadConfig: LoadConfig,\n): Promise<{\n  v: number;\n  s: string;\n  r: string;\n}> => {\n  enum APDU_FIELDS {\n    CLA = 0xe0,\n    INS = 0x0c,\n    P1 = 0x00,\n    P2_v0 = 0x00,\n    P2_full = 0x01,\n  }\n  const { primaryType, types: unsortedTypes, domain, message } = jsonMessage;\n  const { cryptoassetsBaseURL } = getLoadConfig(loadConfig);\n  // Types are sorted by alphabetical order in order to get the same schema hash no matter the JSON format\n  const types = sortObjectAlphabetically(unsortedTypes) as EIP712MessageTypes;\n  const filters = await getFiltersForMessage(jsonMessage, cryptoassetsBaseURL);\n\n  const typeEntries = Object.entries(types) as [\n    keyof EIP712MessageTypes,\n    EIP712MessageTypesEntry[],\n  ][];\n  // Looping on all types entries and fields to send structures' definitions\n  for (const [typeName, entries] of typeEntries) {\n    await sendStructDef(transport, {\n      structType: \"name\",\n      value: typeName as string,\n    });\n\n    for (const { name, type } of entries) {\n      const typeEntryBuffer = makeTypeEntryStructBuffer({ name, type });\n      await sendStructDef(transport, {\n        structType: \"field\",\n        value: typeEntryBuffer,\n      });\n    }\n  }\n\n  if (filters) {\n    await sendFilteringInfo(transport, \"activate\");\n  }\n  // Create the recursion that should pass on each entry\n  // of the domain fields and primaryType fields\n  const recursiveFieldStructImplem = makeRecursiveFieldStructImplem(transport, types, filters);\n\n  // Looping on all domain type's entries and fields to send\n  // structures' implementations\n  const domainName = \"EIP712Domain\";\n  await sendStructImplem(transport, {\n    structType: \"root\",\n    value: domainName,\n  });\n  const domainTypeFields = types[domainName];\n  for (const { name, type } of domainTypeFields) {\n    const domainFieldValue = domain[name];\n    await recursiveFieldStructImplem(destructTypeFromString(type as string), domainFieldValue);\n  }\n\n  if (filters) {\n    const { contractName, fields } = filters;\n    const contractNameInfos = {\n      displayName: contractName.label,\n      filtersCount: fields.length,\n      sig: contractName.signature,\n    };\n    await sendFilteringInfo(transport, \"contractName\", contractNameInfos);\n  }\n\n  // Looping on all primaryType type's entries and fields to send\n  // structures' implementations\n  await sendStructImplem(transport, {\n    structType: \"root\",\n    value: primaryType,\n  });\n  const primaryTypeFields = types[primaryType];\n  for (const { name, type } of primaryTypeFields) {\n    const primaryTypeValue = message[name];\n    await recursiveFieldStructImplem(\n      destructTypeFromString(type as string),\n      primaryTypeValue,\n      name,\n    );\n  }\n\n  // Sending the final signature.\n  const paths = splitPath(path);\n  const signatureBuffer = Buffer.alloc(1 + paths.length * 4);\n  signatureBuffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    signatureBuffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n\n  return transport\n    .send(\n      APDU_FIELDS.CLA,\n      APDU_FIELDS.INS,\n      APDU_FIELDS.P1,\n      fullImplem ? APDU_FIELDS.P2_v0 : APDU_FIELDS.P2_full,\n      signatureBuffer,\n    )\n    .then(response => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n\n      return {\n        v,\n        r,\n        s,\n      };\n    });\n};\n\n/**\n * @ignore for the README\n * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n * @example\n eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n var v = result['v'] - 27;\n v = v.toString(16);\n if (v.length < 2) {\n   v = \"0\" + v;\n }\n console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n })\n */\nexport const signEIP712HashedMessage = (\n  transport: Transport,\n  path: string,\n  domainSeparatorHex: string,\n  hashStructMessageHex: string,\n): Promise<{\n  v: number;\n  s: string;\n  r: string;\n}> => {\n  const domainSeparator = hexBuffer(domainSeparatorHex);\n  const hashStruct = hexBuffer(hashStructMessageHex);\n  const paths = splitPath(path);\n  const buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n  let offset = 0;\n  buffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  offset = 1 + 4 * paths.length;\n  domainSeparator.copy(buffer, offset);\n  offset += 32;\n  hashStruct.copy(buffer, offset);\n\n  return transport.send(0xe0, 0x0c, 0x00, 0x00, buffer).then(response => {\n    const v = response[0];\n    const r = response.slice(1, 1 + 32).toString(\"hex\");\n    const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n    return {\n      v,\n      r,\n      s,\n    };\n  });\n};\n","/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n/* eslint @typescript-eslint/no-duplicate-enum-values: 1 */\n// FIXME drop:\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { BigNumber } from \"bignumber.js\";\n// NB: these are temporary import for the deprecated fallback mechanism\nimport { LedgerEthTransactionResolution, LoadConfig, ResolutionConfig } from \"./services/types\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  decodeTxInfo,\n  hexBuffer,\n  intAsHexBytes,\n  maybeHexBuffer,\n  padHexString,\n  splitPath,\n} from \"./utils\";\nimport { domainResolutionFlow } from \"./modules/Domains\";\nimport ledgerService from \"./services/ledger\";\nimport { EthAppNftNotSupported, EthAppPleaseEnableContractData } from \"./errors\";\nimport { signEIP712HashedMessage, signEIP712Message } from \"./modules/EIP712\";\nimport { EIP712Message } from \"@ledgerhq/types-live\";\n\nexport { ledgerService };\nexport * from \"./utils\";\n\nexport type StarkQuantizationType = \"eth\" | \"erc20\" | \"erc721\" | \"erc20mintable\" | \"erc721mintable\";\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5,\n};\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Blind signing or Contract data in the Ethereum app Settings\",\n    );\n  }\n\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\nexport default class Eth {\n  transport: Transport;\n  loadConfig: LoadConfig;\n\n  setLoadConfig(loadConfig: LoadConfig): void {\n    this.loadConfig = loadConfig;\n  }\n\n  constructor(transport: Transport, scrambleKey = \"w0w\", loadConfig: LoadConfig = {}) {\n    this.transport = transport;\n    this.loadConfig = loadConfig;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        // \"getChallange\",                  | ⚠️\n        // \"provideERC20TokenInformation\",  | Those methods are not decorated as they're\n        // \"setExternalPlugin\",             | being used inside of the `signTransaction` flow\n        // \"setPlugin\",                     | and shouldn't be locking the transport\n        // \"provideDomainName\",             | ⚠️\n        // \"provideNFTInformation\",         |\n        \"getAddress\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n        \"signEIP712Message\",\n        \"signEIP712HashedMessage\",\n        \"starkGetPublicKey\",\n        \"starkSignOrder\",\n        \"starkSignOrder_v2\",\n        \"starkSignTransfer\",\n        \"starkSignTransfer_v2\",\n        \"starkProvideQuantum\",\n        \"starkProvideQuantum_v2\",\n        \"starkUnsafeSign\",\n        \"eth2GetPublicKey\",\n        \"eth2SetWithdrawalIndex\",\n        \"getEIP1024PublicEncryptionKey\",\n        \"getEIP1024SharedSecret\",\n      ],\n      scrambleKey,\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @option chainId optionally display the network clearly on a Stax device\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean,\n    chainId?: string,\n  ): Promise<{\n    publicKey: string;\n    address: string;\n    chainCode?: string;\n  }> {\n    const paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n\n    if (chainId) {\n      const chainIdBufferMask = Buffer.alloc(8, 0);\n      const chainIdBuffer = Buffer.from(padHexString(new BigNumber(chainId).toString(16)), \"hex\");\n      chainIdBufferMask.write(\n        chainIdBuffer.toString(\"hex\"),\n        chainIdBufferMask.length - chainIdBuffer.length,\n        \"hex\",\n      );\n      buffer = Buffer.concat([buffer, chainIdBufferMask]);\n    }\n\n    return this.transport\n      .send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer)\n      .then(response => {\n        const publicKeyLength = response[0];\n        const addressLength = response[1 + publicKeyLength];\n\n        return {\n          publicKey: response.slice(1, 1 + publicKeyLength).toString(\"hex\"),\n          address:\n            \"0x\" +\n            response\n              .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n              .toString(\"ascii\"),\n          chainCode: boolChaincode\n            ? response\n                .slice(\n                  1 + publicKeyLength + 1 + addressLength,\n                  1 + publicKeyLength + 1 + addressLength + 32,\n                )\n                .toString(\"hex\")\n            : undefined,\n        };\n      });\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.\n   *\n   * @param path: the BIP32 path to sign the transaction on\n   * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign\n   * @param resolution: resolution is an object with all \"resolved\" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to \"null\" will fallback everything to blind signing but will still allow the device to sign the transaction.\n   * @example\n   import { ledgerService } from \"@ledgerhq/hw-app-eth\"\n   const tx = \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\"; // raw tx to sign\n   const resolution = await ledgerService.resolveTransaction(tx);\n   const result = eth.signTransaction(\"44'/60'/0'/0/0\", tx, resolution);\n   console.log(result);\n   */\n  async signTransaction(\n    path: string,\n    rawTxHex: string,\n    resolution?: LedgerEthTransactionResolution | null,\n  ): Promise<{\n    s: string;\n    v: string;\n    r: string;\n  }> {\n    if (resolution === undefined) {\n      console.warn(\n        \"hw-app-eth: signTransaction(path, rawTxHex, resolution): \" +\n          \"please provide the 'resolution' parameter. \" +\n          \"See https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-eth/README.md \" +\n          \"– the previous signature is deprecated and providing the 3rd 'resolution' parameter explicitly will become mandatory so you have the control on the resolution and the fallback mecanism (e.g. fallback to blind signing or not).\" +\n          \"// Possible solution:\\n\" +\n          \" + import { ledgerService } from '@ledgerhq/hw-app-eth';\\n\" +\n          \" + const resolution = await ledgerService.resolveTransaction(rawTxHex);\",\n      );\n      resolution = await ledgerService\n        .resolveTransaction(rawTxHex, this.loadConfig, {\n          externalPlugins: true,\n          erc20: true,\n        })\n        .catch(e => {\n          console.warn(\n            \"an error occurred in resolveTransaction => fallback to blind signing: \" + String(e),\n          );\n          return null;\n        });\n    }\n\n    // provide to the device resolved information to make it clear sign the signature\n    if (resolution) {\n      for (const domainDescriptor of resolution.domains) {\n        await domainResolutionFlow(this, domainDescriptor).catch(e => {\n          // error during the domain flow shouldn't be blocking the signature in case of failure\n          log(\"error\", \"domainResolutionFlow failed\", {\n            domainDescriptor,\n            error: e,\n          });\n        });\n      }\n\n      for (const plugin of resolution.plugin) {\n        await this.setPlugin(plugin);\n      }\n\n      for (const { payload, signature } of resolution.externalPlugin) {\n        await this.setExternalPlugin(payload, signature);\n      }\n\n      for (const nft of resolution.nfts) {\n        await this.provideNFTInformation(nft);\n      }\n\n      for (const data of resolution.erc20Tokens) {\n        await this.provideERC20TokenInformation(data);\n      }\n    }\n\n    const rawTx = Buffer.from(rawTxHex, \"hex\");\n    const { vrsOffset, txType, chainId, chainIdTruncated } = decodeTxInfo(rawTx);\n\n    const paths = splitPath(path);\n    let response;\n    let offset = 0;\n    while (offset !== rawTx.length) {\n      const first = offset === 0;\n      const maxChunkSize = first ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n      if (vrsOffset != 0 && offset + chunkSize >= vrsOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize = rawTx.length - offset;\n      }\n\n      const buffer = Buffer.alloc(first ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n      if (first) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      response = await this.transport\n        .send(0xe0, 0x04, first ? 0x00 : 0x80, 0x00, buffer)\n        .catch(e => {\n          throw remapTransactionRelatedErrors(e);\n        });\n\n      offset += chunkSize;\n    }\n\n    const response_byte: number = response[0];\n    let v = \"\";\n\n    if (chainId.times(2).plus(35).plus(1).isGreaterThan(255)) {\n      const oneByteChainId = (chainIdTruncated * 2 + 35) % 256;\n\n      const ecc_parity = Math.abs(response_byte - oneByteChainId);\n\n      if (txType != null) {\n        // For EIP2930 and EIP1559 tx, v is simply the parity.\n        v = ecc_parity % 2 == 1 ? \"00\" : \"01\";\n      } else {\n        // Legacy type transaction with a big chain ID\n        v = chainId.times(2).plus(35).plus(ecc_parity).toString(16);\n      }\n    } else {\n      v = response_byte.toString(16);\n    }\n\n    // Make sure v has is prefixed with a 0 if its length is odd (\"1\" -> \"01\").\n    if (v.length % 2 == 1) {\n      v = \"0\" + v;\n    }\n\n    const r = response.slice(1, 1 + 32).toString(\"hex\");\n    const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n    return { v, r, s };\n  }\n\n  /**\n   * Helper to get resolution and signature of a transaction in a single method\n   *\n   * @param path: the BIP32 path to sign the transaction on\n   * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign\n   * @param resolutionConfig: configuration about what should be clear signed in the transaction\n   * @param throwOnError: optional parameter to determine if a failing resolution of the transaction should throw an error or not\n   * @example\n   const tx = \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\"; // raw tx to sign\n   const result = eth.clearSignTransaction(\"44'/60'/0'/0/0\", tx, { erc20: true, externalPlugins: true, nft: true});\n   console.log(result);\n   */\n  async clearSignTransaction(\n    path: string,\n    rawTxHex: string,\n    resolutionConfig: ResolutionConfig,\n    throwOnError = false,\n  ): Promise<{ r: string; s: string; v: string }> {\n    const resolution = await ledgerService\n      .resolveTransaction(rawTxHex, this.loadConfig, resolutionConfig)\n      .catch(e => {\n        console.warn(\n          \"an error occurred in resolveTransaction => fallback to blind signing: \" + String(e),\n        );\n\n        if (throwOnError) {\n          throw e;\n        }\n        return null;\n      });\n\n    return this.signTransaction(path, rawTxHex, resolution);\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number;\n    erc20ProvisioningNecessary: number;\n    starkEnabled: number;\n    starkv2Supported: number;\n    version: string;\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      return {\n        arbitraryDataEnabled: response[0] & 0x01,\n        erc20ProvisioningNecessary: response[0] & 0x02,\n        starkEnabled: response[0] & 0x04,\n        starkv2Supported: response[0] & 0x08,\n        version: \"\" + response[1] + \".\" + response[2] + \".\" + response[3],\n      };\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n  async signPersonalMessage(\n    path: string,\n    messageHex: string,\n  ): Promise<{\n    v: number;\n    s: string;\n    r: string;\n  }> {\n    const paths = splitPath(path);\n    let offset = 0;\n    const message = Buffer.from(messageHex, \"hex\");\n    let response;\n\n    while (offset !== message.length) {\n      const maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      const chunkSize =\n        offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      response = await this.transport.send(0xe0, 0x08, offset === 0 ? 0x00 : 0x80, 0x00, buffer);\n\n      offset += chunkSize;\n    }\n\n    const v = response[0];\n    const r = response.slice(1, 1 + 32).toString(\"hex\");\n    const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n    return { v, r, s };\n  }\n\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n  signEIP712HashedMessage(\n    path: string,\n    domainSeparatorHex: string,\n    hashStructMessageHex: string,\n  ): Promise<{\n    v: number;\n    s: string;\n    r: string;\n  }> {\n    return signEIP712HashedMessage(this.transport, path, domainSeparatorHex, hashStructMessageHex);\n  }\n\n  /**\n   * Sign an EIP-721 formatted message following the specification here:\n   * https://github.com/LedgerHQ/app-ethereum/blob/develop/doc/ethapp.asc#sign-eth-eip-712\n   * ⚠️ This method is not compatible with nano S (LNS). Make sure to use a try/catch to fallback on the signEIP712HashedMessage method ⚠️\n   @example\n   eth.signEIP721Message(\"44'/60'/0'/0/0\", {\n      domain: {\n        chainId: 69,\n        name: \"Da Domain\",\n        verifyingContract: \"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC\",\n        version: \"1\"\n      },\n      types: {\n        \"EIP712Domain\": [\n              { name: \"name\", type: \"string\" },\n              { name: \"version\", type: \"string\" },\n              { name: \"chainId\", type: \"uint256\" },\n              { name: \"verifyingContract\", type: \"address\" }\n          ],\n        \"Test\": [\n          { name: \"contents\", type: \"string\" }\n        ]\n      },\n      primaryType: \"Test\",\n      message: {contents: \"Hello, Bob!\"},\n    })\n   *\n   * @param {String} path derivationPath\n   * @param {Object} jsonMessage message to sign\n   * @param {Boolean} fullImplem use the legacy implementation\n   * @returns {Promise}\n   */\n  async signEIP712Message(\n    path: string,\n    jsonMessage: EIP712Message,\n    fullImplem = false,\n  ): Promise<{\n    v: number;\n    s: string;\n    r: string;\n  }> {\n    return signEIP712Message(this.transport, path, jsonMessage, fullImplem, this.loadConfig);\n  }\n\n  /**\n   * Method returning a 4 bytes TLV challenge as an hexa string\n   *\n   * @returns {Promise<string>}\n   */\n  async getChallenge(): Promise<string> {\n    enum APDU_FIELDS {\n      CLA = 0xe0,\n      INS = 0x20,\n      P1 = 0x00,\n      P2 = 0x00,\n      LC = 0x00,\n    }\n\n    return this.transport\n      .send(APDU_FIELDS.CLA, APDU_FIELDS.INS, APDU_FIELDS.P1, APDU_FIELDS.P2)\n      .then(res => {\n        const [, fourBytesChallenge, statusCode] =\n          new RegExp(\"(.*)(.{4}$)\").exec(res.toString(\"hex\")) || [];\n\n        if (statusCode !== \"9000\") {\n          throw new Error(\n            `An error happened while generating the challenge. Status code: ${statusCode}`,\n          );\n        }\n        return `0x${fourBytesChallenge}`;\n      })\n      .catch(e => {\n        log(\"error\", \"couldn't request a challenge\", e);\n        throw e;\n      });\n  }\n\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then(response => {\n        return response.slice(0, response.length - 2);\n      });\n  }\n\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder(\n    path: string,\n    sourceTokenAddress: string | undefined,\n    sourceQuantization: BigNumber,\n    destinationTokenAddress: string | undefined,\n    destinationQuantization: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number,\n  ): Promise<Buffer | { r: string; s: string }> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0,\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s,\n      };\n    });\n  }\n\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder_v2(\n    path: string,\n    sourceTokenAddress: string | undefined,\n    sourceQuantizationType: StarkQuantizationType,\n    sourceQuantization: BigNumber | undefined,\n    sourceMintableBlobOrTokenId: BigNumber | undefined,\n    destinationTokenAddress: string | undefined,\n    destinationQuantizationType: StarkQuantizationType,\n    destinationQuantization: BigNumber | undefined,\n    destinationMintableBlobOrTokenId: BigNumber | undefined,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number,\n  ): Promise<Buffer | { r: string; s: string }> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid source quantization type=\" + sourceQuantizationType,\n      );\n    }\n\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid destination quantization type=\" + destinationQuantizationType,\n      );\n    }\n\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(\n      1 + paths.length * 4 + 1 + 20 + 32 + 32 + 1 + 20 + 32 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0,\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (sourceQuantization) {\n      Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(\n        buffer,\n        offset,\n      );\n    }\n\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (destinationQuantization) {\n      Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(\n        buffer,\n        offset,\n      );\n    }\n\n    offset += 32;\n\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(\n        buffer,\n        offset,\n      );\n    }\n\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x03, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s,\n      };\n    });\n  }\n\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignTransfer(\n    path: string,\n    transferTokenAddress: string | undefined,\n    transferQuantization: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n  ): Promise<Buffer | { r: string; s: string }> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s,\n      };\n    });\n  }\n\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n  starkSignTransfer_v2(\n    path: string,\n    transferTokenAddress: string | undefined,\n    transferQuantizationType: StarkQuantizationType,\n    transferQuantization: BigNumber | undefined,\n    transferMintableBlobOrTokenId: BigNumber | undefined,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n    conditionalTransferAddress?: string,\n    conditionalTransferFact?: BigNumber,\n  ): Promise<Buffer | { r: string; s: string }> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(conditionalTransferAddress);\n\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignTransferv2 invalid quantization type=\" + transferQuantizationType,\n      );\n    }\n\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        4 +\n        4 +\n        (conditionalTransferAddressHex ? 32 + 20 : 0),\n      0,\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (transferQuantization) {\n      Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(\n        buffer,\n        offset,\n      );\n    }\n\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(conditionalTransferFact.toString(16).padStart(64, \"0\"), \"hex\").copy(\n        buffer,\n        offset,\n      );\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n\n    return this.transport\n      .send(0xf0, 0x04, conditionalTransferAddressHex ? 0x05 : 0x04, 0x00, buffer)\n      .then(response => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return {\n          r,\n          s,\n        };\n      });\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n  starkProvideQuantum(\n    operationContract: string | undefined,\n    operationQuantization: BigNumber,\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    const buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting Stark extensions\n          return false;\n        }\n\n        throw e;\n      },\n    );\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n  starkProvideQuantum_v2(\n    operationContract: string | undefined,\n    operationQuantizationType: StarkQuantizationType,\n    operationQuantization?: BigNumber,\n    operationMintableBlobOrTokenId?: BigNumber,\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkProvideQuantumV2 invalid quantization type=\" + operationQuantizationType,\n      );\n    }\n\n    const buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (operationQuantization) {\n      Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(\n        buffer,\n        offset,\n      );\n    }\n\n    return this.transport\n      .send(0xf0, 0x08, starkQuantizationTypeMap[operationQuantizationType], 0x00, buffer)\n      .then(\n        () => true,\n        e => {\n          if (e && e.statusCode === 0x6d00) {\n            // this case happen for ETH application versions not supporting Stark extensions\n            return false;\n          }\n\n          throw e;\n        },\n      );\n  }\n\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n  starkUnsafeSign(path: string, hash: string): Promise<Buffer | { r: string; s: string }> {\n    const hashHex = hexBuffer(hash);\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport.send(0xf0, 0x0a, 0x00, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s,\n      };\n    });\n  }\n\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n  eth2GetPublicKey(\n    path: string,\n    boolDisplay?: boolean,\n  ): Promise<{\n    publicKey: string;\n  }> {\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then(response => {\n        return {\n          publicKey: response.slice(0, -2).toString(\"hex\"),\n        };\n      });\n  }\n\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {\n    const buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting ETH 2\n          return false;\n        }\n\n        throw e;\n      },\n    );\n  }\n\n  /**\n   * get a public encryption key on Curve25519 according to EIP 1024\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.getEIP1024PublicEncryptionKey(\"44'/60'/0'/0/0\").then(o => o.publicKey)\n   */\n  getEIP1024PublicEncryptionKey(\n    path: string,\n    boolDisplay?: boolean,\n  ): Promise<{\n    publicKey: string;\n  }> {\n    const paths = splitPath(path);\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x18, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then(response => {\n        return {\n          publicKey: response.slice(0, -2).toString(\"hex\"),\n        };\n      });\n  }\n\n  /**\n   * get a shared secret on Curve25519 according to EIP 1024\n   * @param path a path in BIP 32 format\n   * @param remotePublicKeyHex remote Curve25519 public key\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a shared secret\n   * @example\n   * eth.getEIP1024SharedSecret(\"44'/60'/0'/0/0\", \"87020e80af6e07a6e4697f091eacadb9e7e6629cb7e5a8a371689a3ed53b3d64\").then(o => o.sharedSecret)\n   */\n  getEIP1024SharedSecret(\n    path: string,\n    remotePublicKeyHex: string,\n    boolDisplay?: boolean,\n  ): Promise<{\n    sharedSecret: string;\n  }> {\n    const paths = splitPath(path);\n    const remotePublicKey = hexBuffer(remotePublicKeyHex);\n    const buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    remotePublicKey.copy(buffer, offset);\n    return this.transport\n      .send(0xe0, 0x18, boolDisplay ? 0x01 : 0x00, 0x01, buffer)\n      .then(response => {\n        return {\n          sharedSecret: response.slice(0, -2).toString(\"hex\"),\n        };\n      });\n  }\n\n  /**\n   * provides a trusted description of an ERC 20 token to associate a contract address with a ticker and number of decimals.\n   *\n   * @param data stringified buffer of ERC20 signature\n   * @returns a boolean\n   */\n  provideERC20TokenInformation(data: string): Promise<boolean> {\n    const buffer = Buffer.from(data, \"hex\");\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, buffer).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      },\n    );\n  }\n\n  /**\n   * provides the name of a trusted binding of a plugin with a contract address and a supported method selector. This plugin will be called to interpret contract data in the following transaction signing command.\n   *\n   * @param payload external plugin data\n   * @option signature optionally signature for the plugin\n   * @returns a boolean\n   */\n  setExternalPlugin(payload: string, signature?: string): Promise<boolean> {\n    const payloadBuffer = Buffer.from(payload, \"hex\");\n    const signatureBuffer = Buffer.from(signature ?? \"\", \"hex\");\n    const buffer = Buffer.concat([payloadBuffer, signatureBuffer]);\n    return this.transport.send(0xe0, 0x12, 0x00, 0x00, buffer).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6a80) {\n          // this case happen when the plugin name is too short or too long\n          return false;\n        } else if (e && e.statusCode === 0x6984) {\n          // this case happen when the plugin requested is not installed on the device\n          return false;\n        } else if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app\n          return false;\n        }\n        throw e;\n      },\n    );\n  }\n\n  /**\n   * provides the name of a trusted binding of a plugin with a contract address and a supported method selector. This plugin will be called to interpret contract data in the following transaction signing command.\n   *\n   * @param data stringified buffer of plugin signature\n   * @returns a boolean\n   */\n  setPlugin(data: string): Promise<boolean> {\n    const buffer = Buffer.from(data, \"hex\");\n    return this.transport.send(0xe0, 0x16, 0x00, 0x00, buffer).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6a80) {\n          // this case happen when the plugin name is too short or too long\n          return false;\n        } else if (e && e.statusCode === 0x6984) {\n          // this case happen when the plugin requested is not installed on the device\n          return false;\n        } else if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app\n          return false;\n        }\n        throw e;\n      },\n    );\n  }\n\n  /**\n   *  provides a trusted description of an NFT to associate a contract address with a collectionName.\n   *\n   * @param data stringified buffer of the NFT description\n   * @returns a boolean\n   */\n  provideNFTInformation(data: string): Promise<boolean> {\n    const buffer = Buffer.from(data, \"hex\");\n    return this.transport.send(0xe0, 0x14, 0x00, 0x00, buffer).then(\n      () => true,\n      e => {\n        if (e && e.statusCode === 0x6d00) {\n          // older version of ETH app => error because we don't allow blind sign when NFT is explicitly requested to be resolved.\n          throw new EthAppNftNotSupported();\n        }\n        throw e;\n      },\n    );\n  }\n\n  /**\n   * provides a domain name (like ENS) to be displayed during transactions in place of the address it is associated to. It shall be run just before a transaction involving the associated address that would be displayed on the device.\n   *\n   * @param data an stringied buffer of some TLV encoded data to represent the domain\n   * @returns a boolean\n   */\n  async provideDomainName(data: string): Promise<boolean> {\n    enum APDU_FIELDS {\n      CLA = 0xe0,\n      INS = 0x22,\n      P1_FIRST_CHUNK = 0x01,\n      P1_FOLLOWING_CHUNK = 0x00,\n      P2 = 0x00,\n    }\n    const buffer = Buffer.from(data, \"hex\");\n    const payload = Buffer.concat([Buffer.from(intAsHexBytes(buffer.length, 2), \"hex\"), buffer]);\n\n    const bufferChunks = new Array(Math.ceil(payload.length / 256))\n      .fill(null)\n      .map((_, i) => payload.slice(i * 255, (i + 1) * 255));\n    for (const chunk of bufferChunks) {\n      const isFirstChunk = chunk === bufferChunks[0];\n      await this.transport.send(\n        APDU_FIELDS.CLA,\n        APDU_FIELDS.INS,\n        isFirstChunk ? APDU_FIELDS.P1_FIRST_CHUNK : APDU_FIELDS.P1_FOLLOWING_CHUNK,\n        APDU_FIELDS.P2,\n        chunk,\n      );\n    }\n\n    return true;\n  }\n}\n","export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\troot.CryptoJS = factory();\n\t}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native crypto in web worker (Browser)\n\t    if (typeof self !== 'undefined' && self.crypto) {\n\t        crypto = self.crypto;\n\t    }\n\n\t    // Native crypto from worker\n\t    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n\t        crypto = globalThis.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && typeof require === 'function') {\n\t        try {\n\t            crypto = require('crypto');\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }());\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var j = 0; j < thatSigBytes; j += 4) {\n\t                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));",";(function (root, factory, undef) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"), require(\"./sha256\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\", \"./sha256\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var SHA256 = C_algo.SHA256;\n\n\t    /**\n\t     * SHA-224 hash algorithm.\n\t     */\n\t    var SHA224 = C_algo.SHA224 = SHA256.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n\t                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n\t            ]);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var hash = SHA256._doFinalize.call(this);\n\n\t            hash.sigBytes -= 4;\n\n\t            return hash;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA224('message');\n\t     *     var hash = CryptoJS.SHA224(wordArray);\n\t     */\n\t    C.SHA224 = SHA256._createHelper(SHA224);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA224(message, key);\n\t     */\n\t    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);\n\t}());\n\n\n\treturn CryptoJS.SHA224;\n\n}));",";(function (root, factory) {\n\tif (typeof exports === \"object\") {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(require(\"./core\"));\n\t}\n\telse if (typeof define === \"function\" && define.amd) {\n\t\t// AMD\n\t\tdefine([\"./core\"], factory);\n\t}\n\telse {\n\t\t// Global (browser)\n\t\tfactory(root.CryptoJS);\n\t}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));","/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA3_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n  var PADDING = [6, 1536, 393216, 100663296];\n  var SHIFT = [0, 8, 16, 24];\n  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\n    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\n    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\n    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\n    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n  var BITS = [224, 256, 384, 512];\n  var SHAKE_BITS = [128, 256];\n  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n  var CSHAKE_BYTEPAD = {\n    '128': 168,\n    '256': 136\n  };\n\n  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (bits, padding, outputType) {\n    return function (message) {\n      return new Keccak(bits, padding, bits).update(message)[outputType]();\n    };\n  };\n\n  var createShakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits) {\n      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n    };\n  };\n\n  var createCshakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits, n, s) {\n      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n    };\n  };\n\n  var createKmacOutputMethod = function (bits, padding, outputType) {\n    return function (key, message, outputBits, s) {\n      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n    };\n  };\n\n  var createOutputMethods = function (method, createMethod, bits, padding) {\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createMethod(bits, padding, type);\n    }\n    return method;\n  };\n\n  var createMethod = function (bits, padding) {\n    var method = createOutputMethod(bits, padding, 'hex');\n    method.create = function () {\n      return new Keccak(bits, padding, bits);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    return createOutputMethods(method, createOutputMethod, bits, padding);\n  };\n\n  var createShakeMethod = function (bits, padding) {\n    var method = createShakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits) {\n      return new Keccak(bits, padding, outputBits);\n    };\n    method.update = function (message, outputBits) {\n      return method.create(outputBits).update(message);\n    };\n    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n  };\n\n  var createCshakeMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createCshakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits, n, s) {\n      if (!n && !s) {\n        return methods['shake' + bits].create(outputBits);\n      } else {\n        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n      }\n    };\n    method.update = function (message, outputBits, n, s) {\n      return method.create(outputBits, n, s).update(message);\n    };\n    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n  };\n\n  var createKmacMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createKmacOutputMethod(bits, padding, 'hex');\n    method.create = function (key, outputBits, s) {\n      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n    };\n    method.update = function (key, message, outputBits, s) {\n      return method.create(key, outputBits, s).update(message);\n    };\n    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n  };\n\n  var algorithms = [\n    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n  ];\n\n  var methods = {}, methodNames = [];\n\n  for (var i = 0; i < algorithms.length; ++i) {\n    var algorithm = algorithms[i];\n    var bits = algorithm.bits;\n    for (var j = 0; j < bits.length; ++j) {\n      var methodName = algorithm.name + '_' + bits[j];\n      methodNames.push(methodName);\n      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n      if (algorithm.name !== 'sha3') {\n        var newMethodName = algorithm.name + bits[j];\n        methodNames.push(newMethodName);\n        methods[newMethodName] = methods[methodName];\n      }\n    }\n  }\n\n  function Keccak(bits, padding, outputBits) {\n    this.blocks = [];\n    this.s = [];\n    this.padding = padding;\n    this.outputBits = outputBits;\n    this.reset = true;\n    this.finalized = false;\n    this.block = 0;\n    this.start = 0;\n    this.blockCount = (1600 - (bits << 1)) >> 5;\n    this.byteCount = this.blockCount << 2;\n    this.outputBlocks = outputBits >> 5;\n    this.extraBytes = (outputBits & 31) >> 3;\n\n    for (var i = 0; i < 50; ++i) {\n      this.s[i] = 0;\n    }\n  }\n\n  Keccak.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,\n      blockCount = this.blockCount, index = 0, s = this.s, i, code;\n\n    while (index < length) {\n      if (this.reset) {\n        this.reset = false;\n        blocks[0] = this.block;\n        for (i = 1; i < blockCount + 1; ++i) {\n          blocks[i] = 0;\n        }\n      }\n      if (notString) {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      if (i >= byteCount) {\n        this.start = i - byteCount;\n        this.block = blocks[blockCount];\n        for (i = 0; i < blockCount; ++i) {\n          s[i] ^= blocks[i];\n        }\n        f(s);\n        this.reset = true;\n      } else {\n        this.start = i;\n      }\n    }\n    return this;\n  };\n\n  Keccak.prototype.encode = function (x, right) {\n    var o = x & 255, n = 1;\n    var bytes = [o];\n    x = x >> 8;\n    o = x & 255;\n    while (o > 0) {\n      bytes.unshift(o);\n      x = x >> 8;\n      o = x & 255;\n      ++n;\n    }\n    if (right) {\n      bytes.push(n);\n    } else {\n      bytes.unshift(n);\n    }\n    this.update(bytes);\n    return bytes.length;\n  };\n\n  Keccak.prototype.encodeString = function (str) {\n    var notString, type = typeof str;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (str === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n          str = new Uint8Array(str);\n        } else if (!Array.isArray(str)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var bytes = 0, length = str.length;\n    if (notString) {\n      bytes = length;\n    } else {\n      for (var i = 0; i < str.length; ++i) {\n        var code = str.charCodeAt(i);\n        if (code < 0x80) {\n          bytes += 1;\n        } else if (code < 0x800) {\n          bytes += 2;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes += 3;\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));\n          bytes += 4;\n        }\n      }\n    }\n    bytes += this.encode(bytes * 8);\n    this.update(str);\n    return bytes;\n  };\n\n  Keccak.prototype.bytepad = function (strs, w) {\n    var bytes = this.encode(w);\n    for (var i = 0; i < strs.length; ++i) {\n      bytes += this.encodeString(strs[i]);\n    }\n    var paddingBytes = w - bytes % w;\n    var zeros = [];\n    zeros.length = paddingBytes;\n    this.update(zeros);\n    return this;\n  };\n\n  Keccak.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n    blocks[i >> 2] |= this.padding[i & 3];\n    if (this.lastByteIndex === this.byteCount) {\n      blocks[0] = blocks[blockCount];\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n    blocks[blockCount - 1] |= 0x80000000;\n    for (i = 0; i < blockCount; ++i) {\n      s[i] ^= blocks[i];\n    }\n    f(s);\n  };\n\n  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var hex = '', block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        block = s[i];\n        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\n          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\n          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\n          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n        i = 0;\n      }\n    }\n    if (extraBytes) {\n      block = s[i];\n      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\n      if (extraBytes > 1) {\n        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\n      }\n      if (extraBytes > 2) {\n        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\n      }\n    }\n    return hex;\n  };\n\n  Keccak.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var bytes = this.outputBits >> 3;\n    var buffer;\n    if (extraBytes) {\n      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\n    } else {\n      buffer = new ArrayBuffer(bytes);\n    }\n    var array = new Uint32Array(buffer);\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        array[j] = s[i];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      array[i] = s[i];\n      buffer = buffer.slice(0, bytes);\n    }\n    return buffer;\n  };\n\n  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n  Keccak.prototype.digest = Keccak.prototype.array = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var array = [], offset, block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        offset = j << 2;\n        block = s[i];\n        array[offset] = block & 0xFF;\n        array[offset + 1] = (block >> 8) & 0xFF;\n        array[offset + 2] = (block >> 16) & 0xFF;\n        array[offset + 3] = (block >> 24) & 0xFF;\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      offset = j << 2;\n      block = s[i];\n      array[offset] = block & 0xFF;\n      if (extraBytes > 1) {\n        array[offset + 1] = (block >> 8) & 0xFF;\n      }\n      if (extraBytes > 2) {\n        array[offset + 2] = (block >> 16) & 0xFF;\n      }\n    }\n    return array;\n  };\n\n  function Kmac(bits, padding, outputBits) {\n    Keccak.call(this, bits, padding, outputBits);\n  }\n\n  Kmac.prototype = new Keccak();\n\n  Kmac.prototype.finalize = function () {\n    this.encode(this.outputBits, true);\n    return Keccak.prototype.finalize.call(this);\n  };\n\n  var f = function (s) {\n    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\n      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\n      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n    for (n = 0; n < 48; n += 2) {\n      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\n      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\n      s[0] ^= h;\n      s[1] ^= l;\n      s[10] ^= h;\n      s[11] ^= l;\n      s[20] ^= h;\n      s[21] ^= l;\n      s[30] ^= h;\n      s[31] ^= l;\n      s[40] ^= h;\n      s[41] ^= l;\n      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\n      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\n      s[2] ^= h;\n      s[3] ^= l;\n      s[12] ^= h;\n      s[13] ^= l;\n      s[22] ^= h;\n      s[23] ^= l;\n      s[32] ^= h;\n      s[33] ^= l;\n      s[42] ^= h;\n      s[43] ^= l;\n      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\n      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\n      s[4] ^= h;\n      s[5] ^= l;\n      s[14] ^= h;\n      s[15] ^= l;\n      s[24] ^= h;\n      s[25] ^= l;\n      s[34] ^= h;\n      s[35] ^= l;\n      s[44] ^= h;\n      s[45] ^= l;\n      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\n      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\n      s[6] ^= h;\n      s[7] ^= l;\n      s[16] ^= h;\n      s[17] ^= l;\n      s[26] ^= h;\n      s[27] ^= l;\n      s[36] ^= h;\n      s[37] ^= l;\n      s[46] ^= h;\n      s[47] ^= l;\n      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\n      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\n      s[8] ^= h;\n      s[9] ^= l;\n      s[18] ^= h;\n      s[19] ^= l;\n      s[28] ^= h;\n      s[29] ^= l;\n      s[38] ^= h;\n      s[39] ^= l;\n      s[48] ^= h;\n      s[49] ^= l;\n\n      b0 = s[0];\n      b1 = s[1];\n      b32 = (s[11] << 4) | (s[10] >>> 28);\n      b33 = (s[10] << 4) | (s[11] >>> 28);\n      b14 = (s[20] << 3) | (s[21] >>> 29);\n      b15 = (s[21] << 3) | (s[20] >>> 29);\n      b46 = (s[31] << 9) | (s[30] >>> 23);\n      b47 = (s[30] << 9) | (s[31] >>> 23);\n      b28 = (s[40] << 18) | (s[41] >>> 14);\n      b29 = (s[41] << 18) | (s[40] >>> 14);\n      b20 = (s[2] << 1) | (s[3] >>> 31);\n      b21 = (s[3] << 1) | (s[2] >>> 31);\n      b2 = (s[13] << 12) | (s[12] >>> 20);\n      b3 = (s[12] << 12) | (s[13] >>> 20);\n      b34 = (s[22] << 10) | (s[23] >>> 22);\n      b35 = (s[23] << 10) | (s[22] >>> 22);\n      b16 = (s[33] << 13) | (s[32] >>> 19);\n      b17 = (s[32] << 13) | (s[33] >>> 19);\n      b48 = (s[42] << 2) | (s[43] >>> 30);\n      b49 = (s[43] << 2) | (s[42] >>> 30);\n      b40 = (s[5] << 30) | (s[4] >>> 2);\n      b41 = (s[4] << 30) | (s[5] >>> 2);\n      b22 = (s[14] << 6) | (s[15] >>> 26);\n      b23 = (s[15] << 6) | (s[14] >>> 26);\n      b4 = (s[25] << 11) | (s[24] >>> 21);\n      b5 = (s[24] << 11) | (s[25] >>> 21);\n      b36 = (s[34] << 15) | (s[35] >>> 17);\n      b37 = (s[35] << 15) | (s[34] >>> 17);\n      b18 = (s[45] << 29) | (s[44] >>> 3);\n      b19 = (s[44] << 29) | (s[45] >>> 3);\n      b10 = (s[6] << 28) | (s[7] >>> 4);\n      b11 = (s[7] << 28) | (s[6] >>> 4);\n      b42 = (s[17] << 23) | (s[16] >>> 9);\n      b43 = (s[16] << 23) | (s[17] >>> 9);\n      b24 = (s[26] << 25) | (s[27] >>> 7);\n      b25 = (s[27] << 25) | (s[26] >>> 7);\n      b6 = (s[36] << 21) | (s[37] >>> 11);\n      b7 = (s[37] << 21) | (s[36] >>> 11);\n      b38 = (s[47] << 24) | (s[46] >>> 8);\n      b39 = (s[46] << 24) | (s[47] >>> 8);\n      b30 = (s[8] << 27) | (s[9] >>> 5);\n      b31 = (s[9] << 27) | (s[8] >>> 5);\n      b12 = (s[18] << 20) | (s[19] >>> 12);\n      b13 = (s[19] << 20) | (s[18] >>> 12);\n      b44 = (s[29] << 7) | (s[28] >>> 25);\n      b45 = (s[28] << 7) | (s[29] >>> 25);\n      b26 = (s[38] << 8) | (s[39] >>> 24);\n      b27 = (s[39] << 8) | (s[38] >>> 24);\n      b8 = (s[48] << 14) | (s[49] >>> 18);\n      b9 = (s[49] << 14) | (s[48] >>> 18);\n\n      s[0] = b0 ^ (~b2 & b4);\n      s[1] = b1 ^ (~b3 & b5);\n      s[10] = b10 ^ (~b12 & b14);\n      s[11] = b11 ^ (~b13 & b15);\n      s[20] = b20 ^ (~b22 & b24);\n      s[21] = b21 ^ (~b23 & b25);\n      s[30] = b30 ^ (~b32 & b34);\n      s[31] = b31 ^ (~b33 & b35);\n      s[40] = b40 ^ (~b42 & b44);\n      s[41] = b41 ^ (~b43 & b45);\n      s[2] = b2 ^ (~b4 & b6);\n      s[3] = b3 ^ (~b5 & b7);\n      s[12] = b12 ^ (~b14 & b16);\n      s[13] = b13 ^ (~b15 & b17);\n      s[22] = b22 ^ (~b24 & b26);\n      s[23] = b23 ^ (~b25 & b27);\n      s[32] = b32 ^ (~b34 & b36);\n      s[33] = b33 ^ (~b35 & b37);\n      s[42] = b42 ^ (~b44 & b46);\n      s[43] = b43 ^ (~b45 & b47);\n      s[4] = b4 ^ (~b6 & b8);\n      s[5] = b5 ^ (~b7 & b9);\n      s[14] = b14 ^ (~b16 & b18);\n      s[15] = b15 ^ (~b17 & b19);\n      s[24] = b24 ^ (~b26 & b28);\n      s[25] = b25 ^ (~b27 & b29);\n      s[34] = b34 ^ (~b36 & b38);\n      s[35] = b35 ^ (~b37 & b39);\n      s[44] = b44 ^ (~b46 & b48);\n      s[45] = b45 ^ (~b47 & b49);\n      s[6] = b6 ^ (~b8 & b0);\n      s[7] = b7 ^ (~b9 & b1);\n      s[16] = b16 ^ (~b18 & b10);\n      s[17] = b17 ^ (~b19 & b11);\n      s[26] = b26 ^ (~b28 & b20);\n      s[27] = b27 ^ (~b29 & b21);\n      s[36] = b36 ^ (~b38 & b30);\n      s[37] = b37 ^ (~b39 & b31);\n      s[46] = b46 ^ (~b48 & b40);\n      s[47] = b47 ^ (~b49 & b41);\n      s[8] = b8 ^ (~b0 & b2);\n      s[9] = b9 ^ (~b1 & b3);\n      s[18] = b18 ^ (~b10 & b12);\n      s[19] = b19 ^ (~b11 & b13);\n      s[28] = b28 ^ (~b20 & b22);\n      s[29] = b29 ^ (~b21 & b23);\n      s[38] = b38 ^ (~b30 & b32);\n      s[39] = b39 ^ (~b31 & b33);\n      s[48] = b48 ^ (~b40 & b42);\n      s[49] = b49 ^ (~b41 & b43);\n\n      s[0] ^= RC[n];\n      s[1] ^= RC[n + 1];\n    }\n  };\n\n  if (COMMON_JS) {\n    module.exports = methods;\n  } else {\n    for (i = 0; i < methodNames.length; ++i) {\n      root[methodNames[i]] = methods[methodNames[i]];\n    }\n    if (AMD) {\n      define(function () {\n        return methods;\n      });\n    }\n  }\n})();\n"],"names":["ERC20_CLEAR_SIGNED_SELECTORS","ERC721_CLEAR_SIGNED_SELECTORS","ERC1155_CLEAR_SIGNED_SELECTORS","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","error","off","_logLevel","_globalLogger","_normalizeError","missing","forEach","form","normalize","Error","push","length","join","String","fromCharCode","message","_checkNormalize","LogLevel","ErrorCode","HEX","Logger","constructor","version","Object","defineProperty","this","enumerable","value","writable","_log","logLevel","args","level","toLowerCase","throwArgumentError","console","log","apply","levels","DEBUG","INFO","warn","WARNING","makeError","code","params","errors","UNKNOWN_ERROR","messageDetails","keys","key","Uint8Array","hex","i","JSON","stringify","toString","reason","url","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","throwError","name","INVALID_ARGUMENT","argument","assert","condition","assertArgument","checkNormalize","UNSUPPORTED_OPERATION","operation","checkSafeUint53","checkArgumentCount","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","checkNew","target","kind","checkAbstract","globalLogger","setCensorship","censorship","permanent","setLogLevel","from","logger","isHexable","toHexString","addSlice","array","slice","Array","prototype","call","arguments","isBytesLike","isHexString","isBytes","isInteger","v","arrayify","options","result","unshift","parseInt","allowMissingPrefix","substring","hexPad","concat","items","objects","map","item","reduce","accum","offset","object","set","match","HexCharacters","hexlify","Math","floor","hexZeroPad","arrayifyInteger","unarrayifyInteger","data","_encode","isArray","payload","child","encode","_decodeChildren","childOffset","decoded","_decode","consumed","BUFFER_OVERRUN","lengthLength","decode","bytes","padHexString","str","splitPath","path","split","element","number","isNaN","hexBuffer","strWithoutPrefix","startsWith","Buffer","maybeHexBuffer","decodeTxInfo","rawTx","txType","includes","rlpData","rlpTx","chainIdTruncated","rlpDecoded","decodedTx","to","chainId","chainIdSrc","BigNumber","chainIdTruncatedBuf","alloc","copy","readUInt32BE","vrsOffset","rlpVrs","intAsHexBytes","int","padStart","tokenSelectors","values","nftSelectors","mergeResolutions","resolutionsArray","mergedResolutions","nfts","erc20Tokens","externalPlugin","plugin","domains","resolutions","BN","_BN","_constructorGuard","MAX_SAFE","_warnedToStringRadix","constructorGuard","_hex","_isBigNumber","freeze","fromTwos","toBigNumber","toBN","toTwos","abs","add","other","sub","div","isZero","throwFault","mul","mod","isNeg","umod","pow","and","isNegative","or","xor","mask","maskn","shl","shln","shr","shrn","eq","lt","lte","gt","gte","toNumber","toBigInt","BigInt","e","toJSON","type","toHex","anyValue","isBigNumber","keccak256","sha3","getChecksumAddress","address","chars","expanded","charCodeAt","hashed","toUpperCase","ibanLookup","safeDigits","x","log10","LN10","ibanChecksum","c","block","checksum","getAddress","UnicodeNormalizationForm","Utf8ErrorReason","ignoreFunc","output","badCodepoint","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","Utf8ErrorFuncs","ignore","replace","OVERLONG","getUtf8CodePoints","onError","extraLength","overlongMask","res","j","nextChar","MISSING_CONTINUE","OUT_OF_RANGE","UTF16_SURROGATE","toUtf8Bytes","current","c2","pair","toUtf8String","codePoint","id","text","defineReadOnly","getStatic","ctor","getPrototypeOf","opaque","bigint","boolean","string","_isFrozen","undefined","isFrozen","_deepCopy","deepCopy","Description","Coder","localName","dynamic","_throwError","Writer","wordSize","_data","_dataLength","_padding","hexConcat","_writeData","appendWriter","writer","writeBytes","paddingOffset","_getValue","writeValue","writeUpdatableValue","Reader","coerceFunc","allowLoose","_offset","coerce","_coerceFunc","_peekBytes","loose","alignedLength","ceil","subReader","readBytes","readValue","AddressCoder","super","defaultValue","reader","AnonymousCoder","coder","pack","coders","arrayValues","unique","staticWriter","dynamicWriter","updateFuncs","index","dynamicOffset","updateFunc","baseOffset","func","unpack","baseReader","offsetReader","baseType","uniqueNames","get","ArrayCoder","defaultChild","BooleanCoder","DynamicBytesCoder","BytesCoder","FixedBytesCoder","size","NullCoder","NegativeOne","Zero","One","MaxUint256","NumberCoder","signed","maxUintValue","bounds","StringCoder","TupleCoder","types","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","indexOf","populate","FormatTypes","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","arrayLength","arrayChildren","fromObject","components","_isParamType","format","indexed","comp","parse","allowIndexed","fromString","isParamType","verifyType","node","param","originalParam","newNode","parent","state","allowType","allowParams","allowName","allowArray","sibling","readArray","parseParamType","parseParams","allowIndex","trim","depth","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","modifier","parseGas","gas","comps","parseModifiers","constant","payable","stateMutability","verifyState","isConstructorFragment","parens","outputs","isFunctionFragment","returns","checkForbidden","fragment","sig","isErrorFragment","regexIdentifier","paramTypeBytes","paramTypeNumber","defaultAbiCoder","_getCoder","component","_getWordSize","_getReader","_getWriter","getDefaultValue","LogDescription","TransactionDescription","ErrorDescription","Indexed","isIndexed","_isIndexed","BuiltinErrors","signature","wrapAccessError","property","wrap","Interface","fragments","abi","filter","bucket","deploy","functions","events","getAbiCoder","getSighash","endOffset","getEventTopic","eventFragment","getFunction","nameOrSignatureOrSighash","matching","f","getEvent","nameOrSignatureOrTopic","topichash","getError","_","_decodeParams","_abiCoder","_encodeParams","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","functionFragment","encodeFunctionData","decodeFunctionResult","errorArgs","errorName","errorSignature","selector","builtin","method","encodeFunctionResult","encodeFilterTopics","topics","encodeTopic","pop","encodeEventLog","dataTypes","dataValues","decodeEventLog","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","hash","parseTransaction","tx","parseLog","topic","parseError","hexData","errorFragment","isInterface","_isInterface","REGISTRIES","resolvers","forward","reverse","signatures","patterns","coinTypes","getRegistries","__awaiter","defaultLoadConfig","nftExplorerBaseURL","pluginBaseURL","extraPlugins","cryptoassetsBaseURL","getLoadConfig","userLoadConfig","assign","asContractAddress","addr","a","erc20SignaturesBlob","buf","entries","tickerLength","readUInt8","ticker","contractAddress","decimals","entry","list","byContractAndChainId","cache","signatureBlob","signaturesByChainId","api","getAdditionalDataForContract","loadConfig","shouldResolve","resolution","nft","nftInfo","getNFTInfo","response","axios","then","r","catch","collectionNameLength","collectionName","_a","substr","acc","curr","token","erc20Info","byContractAddressAndChainId","contract","_b","findERC20SignaturesInfo","loadNanoAppPlugins","nftPluginPayload","loadNftPlugin","externalPlugins","contractMethodInfos","loadInfosForContractMethod","lcSelector","lcContractAddress","contractSelectors","erc20OfInterest","erc20ContractAddress","seg","externalPluginResolution","resolveTransaction","rawTxHex","resolutionConfig","erc20","pluginsResolution","contractResolution","domainResolutions","signDomainResolution","domain","registryName","challenge","lengthIsValid","Number","containsOnlyValidChars","test","validateDomain","registry","find","request","status","signAddressResolution","domainResolutionFlow","appBinding","domainDescriptor","getChallenge","domainAPDU","ledgerService","provideDomainName","EthAppPleaseEnableContractData","createCustomErrorClass","EthAppNftNotSupported","isFunction","createErrorClass","createImpl","ctorFunc","instance","stack","create","UnsubscriptionError","_super","err","arrRemove","arr","splice","Subscription","initialTeardown","closed","_parentage","_finalizers","unsubscribe","_parentage_1","__values","_parentage_1_1","next","done","remove","initialFinalizer","_finalizers_1","_finalizers_1_1","finalizer","execFinalizer","__spreadArray","__read","teardown","_hasParent","_addParent","_removeParent","EMPTY","empty","EMPTY_SUBSCRIPTION","isSubscription","config","onUnhandledError","onStoppedNotification","Promise","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","timeoutProvider","setTimeout","handler","timeout","_i","delegate","clearTimeout","handle","noop","COMPLETE_NOTIFICATION","createNotification","context","errorContext","cb","isRoot","errorThrown","Subscriber","destination","_this","isStopped","EMPTY_OBSERVER","__extends","complete","SafeSubscriber","handleStoppedNotification","nextNotification","_next","_error","_complete","_bind","Function","bind","fn","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context_1","reportUnhandledError","notification","subscriber","observable","Symbol","identity","pipeFromArray","fns","prev","Observable","subscribe","_subscribe","lift","operator","source","isObserver","_trySubscribe","sink","promiseCtor","getPromiseCtor","resolve","reject","Symbol_observable","pipe","operations","toPromise","ObjectUnsubscribedError","Subject","currentObservers","observers","hasError","thrownError","subject","AnonymousSubject","_throwIfClosed","_c","shift","_checkFinalizedStatuses","_innerSubscribe","asObservable","intParser","floatParser","parseFloat","boolParser","stringParser","stringArrayParser","v_array","envDefinitions","ADDRESS_POISONING_FAMILIES","def","parser","desc","ANALYTICS_CONSOLE","DEBUG_THEME","API_ICP_ENDPOINT","API_CASPER_INDEXER_ENDPOINT","API_CASPER_NODE_ENDPOINT","API_ALGORAND_BLOCKCHAIN_EXPLORER_API_ENDPOINT","API_CELO_INDEXER","API_CELO_NODE","COSMOS_GAS_AMPLIFIER","API_FILECOIN_ENDPOINT","API_STACKS_ENDPOINT","API_POLKADOT_INDEXER","API_POLKADOT_SIDECAR","API_POLKADOT_SIDECAR_CREDENTIALS","API_POLKADOT_NODE","ELROND_API_ENDPOINT","ELROND_DELEGATION_API_ENDPOINT","API_STELLAR_HORIZON","API_STELLAR_HORIZON_FETCH_LIMIT","API_STELLAR_HORIZON_STATIC_FEE","API_TEZOS_BAKER","API_TEZOS_BLOCKCHAIN_EXPLORER_API_ENDPOINT","API_TEZOS_TZKT_API","API_TEZOS_NODE","API_TRONGRID_PROXY","API_SOLANA_PROXY","SOLANA_VALIDATORS_APP_BASE_URL","SOLANA_TESTNET_VALIDATORS_APP_BASE_URL","SOLANA_TX_CONFIRMATION_TIMEOUT","API_HEDERA_MIRROR","API_VECHAIN_THOREST","BASE_SOCKET_URL","BOT_TIMEOUT_SCAN_ACCOUNTS","BOT_SPEC_DEFAULT_TIMEOUT","BUY_API_BASE","CARDANO_API_ENDPOINT","CARDANO_TESTNET_API_ENDPOINT","ICON_NODE_ENDPOINT","ICON_DEBUG_ENDPOINT","ICON_INDEXER_ENDPOINT","ICON_TESTNET_NODE_ENDPOINT","ICON_TESTNET_DEBUG_ENDPOINT","ICON_TESTNET_INDEXER_ENDPOINT","COINAPPS","CRYPTO_ORG_INDEXER","CRYPTO_ORG_TESTNET_INDEXER","CRYPTO_ORG_RPC_URL","CRYPTO_ORG_TESTNET_RPC_URL","DEBUG_UTXO_DISPLAY","DEBUG_HTTP_RESPONSE","DEVICE_CANCEL_APDU_FLUSH_MECHANISM","DEVICE_PROXY_URL","DEVICE_PROXY_MODEL","DISABLE_TRANSACTION_BROADCAST","DISABLE_SYNC_TOKEN","DISABLE_FW_UPDATE_VERSION_CHECK","EIP1559_MINIMUM_FEES_GATE","EIP1559_PRIORITY_FEE_LOWER_GATE","EIP1559_BASE_FEE_MULTIPLIER","EXPERIMENTAL_BLE","EXPERIMENTAL_CURRENCIES","EXPERIMENTAL_EXPLORERS","EXPERIMENTAL_LANGUAGES","EXPERIMENTAL_MANAGER","EXPERIMENTAL_ROI_CALCULATION","EXPERIMENTAL_SEND_MAX","EXPERIMENTAL_USB","EXPERIMENTAL_SWAP","EXPLORER","EXPLORER_STAGING","EXPLORER_BETA","EXPLORER_SATSTACK","EXPORT_EXCLUDED_LOG_TYPES","EXPORT_MAX_LOGS","DISABLE_APP_VERSION_REQUIREMENTS","FORCE_PROVIDER","FILTER_ZERO_AMOUNT_ERC20_EVENTS","GET_CALLS_RETRY","GET_CALLS_TIMEOUT","HIDE_EMPTY_TOKEN_ACCOUNTS","KEYCHAIN_OBSERVABLE_RANGE","LEDGER_CLIENT_VERSION","LEDGER_COUNTERVALUES_API","LEDGER_REST_API_BASE","LEGACY_KT_SUPPORT_TO_YOUR_OWN_RISK","MANAGER_API_BASE","MANAGER_DEV_MODE","MANAGER_INSTALL_DELAY","MAPPING_SERVICE","MAX_ACCOUNT_NAME_SIZE","MOCK","MOCK_COUNTERVALUES","MOCK_EXCHANGE_TEST_CONFIG","MOCK_REMOTE_LIVE_MANIFEST","MOCK_OS_VERSION","MOCK_NO_BYPASS","NFT_CURRENCIES","NFT_ETH_METADATA_SERVICE","OPERATION_ADDRESSES_LIMIT","OPERATION_OPTIMISTIC_RETENTION","OPERATION_PAGE_SIZE_INITIAL","POLKADOT_ELECTION_STATUS_THRESHOLD","SATSTACK","SCAN_FOR_INVALID_PATHS","SEED","SHOW_LEGACY_NEW_ACCOUNT","SIMPLE_HASH_API_BASE","SKIP_ONBOARDING","SPECULOS_API_PORT","SPECULOS_PID_OFFSET","SPECULOS_USE_WEBSOCKET","SWAP_API_BASE","SWAP_USER_IP","SYNC_ALL_INTERVAL","SYNC_BOOT_DELAY","SYNC_PENDING_INTERVAL","SYNC_OUTDATED_CONSIDERED_DELAY","SYNC_MAX_CONCURRENT","BOT_MAX_CONCURRENT","USER_ID","WALLETCONNECT","CLOUD_SYNC_API_STAGING","CLOUD_SYNC_API_PROD","WITH_DEVICE_POLLING_DELAY","ANNOUNCEMENTS_API_URL","ANNOUNCEMENTS_API_VERSION","STATUS_API_URL","STATUS_API_VERSION","TEZOS_MAX_TX_QUERIES","TRUSTCHAIN_API_STAGING","TRUSTCHAIN_API_PROD","PLATFORM_DEBUG","PLATFORM_EXPERIMENTAL_APPS","PLATFORM_MANIFEST_API_URL","PLATFORM_LOCAL_MANIFEST_JSON","PLATFORM_GLOBAL_CATALOG_API_URL","PLATFORM_GLOBAL_CATALOG_STAGING_API_URL","PLATFORM_RAMP_CATALOG_API_URL","PLATFORM_RAMP_CATALOG_STAGING_API_URL","PLATFORM_API_URL","PLATFORM_API_VERSION","PLAYWRIGHT_RUN","MARKET_API_URL","USE_LEARN_STAGING_URL","DYNAMIC_CAL_BASE_URL","CAL_SERVICE_URL","FEATURE_FLAGS","PERFORMANCE_CONSOLE","ETHEREUM_STUCK_TRANSACTION_TIMEOUT","EVM_REPLACE_TX_LEGACY_GASPRICE_FACTOR","EVM_REPLACE_TX_EIP1559_MAXFEE_FACTOR","EVM_REPLACE_TX_EIP1559_MAXPRIORITYFEE_FACTOR","ENABLE_NETWORK_LOGS","CRYPTO_ASSET_SEARCH_KEYS","VERBOSE","DEFAULT_TRANSACTION_POLLING_INTERVAL","LOW_BATTERY_PERCENTAGE","LOG_DRAWERS","defaults","sortObjectAlphabetically","obj","sort","field","getFiltersForMessage","shouldUseV1Filters","calServiceURL","schemaHash","sortedTypes","SHA224","getSchemaHashForMessage","verifyingContract","eip712_signatures_version","chain_id","contracts","filters","_f","_e","_d","eip712_signatures","messageId","_h","_g","EIP712CAL","EIP712CALV2","EIP712_ARRAY_TYPE_VALUE","EIP712_TYPE_PROPERTIES","CUSTOM","sizeInBits","INT","UINT","ADDRESS","BOOL","STRING","BYTES","EIP712_TYPE_ENCODERS","failSafeValue","valueAsBN","sizeInBytes","plus","paddedHexString","destructTypeFromString","typeName","splitNameAndArraysRegex","splitArraysRegex","splitNameAndNumberRegex","maybeArrays","exec","bits","matchAll","makeTypeEntryStructBuffer","typeDescription","arrSizes","isTypeAnArray","Boolean","typeProperties","typeKey","typeSizeInBits","typeDescData","constructTypeDescByteString","typeSize","typeValue","isArrayBit","hasTypeSize","typeValueBits","bufferArray","FIXED","DYNAMIC","sendStructDef","transport","structDef","APDU_FIELDS","structType","send","CLA","INS","P1_complete","P2_name","P2_field","sendStructImplem","structImplem","P2_root","P2_array","rawData","encodedData","dataLengthPer16Bits","dataLengthModulo16Bits","bufferSlices","fill","bufferSlice","P1_partial","sendFilteringInfo","P1","P2_activate","displayName","filtersCount","displayNameLengthBuffer","displayNameBuffer","filtersCountBuffer","sigLengthBuffer","sigBuffer","callData","P2_contract_name","P2_show_field","signEIP712Message","transport_1","path_1","jsonMessage_1","args_1","jsonMessage","fullImplem","primaryType","unsortedTypes","typeEntries","typeEntryBuffer","recursiveFieldStructImplem","makeRecursiveFieldStructImplem","typesMap","destructedType_1","data_1","destructedType","currSize","restSizes","isCustomType","fieldName","fieldValue","fieldType","fields","label","domainName","domainTypeFields","domainFieldValue","contractName","contractNameInfos","primaryTypeFields","primaryTypeValue","paths","signatureBuffer","writeUInt32BE","P2_v0","P2_full","s","starkQuantizationTypeMap","eth","erc721","erc20mintable","erc721mintable","remapTransactionRelatedErrors","statusCode","Eth","setLoadConfig","scrambleKey","decorateAppAPIMethods","boolDisplay","boolChaincode","buffer","chainIdBufferMask","chainIdBuffer","write","publicKeyLength","addressLength","publicKey","chainCode","signTransaction","setPlugin","setExternalPlugin","provideNFTInformation","provideERC20TokenInformation","first","maxChunkSize","chunkSize","response_byte","times","isGreaterThan","oneByteChainId","ecc_parity","clearSignTransaction","rawTxHex_1","resolutionConfig_1","throwOnError","getAppConfiguration","arbitraryDataEnabled","erc20ProvisioningNecessary","starkEnabled","starkv2Supported","signPersonalMessage","messageHex","signEIP712HashedMessage","domainSeparatorHex","hashStructMessageHex","domainSeparator","hashStruct","P2","fourBytesChallenge","starkGetPublicKey","starkSignOrder","sourceTokenAddress","sourceQuantization","destinationTokenAddress","destinationQuantization","sourceVault","destinationVault","amountSell","amountBuy","nonce","timestamp","sourceTokenAddressHex","destinationTokenAddressHex","starkSignOrder_v2","sourceQuantizationType","sourceMintableBlobOrTokenId","destinationQuantizationType","destinationMintableBlobOrTokenId","starkSignTransfer","transferTokenAddress","transferQuantization","targetPublicKey","amountTransfer","transferTokenAddressHex","targetPublicKeyHex","starkSignTransfer_v2","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferAddress","conditionalTransferFact","conditionalTransferAddressHex","starkProvideQuantum","operationContract","operationQuantization","operationContractHex","starkProvideQuantum_v2","operationQuantizationType","operationMintableBlobOrTokenId","starkUnsafeSign","hashHex","eth2GetPublicKey","eth2SetWithdrawalIndex","withdrawalIndex","getEIP1024PublicEncryptionKey","getEIP1024SharedSecret","remotePublicKeyHex","remotePublicKey","sharedSecret","payloadBuffer","bufferChunks","chunk","isFirstChunk","P1_FIRST_CHUNK","P1_FOLLOWING_CHUNK","subscribers","date","Date","dispatch","LocalTracer","trace","getContext","setContext","updateContext","contextToAdd","getType","setType","withType","withContext","withUpdatedContext","listen","window","__ledgerLogsListen","module","exports","CryptoJS","crypto","self","globalThis","msCrypto","global","require","cryptoSecureRandomInt","getRandomValues","Uint32Array","randomBytes","readInt32LE","F","subtype","C","C_lib","lib","Base","extend","overrides","mixIn","hasOwnProperty","init","$super","properties","propertyName","clone","WordArray","words","sigBytes","encoder","Hex","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","random","nBytes","C_enc","enc","hexChars","bite","hexStr","hexStrLength","Latin1","latin1Chars","latin1Str","latin1StrLength","Utf8","decodeURIComponent","escape","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","reset","_nDataBytes","_append","_process","doFlush","processedWords","dataWords","dataSigBytes","blockSize","nBlocksReady","nWordsReady","max","_minBufferSize","nBytesReady","min","_doProcessBlock","C_algo","Hasher","cfg","_doReset","update","messageUpdate","finalize","_doFinalize","_createHelper","hasher","_createHmacHelper","HMAC","algo","factory","SHA256","_hash","HmacSHA224","H","K","isPrime","n","sqrtN","sqrt","factor","getFractionalBits","nPrime","W","M","b","d","g","h","gamma0x","gamma0","gamma1x","gamma1","maj","sigma0","t1","nBitsTotal","nBitsLeft","HmacSHA256","INPUT_ERROR","WINDOW","root","JS_SHA3_NO_WINDOW","WEB_WORKER","JS_SHA3_NO_NODE_JS","process","versions","COMMON_JS","JS_SHA3_NO_COMMON_JS","AMD","define","ARRAY_BUFFER","JS_SHA3_NO_ARRAY_BUFFER","ArrayBuffer","HEX_CHARS","CSHAKE_PADDING","SHIFT","RC","BITS","SHAKE_BITS","OUTPUT_TYPES","CSHAKE_BYTEPAD","JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW","isView","createOutputMethod","padding","outputType","Keccak","createShakeOutputMethod","outputBits","createCshakeOutputMethod","methods","createKmacOutputMethod","createOutputMethods","createMethod","algorithms","w","bytepad","Kmac","methodNames","algorithm","methodName","newMethodName","blocks","finalized","start","blockCount","byteCount","outputBlocks","extraBytes","notString","lastByteIndex","right","encodeString","strs","paddingBytes","zeros","arrayBuffer","digest","l","c0","c1","c3","c4","c5","c6","c7","c8","c9","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","b10","b11","b12","b13","b14","b15","b16","b17","b18","b19","b20","b21","b22","b23","b24","b25","b26","b27","b28","b29","b30","b31","b32","b33","b34","b35","b36","b37","b38","b39","b40","b41","b42","b43","b44","b45","b46","b47","b48","b49"],"sourceRoot":""}