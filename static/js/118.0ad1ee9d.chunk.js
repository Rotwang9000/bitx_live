"use strict";(globalThis.webpackChunkwinbit32=globalThis.webpackChunkwinbit32||[]).push([[118],{82118:(i,t,e)=>{e.d(t,{getEVMSigner:()=>r});e(47489);var a=e(44244);async function r({chain:i,derivationPath:t,provider:r}){let{AbstractSigner:n}=await Promise.resolve().then(e.bind(e,32172));class s extends n{address;chain;derivationPath;provider;constructor({chain:i,derivationPath:t,provider:e}){super(e),this.address="",this.chain=i,this.derivationPath=t,this.provider=e}getAddress=async()=>{if(!this.address){let{default:i}=await Promise.all([e.e(789),e.e(572)]).then(e.t.bind(e,36572,19)),t=await i.ethereumGetAddress({path:(0,a.fi)(this.derivationPath),showOnTrezor:!0});if(!t.success)throw new a.Oo({errorKey:"wallet_trezor_failed_to_get_address",info:{...t,chain:this.chain,derivationPath:this.derivationPath}});this.address=t.payload.address}return this.address};signMessage=async i=>{let{default:t}=await Promise.all([e.e(789),e.e(572)]).then(e.t.bind(e,36572,19)),r=await t.ethereumSignMessage({path:(0,a.fi)(this.derivationPath),message:i});if(!r.success)throw new a.Oo({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...r,message:i,chain:this.chain,derivationPath:this.derivationPath}});return r.payload.signature};signTypedData(){throw new Error("Not implemented")}signTransaction=async({to:i,gasLimit:t,value:r,data:n,nonce:s,maxFeePerGas:o,maxPriorityFeePerGas:h,gasPrice:d})=>{if(!i)throw new a.Oo({errorKey:"wallet_missing_params",info:{to:i}});if(!t)throw new a.Oo({errorKey:"wallet_missing_params",info:{gasLimit:t}});let l=o&&h;if(l&&!o)throw new a.Oo({errorKey:"wallet_missing_params",info:{maxFeePerGas:o}});if(l&&!h)throw new a.Oo({errorKey:"wallet_missing_params",info:{maxPriorityFeePerGas:h}});if(!l&&!d)throw new a.Oo({errorKey:"wallet_missing_params",info:{gasPrice:d}});let{default:c}=await Promise.all([e.e(789),e.e(572)]).then(e.t.bind(e,36572,19)),{Transaction:g,toHexString:w}=await Promise.resolve().then(e.bind(e,32172)),P=l?{maxFeePerGas:w(BigInt(o?.toString()||0)),maxPriorityFeePerGas:w(BigInt(h?.toString()||0))}:d&&{gasPrice:w(BigInt(d?.toString()||0))}||{gasPrice:"0x0"},m={chainId:Number.parseInt(a.l6[this.chain]),to:i.toString(),frin:this.address,value:w(BigInt(r?.toString()||0)),gasLimit:w(BigInt(t?.toString()||0)),nonce:(s?.toString()||await this.provider.getTransactionCount(await this.getAddress(),"pending")).toString(),data:n?.toString()||"0x",...P},{success:f,payload:v}=await c.ethereumSignTransaction({path:(0,a.fi)(this.derivationPath),transaction:m});if(!f)throw new a.Oo({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{...v,chain:this.chain,derivationPath:this.derivationPath}});let{r:_,s:u,v:p}=v,y=g.from({...m,nonce:Number.parseInt(m.nonce),type:l?2:0,signature:{r:_,s:u,v:new a.Lm(p).getBaseValue("number")}}).serialized;if(!y)throw new a.Oo({errorKey:"wallet_trezor_failed_to_sign_transaction",info:{chain:this.chain,derivationPath:this.derivationPath}});return y};connect=i=>{if(!i)throw new a.Oo({errorKey:"wallet_provider_not_found",info:{wallet:a.$p.TREZOR,chain:this.chain,derivationPath:this.derivationPath}});return new s({chain:this.chain,derivationPath:this.derivationPath,provider:i})}}return new s({chain:i,derivationPath:t,provider:r})}}}]);
//# sourceMappingURL=118.0ad1ee9d.chunk.js.map