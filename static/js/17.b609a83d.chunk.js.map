{"version":3,"file":"static/js/17.b609a83d.chunk.js","mappings":"4eAqDA,MAAqBA,EAMnBC,WAAAA,EAAY,QAAEC,EAAO,QAAEC,GAA2D,CAAC,GALnF,KAAAC,gBAAkB,IAClB,KAAAC,oBAAsB,KACtB,KAAAC,YAA8C,KAoI9C,KAAAC,QAAU,IAAIC,KA6Dd,KAAAC,KAAO,CAAAC,EAAAC,EAAAC,EAAAC,KAAAC,IAQcC,EAAA,MAAAL,EAAAC,EAAAC,EAAAC,KAAAC,QAAA,aAPnBE,EACAC,EACAC,EACAC,EACAC,EAAeC,EAAOC,MAAM,GAC5BC,EAA4B,CAACC,EAAAA,GAAYC,KACzC,eAAEC,GAAgD,CAAC,GAEnD,MAAMC,EAASC,KAAKD,OAAOE,mBAAmB,CAAEC,SAAU,SAE1D,GAAIV,EAAKW,QAAU,IAEjB,MADAJ,EAAOK,MAAM,uCAAwC,CAAEC,WAAYb,EAAKW,SAClE,IAAIG,EAAAA,GACR,4CAA8Cd,EAAKW,OACnD,oBAIJJ,EAAOK,MAAM,uBAAwB,CAAEN,mBACvC,MAAMS,QAAiBP,KAAKQ,SAE1Bf,EAAOgB,OAAO,CAAChB,EAAOiB,KAAK,CAACtB,EAAKC,EAAKC,EAAIC,IAAME,EAAOiB,KAAK,CAAClB,EAAKW,SAAUX,IAC5E,CAAEM,mBAEJC,EAAOK,MAAM,mCACb,MAAMO,EAAKJ,EAASK,aAAaL,EAASJ,OAAS,GAEnD,IAAKR,EAAWkB,MAAKC,GAAKA,IAAMH,IAC9B,MAAM,IAAII,EAAAA,GAAqBJ,GAGjC,OAAOJ,CACT,IAyGA,KAAAS,YAA6B,KAvU3BhB,KAAKD,OAAS,IAAIkB,EAAAA,GAAmB,OAAP1C,QAAO,IAAPA,EAAAA,EAhDT,YAgDsCD,EAC7D,CA+DAkC,QAAAA,CACEU,GACEpB,eAAgBqB,GAAiD,CAAC,GAEpE,MAAM,IAAIC,MAAM,2BAClB,CASAC,YAAAA,CAAaC,EAAiBC,GAC5B,IAAIC,GAAe,EAuBnB,MAlBaC,KAAWtC,EAAA,gCACtB,IAAIqC,EACJ,IAAK,MAAME,KAAQJ,EAAO,CACxB,MAAMK,QAAU3B,KAAKQ,SAASkB,GAC9B,GAAIF,EAAc,OAClB,MAAMI,EAASD,EAAEf,aAAae,EAAExB,OAAS,GACzC,GAAIyB,IAAWhC,EAAAA,GAAYC,GACzB,MAAM,IAAIkB,EAAAA,GAAqBa,GAEjCL,EAASM,KAAKF,EAChB,CACF,IAEAF,GAAOK,MACL,KAAON,GAAgBD,EAASQ,aAChCC,IAAMR,GAAgBD,EAASU,MAAMD,KAGhC,CAAEE,YAtBWA,KAClBV,GAAe,CAAI,EAsBvB,CAUAW,cAAAA,CAAeC,GAAe,CAW9BC,KAAAA,GACE,OAAOC,QAAQC,SACjB,CAWAC,EAAAA,CAAGC,EAAmBC,GACpB1C,KAAKrB,QAAQ6D,GAAGC,EAAWC,EAC7B,CAKAC,GAAAA,CAAIF,EAAmBC,GACrB1C,KAAKrB,QAAQiE,eAAeH,EAAWC,EACzC,CAEAG,IAAAA,CAAKC,KAAkBC,GACrB/C,KAAKrB,QAAQkE,KAAKC,KAAUC,EAC9B,CAKAC,YAAAA,GACEC,QAAQC,KACN,+FAEJ,CAKAC,kBAAAA,CAAmB3E,GACjBwB,KAAKxB,gBAAkBA,CACzB,CAKA4E,8BAAAA,CAA+B3E,GAC7BuB,KAAKvB,oBAAsBA,CAC7B,CA0DA,aAAO4E,CAAOC,EAAc,IAAMC,GAChC,OAAO,IAAIjB,SAAQ,CAACC,EAASiB,KAC3B,IAAIC,GAAQ,EACZ,MAAMC,EAAM1D,KAAK2D,OAAO,CACtB9B,KAAMG,IACJyB,GAAQ,EACJC,GAAKA,EAAIxB,cACT0B,GAAiBC,aAAaD,GAClC5D,KAAK8D,KAAK9B,EAAE+B,WAAYT,GAAaxB,KAAKS,EAASiB,EAAO,EAE5DvB,MAAOD,IACD4B,GAAiBC,aAAaD,GAClCJ,EAAOxB,EAAE,EAEXD,SAAUA,KACJ6B,GAAiBC,aAAaD,GAE7BH,GACHD,EAAO,IAAIlD,EAAAA,GAAeN,KAAKgE,2BAA4B,iBAC7D,IAGEJ,EAAkBL,EACpBU,YAAW,KACTP,EAAIxB,cACJsB,EAAO,IAAIlD,EAAAA,GAAeN,KAAKkE,2BAA4B,iBAAiB,GAC3EX,GACH,IAAI,GAEZ,CAaMY,kBAAAA,CAA2BC,G,yCAC/B,MAAMrE,EAASC,KAAKD,OAAOE,mBAAmB,CAC5CC,SAAU,qBACVzB,oBAAqBuB,KAAKvB,sBAG5B,GAAIuB,KAAKqE,oBAEP,MADAtE,EAAOK,MAAM,mCACP,IAAIkE,EAAAA,GACR,iFAKJ,IAAIC,EACJ,MAAMC,EAA6B,IAAIlC,SAAQX,IAC7C4C,EAAc5C,CAAC,IAEjB3B,KAAKqE,oBAAsBG,EAG3B,IAAIC,GAAsB,EAC1B,MAAMC,EAAUT,YAAW,KACzBlE,EAAOK,MAAM,2DAA4D,CACvE3B,oBAAqBuB,KAAKvB,sBAE5BgG,GAAsB,EACtBzE,KAAK6C,KAAK,eAAe,GACxB7C,KAAKvB,qBAER,IACE,MAAMkG,QAAYP,IAOlB,OALIK,IACF1E,EAAOK,MAAM,gDACbJ,KAAK6C,KAAK,eAGL8B,CACT,CAAE,QACA5E,EAAOK,MAAM,iCAEbyD,aAAaa,GACTH,GAAaA,IACjBvE,KAAKqE,oBAAsB,IAC7B,CACF,G,CAEAO,qBAAAA,CAAsBC,EAA2BC,EAAwBC,GACvE,IAAK,MAAMC,KAAcF,EACvBD,EAAKG,GAAchF,KAAKiF,qBAAqBD,EAAYH,EAAKG,GAAaH,EAAME,EAErF,CAIAE,oBAAAA,CACED,EACAZ,EACAc,EACAH,GAEA,MAAO,IAAUhC,IAAQ5D,EAAA,gCACvB,MAAM,YAAE6B,GAAgBhB,KAExB,GAAIgB,EACF,OAAOsB,QAAQkB,OACb,IAAIlD,EAAAA,GAAe,+BAAiCU,EAAc,IAAK,oBAI3E,IAGE,OAFAhB,KAAKgB,YAAcgE,EACnBhF,KAAKmC,eAAe4C,SACPX,EAAEe,MAAMD,EAAKnC,EAC5B,CAAE,QACA/C,KAAKgB,YAAc,IACrB,CACF,GACF,CAUAoE,eAAAA,CAAgB9G,GACd0B,KAAKD,OAASC,KAAKD,OAAOsF,YAAY/G,EACxC,CASAgH,kBAAAA,CAAmBC,GACjBvF,KAAKD,OAAOyF,cAAcD,EAC5B,CAKAE,eAAAA,GACE,OAAOzF,KAAKD,OAAO2F,YACrB,EAEOtH,EAAA8F,2BAA6B,mCAC7B9F,EAAA4F,2BAA6B,yB,gCC9atC,SAAS2B,EAAWC,GAClB,MAAMC,EAAIpG,EAAOC,MAAM,GAEvB,OADAmG,EAAEC,cAAcF,EAAO,GAChBC,CACT,CAEA,MAAME,EAAa,CACjBvG,KAAMC,EAAOC,MAAM,GACnBW,WAAY,EACZ2F,SAAU,GA2GZ,EAlGyBC,CAACC,EAAiBC,KAClC,CAOLC,UAAAA,CAAW1E,GAKT,IAAIlC,EAAOC,EAAOgB,OAAO,CAACkF,EAAWjE,EAAKvB,QAASuB,IAEnD,MAAM2E,EAAYF,EAAa,EACzBG,EAAWC,KAAKC,KAAKhH,EAAKW,OAASkG,GAGzC7G,EAAOC,EAAOgB,OAAO,CAACjB,EAAMC,EAAOC,MAAM4G,EAAWD,EAAY7G,EAAKW,OAAS,GAAGsG,KAAK,KAEtF,MAAMC,EAAmB,GAEzB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAUK,IAAK,CACjC,MAAMC,EAAOnH,EAAOC,MAAM,GAC1BkH,EAAKd,cAAcI,EAAS,GAC5BU,EAAKC,WA9CD,EA8CiB,GACrBD,EAAKd,cAAca,EAAG,GAGtB,MAAMG,EAAQtH,EAAKuH,MAAMJ,EAAIN,GAAYM,EAAI,GAAKN,GAElDK,EAAOM,KAAKvH,EAAOgB,OAAO,CAACmG,EAAME,IACnC,CAEA,OAAOJ,CACT,EAUAO,cAAAA,CAAeC,EAAkBJ,GAC/B,IAAI,KAAEtH,EAAI,WAAEa,EAAU,SAAE2F,GAAakB,GAAOnB,EAE5C,GAAIe,EAAMlG,aAAa,KAAOsF,EAC5B,MAAM,IAAI5F,EAAAA,GAAe,kBAAmB,kBAG9C,GAzEM,IAyEFwG,EAAMK,UAAU,GAClB,MAAM,IAAI7G,EAAAA,GAAe,cAAe,cAG1C,GAAIwG,EAAMlG,aAAa,KAAOoF,EAC5B,MAAM,IAAI1F,EAAAA,GAAe,mBAAoB,mBAI1C4G,IACH7G,EAAayG,EAAMlG,aAAa,IAGlCoF,IAEA,MAAMoB,EAAYN,EAAMC,MAAMG,EAAM,EAAI,GAQxC,OAPA1H,EAAOC,EAAOgB,OAAO,CAACjB,EAAM4H,IAGxB5H,EAAKW,OAASE,IAChBb,EAAOA,EAAKuH,MAAM,EAAG1G,IAGhB,CACLb,OACAa,aACA2F,WAEJ,EASAqB,gBAAAA,CAAiBH,GACf,GAAIA,GAAOA,EAAI7G,aAAe6G,EAAI1H,KAAKW,OACrC,OAAO+G,EAAI1H,IAEf,I,qTC7HJ,MAAM8H,EAAgB,CACpB,CACEC,SAAUC,EAAAA,oBAIR,SAAgBC,I,yCAIpB,aAHqBC,UAAUC,IAAIC,cAAc,CAC/CC,QAASP,GAGb,G,CAEM,SAAgBQ,I,yCAEpB,aADsBJ,UAAUC,IAAII,cACrBC,QAAOC,GAAKA,EAAEV,WAAaC,EAAAA,mBAC5C,G,6TCOA,MAAqBU,UAAwB9J,EAO3CC,WAAAA,CAAY8J,EAAmBC,GAC7BC,QALF,KAAAnC,QAAUK,KAAK+B,MAAsB,MAAhB/B,KAAKgC,UAC1B,KAAApC,WAAa,GAyHb,KAAAqC,oBAAqB,EACrB,KAAAC,gBAAmBzG,IACbhC,KAAKwI,qBACTxI,KAAKwI,oBAAqB,EAC1BxI,KAAK6C,KAAK,aAAcb,GAAE,EAxH1BhC,KAAKmI,OAASA,EACdnI,KAAKoI,gBAAkBA,EACvBpI,KAAKtB,aAAcgK,EAAAA,EAAAA,IAAqBP,EAAOQ,UACjD,CAqDA,cAAaC,G,yCACX,MAAMT,QAAeV,IACrB,OAAOS,EAAgBpE,KAAKqE,EAC9B,G,CAKA,oBAAaU,G,yCACX,MAAMC,QAAgBhB,IACtB,OAAuB,IAAnBgB,EAAQ3I,OAAqB,KAC1B+H,EAAgBpE,KAAKgF,EAAQ,GACtC,G,CAKA,WAAahF,CAAKqE,G,+CACVA,EAAOrE,OAEgB,OAAzBqE,EAAOY,sBACHZ,EAAOa,oBAhGQ,UAmGjBC,EAAsBd,GAC5B,MAAMe,EAAQf,EAAOgB,eAAe,GAAGC,WAAWC,MAAK,EAAGC,gBACxDA,EAAWzI,MAAK0I,GAA0B,MAArBA,EAAEC,mBAGzB,IAAKN,EACH,MAAM,IAAIO,EAAAA,GACR,qGAIJ,MAAMrB,EAAkBc,EAAMd,gBAE9B,UACQD,EAAOuB,eAAetB,EAC9B,CAAE,MAAOpG,GAEP,YADMmG,EAAO9F,QACP,IAAIoH,EAAAA,GAA+BzH,EAAE2H,QAC7C,CAEA,MAAMC,EAAY,IAAI1B,EAAgBC,EAAQC,GAExCyB,EAAe7H,IACfmG,IAAWnG,EAAEmG,SAEfT,UAAUC,IAAImC,oBAAoB,aAAcD,GAEhDD,EAAUnB,gBAAgB,IAAIsB,EAAAA,oBAChC,EAKF,OADArC,UAAUC,IAAIqC,iBAAiB,aAAcH,GACtCD,CACT,G,CAYMvH,KAAAA,G,+CACErC,KAAKqE,0BACLrE,KAAKmI,OAAO8B,iBAAiBjK,KAAKoI,uBAClCa,EAAsBjJ,KAAKmI,cAC3BnI,KAAKmI,OAAO9F,OACpB,G,CAOM7B,QAAAA,CAASkB,G,yCAoCb,aAnCgB1B,KAAKmE,oBAAmB,IAAWhF,EAAA,gCACjD,MAAM,QAAE+G,EAAO,WAAEC,GAAenG,MAChCkK,EAAAA,EAAAA,IAAI,OAAQ,MAAQxI,EAAKyI,SAAS,QAClC,MAAMC,EAAUC,EAAWnE,EAASC,GAE9BO,EAAS0D,EAAQhE,WAAW1E,GAElC,IAAK,IAAIiF,EAAI,EAAGA,EAAID,EAAOvG,OAAQwG,UAC3B3G,KAAKmI,OAAOmC,YArKH,EAqK+B5D,EAAOC,IAIvD,IAAI4D,EACArD,EAEJ,OAASqD,EAASH,EAAQ/C,iBAAiBH,KAAO,CAChD,MAAMvF,QAAU3B,KAAKmI,OAAOqC,WA7Kb,EA6KwCrE,GAGjDsE,EAAShL,EAAOiB,KAAKiB,EAAEnC,KAAKiL,QAClCvD,EAAMkD,EAAQnD,eAAeC,EAAKuD,EACpC,CAGA,OADAP,EAAAA,EAAAA,IAAI,OAAQ,MAAQK,EAAOJ,SAAS,QAC7BI,CACT,MAAGG,OAAM1I,IACP,GAAIA,GAAKA,EAAE2H,SAAW3H,EAAE2H,QAAQgB,SAAS,gBAGvC,MAFA3K,KAAKyI,gBAAgBzG,GAEf,IAAI4I,EAAAA,GAAkC5I,EAAE2H,SAGhD,MAAM3H,CAAC,GAIX,G,CAEAG,cAAAA,GAAkB,EAzKX+F,EAAA2C,YDhBkBA,IACzBvI,QAAQC,UAAUmF,aAAeA,UAAUC,KAA2C,oBAA7BD,UAAUC,IAAII,YCoBhEG,EAAA4C,KAAOhD,EAQPI,EAAAvE,OAAUpC,IACf,IAAIC,GAAe,EA0BnB,OD9DE,W,yCACJ,MAAMuJ,QAAwBjD,IAC9B,OAAIiD,EAAgB5K,OAAS,EAAU4K,EAAgB,GAChDtD,GACT,G,CCiCIuD,GAAuBlJ,MACrBqG,IACE,IAAK3G,EAAc,CACjB,MAAM9C,GAAcgK,EAAAA,EAAAA,IAAqBP,EAAOQ,WAChDpH,EAASM,KAAK,CACZoJ,KAAM,MACNlH,WAAYoE,EACZzJ,gBAEF6C,EAASQ,UACX,KAEFE,IACMiJ,OAAOC,cAAgBlJ,aAAiBiJ,OAAOC,cAA+B,KAAflJ,EAAMmJ,KACvE7J,EAASU,MAAM,IAAIoJ,EAAAA,GAA+BpJ,EAAM0H,UAExDpI,EAASU,MAAM,IAAIqJ,EAAAA,GAA2BrJ,EAAM0H,SACtD,IAQG,CACLzH,YALF,WACEV,GAAe,CACjB,EAIC,E,UAkIL,SAAeyH,EAAsBd,G,yCACnC,UACQA,EAAOoD,OACf,CAAE,MAAOC,GACPvI,QAAQC,KAAKsI,EACf,CACF,G,8CC1LA,IAAIC,EAAK,EACT,MAAMC,EAA4B,GAQrBxB,EAAMA,CAACe,EAAetB,EAAkBnK,KACnD,MAAMmM,EAAW,CACfV,OACAQ,GAAIG,SAASH,GACbI,KAAM,IAAIC,MAERnC,IAASgC,EAAIhC,QAAUA,GACvBnK,IAAMmM,EAAInM,KAAOA,GACrBuM,EAASJ,EAAI,EA4CT,MAAO1K,EACX5C,WAAAA,CACU4M,EACA3M,GADA,KAAA2M,KAAAA,EACA,KAAA3M,QAAAA,CACP,CAEH8B,KAAAA,CAAMuJ,EAAiBnK,GAvCJY,GACnB6K,OACAtB,UACAnK,OACAlB,cAOA,MAAMqN,EAAW,CACfV,OACAQ,GAAIG,SAASH,GACbI,KAAM,IAAIC,MAGRnC,IAASgC,EAAIhC,QAAUA,GACvBnK,IAAMmM,EAAInM,KAAOA,GACjBlB,IAASqN,EAAIrN,QAAUA,GAE3ByN,EAASJ,EAAI,EAmBXvL,CAAM,CACJ6K,KAAMjL,KAAKiL,KACXtB,UACAnK,OACAlB,QAAS0B,KAAK1B,SAElB,CAEAoH,UAAAA,GACE,OAAO1F,KAAK1B,OACd,CAEA0N,UAAAA,CAAW1N,GACT0B,KAAK1B,QAAUA,CACjB,CAEAkH,aAAAA,CAAcD,GACZvF,KAAK1B,QAAO2N,OAAAC,OAAAD,OAAAC,OAAA,GAAQlM,KAAK1B,SAAYiH,EACvC,CAEA4G,OAAAA,GACE,OAAOnM,KAAKiL,IACd,CAEAmB,OAAAA,CAAQnB,GACNjL,KAAKiL,KAAOA,CACd,CAQAoB,QAAAA,CAASpB,GACP,OAAO,IAAIhK,EAAYgK,EAAMjL,KAAK1B,QACpC,CAUA+G,WAAAA,CAAY/G,GACV,OAAO,IAAI2C,EAAYjB,KAAKiL,KAAM3M,EACpC,CASA2B,kBAAAA,CAAmBsF,GACjB,OAAO,IAAItE,EAAYjB,KAAKiL,KAAIgB,OAAAC,OAAAD,OAAAC,OAAA,GAAOlM,KAAK1B,SAAYiH,GAC1D,EASK,MAAM5B,EAAUjB,IACrBgJ,EAAY1E,KAAKtE,GACV,KACL,MAAMiE,EAAI+E,EAAYY,QAAQ5J,IAEnB,IAAPiE,IAEF+E,EAAY/E,GAAK+E,EAAYA,EAAYvL,OAAS,GAClDuL,EAAYa,M,GAKlB,SAASR,EAAS7B,GAChB,IAAK,IAAIvD,EAAI,EAAGA,EAAI+E,EAAYvL,OAAQwG,IACtC,IACE+E,EAAY/E,GAAGuD,E,CACf,MAAOlI,GACPiB,QAAQhB,MAAMD,E,CAGpB,CAUsB,qBAAXkJ,SACTA,OAAOsB,mBAAqB7I,E","sources":["../node_modules/@ledgerhq/hw-transport/src/Transport.ts","../node_modules/@ledgerhq/devices/src/hid-framing.ts","../node_modules/@ledgerhq/hw-transport-webusb/src/webusb.ts","../node_modules/@ledgerhq/hw-transport-webusb/src/TransportWebUSB.ts","../node_modules/@ledgerhq/logs/src/index.ts"],"sourcesContent":["import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nimport { LocalTracer, TraceContext, LogType } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n\nconst DEFAULT_LOG_TYPE = \"transport\";\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\nexport type DescriptorEventType = \"add\" | \"remove\";\n/**\n * A \"descriptor\" is a parameter that is specific to the implementation, and can be an ID, file path, or URL.\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: DescriptorEventType;\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n * Observer generic type, following the Observer pattern\n */\nexport type Observer<EventType, EventError = unknown> = Readonly<{\n  next: (event: EventType) => unknown;\n  error: (e: EventError) => unknown;\n  complete: () => unknown;\n}>;\n\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n  tracer: LocalTracer;\n\n  constructor({ context, logType }: { context?: TraceContext; logType?: LogType } = {}) {\n    this.tracer = new LocalTracer(logType ?? DEFAULT_LOG_TYPE, context);\n  }\n\n  /**\n   * Check if the transport is supported on the current platform/browser.\n   * @returns {Promise<boolean>} A promise that resolves with a boolean indicating support.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List all available descriptors for the transport.\n   * For a better granularity, checkout `listen()`.\n   *\n   * @returns {Promise<Array<any>>} A promise that resolves with an array of descriptors.\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen for device events for the transport. The method takes an observer of DescriptorEvent and returns a Subscription.\n   * A DescriptorEvent is an object containing a \"descriptor\" and a \"type\" field. The \"type\" field can be \"add\" or \"remove\", and the \"descriptor\" field can be passed to the \"open\" method.\n   * The \"listen\" method will first emit all currently connected devices and then will emit events as they occur, such as when a USB device is plugged in or a Bluetooth device becomes discoverable.\n   * @param {Observer<DescriptorEvent<any>>} observer - An object with \"next\", \"error\", and \"complete\" functions, following the observer pattern.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop listening to descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (observer: Observer<DescriptorEvent<any>>) => Subscription;\n\n  /**\n   * Attempt to create a Transport instance with a specific descriptor.\n   * @param {any} descriptor - The descriptor to open the transport with.\n   * @param {number} timeout - An optional timeout for the transport connection.\n   * @param {TraceContext} context Optional tracing/log context\n   * @returns {Promise<Transport>} A promise that resolves with a Transport instance.\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeoutMs?: number,\n    context?: TraceContext,\n  ) => Promise<Transport>;\n\n  /**\n   * Send data to the device using a low level API.\n   * It's recommended to use the \"send\" method for a higher level API.\n   * @param {Buffer} apdu - The data to send.\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  exchange(\n    _apdu: Buffer,\n    { abortTimeoutMs: _abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * Send apdus in batch to the device using a low level API.\n   * The default implementation is to call exchange for each apdu.\n   * @param {Array<Buffer>} apdus - array of apdus to send.\n   * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n   * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n   */\n  exchangeBulk(apdus: Buffer[], observer: Observer<Buffer>): Subscription {\n    let unsubscribed = false;\n    const unsubscribe = () => {\n      unsubscribed = true;\n    };\n\n    const main = async () => {\n      if (unsubscribed) return;\n      for (const apdu of apdus) {\n        const r = await this.exchange(apdu);\n        if (unsubscribed) return;\n        const status = r.readUInt16BE(r.length - 2);\n        if (status !== StatusCodes.OK) {\n          throw new TransportStatusError(status);\n        }\n        observer.next(r);\n      }\n    };\n\n    main().then(\n      () => !unsubscribed && observer.complete(),\n      e => !unsubscribed && observer.error(e),\n    );\n\n    return { unsubscribe };\n  }\n\n  /**\n   * Set the \"scramble key\" for the next data exchanges with the device.\n   * Each app can have a different scramble key and it is set internally during instantiation.\n   * @param {string} key - The scramble key to set.\n   * deprecated This method is no longer needed for modern transports and should be migrated away from.\n   * no @ before deprecated as it breaks documentationjs on version 14.0.2\n   * https://github.com/documentationjs/documentation/issues/1596\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * Close the connection with the device.\n   *\n   * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n   * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n   * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n   *\n   * @returns {Promise<void>} A promise that resolves when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen for an event on the transport instance.\n   * Transport implementations may have specific events. Common events include:\n   * \"disconnect\" : triggered when the transport is disconnected.\n   * @param {string} eventName - The name of the event to listen for.\n   * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\",\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * Send data to the device using the higher level API.\n   *\n   * @param {number} cla - The instruction class for the command.\n   * @param {number} ins - The instruction code for the command.\n   * @param {number} p1 - The first parameter for the instruction.\n   * @param {number} p2 - The second parameter for the instruction.\n   * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n   * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n   * @param {Object} options - Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK],\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n\n    if (data.length >= 256) {\n      tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\",\n      );\n    }\n\n    tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n    const response = await this.exchange(\n      // The size of the data is added in 1 byte just before `data`\n      Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]),\n      { abortTimeoutMs },\n    );\n    tracer.trace(\"Received response from exchange\");\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout?: number): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  // Blocks other exchange to happen concurrently\n  exchangeBusyPromise: Promise<void> | null | undefined;\n\n  /**\n   * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n   *\n   * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n   *\n   * @param f The exchange job, using the transport to run\n   * @returns a Promise resolving with the output of the given job\n   */\n  async exchangeAtomicImpl<Output>(f: () => Promise<Output>): Promise<Output> {\n    const tracer = this.tracer.withUpdatedContext({\n      function: \"exchangeAtomicImpl\",\n      unresponsiveTimeout: this.unresponsiveTimeout,\n    });\n\n    if (this.exchangeBusyPromise) {\n      tracer.trace(\"Atomic exchange is already busy\");\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\",\n      );\n    }\n\n    // Sets the atomic guard\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n\n    // The device unresponsiveness handler\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n        unresponsiveTimeout: this.unresponsiveTimeout,\n      });\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        tracer.trace(\"Device was unresponsive, emitting responsive\");\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      tracer.trace(\"Finalize, clearing busy guard\");\n\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  }\n\n  decorateAppAPIMethods(self: Record<string, any>, methods: Array<string>, scrambleKey: string) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string,\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"),\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  /**\n   * Sets the context used by the logging/tracing mechanism\n   *\n   * Useful when re-using (cached) the same Transport instance,\n   * but with a new tracing context.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  setTraceContext(context?: TraceContext) {\n    this.tracer = this.tracer.withContext(context);\n  }\n\n  /**\n   * Updates the context used by the logging/tracing mechanism\n   *\n   * The update only overrides the key-value that are already defined in the current context.\n   *\n   * @param contextToAdd A TraceContext that will be added to the current context\n   */\n  updateTraceContext(contextToAdd: TraceContext) {\n    this.tracer.updateContext(contextToAdd);\n  }\n\n  /**\n   * Gets the tracing context of the transport instance\n   */\n  getTraceContext(): TraceContext | undefined {\n    return this.tracer.getContext();\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n","import { TransportError } from \"@ledgerhq/errors\";\n\n// Represents a response message from the device being reduced from HID USB frames/packets\nexport type ResponseAcc =\n  | {\n      data: Buffer;\n      dataLength: number;\n      // The current frame id/number\n      sequence: number;\n    }\n  | null\n  | undefined;\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n * Object to handle HID frames (encoding and decoding)\n *\n * @param channel\n * @param packetSize The HID protocol packet size in bytes (usually 64)\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    /**\n     * Frames/encodes an APDU message into HID USB packets/frames\n     *\n     * @param apdu The APDU message to send, in a Buffer containing [cla, ins, p1, p2, data length, data(if not empty)]\n     * @returns an array of HID USB frames ready to be sent\n     */\n    makeBlocks(apdu: Buffer): Buffer[] {\n      // Encodes the APDU length in 2 bytes before the APDU itself.\n      // The length is measured as the number of bytes.\n      // As the size of the APDU `data` should have been added in 1 byte just before `data`,\n      // the minimum size of an APDU is 5 bytes.\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n\n      // Fills data with 0-padding\n      data = Buffer.concat([data, Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n\n      const blocks: Buffer[] = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n\n        // `slice` and not `subarray`: this might not be a Node Buffer, but probably only a Uint8Array\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    /**\n     * Reduces HID USB packets/frames to one response.\n     *\n     * @param acc The value resulting from (accumulating) the previous call of reduceResponse.\n     *   On first call initialized to `initialAcc`. The accumulator enables handling multi-frames messages.\n     * @param chunk Current chunk to reduce into accumulator\n     * @returns An accumulator value updated with the current chunk\n     */\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      // Gets the total length of the response from the 1st frame\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      // The total length on the 1st frame takes 2 more bytes\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      // Removes any 0 padding\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    /**\n     * Returns the response message that has been reduced from the HID USB frames\n     *\n     * @param acc The accumulator\n     * @returns A Buffer containing the cleaned response message, or null if no response message, or undefined if the\n     *   accumulator is incorrect (message length is not valid)\n     */\n    getReducedResult(acc: ResponseAcc): Buffer | null | undefined {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n","import { ledgerUSBVendorId } from \"@ledgerhq/devices\";\n\nconst ledgerDevices = [\n  {\n    vendorId: ledgerUSBVendorId,\n  },\n];\n\nexport async function requestLedgerDevice(): Promise<USBDevice> {\n  const device = await navigator.usb.requestDevice({\n    filters: ledgerDevices,\n  });\n  return device;\n}\n\nexport async function getLedgerDevices(): Promise<USBDevice[]> {\n  const devices = await navigator.usb.getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nexport async function getFirstLedgerDevice(): Promise<USBDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  return requestLedgerDevice();\n}\n\nexport const isSupported = (): Promise<boolean> =>\n  Promise.resolve(!!navigator && !!navigator.usb && typeof navigator.usb.getDevices === \"function\");\n","import Transport from \"@ledgerhq/hw-transport\";\nimport type { Observer, DescriptorEvent, Subscription } from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport {\n  device: USBDevice;\n  deviceModel: DeviceModel | null | undefined;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (observer: Observer<DescriptorEvent<USBDevice>>): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      device => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({\n            type: \"add\",\n            descriptor: device,\n            deviceModel,\n          });\n          observer.complete();\n        }\n      },\n      error => {\n        if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      },\n    );\n\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n\n    return {\n      unsubscribe,\n    };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some(a => a.interfaceClass === 255),\n    );\n\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\",\n      );\n    }\n\n    const interfaceNumber = iface.interfaceNumber;\n\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e: any) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n\n    const transport = new TransportWebUSB(device, interfaceNumber);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    const b = await this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize);\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    return b as Buffer;\n  }\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n","export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n"],"names":["Transport","constructor","context","logType","exchangeTimeout","unresponsiveTimeout","deviceModel","_events","EventEmitter","send","cla_1","ins_1","p1_1","p2_1","args_1","__awaiter","cla","ins","p1","p2","data","Buffer","alloc","statusList","StatusCodes","OK","abortTimeoutMs","tracer","this","withUpdatedContext","function","length","trace","dataLength","TransportError","response","exchange","concat","from","sw","readUInt16BE","some","s","TransportStatusError","_appAPIlock","LocalTracer","_apdu","_abortTimeoutMs","Error","exchangeBulk","apdus","observer","unsubscribed","main","apdu","r","status","next","then","complete","e","error","unsubscribe","setScrambleKey","_key","close","Promise","resolve","on","eventName","cb","off","removeListener","emit","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","create","openTimeout","listenTimeout","reject","found","sub","listen","listenTimeoutId","clearTimeout","open","descriptor","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout","exchangeAtomicImpl","f","exchangeBusyPromise","TransportRaceCondition","resolveBusy","busyPromise","unresponsiveReached","timeout","res","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","apply","setTraceContext","withContext","updateTraceContext","contextToAdd","updateContext","getTraceContext","getContext","asUInt16BE","value","b","writeUInt16BE","initialAcc","sequence","createHIDframing","channel","packetSize","makeBlocks","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt8","chunkData","getReducedResult","ledgerDevices","vendorId","ledgerUSBVendorId","requestLedgerDevice","navigator","usb","requestDevice","filters","getLedgerDevices","getDevices","filter","d","TransportWebUSB","device","interfaceNumber","super","floor","random","_disconnectEmitted","_emitDisconnect","identifyUSBProductId","productId","request","openConnected","devices","configuration","selectConfiguration","gracefullyResetDevice","iface","configurations","interfaces","find","alternates","a","interfaceClass","TransportInterfaceNotAvailable","claimInterface","message","transport","onDisconnect","removeEventListener","DisconnectedDevice","addEventListener","releaseInterface","log","toString","framing","hidFraming","transferOut","result","transferIn","buffer","catch","includes","DisconnectedDeviceDuringOperation","isSupported","list","existingDevices","getFirstLedgerDevice","type","window","DOMException","code","TransportWebUSBGestureRequired","TransportOpenUserCancelled","reset","err","id","subscribers","obj","String","date","Date","dispatch","setContext","Object","assign","getType","setType","withType","indexOf","pop","__ledgerLogsListen"],"sourceRoot":""}