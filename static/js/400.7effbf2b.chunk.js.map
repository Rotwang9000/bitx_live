{"version":3,"file":"static/js/400.7effbf2b.chunk.js","mappings":"4JAqBWA,EACAC,E,YAAAA,EAMRD,IAAkBA,EAAgB,CAAE,IALrBE,KAAU,OACxBD,EAAcE,MAAW,QACzBF,EAAcG,OAAY,SAC1BH,EAAcI,MAAW,QACzBJ,EAAcK,KAAU,OAE5B,MAAMC,EAAU,CACZ,CAACP,EAAcE,MAAO,CAClBM,GAAIR,EAAcE,KAClBO,YAAa,iBACbC,YAAa,EACbC,mBAAoB,EACpBC,SAAS,EACTC,WAAY,OACZC,MAAO,CAAC,UAAY,WACpBC,aAAed,GAAoB,MAEvC,CAACD,EAAcG,OAAQ,CACnBK,GAAIR,EAAcG,MAClBM,YAAa,sBACbC,YAAa,GACbC,mBAAoB,EACpBC,SAAS,EACTC,WAAY,OACZC,MAAO,CAAC,WACRC,aAAed,IAAsB,IAAIe,EAAI,OAAOC,EAAAA,EAAOC,GAA6C,QAAzCF,EAAKC,EAAAA,EAAOE,OAAOlB,UAAqC,IAAPe,EAAgBA,EAAK,GAAI,SAAW,KAAW,IAAQ,GAE3K,CAAChB,EAAcI,QAAS,CACpBI,GAAIR,EAAcI,OAClBK,YAAa,qBACbC,YAAa,GACbC,mBAAoB,EACpBC,SAAS,EACTC,WAAY,QACZC,MAAO,CAAC,WACRC,aAAed,GAAqB,IAExC,CAACD,EAAcK,OAAQ,CACnBG,GAAIR,EAAcK,MAClBI,YAAa,sBACbC,YAAa,GACbC,mBAAoB,EACpBC,SAAS,EACTC,WAAY,QACZC,MAAO,CAAC,WACRC,aAAed,GAAoB,KACnCmB,cAAe,CACX,CACIC,YAAa,uCACbC,WAAY,uCACZC,UAAW,uCACXC,aAAc,0CAI1B,CAACxB,EAAcM,MAAO,CAClBE,GAAIR,EAAcM,KAClBG,YAAa,iBACbC,YAAa,GACbC,mBAAoB,EACpBC,SAAS,EACTC,WAAY,QACZC,MAAO,CAAC,WACRC,aAAed,GAAqB,GACpCmB,cAAe,CACX,CACIC,YAAa,uCACbC,WAAY,uCACZC,UAAW,uCACXC,aAAc,2CAMpBxB,EAAcE,KACVF,EAAcG,MACTH,EAAcI,OACnBJ,EAAcK,MAClBL,EAAcM,KAExB,MAAMmB,EAAcC,OAAOC,OAAOpB,GAIrBqB,EAAoB,MAwBpBC,EAAwB5B,IACjC,MAAMe,EAASS,EAAYK,MAAKC,GAAKA,EAAEpB,qBAAuBV,IAC9D,GAAIe,EACA,OAAOA,EACX,MAAMgB,EAAK/B,GAAgB,EAE3B,OADoBwB,EAAYK,MAAKC,GAAKA,EAAErB,cAAgBsB,GAAG,EAO7DC,EAAoB,GACpBC,EAAqB,CAAC,EAC5B,IAAK,MAAMjC,KAAMM,EAAS,CACtB,MAAMS,EAAcT,EAAQN,IACpBmB,cAAAY,GAAkBhB,EAC1B,GAAIgB,EACA,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAAcI,OAAQD,IAAK,CAC3C,MAAMJ,EAAOC,EAAcG,GAC3BF,EAAkBI,KAAKN,EAAKV,aAC5Ba,EAAmBH,EAAKV,aAAea,EAAmBH,EAAKV,YAAYiB,QAAQ,KAAM,KAAOZ,OAAOa,OAAO,CAAEC,YAAAxB,GAAee,EAClI,CAET,C","sources":["../node_modules/.pnpm/@ledgerhq+devices@8.2.1/node_modules/@ledgerhq/devices/lib-es/index.js"],"sourcesContent":["import semver from \"semver\";\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\nexport var DeviceModelId;\n(function (DeviceModelId) {\n    DeviceModelId[\"blue\"] = \"blue\";\n    DeviceModelId[\"nanoS\"] = \"nanoS\";\n    DeviceModelId[\"nanoSP\"] = \"nanoSP\";\n    DeviceModelId[\"nanoX\"] = \"nanoX\";\n    DeviceModelId[\"stax\"] = \"stax\";\n})(DeviceModelId || (DeviceModelId = {}));\nconst devices = {\n    [DeviceModelId.blue]: {\n        id: DeviceModelId.blue,\n        productName: \"Ledger Blue\",\n        productIdMM: 0x00,\n        legacyUsbProductId: 0x0000,\n        usbOnly: true,\n        memorySize: 480 * 1024,\n        masks: [0x31000000, 0x31010000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n    },\n    [DeviceModelId.nanoS]: {\n        id: DeviceModelId.nanoS,\n        productName: \"Ledger Nano S\",\n        productIdMM: 0x10,\n        legacyUsbProductId: 0x0001,\n        usbOnly: true,\n        memorySize: 320 * 1024,\n        masks: [0x31100000],\n        getBlockSize: (firmwareVersion) => { var _a; return semver.lt((_a = semver.coerce(firmwareVersion)) !== null && _a !== void 0 ? _a : \"\", \"2.0.0\") ? 4 * 1024 : 2 * 1024; },\n    },\n    [DeviceModelId.nanoSP]: {\n        id: DeviceModelId.nanoSP,\n        productName: \"Ledger Nano S Plus\",\n        productIdMM: 0x50,\n        legacyUsbProductId: 0x0005,\n        usbOnly: true,\n        memorySize: 1533 * 1024,\n        masks: [0x33100000],\n        getBlockSize: (_firmwareVersion) => 32,\n    },\n    [DeviceModelId.nanoX]: {\n        id: DeviceModelId.nanoX,\n        productName: \"Ledger Nano X\",\n        productIdMM: 0x40,\n        legacyUsbProductId: 0x0004,\n        usbOnly: false,\n        memorySize: 2 * 1024 * 1024,\n        masks: [0x33000000],\n        getBlockSize: (_firwareVersion) => 4 * 1024,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-0004-0003-4c6564676572\",\n            },\n        ],\n    },\n    [DeviceModelId.stax]: {\n        id: DeviceModelId.stax,\n        productName: \"Ledger Stax\",\n        productIdMM: 0x60,\n        legacyUsbProductId: 0x0006,\n        usbOnly: false,\n        memorySize: 1533 * 1024,\n        masks: [0x33200000],\n        getBlockSize: (_firmwareVersion) => 32,\n        bluetoothSpec: [\n            {\n                serviceUuid: \"13d63400-2c97-6004-0000-4c6564676572\",\n                notifyUuid: \"13d63400-2c97-6004-0001-4c6564676572\",\n                writeUuid: \"13d63400-2c97-6004-0002-4c6564676572\",\n                writeCmdUuid: \"13d63400-2c97-6004-0003-4c6564676572\",\n            },\n        ],\n    },\n};\nconst productMap = {\n    Blue: DeviceModelId.blue,\n    \"Nano S\": DeviceModelId.nanoS,\n    \"Nano S Plus\": DeviceModelId.nanoSP,\n    \"Nano X\": DeviceModelId.nanoX,\n    Stax: DeviceModelId.stax,\n};\nconst devicesList = Object.values(devices);\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n/**\n *\n */\nexport const getDeviceModel = (id) => {\n    const info = devices[id];\n    if (!info)\n        throw new Error(\"device '\" + id + \"' does not exist\");\n    return info;\n};\n/**\n * Given a `targetId`, return the deviceModel associated to it,\n * based on the first two bytes.\n */\nexport const identifyTargetId = (targetId) => {\n    const deviceModel = devicesList.find(({ masks }) => masks.find(mask => (targetId & 0xffff0000) === mask));\n    return deviceModel;\n};\n/**\n * From a given USB product id, return the deviceModel associated to it.\n *\n * The mapping from the product id is only based on the 2 most significant bytes.\n * For example, Stax is defined with a product id of 0x60ii, a product id 0x6011 would be mapped to it.\n */\nexport const identifyUSBProductId = (usbProductId) => {\n    const legacy = devicesList.find(d => d.legacyUsbProductId === usbProductId);\n    if (legacy)\n        return legacy;\n    const mm = usbProductId >> 8;\n    const deviceModel = devicesList.find(d => d.productIdMM === mm);\n    return deviceModel;\n};\nexport const identifyProductName = (productName) => {\n    const deviceModel = devicesList.find(d => d.id === productMap[productName]);\n    return deviceModel;\n};\nconst bluetoothServices = [];\nconst serviceUuidToInfos = {};\nfor (const id in devices) {\n    const deviceModel = devices[id];\n    const { bluetoothSpec } = deviceModel;\n    if (bluetoothSpec) {\n        for (let i = 0; i < bluetoothSpec.length; i++) {\n            const spec = bluetoothSpec[i];\n            bluetoothServices.push(spec.serviceUuid);\n            serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[spec.serviceUuid.replace(/-/g, \"\")] = Object.assign({ deviceModel }, spec);\n        }\n    }\n}\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid) => serviceUuidToInfos[uuid.toLowerCase()];\n//# sourceMappingURL=index.js.map"],"names":["e","o","blue","nanoS","nanoSP","nanoX","stax","r","id","productName","productIdMM","legacyUsbProductId","usbOnly","memorySize","masks","getBlockSize","c","s","lt","coerce","bluetoothSpec","serviceUuid","notifyUuid","writeUuid","writeCmdUuid","i","Object","values","S","m","find","n","t","u","a","d","length","push","replace","assign","deviceModel"],"sourceRoot":""}