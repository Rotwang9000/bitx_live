"use strict";(globalThis.webpackChunkwinbit32=globalThis.webpackChunkwinbit32||[]).push([[380],{55380:(e,t,a)=>{var s;a.d(t,{BTCToolbox:()=>j,Psbt:()=>n.iL});var r,i,n=a(32460),o=a(7719),c=a(45370),d=a(56498),u=(a(64029),a(53731)),h=(a(96762),a(48950),a(11352)),p=a(32871),l=a(74248).Buffer,f=a(28819),w=e=>`https://api.blockchair.com/${m(e)}`,y=e=>{switch(e){case o.sW.Bitcoin:return 5;case o.sW.Dogecoin:return 1e4;case o.sW.Litecoin:return 1;default:return 2}},m=e=>{switch(e){case o.sW.BitcoinCash:return"bitcoin-cash";case o.sW.Litecoin:return"litecoin";case o.sW.Dash:return"dash";case o.sW.Dogecoin:return"dogecoin";case o.sW.Polkadot:return"polkadot";default:return"bitcoin"}},x=async(e,t)=>{try{const t=await o.R0.get(e);if(!t||200!==t.context.code)throw new Error(`failed to query ${e}`);return t.data}catch(i){if(!t)throw i;const s=await o.R0.get(`${e}${t?`&key=${t}`:""}`);if(!s||200!==s.context.code)throw new Error(`failed to query ${e}`);return s.data}},g={utxo:[],address:{balance:0,transaction_count:0}},v=async({address:e,chain:t,apiKey:a})=>{if(!e)throw new Error("address is required");try{return(await x(`${w(t)}/dashboards/address/${e}?transaction_details=true`,a))[e]}catch(s){return g}},K=async({chain:e,apiKey:t,txHash:a})=>{if(!a)throw new Error("txHash is required");try{return(await x(`${w(e)}/raw/transaction/${a}`,t))?.[a]?.raw_transaction}catch(s){return console.error(s),""}},W=async({chain:e,address:t,apiKey:a,offset:s=0})=>{if(!t)throw new Error("address is required");try{const r=await x(`${w(e)}/outputs?q=is_spent(false),recipient(${t})&limit=100&offset=${s}`,a),i=r.filter((({is_spent:e})=>!e)).map((({script_hex:e,block_id:t,transaction_hash:a,index:s,value:r,spending_signature_hex:i})=>({hash:a,index:s,value:r,txHex:i,script_hex:e,is_confirmed:-1!==t})));if(100!==r.length)return i;const n=await W({address:t,chain:e,apiKey:a,offset:r?.[99]?.transaction_id});return i.concat(n)}catch(r){return console.error(r),[]}},b=({apiKey:e,chain:t})=>({getConfirmedBalance:a=>(async({chain:e,address:t,apiKey:a})=>{if(!t)throw new Error("address is required");try{return(await x(`${w(e)}/addresses/balances?addresses=${t}`,a))[t]||0}catch(s){return 0}})({chain:t,address:a,apiKey:e}),getRawTx:a=>K({txHash:a,chain:t,apiKey:e}),getSuggestedTxFee:()=>(async e=>{try{const{feePerKb:t}=await o.R0.get(`https://app.bitgo.com/api/v2/${e.toLowerCase()}/tx/fee`),a=t/1e3;return Math.max(a,y(e))}catch(t){return y(e)}})(t),getBalance:a=>(async({address:e,chain:t,apiKey:a})=>(await v({address:e,chain:t,apiKey:a}))?.address.balance)({address:a,chain:t,apiKey:e}),getAddressData:a=>v({address:a,chain:t,apiKey:e}),scanUTXOs:a=>(async({address:e,chain:t,apiKey:a,fetchTxHex:s=!0})=>{const r=await W({chain:t,address:e,apiKey:a}),i=[];for(let{hash:n,index:o,script_hex:c,value:d}of r){let r;s&&(r=await K({txHash:n,chain:t,apiKey:a})),i.push({address:e,hash:n,index:o,txHex:r,value:d,witnessUtxo:{value:d,script:l.from(c,"hex")}})}return i})({...a,chain:t,apiKey:e})}),P="undefined"!==typeof f&&f.pid?f.pid.toString(36):"",H=e=>{switch(e){case o.sW.Bitcoin:return n.o8.bitcoin;case o.sW.BitcoinCash:return c.bitcoincash.main.toBitcoinJS();case o.sW.Dash:return c.dash.main.toBitcoinJS();case o.sW.Litecoin:return c.litecoin.main.toBitcoinJS();case o.sW.Dogecoin:{const e={private:70615956,public:70617039};return c.dogecoin.test.versions.bip32=e,c.dogecoin.main.toBitcoinJS()}default:throw new Error("Invalid chain")}},T=0,C=()=>P+(()=>{const e=Date.now(),t=T||e;return e>(T=t)?e:t+1})().toString(36),k=async({txHash:e,rpcUrl:t})=>{const a=JSON.stringify({jsonrpc:"2.0",method:"sendrawtransaction",params:[e],id:C()}),s=await o.R0.post(t,{headers:{"Content-Type":"application/json"},body:a});if(s.error)throw new Error(`failed to broadcast a transaction: ${s.error?.message}`);if(s.result.includes('"code":-26'))throw new Error("Invalid transaction: the transaction amount was too low");return s.result};(i=r||={}).Mainnet="mainnet",i.Testnet="testnet";var E,R=e=>{switch(e){case o.sW.Bitcoin:case o.sW.BitcoinCash:return 550;case o.sW.Dash:case o.sW.Litecoin:return 5500;case o.sW.Dogecoin:return 1e5;default:throw new Error("Invalid Chain")}},$=({inputs:e,outputs:t,feeRate:a=1,chain:s=o.sW.Bitcoin})=>{const r=Math.ceil(a),i=e[0]&&"address"in e[0]&&e[0].address?A(e[0].address):"P2PKH",n=e.filter((e=>S(e)*r<=e.value)),c=B+t.reduce(((e,t)=>e+I(t,i)),0),d=t.reduce(((e,t)=>e+t.value),0);let u=c*r,h=0;const p=[];for(let o of n){const e=S(o);u+=r*e,h+=o.value,p.push(o);const a=u+d;if(h<a)continue;const n=h-a,c=r*I({address:"",value:0},i);if(n>c){const e=c+u,a=h-(d+e);if(a>Math.max(S({})*r,R(s)))return{inputs:p,outputs:t.concat({value:a,address:""}),fee:e}}return{inputs:p,outputs:t,fee:u}}return{fee:r*M({inputs:e,outputs:t,feeRate:r})}},B=10,F=e=>{const t=l.from(e,"utf8");return n.K$.compile([n.Ez.OP_RETURN,t])};(e=>{e.P2PKH="P2PKH",e.P2WPKH="P2WPKH"})(E||={});var D={P2PKH:148,P2WPKH:68},_={P2PKH:34,P2WPKH:31},A=e=>{if(e.startsWith("bc1")||e.startsWith("ltc1"))return"P2WPKH";if(e.startsWith("1")||e.startsWith("3")||e.startsWith("L")||e.startsWith("M")||e.startsWith("X")||e.startsWith("D")||e.startsWith("bitcoincash:q")||e.startsWith("q"))return"P2PKH";throw new Error("Invalid address")},M=({inputs:e,outputs:t,feeRate:a})=>{const s=e[0]&&"address"in e[0]&&e[0].address?A(e[0].address):"P2PKH",r=e.filter((e=>e.value>=D["type"in e?e.type:"P2PKH"]*Math.ceil(a))).reduce(((e,t)=>e+S(t)),0),i=t?.reduce(((e,t)=>e+I(t)),0)||_[s];return B+r+i},S=e=>"type"in e?D[e.type]:"address"in e&&e.address?D[A(e.address)]:148,I=(e,t)=>e?.script?10+e.script.length+(e.script.length>=74?2:1):t?_[t]:_.P2PKH,O=[o.sW.Dash,o.sW.Dogecoin],U=({phrase:e,wif:t,derivationPath:r,chain:i})=>{if(!t&&!e)throw new Error("Either phrase or wif must be provided");const n=(0,u.dg)(s||(s=a.t(d,2))),o=H(i);if(t)return n.fromWIF(t,o);const c=(0,p.kw)(e),f=h.c.fromMasterSeed(c,o).derive(r);if(!f.privateKey)throw new Error("Could not get private key from phrase");return n.fromPrivateKey(l.from(f.privateKey),{network:o})},L=({address:e,chain:t})=>{try{return(0,n.f0)(s||(s=a.t(d,2))),n.hl.toOutputScript(e,H(t)),!0}catch(i){return!1}},V=async e=>(e=>({[o.ok.Average]:e,[o.ok.Fast]:1.5*e,[o.ok.Fastest]:2*e}))(await e.getSuggestedTxFee()),q=async({assetValue:e,recipient:t,memo:a,sender:s,fetchTxHex:r=!1,apiClient:i})=>({inputs:await i.scanUTXOs({address:s,fetchTxHex:r}),outputs:[{address:t,value:Number(e.bigIntValue)},...a?[{address:"",script:F(a),value:0}]:[]]}),J=async({assetValue:e,recipient:t,memo:r,feeRate:i,sender:c,fetchTxHex:u=!1,apiClient:h,chain:p})=>{const f=r?F(r):null,w=await q({assetValue:e,recipient:t,memo:r,sender:c,fetchTxHex:u,apiClient:h}),{inputs:y,outputs:m}=$({...w,feeRate:i,chain:p});if(!y||!m)throw new Error("Insufficient Balance for transaction");const x=new n.iL({network:H(p)});p===o.sW.Dogecoin&&x.setMaximumFeeRate(65e7);for(let a of y)x.addInput({hash:a.hash,index:a.index,...!!a.witnessUtxo&&!O.includes(p)&&{witnessUtxo:a.witnessUtxo},...O.includes(p)&&{nonWitnessUtxo:a.txHex?l.from(a.txHex,"hex"):void 0}});for(let o of m){const e="address"in o&&o.address?o.address:c,t=o.script?f?{script:f,value:0}:void 0:{address:e,value:o.value};t&&((0,n.f0)(s||(s=a.t(d,2))),x.addOutput(t))}return{psbt:x,utxos:w.inputs,inputs:y}},z=async({assetValue:e,apiClient:t,chain:a,feeOptionKey:s=o.ok.Fast,feeRate:r,fetchTxHex:i=!1,memo:n,recipient:c,from:d})=>{const u=await q({assetValue:e,recipient:c,memo:n,sender:d,fetchTxHex:i,apiClient:t}),h=r?Math.floor(r):(await V(t))[s];return $({...u,feeRate:h,chain:a})},N=e=>({accumulative:$,apiClient:e.apiClient,broadcastTx:e.broadcastTx,calculateTxSize:M,buildTx:t=>J({...t,...e}),getAddressFromKeys:t=>(({keys:e,chain:t})=>{if(!e)throw new Error("Keys must be provided");const a=O.includes(t)?n.KT.p2pkh:n.KT.p2wpkh,{address:s}=a({pubkey:e.publicKey,network:H(t)});if(!s)throw new Error("Address not defined");return s})({keys:t,...e}),validateAddress:t=>L({address:t,...e}),createKeysForPath:t=>U({...t,...e}),getPrivateKeyFromMnemonic:async t=>U({...e,...t}).toWIF(),getBalance:async(t,a)=>(async({address:e,chain:t,apiClient:a})=>{const s=(await a.getBalance(e)||0)/10**o.Z$[t];return[await o.An.from({asset:`${t}.${t}`,value:s})]})({address:t,...e}),getFeeRates:()=>V(e.apiClient),transfer:t=>(async({signTransaction:e,from:t,memo:a,recipient:s,chain:r,apiClient:i,feeOptionKey:n,broadcastTx:c,feeRate:d,assetValue:u})=>{if(!t)throw new Error("From address must be provided");if(!s)throw new Error("Recipient address must be provided");const h=d||(await V(i))[n||o.ok.Fast],{psbt:p}=await J({recipient:s,feeRate:h,sender:t,fetchTxHex:O.includes(r),chain:r,apiClient:i,assetValue:u,memo:a}),l=await e(p);return l.finalizeAllInputs(),c(l.extractTransaction().toHex())})({...t,...e}),getInputsOutputsFee:t=>z({...t,...e}),estimateTransactionFee:async t=>o.An.from({chain:e.chain,value:new o.Lm({value:(await z({...t,...e})).fee,decimal:8}).getValue("string")}),estimateMaxSendableAmount:async t=>(async({from:e,memo:t,feeRate:a,feeOptionKey:s=o.ok.Fast,recipients:r=1,chain:i,apiClient:n})=>{const c=await n.getAddressData(e),d=a?Math.ceil(a):(await V(n))[s],u=c?.utxo.map((e=>({...e,type:"P2PKH",hash:""}))).filter((e=>e.value>Math.max(R(i),S(e)*d)));if(!u?.length)return o.An.from({chain:i});const h=o.An.from({chain:i,value:u.reduce(((e,t)=>e+t.value),0)}),p="number"===typeof r?Array.from({length:r},(()=>({address:e,value:0}))):r;if(t){const a=F(t);p.push({address:e,script:a,value:0})}const l=M({inputs:u,outputs:p,feeRate:d})*d;return h.sub(l)})({...t,...e})}),X=(o.sW.BitcoinCash,e=>({apiKey:t,rpcUrl:a=o.OV[e],apiClient:s})=>N({chain:e,broadcastTx:e=>k({txHash:e,rpcUrl:a}),apiClient:s||b({apiKey:t,chain:e})})),j=X(o.sW.Bitcoin);X(o.sW.Dash),X(o.sW.Dogecoin),X(o.sW.Litecoin)}}]);
//# sourceMappingURL=380.a6d1d229.chunk.js.map