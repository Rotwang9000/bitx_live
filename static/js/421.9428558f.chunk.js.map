{"version":3,"file":"static/js/421.9428558f.chunk.js","mappings":"8PAMM,SAAUA,EAAaC,GAiEzB,OA/DAC,eAAsBC,EAAmBC,IACrCC,EAAAA,EAAAA,IAAkB,MAAXD,IAAoBA,EAAQE,UAAW,mCAAoC,aAElF,MAAMC,EAAWJ,EAAIK,IAAIC,MAAM,KAAK,GAAGC,eAEvCL,EAAAA,EAAAA,IAAoB,SAAbE,GAAoC,UAAbA,EAAsB,wBAAyBA,IAAa,wBAAyB,CAC/GI,KAAM,CAAEJ,YACRK,UAAW,aAGfP,EAAAA,EAAAA,IAAoB,UAAbE,IAAyBJ,EAAIU,aAAeV,EAAIW,4BAA6B,8CAA+C,wBAAyB,CACxJF,UAAW,YAGf,IAAIG,EAAsB,KAE1B,MAAMC,EAAa,IAAIC,gBAEjBC,EAAQC,YAAW,KACrBJ,GAAQK,EAAAA,EAAAA,IAAU,kBAAmB,WACrCJ,EAAWK,OAAO,GACnBlB,EAAImB,SAEHlB,GACAA,EAAQmB,aAAY,KAChBR,GAAQK,EAAAA,EAAAA,IAAU,oBAAqB,aACvCJ,EAAWK,OAAO,IAI1B,MAAMG,EAAO,CACTC,OAAQtB,EAAIsB,OACZC,QAAS,IAAIC,QAAQC,MAAMC,KAAK1B,IAChC2B,KAAM3B,EAAI2B,WAAQC,EAClBC,OAAQhB,EAAWgB,QAGvB,IAAIC,EACJ,IACIA,QAAaC,MAAM/B,EAAIK,IAAKgB,E,CAC9B,MAAOW,GAEL,GADAC,aAAalB,GACTH,EAAS,MAAMA,EACnB,MAAMoB,C,CAGVC,aAAalB,GAEb,MAAMQ,EAAkC,CAAC,EACzCO,EAAKP,QAAQW,SAAQ,CAACC,EAAOC,KACzBb,EAAQa,EAAI7B,eAAiB4B,CAAK,IAGtC,MAAME,QAAiBP,EAAKQ,cACtBX,EAAoB,MAAZU,EAAoB,KAAM,IAAIE,WAAWF,GAEvD,MAAO,CACHG,WAAYV,EAAKW,OACjBC,cAAeZ,EAAKa,WACpBpB,UAASI,OAEjB,CAGJ,CAGuC9B,ICIvC,IAAI+C,EAAqC/C,IAEzC,MAAMgD,EAAS,IAAIC,OAAO,kCAAmC,KACvDC,EAAS,IAAID,OAAO,wBAA0B,KAGpD,IAAIE,GAAS,EAGbjD,eAAekD,EAAgB5C,EAAawB,GACxC,IACI,MAAMqB,EAAQ7C,EAAI6C,MAAML,GACxB,IAAKK,EAAS,MAAM,IAAIC,MAAM,gBAC9B,OAAO,IAAIC,EAAc,IAAK,KAAM,CAChC,eAAiBF,EAAM,IAAM,cAC7BA,EAAM,GCtFZ,SAAuBG,GACzBA,EAAWC,KAAKD,GAChB,MAAME,EAAO,IAAIhB,WAAWc,EAASG,QACrC,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAASG,OAAQC,IACjCF,EAAKE,GAAKJ,EAASK,WAAWD,GAElC,OAAOE,EAAAA,EAAAA,IAASJ,EACpB,CD+EuBK,CAAaV,EAAM,KAm2BvBf,EAn2BsCe,EAAM,IAo2BpDW,EAAAA,EAAAA,IAAY1B,EAAM2B,QAAQ,yBAAyB,CAACC,EAAKC,IACrDC,OAAOC,aAAaC,SAASH,EAAM,S,CAp2B5C,MAAOpD,GACL,OAAO,IAAIwC,EAAc,IAAK,kCAAmC,CAAC,EAAI,KAAM,IAAIgB,EAAa/D,G,CAi2BrG,IAAmB8B,CA/1BnB,CAMA,SAASkC,EAAmBC,GAWxB,OAVAvE,eAA2BM,EAAawB,GACpC,IACI,MAAMqB,EAAQ7C,EAAI6C,MAAMH,GACxB,IAAKG,EAAS,MAAM,IAAIC,MAAM,gBAC9B,OAAO,IAAIiB,EAAa,GAAIE,IAAYpB,EAAM,K,CAChD,MAAOtC,GACL,OAAO,IAAIwC,EAAc,IAAK,iCAAkC,CAAC,EAAI,KAAM,IAAIgB,EAAa/D,G,CAEpG,CAGJ,CAEA,MAAMkE,EAA6C,CAC/C,KAAQtB,EACR,KAAQoB,EAAmB,kCAGzBG,EAAkD,IAAIC,QAKtD,MAAOC,EACT,GACA,GAEAC,WAAAA,CAAYC,GACRC,MAAK,EAAa,GAClBA,MAAK,GAAa,EAElBL,EAAaM,IAAIF,GAAS,KACtB,IAAIC,MAAK,EAAT,CACAA,MAAK,GAAa,EAElB,IAAK,MAAME,KAAYF,MAAK,EACxB7D,YAAW,KAAQ+D,GAAU,GAAK,GAEtCF,MAAK,EAAa,E,CAAG,GAE7B,CAEAzD,WAAAA,CAAY2D,IACR7E,EAAAA,EAAAA,KAAQ2E,MAAK,EAAY,2BAA4B,wBAAyB,CAC1EpE,UAAW,wCAEfoE,MAAK,EAAWG,KAAKD,EACzB,CAEA,aAAI5E,GAAuB,OAAO0E,MAAK,CAAY,CAEnDI,WAAAA,IACI/E,EAAAA,EAAAA,KAAQ2E,KAAK1E,UAAW,YAAa,YAAa,CAAC,EACvD,EAIJ,SAAS8E,EAAYpD,GACjB,GAAc,MAAVA,EAAkB,MAAM,IAAIsB,MAAM,qCAEtC,OADAtB,EAAOoD,cACApD,CACX,CAgBM,MAAOuC,EACT,GACA,GACA,GACA,GACA,GACA,GAEA,GACA,GACA,GAGA,GACA,GACA,GAEA,GAEA,GAEA,GAKA,OAAI/D,GAAgB,OAAOwE,MAAK,CAAM,CACtC,OAAIxE,CAAIA,GACJwE,MAAK,EAAOZ,OAAO5D,EACvB,CAqBA,QAAIsB,GACA,OAAkB,MAAdkD,MAAK,EAAwB,KAC1B,IAAItC,WAAWsC,MAAK,EAC/B,CACA,QAAIlD,CAAKA,GACL,GAAY,MAARA,EACAkD,MAAK,OAAQjD,EACbiD,MAAK,OAAYjD,OACd,GAAqB,kBAAVD,EACdkD,MAAK,GAAQhB,EAAAA,EAAAA,IAAYlC,GACzBkD,MAAK,EAAY,kBACd,GAAIlD,aAAgBY,WACvBsC,MAAK,EAAQlD,EACbkD,MAAK,EAAY,+BACd,IAAqB,kBAAVlD,EAId,MAAM,IAAIwB,MAAM,gBAHhB0B,MAAK,GAAQhB,EAAAA,EAAAA,IAAYqB,KAAKC,UAAUxD,IACxCkD,MAAK,EAAY,kB,CAIzB,CAKAO,OAAAA,GACI,OAAsB,MAAdP,MAAK,CACjB,CAOA,UAAIvD,GACA,OAAIuD,MAAK,EAAkBA,MAAK,EAC5BA,KAAKO,UAAoB,OACtB,KACX,CACA,UAAI9D,CAAOA,GACO,MAAVA,IAAkBA,EAAS,IAC/BuD,MAAK,EAAUZ,OAAO3C,GAAQ+D,aAClC,CAWA,WAAI9D,GACA,MAAMA,EAAU+D,OAAOC,OAAO,CAAC,EAAIV,MAAK,GAexC,OAbIA,MAAK,IACLtD,EAAuB,cAAI,SChRjC,SAAuBiE,GACzB,MAAMjC,GAAOI,EAAAA,EAAAA,IAAS6B,GACtB,IAAInC,EAAW,GACf,IAAK,IAAII,EAAI,EAAGA,EAAIF,EAAKC,OAAQC,IAC7BJ,GAAYY,OAAOC,aAAaX,EAAKE,IAEzC,OAAOgC,KAAKpC,EAChB,CDyQiDqC,EAAa7B,EAAAA,EAAAA,IAAYgB,MAAK,OAGnEA,KAAKc,YACLpE,EAAQ,mBAAqB,QAGF,MAA3BA,EAAQ,iBAA2BsD,MAAK,IACxCtD,EAAQ,gBAAkBsD,MAAK,GAE/BA,KAAKlD,OAAQJ,EAAQ,kBAAoB0C,OAAOY,KAAKlD,KAAK6B,SAEvDjC,CACX,CAKAqE,SAAAA,CAAUxD,GACN,OAAOyC,KAAKtD,QAAQa,EAAI7B,cAC5B,CAMAsF,SAAAA,CAAUzD,EAAaD,GACnB0C,MAAK,EAASZ,OAAO7B,GAAK7B,eAAiB0D,OAAO9B,EACtD,CAKA2D,YAAAA,GACIjB,MAAK,EAAW,CAAC,CACrB,CAEA,CAACkB,OAAOC,YACJ,MAAMzE,EAAUsD,KAAKtD,QACf0E,EAAOX,OAAOW,KAAK1E,GACzB,IAAI2E,EAAQ,EACZ,MAAO,CACHC,KAAMA,KACF,GAAID,EAAQD,EAAKzC,OAAQ,CACrB,MAAMpB,EAAM6D,EAAKC,KACjB,MAAO,CACH/D,MAAO,CAAEC,EAAKb,EAAQa,IAAQgE,MAAM,E,CAG5C,MAAO,CAAEjE,WAAOP,EAAWwE,MAAM,EAAM,EAGnD,CAOA,eAAI1F,GACA,OAAOmE,MAAK,GAAU,IAC1B,CAKAwB,cAAAA,CAAeC,EAAkBC,IAC7BC,EAAAA,EAAAA,KAAgBF,EAASpD,MAAM,KAAM,wCAAyC,WAAY,cAC1F2B,MAAK,EAAS,GAAIyB,KAAcC,GACpC,CAMA,aAAIZ,GACA,OAAOd,MAAK,CAChB,CACA,aAAIc,CAAUxD,GACV0C,MAAK,IAAU1C,CACnB,CAMA,+BAAIxB,GACA,QAASkE,MAAK,CAClB,CACA,+BAAIlE,CAA4BwB,GAC5B0C,MAAK,IAAmB1C,CAC5B,CAMA,WAAIhB,GAAoB,OAAO0D,MAAK,CAAU,CAC9C,WAAI1D,CAAQA,IACRqF,EAAAA,EAAAA,IAAerF,GAAW,EAAG,2BAA4B,UAAWA,GACpE0D,MAAK,EAAW1D,CACpB,CASA,iBAAIsF,GACA,OAAO5B,MAAK,GAAc,IAC9B,CACA,iBAAI4B,CAAcC,GACd7B,MAAK,EAAa6B,CACtB,CAYA,eAAIC,GACA,OAAO9B,MAAK,GAAY,IAC5B,CACA,eAAI8B,CAAYC,GACZ/B,MAAK,EAAW+B,CACpB,CAKA,aAAIC,GACA,OAAOhC,MAAK,GAAU,IAC1B,CACA,aAAIgC,CAAUC,GACVjC,MAAK,EAASiC,CAClB,CAiBA,cAAIC,GACA,OAAOlC,MAAK,GAAejC,CAC/B,CACA,cAAImE,CAAW5E,GACX0C,MAAK,EAAc1C,CACvB,CAQAwC,WAAAA,CAAYtE,GACRwE,MAAK,EAAOZ,OAAO5D,GAEnBwE,MAAK,GAAiB,EACtBA,MAAK,GAAQ,EACbA,MAAK,EAAW,CAAC,EACjBA,MAAK,EAAU,GACfA,MAAK,EAAW,IAEhBA,MAAK,EAAY,CACbmC,aA3YU,IA4YVC,YA7YS,IAgZbpC,MAAK,EAAc,IACvB,CAEAqC,QAAAA,GACI,MAAO,wBAAyBhC,KAAKC,UAAUN,KAAKvD,eAAiB4D,KAAKC,UAAUN,KAAKxE,gBAAkB6E,KAAKC,UAAUN,KAAKtD,iBAAmBsD,MAAK,GAAQsC,EAAAA,EAAAA,IAAQtC,MAAK,GAAQ,SACxL,CAMAuC,iBAAAA,CAAkBC,GACa,MAAvBA,EAAOL,eACPnC,MAAK,EAAUmC,aAAeK,EAAOL,cAEf,MAAtBK,EAAOJ,cACPpC,MAAK,EAAUoC,YAAcI,EAAOJ,YAE5C,CAEA,OAAM,CAAMK,EAAiBC,EAAiBC,EAAeC,EAAwBC,GACjF,GAAIJ,GAAWzC,MAAK,EAAUoC,YAC1B,OAAOS,EAAUC,gBAAgB,iCAGrCzH,EAAAA,EAAAA,IAAO0H,KAAaL,EAAS,UAAW,UAAW,CAC/C9G,UAAW,eAAgBoH,OAAQ,UAAWjD,QAAS6C,IAGvDD,EAAQ,SA+cpB,SAAcA,GACV,OAAO,IAAIM,SAASC,GAAY/G,WAAW+G,EAASP,IACxD,CAjd+BQ,CAAKR,GAE5B,IAAIxH,EAAM6E,KAAKoD,QACf,MAAMC,GAAUlI,EAAIK,IAAIC,MAAM,KAAK,IAAM,IAAIC,cAG7C,GAAI2H,KAAU3D,EAAU,CACpB,MAAM4D,QAAe5D,EAAS2D,GAAQlI,EAAIK,IAAK4E,EAAYwC,GAAS,IACpE,GAAIU,aAAkB/E,EAAe,CACjC,IAAIgF,EAAWD,EAEf,GAAItD,KAAK8B,YAAa,CAClB1B,EAAYwC,GAAS,GACrB,IACIW,QAAiBvD,KAAK8B,YAAY3G,EAAKoI,E,CACzC,MAAOxH,GAGiB,MAAlBA,EAAMyH,UAA4C,kBAAjBzH,EAAM0H,OACvCF,EAAST,gBAAgB,oCAAqC/G,GAAO2H,U,EAOjF,OAAOH,C,CAEXpI,EAAMmI,C,CAINtD,KAAK4B,gBAAiBzG,QAAY6E,KAAK4B,cAAczG,IAEzD,MAAM8B,QAAa+C,KAAKkC,WAAW/G,EAAKiF,EAAYwC,GAAS,IAC7D,IAAIW,EAAW,IAAIhF,EAActB,EAAKU,WAAYV,EAAKY,cAAeZ,EAAKP,QAASO,EAAKH,KAAM8F,GAE/F,GAA4B,MAAxBW,EAAS5F,YAA8C,MAAxB4F,EAAS5F,WAAoB,CAG5D,IACI,MAAMgG,EAAWJ,EAAS7G,QAAQiH,UAAY,GAC9C,OAAOxI,EAAIyI,SAASD,IAAU,EAAMlB,EAAU,EAAGC,EAAS,EAAGE,EAAUW,E,CACzE,MAAOxH,GAAQ,CAGjB,OAAOwH,C,CAEJ,GAA4B,MAAxBA,EAAS5F,aAGM,MAAlBqC,KAAKgC,iBAA4BhC,KAAKgC,UAAU7G,EAAKoI,EAAUd,IAAW,CAC1E,MAAMoB,EAAaN,EAAS7G,QAAQ,eACpC,IAAIiG,EAAQ3C,MAAK,EAAUmC,aAAe2B,KAAKC,MAAMD,KAAKE,SAAWF,KAAKG,IAAI,EAAGxB,IAIjF,MAH2B,kBAAhBoB,GAA4BA,EAAWxF,MAAM,mBACpDsE,EAAQrD,SAASuE,IAEd1I,EAAIiI,SAAQ,EAAMX,EAAU,EAAGC,EAASC,EAAOC,EAAUW,E,CAIxE,GAAIvD,KAAK8B,YAAa,CAClB1B,EAAYwC,GAAS,GACrB,IACIW,QAAiBvD,KAAK8B,YAAY3G,EAAKoI,E,CACzC,MAAOxH,GAGiB,MAAlBA,EAAMyH,UAA4C,kBAAjBzH,EAAM0H,OACvCF,EAAST,gBAAgB,oCAAqC/G,GAAO2H,WAIzE,IAAIf,EAAQ3C,MAAK,EAAUmC,aAAe2B,KAAKC,MAAMD,KAAKE,SAAWF,KAAKG,IAAI,EAAGxB,IAGjF,OAFI1G,EAAM0H,OAAS,IAAKd,EAAQ5G,EAAM0H,OAE/BtI,EAAIiI,SAAQ,EAAMX,EAAU,EAAGC,EAASC,EAAOC,EAAUW,E,EAIxE,OAAOA,CACX,CAKAW,IAAAA,GAGI,OAFA7I,EAAAA,EAAAA,IAAuB,MAAhB2E,MAAK,EAAiB,uBAAwB,wBAAyB,CAAEpE,UAAW,sBAC3FoE,MAAK,EAAU,IAAIH,EAAkBG,MAC9BA,MAAK,EAAM,EAAG+C,IAAY/C,KAAK1D,QAAS,EAAG0D,KAAM,IAAIzB,EAAc,EAAG,GAAI,CAAC,EAAI,KAAMyB,MAChG,CAMAmE,MAAAA,IACI9I,EAAAA,EAAAA,IAAuB,MAAhB2E,MAAK,EAAiB,4BAA6B,wBAAyB,CAAEpE,UAAW,wBAChG,MAAMoB,EAAS2C,EAAayE,IAAIpE,MAChC,IAAKhD,EAAU,MAAM,IAAIsB,MAAM,qCAC/BtB,GACJ,CAMA4G,QAAAA,CAASD,GAEL,MAAMU,EAAUrE,KAAKxE,IAAIC,MAAM,KAAK,GAAGC,cACjC4I,EAASX,EAASlI,MAAM,KAAK,GAAGC,eAMtCL,EAAAA,EAAAA,IAAuB,QAAhB2E,KAAKvD,SAAiC,UAAZ4H,GAAkC,SAAXC,IAAsBX,EAAStF,MAAM,YAAa,uBAAwB,wBAAyB,CACvJzC,UAAW,YAAaoE,KAAKvD,UAAY4D,KAAKC,UAAUN,KAAKxE,WAAa6E,KAAKC,UAAUqD,QAI7F,MAAMxI,EAAM,IAAIoE,EAAaoE,GAa7B,OAZAxI,EAAIsB,OAAS,MACbtB,EAAI2F,UAAYd,KAAKc,UACrB3F,EAAImB,QAAU0D,KAAK1D,QACnBnB,GAAI,EAAWsF,OAAOC,OAAO,CAAC,EAAIV,MAAK,GACnCA,MAAK,IAAS7E,GAAI,EAAQ,IAAIuC,WAAWsC,MAAK,IAClD7E,GAAI,EAAY6E,MAAK,EAOd7E,CACX,CAKAiI,KAAAA,GACI,MAAMA,EAAQ,IAAI7D,EAAaS,KAAKxE,KA4BpC,OAzBA4H,GAAM,EAAUpD,MAAK,EAGjBA,MAAK,IAASoD,GAAM,EAAQpD,MAAK,GACrCoD,GAAM,EAAYpD,MAAK,EAGvBoD,GAAM,EAAW3C,OAAOC,OAAO,CAAC,EAAIV,MAAK,GAGzCoD,GAAM,EAASpD,MAAK,EAEhBA,KAAKc,YAAasC,EAAMtC,WAAY,GAExCsC,EAAM9G,QAAU0D,KAAK1D,QACjB0D,KAAKlE,8BAA+BsH,EAAMtH,6BAA8B,GAE5EsH,GAAM,EAAapD,MAAK,EACxBoD,GAAM,EAAWpD,MAAK,EACtBoD,GAAM,EAASpD,MAAK,EAEpBoD,GAAM,EAAY3C,OAAOC,OAAO,CAAC,EAAIV,MAAK,GAE1CoD,GAAM,EAAcpD,MAAK,EAElBoD,CACX,CAMA,iBAAOmB,GACHpG,GAAS,CACb,CAKA,iBAAOqG,CAAWnB,GACd,OAAO3D,EAAS2D,EAAO3H,gBAAkB,IAC7C,CAUA,sBAAO+I,CAAgBpB,EAAgBqB,GAEnC,GAAe,UADfrB,EAASA,EAAO3H,gBACoB,UAAX2H,EACrB,MAAM,IAAI/E,MAAM,oBAAqB+E,yBAEzC,GAAIlF,EAAU,MAAM,IAAIG,MAAM,mBAC9BoB,EAAS2D,GAAUqB,CACvB,CAUA,qBAAOC,CAAeC,GAClB,GAAIzG,EAAU,MAAM,IAAIG,MAAM,mBAC9BP,EAAoB6G,CACxB,CAaA,uBAAOC,CAAiB5J,GACpB,OAAOD,GACX,CAWA,wBAAO8J,GACH,OAAO1G,CACX,CASA,4BAAO2G,CAAsBtF,GACzB,OAAOD,EAAmBC,EAC9B,EAYE,MAAOlB,EACT,GACA,GACA,GACA,GACA,GAEA,GAEA8D,QAAAA,GACI,MAAO,yBAA0BrC,KAAKrC,mBAAqBqC,MAAK,GAAQsC,EAAAA,EAAAA,IAAQtC,MAAK,GAAQ,SACjG,CAKA,cAAIrC,GAAuB,OAAOqC,MAAK,CAAa,CAKpD,iBAAInC,GAA0B,OAAOmC,MAAK,CAAgB,CAK1D,WAAItD,GAAoC,OAAO+D,OAAOC,OAAO,CAAC,EAAIV,MAAK,EAAW,CAKlF,QAAIlD,GACA,OAAsB,MAAdkD,MAAK,EAAiB,KAAM,IAAItC,WAAWsC,MAAK,EAC5D,CAQA,YAAIgF,GACA,IACI,OAAsB,MAAdhF,MAAK,EAAiB,IAAIiF,EAAAA,EAAAA,IAAajF,MAAK,E,CACtD,MAAOjE,IACLV,EAAAA,EAAAA,KAAO,EAAO,wCAAyC,wBAAyB,CAC5EO,UAAW,WAAYD,KAAM,CAAE4H,SAAUvD,O,CAGrD,CAQA,YAAIkF,GACA,IACI,OAAO7E,KAAK8E,MAAMnF,KAAKgF,S,CACzB,MAAOjJ,IACLV,EAAAA,EAAAA,KAAO,EAAO,kCAAmC,wBAAyB,CACtEO,UAAW,WAAYD,KAAM,CAAE4H,SAAUvD,O,CAGrD,CAEA,CAACkB,OAAOC,YACJ,MAAMzE,EAAUsD,KAAKtD,QACf0E,EAAOX,OAAOW,KAAK1E,GACzB,IAAI2E,EAAQ,EACZ,MAAO,CACHC,KAAMA,KACF,GAAID,EAAQD,EAAKzC,OAAQ,CACrB,MAAMpB,EAAM6D,EAAKC,KACjB,MAAO,CACH/D,MAAO,CAAEC,EAAKb,EAAQa,IAAQgE,MAAM,E,CAG5C,MAAO,CAAEjE,WAAOP,EAAWwE,MAAM,EAAM,EAGnD,CAEAzB,WAAAA,CAAYnC,EAAoBE,EAAuBnB,EAA2CI,EAAyBiD,GACvHC,MAAK,EAAcrC,EACnBqC,MAAK,EAAiBnC,EACtBmC,MAAK,EAAWS,OAAOW,KAAK1E,GAAS0I,QAAO,CAACC,EAAOC,KAChDD,EAAMC,EAAE5J,eAAiB0D,OAAO1C,EAAQ4I,IACjCD,IACgB,CAAC,GAC5BrF,MAAK,EAAkB,MAARlD,EAAgB,KAAM,IAAIY,WAAWZ,GACpDkD,MAAK,EAAYD,GAAW,KAE5BC,MAAK,EAAS,CAAEuF,QAAS,GAC7B,CAOAzC,eAAAA,CAAgByC,EAAkBxJ,GAC9B,IAAI8B,EAKAA,EAJC0H,EAIe,kCAAmCvF,KAAKrC,cAAgBqC,KAAKnC,kBAAoB0H,KAFjF,kCADhBA,EAAU,GAAIvF,KAAKrC,cAAgBqC,KAAKnC,mBAK5C,MAAM0F,EAAW,IAAIhF,EAAc,IAAKV,EAAemC,KAAKtD,QACxDsD,KAAKlD,KAAMkD,MAAK,QAAYjD,GAEhC,OADAwG,GAAS,EAAS,CAAEgC,UAASxJ,SACtBwH,CACX,CAOAiC,kBAAAA,CAAmBD,EAAkB9B,GACpB,MAATA,EACAA,GAAS,GAET9B,EAAAA,EAAAA,IAAe8D,OAAOC,UAAUjC,IAAUA,GAAS,EAAG,wBAAyB,QAASA,GAG5F,MAAM1H,EAAQ,IAAIuC,MAAMiH,GAAW,uBAInC,MAFAI,EAAAA,EAAAA,GAAgC5J,EAAO,CAAE0H,QAAOD,UAAU,IAEpDzH,CACV,CAKAgF,SAAAA,CAAUxD,GACN,OAAOyC,KAAKtD,QAAQa,EAAI7B,cAC5B,CAKA6E,OAAAA,GACI,OAAsB,MAAdP,MAAK,CACjB,CAKA,WAAID,GAAiC,OAAOC,MAAK,CAAU,CAK3D4F,EAAAA,GACI,MAAgC,KAAxB5F,MAAK,EAAOuF,SAAkBvF,KAAKrC,YAAc,KAAOqC,KAAKrC,WAAa,GACtF,CAKA+F,QAAAA,GACI,GAAI1D,KAAK4F,KAAQ,OACjB,IAAI,QAAEL,EAAO,MAAExJ,GAAUiE,MAAK,EACd,KAAZuF,IACAA,EAAU,mBAAoBvF,KAAKrC,cAAgBqC,KAAKnC,iBAG5D,IAAIgI,EAA4B,KAC5B7F,KAAKD,UAAW8F,EAAa7F,KAAKD,QAAQvE,KAE9C,IAAIsK,EAA8B,KAClC,IACQ9F,MAAK,IAAS8F,GAAeb,EAAAA,EAAAA,IAAajF,MAAK,G,CACrD,MAAO+F,GAAI,EAEb1K,EAAAA,EAAAA,KAAO,EAAOkK,EAAS,eAAgB,CACnCxF,QAAUC,KAAKD,SAAW,kBAAoBwD,SAAUvD,KAAMjE,QAC9DJ,KAAM,CACFkK,aAAYC,eACZE,eAAgB,GAAIhG,KAAKrC,cAAgBqC,KAAKnC,kBAE1D,EAIJ,SAASkF,IAAoB,OAAQ,IAAIkD,MAAQlD,SAAW,C,gDEt7B5D,MAAMmD,EAAQ,IAAIxI,WAAW,IAG7B,SAASyI,EAAeC,GAEpB,OADAzE,EAAAA,EAAAA,IAA+B,IAAhByE,EAAKzH,OAAc,oCAAqC,OAAQyH,GACxEA,CACX,CAEA,SAASC,EAAaC,GAClB,MAAMC,GAAQvH,EAAAA,EAAAA,IA0BZ,SAAuBsH,GACzB,IACI,GAAoB,IAAhBA,EAAK3H,OAAgB,MAAM,IAAIL,MAAM,eACzC,OAAOkI,EAAAA,EAAAA,IAAcF,E,CACvB,MAAOvK,IACL4F,EAAAA,EAAAA,KAAe,EAAO,qBAAsB5F,EAAMwJ,WAAa,OAAQe,E,CAE/E,CAjC8BG,CAAaH,IACjCI,EAA2B,GAEjC,GAAoB,IAAhBJ,EAAK3H,OAAgB,OAAO+H,EAEhC,IAAIC,EAAO,EACX,IAAK,IAAI/H,EAAI,EAAGA,EAAI2H,EAAM5H,OAAQC,IAAK,CAIzB,KAHA2H,EAAM3H,KAIZ8H,EAAMvG,KAAKgG,EAAeI,EAAMK,MAAMD,EAAM/H,KAC5C+H,EAAO/H,EAAI,E,CAQnB,OAHA+C,EAAAA,EAAAA,IAAegF,EAAOJ,EAAM5H,OAAQ,oCAAqC,OAAQ2H,GAEjFI,EAAMvG,KAAKgG,EAAeI,EAAMK,MAAMD,KAC/BD,CACX,CA2BM,SAAUG,EAASP,IACrB3E,EAAAA,EAAAA,IAAgC,kBAAV2E,EAAoB,iCAAkC,OAAQA,IAEpF3E,EAAAA,EAAAA,IAAe2E,EAAK3H,OAAQ,iCAAkC,OAAQ2H,GAEtE,IAAIhD,EAA8B4C,EAElC,MAAMQ,EAAQL,EAAaC,GAC3B,KAAOI,EAAM/H,QACT2E,GAASwD,EAAAA,EAAAA,IAAUC,EAAAA,EAAAA,IAAO,CAAEzD,GAAQwD,EAAAA,EAAAA,GAAuBJ,EAAMM,UAGrE,OAAO1E,EAAAA,EAAAA,IAAQgB,EACnB,CAQM,SAAU2D,EAAUX,EAAcY,GACpC,MAAMvI,EAAwB,MAAduI,EAAsBA,EAAY,GAIlD,OAFAvF,EAAAA,EAAAA,IAAehD,GAAU,IAAK,sCAAuC,SAAUA,IAExE2D,EAAAA,EAAAA,KAAQyE,EAAAA,EAAAA,IAAOV,EAAaC,GAAMa,KAAKf,KAC1CzE,EAAAA,EAAAA,IAAeyE,EAAKzH,QAAUA,EAAQ,SAAU0B,KAAKC,UAAUgG,cAAmB3H,UAAiB,OAAQ2H,GAE3G,MAAMC,EAAQ,IAAI7I,WAAW0I,EAAKzH,OAAS,GAG3C,OAFA4H,EAAMtG,IAAImG,EAAM,GAChBG,EAAM,GAAKA,EAAM5H,OAAS,EACnB4H,CAAK,MACT,IACX,CA1FAL,EAAMkB,KAAK,G,qCCkBX,SAASC,EAAYC,GASjB,OARIA,EAAKjJ,MAAM,qBACXiJ,EAAOA,EAAKC,UAAU,IACfD,EAAKjJ,MAAM,eAClBiJ,EAAOA,EAAKC,UAAU,IAEtB5F,EAAAA,EAAAA,KAAe,EAAO,0BAA2B,OAAQ2F,GAGtD,gCAAkCA,GAC7C,CAqDM,MAAgBE,EAITlB,KAKTxG,WAAAA,CAAYwG,IACRX,EAAAA,EAAAA,GAA0C3F,KAAM,CAAEsG,QACtD,CAEAmB,OAAAA,CAAQC,GACJ,OAAO1H,IACX,CAKA2H,gBAAAA,CAAiBC,GACb,OAAO,CACX,CAKA,mBAAMC,CAAcD,EAAkBE,GAClC,MAAM,IAAIxJ,MAAM,mBACpB,CAKA,mBAAMyJ,CAAcH,EAAkBlJ,GAClC,MAAM,IAAIJ,MAAM,mBACpB,EAmBJ,MAAM0J,EAAc,IAAI/J,OAAO,kBAAoB,KAC7CgK,EAAW,CACb,IAAIhK,OAAO,mBAAqB,KAChC,IAAIA,OAAO,gBAAiB,KAC5B+J,EACA,IAAI/J,OAAO,mCAAoC,MAO7C,MAAOiK,EAITC,SAKAL,QAKAxB,KAGA,GAEA,GAEAxG,WAAAA,CAAYqI,EAA4BL,EAAiBxB,IACrDX,EAAAA,EAAAA,GAA8B3F,KAAM,CAAEmI,WAAUL,UAASxB,SACzDtG,MAAK,EAAgB,KAErBA,MAAK,EAAY,IAAIoI,EAAAA,GAASN,EAAS,CACnC,yDACA,sDACA,gDACA,oDACA,uDACA,sDACDK,EAEP,CAKA,sBAAME,GAkBF,OAjB0B,MAAtBrI,MAAK,IACLA,MAAK,EAAgB,WACjB,IACI,aAAaA,MAAK,EAAUsI,kBAAkB,a,CAChD,MAAOvM,GAGL,IAAIwM,EAAAA,EAAAA,IAAQxM,EAAO,kBAAqB,OAAO,EAK/C,MAFAiE,MAAK,EAAgB,KAEfjE,C,CAEb,EAboB,UAgBZiE,MAAK,CACtB,CAEA,OAAM,CAAOwI,EAAkBhG,GAC3BA,GAAUA,GAAU,IAAIoE,QACxB,MAAM6B,EAAQzI,MAAK,EAAU0I,UAG7BlG,EAAOmG,QAAQ9B,EAAS7G,KAAKsG,OAE7B,IAAIsC,EAAoC,WAC9B5I,KAAKqI,qBACXO,EAAWH,EAAMI,YAAYL,IAC7BnN,EAAAA,EAAAA,IAAOuN,EAAU,mBAAoB,gBAAiB,CAClDjN,KAAM,CAAE6M,cAGZhG,EAAS,CACLyE,EAAUjH,KAAKsG,KAAM,KACrBmC,EAAMK,mBAAmBF,EAAUpG,IAGvCgG,EAAW,wBAGfhG,EAAOrC,KAAK,CACR4I,gBAAgB,IAGpB,IACI,MAAMzF,QAAetD,MAAK,EAAUwI,MAAahG,GAEjD,OAAIoG,EACOH,EAAMO,qBAAqBJ,EAAUtF,GAAQ,GAGjDA,C,CACT,MAAOvH,GACL,KAAKwM,EAAAA,EAAAA,IAAQxM,EAAO,kBAAqB,MAAMA,C,CAGnD,OAAO,IACX,CAMA,gBAAMkN,CAAWrB,GAEb,GADgB,MAAZA,IAAoBA,EAAW,IAClB,KAAbA,EACA,IACI,MAAMtE,QAAetD,MAAK,EAAO,iBAGjC,OAAc,MAAVsD,GAAkBA,IAAW4F,EAAAA,EAAsB,KAEhD5F,C,CACT,MAAOvH,GACL,IAAIwM,EAAAA,EAAAA,IAAQxM,EAAO,kBAAqB,OAAO,KAC/C,MAAMA,C,CAKd,GAAI6L,GAAY,GAAKA,EAAW,WAAY,CACxC,IAAIuB,EAAcvB,EAAW,WAE7B,MAAMlJ,QAAasB,MAAK,EAAO,qBAAsB,CAAEmJ,IACvD,IAAIC,EAAAA,EAAAA,IAAY1K,EAAM,IAAO,OAAOuK,EAAAA,EAAAA,GAAWvK,E,CAGnD,IAAI2K,EAA6C,KACjD,IAAK,MAAMC,KAAUtJ,KAAKmI,SAASoB,QAC/B,GAAMD,aAAkB9B,GACpB8B,EAAO3B,iBAAiBC,GAAW,CACnCyB,EAAaC,EACb,K,CAIR,GAAkB,MAAdD,EAAsB,OAAO,KAGjC,MAAM3K,QAAasB,MAAK,EAAO,qBAAsB,CAAE4H,IAGvD,GAAY,MAARlJ,GAAyB,OAATA,EAAiB,OAAO,KAG5C,MAAMoJ,QAAgBuB,EAAWtB,cAAcH,EAAUlJ,GAEzD,GAAe,MAAXoJ,EAAmB,OAAOA,GAE9BzM,EAAAA,EAAAA,KAAO,EAAO,oBAAqB,wBAAyB,CACxDO,UAAW,cAAegM,KAC1BjM,KAAM,CAAEiM,WAAUlJ,SAE1B,CAMA,aAAM8K,CAAQjM,GACV,MAAMmB,QAAasB,MAAK,EAAO,uBAAwB,CAAEzC,IACzD,OAAY,MAARmB,GAAyB,OAATA,EAAwB,KACrCA,CACX,CAKA,oBAAM+K,GAEF,MAAM/K,QAAasB,MAAK,EAAO,wBAG/B,GAAY,MAARtB,GAAyB,OAATA,EAAiB,OAAO,KAG5C,MAAMgL,EAAOhL,EAAKL,MAAM,4EACxB,GAAIqL,EAAM,CACN,MAAMrG,EAAsB,aAAZqG,EAAK,GAAqB,OAAQ,OAC5C/K,EAASW,SAASoK,EAAK,GAAI,IACjC,GAAIA,EAAK,GAAG/K,SAAoB,EAATA,EACnB,MAAO,GAAI0E,QAAesG,EAAAA,EAAAA,GAAa,KAAOD,EAAK,K,CAK3D,MAAME,EAAQlL,EAAKL,MAAM,iCACzB,GAAIuL,GAA6B,KAApBA,EAAM,GAAGjL,OAClB,MAAO,SAAWiL,EAAM,MAG5BvO,EAAAA,EAAAA,KAAO,EAAO,2CAA4C,wBAAyB,CAC/EO,UAAW,mBACXD,KAAM,CAAE+C,SAEhB,CAUA,eAAMmL,GAEF,aADqB7J,KAAK8J,cACZtO,GAClB,CAUA,gBAAMsO,GACF,MAAMC,EAAgC,CAAE,CAAEC,KAAM,OAAQ1M,MAAO0C,KAAKsG,OACpE,IAGI,MAAM2D,QAAejK,KAAKwJ,QAAQ,UAClC,GAAc,MAAVS,EAEA,OADAF,EAAQ5J,KAAK,CAAE6J,KAAM,UAAW1M,MAAO,KAChC,CAAE9B,IAAK,KAAMuO,WAExBA,EAAQ5J,KAAK,CAAE6J,KAAM,SAAU1M,MAAO2M,IAEtC,IAAK,IAAIrL,EAAI,EAAGA,EAAIqJ,EAAStJ,OAAQC,IAAK,CACtC,MAAMP,EAAQ4L,EAAO5L,MAAM4J,EAASrJ,IACpC,GAAa,MAATP,EAAiB,SAErB,MAAMgF,EAAShF,EAAM,GAAG3C,cAExB,OAAQ2H,GACJ,IAAK,QACL,IAAK,OAED,OADA0G,EAAQ5J,KAAK,CAAE6J,KAAM,MAAO1M,MAAO2M,IAC5B,CAAEF,UAASvO,IAAKyO,GAC3B,IAAK,OAAQ,CACT,MAAMzO,EAAM6L,EAAY4C,GAGxB,OAFAF,EAAQ5J,KAAK,CAAE6J,KAAM,OAAQ1M,MAAO2M,IACpCF,EAAQ5J,KAAK,CAAE6J,KAAM,MAAO1M,MAAO9B,IAC5B,CAAEuO,UAASvO,M,CAGtB,IAAK,SACL,IAAK,UAAW,CAEZ,MAAM0O,EAAuB,WAAX7G,EAAuB,oBAAqB,eAC9D0G,EAAQ5J,KAAK,CAAE6J,KAAM3G,EAAQ/F,MAAO2M,IAGpC,MAAME,QAAcnK,KAAKiJ,aACzB,GAAa,MAATkB,EAEA,OADAJ,EAAQ5J,KAAK,CAAE6J,KAAM,SAAU1M,MAAO,KAC/B,CAAE9B,IAAK,KAAMuO,WAGxB,MAAMrD,GAASrI,EAAM,IAAM,IAAI5C,MAAM,KACrC,GAAqB,IAAjBiL,EAAM/H,OAEN,OADAoL,EAAQ5J,KAAK,CAAE6J,KAAW,IAAK3G,QAAe/F,MAAQe,EAAM,IAAM,KAC3D,CAAE7C,IAAK,KAAMuO,WAGxB,MAAMK,EAAU1D,EAAM,GAEhB2D,EAAW,IAAIjC,EAAAA,GAAS1B,EAAM,GAAI,CAEpC,gDACA,gDAGA,2CACA,4DACD1G,KAAKmI,UAGR,GAAe,WAAX9E,EAAqB,CACrB,MAAMiH,QAAmBD,EAASE,QAAQH,GAE1C,GAAID,IAAUG,EAEV,OADAP,EAAQ5J,KAAK,CAAE6J,KAAM,SAAU1M,MAAOgN,IAC/B,CAAE9O,IAAK,KAAMuO,WAExBA,EAAQ5J,KAAK,CAAE6J,KAAM,QAAS1M,MAAOgN,G,MAElC,GAAe,YAAXjH,EAAsB,CAC7B,MAAMmH,QAAgBH,EAASI,UAAUN,EAAOC,GAChD,IAAKI,EAED,OADAT,EAAQ5J,KAAK,CAAE6J,KAAM,WAAY1M,MAAO,MACjC,CAAE9B,IAAK,KAAMuO,WAExBA,EAAQ5J,KAAK,CAAE6J,KAAM,UAAW1M,MAAOkN,EAAQnI,Y,CAInD,IAAIqI,QAAoBL,EAASH,GAAUE,GAC3C,GAAmB,MAAfM,GAAuC,OAAhBA,EAEvB,OADAX,EAAQ5J,KAAK,CAAE6J,KAAM,gBAAiB1M,MAAO,KACtC,CAAE9B,IAAK,KAAMuO,WAGxBA,EAAQ5J,KAAK,CAAE6J,KAAM,oBAAqB1M,MAAOoN,IAGlC,YAAXrH,IACAqH,EAAcA,EAAYzL,QAAQ,QAAQ0L,EAAAA,EAAAA,IAAQP,EAAS,IAAI7C,UAAU,IACzEwC,EAAQ5J,KAAK,CAAE6J,KAAM,wBAAyB1M,MAAOoN,KAIrDA,EAAYrM,MAAM,aAClBqM,EAAcrD,EAAYqD,IAE9BX,EAAQ5J,KAAK,CAAE6J,KAAM,eAAgB1M,MAAOoN,IAG5C,IAAIE,EAAgB,CAAC,EACrB,MAAMrH,QAAkB,IAAIhE,EAAamL,GAAcxG,OACvDX,EAASG,WAET,IACIkH,EAAWrH,EAAS2B,Q,CACtB,MAAOnJ,GACL,IACIgO,EAAQ5J,KAAK,CAAE6J,KAAM,YAAa1M,MAAOiG,EAASyB,U,CACpD,MAAOjJ,GACL,MAAMwK,EAAQhD,EAASzG,KAIvB,OAHIyJ,GACAwD,EAAQ5J,KAAK,CAAE6J,KAAM,YAAa1M,OAAOgF,EAAAA,EAAAA,IAAQiE,KAE9C,CAAE/K,IAAK,KAAMuO,U,CAExB,MAAO,CAAEvO,IAAK,KAAMuO,U,CAGxB,IAAKa,EAED,OADAb,EAAQ5J,KAAK,CAAE6J,KAAM,YAAa1M,MAAO,KAClC,CAAE9B,IAAK,KAAMuO,WAGxBA,EAAQ5J,KAAK,CAAE6J,KAAM,WAAY1M,MAAO+C,KAAKC,UAAUsK,KAGvD,IAAIC,EAAWD,EAASE,MACxB,GAAyB,kBAAdD,EAEP,OADAd,EAAQ5J,KAAK,CAAE6J,KAAM,YAAa1M,MAAO,KAClC,CAAE9B,IAAK,KAAMuO,WAGxB,GAAIc,EAASxM,MAAM,6BAEZ,CAGH,GAAY,MADCwM,EAASxM,MAAM2J,GAGxB,OADA+B,EAAQ5J,KAAK,CAAE6J,KAAM,iBAAkB1M,MAAOuN,IACvC,CAAErP,IAAK,KAAMuO,WAGxBA,EAAQ5J,KAAK,CAAE6J,KAAM,gBAAiB1M,MAAOuN,IAC7CA,EAAWxD,EAAYwD,E,CAK3B,OAFAd,EAAQ5J,KAAK,CAAE6J,KAAM,MAAO1M,MAAOuN,IAE5B,CAAEd,UAASvO,IAAKqP,E,IAIrC,MAAO9O,GAAQ,CAEjB,MAAO,CAAEgO,UAASvO,IAAK,KAC3B,CAEA,0BAAauP,CAAc5C,GACvB,MAAM6C,QAAgB7C,EAAS8C,aAEzBC,EAAYF,EAAQG,UAAqB,kCAM/C,OAHA9P,EAAAA,EAAAA,IAAO6P,EAAW,+BAAgC,wBAAyB,CACvEtP,UAAW,gBAAiBD,KAAM,CAAEqP,aAEjCE,EAAUpD,OACrB,CAEA,cAAa,CAAaK,EAAoB7B,GAC1C,MAAM8E,QAAgBlD,EAAY6C,cAAc5C,GAEhD,IACI,MAAMkC,EAAW,IAAIjC,EAAAA,GAASgD,EAAS,CACnC,qDACDjD,GAEGkD,QAAahB,EAASiB,SAASzE,EAASP,GAAO,CACjDyC,gBAAgB,IAGpB,OAAIsC,IAASnC,EAAAA,EAAsB,KAC5BmC,C,CAET,MAAOtP,GAGL,MAAMA,C,CAGV,OAAO,IACX,CAMA,qBAAawP,CAASpD,EAA4B7B,GAE9C,IAAIkF,EAAclF,EAClB,OAAa,CACT,GAAoB,KAAhBkF,GAAsC,MAAhBA,EAAuB,OAAO,KAIxD,GAAa,QAATlF,GAAkC,QAAhBkF,EAAyB,OAAO,KAGtD,MAAMH,QAAanD,GAAY,EAAaC,EAAUqD,GAGtD,GAAY,MAARH,EAAc,CACd,MAAMC,EAAW,IAAIpD,EAAYC,EAAUkD,EAAM/E,GAGjD,OAAIkF,IAAgBlF,SAAgBgF,EAASjD,mBAEtCiD,EAFoE,I,CAM/EE,EAAcA,EAAY/P,MAAM,KAAKmL,MAAM,GAAG6E,KAAK,I,CAE3D,E,8BC3kBJ,MAAMC,EAAOC,OAAO,GAId,SAAUC,EAAUC,EAAoBC,GAC1C,OAAQ,SAASxO,GACb,OAAa,MAATA,EAAwBwO,EACrBD,EAAOvO,EAClB,CACJ,CAEM,SAAUyO,EAAQF,EAAoBD,GACxC,OAASI,IACL,GAAIJ,GAAsB,MAATI,EAAiB,OAAO,KACzC,IAAKpP,MAAMqP,QAAQD,GAAU,MAAM,IAAI1N,MAAM,gBAC7C,OAAO0N,EAAM7E,KAAKvI,GAAMiN,EAAOjN,IAAG,CAE1C,CAKM,SAAUsN,EAAOL,EAAoCM,GACvD,OAAS7O,IACL,MAAMgG,EAAc,CAAC,EACrB,IAAK,MAAM/F,KAAOsO,EAAQ,CACtB,IAAIO,EAAS7O,EACb,GAAI4O,GAAY5O,KAAO4O,KAAcC,KAAU9O,GAC3C,IAAK,MAAM+O,KAAUF,EAAS5O,GAC1B,GAAI8O,KAAU/O,EAAO,CACjB8O,EAASC,EACT,K,CAKZ,IACI,MAAMC,EAAKT,EAAOtO,GAAKD,EAAM8O,SAClBrP,IAAPuP,IAAoBhJ,EAAO/F,GAAO+O,E,CACxC,MAAOvQ,GACL,MAAMwJ,EAAWxJ,aAAiBuC,MAASvC,EAAMwJ,QAAS,gBAC1DlK,EAAAA,EAAAA,KAAO,EAAO,2BAA4BkC,MAAUgI,KAAa,WAAY,CAAEjI,S,EAGvF,OAAOgG,CAAM,CAErB,CAYM,SAAUiJ,EAAWjP,GAEvB,OADAqE,EAAAA,EAAAA,KAAeyH,EAAAA,EAAAA,IAAY9L,GAAO,GAAO,eAAgB,QAASA,GAC3DA,CACX,CAEM,SAAUkP,EAAWlP,GAEvB,OADAqE,EAAAA,EAAAA,KAAeyH,EAAAA,EAAAA,IAAY9L,EAAO,IAAK,eAAgB,QAASA,GACzDA,CACX,CASA,MAAMmP,EAAaP,EAAO,CACtBpE,QAASmB,EAAAA,EACTyD,UAAWF,EACXG,YAAaC,EAAAA,GACblO,KAAM6N,EACNlL,MAAOuL,EAAAA,GACPC,QAASjB,GAjCP,SAAwBtO,GAC1B,OAAQA,GACJ,KAAK,EAAM,IAAK,OACZ,OAAO,EACX,KAAK,EAAO,IAAK,QACb,OAAO,GAEfqE,EAAAA,EAAAA,KAAe,EAAO,oBAAqBtB,KAAKC,UAAUhD,KAAW,QAASA,EAClF,IAyBsC,GAClCwP,OAAQf,EAAQS,GAChBO,gBAAiBP,EACjBQ,iBAAkBJ,EAAAA,IACnB,CACCvL,MAAO,CAAE,cAOb,MAAM4L,EAAef,EAAO,CACxBgB,KAAMtB,EAAUY,GAChBW,WAAYX,EACZY,sBAAuBxB,EAAUY,EAAY,MAE7Ca,OAAQT,EAAAA,GAERU,UAAWV,EAAAA,GACXW,MAAO3B,EAAUW,GACjBiB,WAAYC,EAAAA,GAEZC,SAAUD,EAAAA,GACVE,QAASF,EAAAA,GAETG,UAAWhC,EAAUY,EAAY,MACjCqB,aAAcjC,EAAUY,EAAY,MAEpCsB,YAAalC,EAAU6B,EAAAA,GAAW,MAClCM,cAAenC,EAAU6B,EAAAA,GAAW,MAEpCO,MAAOpC,EAAU3C,EAAAA,GACjBgF,WAAYrC,EAAUY,EAAY,MAClC0B,UAAW3B,EAEX4B,cAAevC,EAAU6B,EAAAA,KAC1B,CACCQ,WAAY,CAAE,aAYlB,MAAMG,GAAoBlC,EAAO,CAC7Bc,iBAAkBJ,EAAAA,GAClBD,YAAaC,EAAAA,GACbG,gBAAiBP,EACjB1E,QAASmB,EAAAA,EACT6D,OAAQf,EAAQS,GAChB9N,KAAM6N,EACNlL,MAAOuL,EAAAA,GACPF,UAAWF,GACZ,CACCnL,MAAO,CAAE,cAOb,MAAMgN,GAA4BnC,EAAO,CACrCoC,GAAI1C,EAAU3C,EAAAA,EAAY,MAC1BpM,KAAM+O,EAAU3C,EAAAA,EAAY,MAC5BsF,gBAAiB3C,EAAU3C,EAAAA,EAAY,MAEvC5H,MAAOuL,EAAAA,GACP4B,KAAM5C,EAAUtJ,EAAAA,IAChBqL,QAASF,EAAAA,GACTK,YAAalC,EAAU6B,EAAAA,GAAW,MAClCgB,UAAW7C,EAAUW,GACrBG,UAAWF,EACXU,KAAMV,EACNkC,KAAM3C,GAhBJ,SAA2BzO,GAC7B,OAAO8Q,GAAkB9Q,EAC7B,IAeIqP,YAAaC,EAAAA,GAEb+B,kBAAmBlB,EAAAA,GACnBmB,kBAAmBhD,EAAU6B,EAAAA,IAC7BoB,aAAcjD,EAAU6B,EAAAA,GAAW,MACnC7P,OAAQgO,EAAUgB,EAAAA,IAClB5C,KAAM4B,EAAUgB,EAAAA,GAAW,IAC5B,CACCgC,kBAAmB,CAAE,YACrB1B,KAAM,CAAE,mBACR7L,MAAO,CAAE,sBAOP,SAAUyN,GAA0BxR,GAIlCA,EAAMgR,KAAMb,EAAAA,EAAAA,IAAUnQ,EAAMgR,MAAQ5C,IACpCpO,EAAMgR,GAAK,8CAGf,MAAMhL,EAAS4I,EAAO,CAClBgB,KAAMV,EAGNnL,MAAOuK,EAAUgB,EAAAA,QAAW7P,GAE5BiN,KAAO1M,GACW,OAAVA,GAA2B,MAATA,EAAwB,GACvCsP,EAAAA,EAAAA,IAAUtP,GAErByR,WAAYnD,EAAUoD,EAAAA,EAAe,MACrCC,oBAAqBrD,EAAUG,EAAQS,GAAY,GAAO,MAE1DE,UAAWd,EAAUY,EAAY,MACjCG,YAAaf,EAAUgB,EAAAA,GAAW,MAClCI,iBAAkBpB,EAAUgB,EAAAA,GAAW,MAEvC/P,KAAMoM,EAAAA,EAGNiG,SAAUtD,EAAU6B,EAAAA,IACpB0B,qBAAsBvD,EAAU6B,EAAAA,IAChC2B,aAAcxD,EAAU6B,EAAAA,IACxB4B,iBAAkBzD,EAAU6B,EAAAA,GAAW,MAEvCC,SAAUD,EAAAA,GACVa,GAAI1C,EAAU3C,EAAAA,EAAY,MAC1B3L,MAAOmQ,EAAAA,GACPF,MAAOX,EAAAA,GACPlO,KAAM6N,EAEN+C,QAAS1D,EAAU3C,EAAAA,EAAY,MAE/BsG,QAAS3D,EAAU6B,EAAAA,GAAW,OAC/B,CACC/O,KAAM,CAAE,SACRgP,SAAU,CAAE,OACZrM,MAAO,CAAE,qBArCE6K,CAsCZ5O,GAsBH,GAnBiB,MAAbgG,EAAOgL,IAAgC,MAAlBhL,EAAOgM,UAC5BhM,EAAOgM,QCvNT,SAA2BE,GAC7B,MAAM3S,GAAOoM,EAAAA,EAAAA,GAAWuG,EAAG3S,MAG3B,IAAI4S,GAFUhC,EAAAA,EAAAA,IAAU+B,EAAGjC,MAAO,YAEblL,SAAS,IAS9B,OAPIoN,EADa,MAAbA,EACW,KACJA,EAAS9Q,OAAS,EACd,MAAQ8Q,EAER,KAAOA,GAGfxG,EAAAA,EAAAA,IAAWyG,EAAAA,EAAAA,KAAU5I,EAAAA,EAAAA,IAAU6I,EAAAA,EAAAA,GAAU,CAAE9S,EAAM4S,KAAc,IAC1E,CDyMyBG,CAAiBtM,IAMlB,IAAfhG,EAAM0M,MAA6B,IAAf1M,EAAM0M,MAAmC,MAApB1M,EAAMyR,aAChDzL,EAAOyL,WAAa,IAIpBzR,EAAMuS,UACNvM,EAAOuM,UAAYC,EAAAA,EAAUjT,KAAKS,EAAMuS,WAExCvM,EAAOuM,UAAYC,EAAAA,EAAUjT,KAAKS,GAIhB,MAAlBgG,EAAOiM,QAAiB,CACxB,MAAMA,EAAUjM,EAAOuM,UAAUE,cAClB,MAAXR,IAAmBjM,EAAOiM,QAAUA,E,CA4C5C,OAJIjM,EAAOoJ,YAAae,EAAAA,EAAAA,IAAUnK,EAAOoJ,aAAehB,IACpDpI,EAAOoJ,UAAY,MAGhBpJ,CACX,CEzSM,MAAO0M,GAOA1J,KAKTxG,WAAAA,CAAYwG,IACRX,EAAAA,EAAAA,GAAgC3F,KAAM,CAAEsG,QAC5C,CAKAlD,KAAAA,GACI,OAAO,IAAI4M,GAAchQ,KAAKsG,KAClC,EA+CE,MAAO2J,WAAsBD,GAOtBE,eAKAC,OAKAC,SAKAC,WAKAC,cAKAC,uBAKAC,oBAQT1Q,WAAAA,CAAYoQ,EAAyBO,GACX,MAAlBP,IAA0BA,EAAiB,GAC/CQ,MAAM,sCAAwCR,GAAkB,KAEhE,MAAMS,EAAgC,CAAET,kBACxC,SAASjQ,EAAIqG,EAA+BsK,GACxC,IAAItT,GAASmT,GAAS,CAAC,GAAInK,GACd,MAAThJ,IAAiBA,EAAQsT,IAC7BjP,EAAAA,EAAAA,IAAiC,kBAAXrE,EAAqB,qBAAsBgJ,IAAS,QAASmK,GACnFE,EAAMrK,GAAQhJ,CAClB,CAEA2C,EAAI,SAAU,MACdA,EAAI,WAAY,MAChBA,EAAI,aAAc,GAClBA,EAAI,gBAAiB,IACrBA,EAAI,yBAA0B,MAC9BA,EAAI,sBAAuB,OAE3B0F,EAAAA,EAAAA,GAAgC3F,KAAM2Q,EAC1C,CAEAvN,KAAAA,GACI,OAAO,IAAI6M,GAAcjQ,KAAKkQ,eAAgBlQ,KAClD,EAYE,MAAO6Q,WAAkBb,GAKlBlI,QAKAgJ,cAOThR,WAAAA,CAAYgI,EAAyBgJ,GACjCJ,MAAM,mCACN/K,EAAAA,EAAAA,GAA4B3F,KAAM,CAC9B8H,QAAUA,GA9KH,6CA+KPgJ,cAAkC,MAAjBA,EAAyB,EAAGA,GAErD,CAEA1N,KAAAA,GACI,OAAO,IAAIyN,GAAU7Q,KAAK8H,QAAS9H,KAAK8Q,cAC5C,EAwCE,MAAOC,WAAqCf,GACrC,GACA,GAKT,OAAIxU,GAAgB,OAAOwE,MAAK,CAAM,CAKtC,eAAI8B,GAAwL,OAAO9B,MAAK,CAAc,CAMtNF,WAAAA,CAAYtE,EAAasG,GACrB4O,MAAM,oDACN1Q,MAAK,EAAOxE,EACZwE,MAAK,EAAe8B,CACxB,CAGAsB,KAAAA,GAAwC,OAAOpD,IAAM,ECrMzD,MAAMgR,GAAgD,IAAIC,IAOpD,MAAOC,GACT,GACA,GAEA,GAKApR,WAAAA,CAAYwG,EAAciJ,GACtBvP,MAAK,EAAQsG,EACbtG,MAAK,GAAWyN,EAAAA,EAAAA,IAAU8B,GAC1BvP,MAAK,EAAW,IAAIiR,GACxB,CAKAE,MAAAA,GACI,MAAO,CAAE7K,KAAMtG,KAAKsG,KAAMiJ,QAASnQ,OAAOY,KAAKuP,SACnD,CAQA,QAAIjJ,GAAiB,OAAOtG,MAAK,CAAO,CACxC,QAAIsG,CAAKhJ,GAAiB0C,MAAK,EAAS1C,CAAO,CAK/C,WAAIiS,GAAoB,OAAOvP,MAAK,CAAU,CAC9C,WAAIuP,CAAQjS,GAAuB0C,MAAK,GAAWyN,EAAAA,EAAAA,IAAUnQ,EAAO,UAAY,CAShF8T,OAAAA,CAAQC,GACJ,GAAa,MAATA,EAAiB,OAAO,EAE5B,GAAsB,kBAAXA,EAAqB,CAC5B,IACI,OAAQrR,KAAKuP,WAAY9B,EAAAA,EAAAA,IAAU4D,E,CACrC,MAAOtV,GAAQ,CACjB,OAAQiE,KAAKsG,OAAS+K,C,CAG1B,GAAsB,kBAAXA,GAAyC,kBAAXA,EAAqB,CAC1D,IACI,OAAQrR,KAAKuP,WAAY9B,EAAAA,EAAAA,IAAU4D,E,CACrC,MAAOtV,GAAQ,CACjB,OAAO,C,CAGX,GAAsB,kBAAXsV,EAAqB,CAC5B,GAAqB,MAAjBA,EAAM9B,QAAiB,CACvB,IACI,OAAQvP,KAAKuP,WAAY9B,EAAAA,EAAAA,IAAU4D,EAAM9B,Q,CAC3C,MAAOxT,GAAQ,CACjB,OAAO,C,CAEX,OAAkB,MAAdsV,EAAM/K,MACEtG,KAAKsG,OAAS+K,EAAM/K,I,CAKpC,OAAO,CACX,CAKA,WAAIiD,GACA,OAAO3M,MAAMC,KAAKmD,MAAK,EAASsR,SACpC,CAMAC,YAAAA,CAAajI,GACT,GAAItJ,MAAK,EAASoE,IAAIkF,EAAOhD,MACzB,MAAM,IAAIhI,MAAM,mCAAoCgL,EAAOhD,SAG/D,OADAtG,MAAK,EAASC,IAAIqJ,EAAOhD,KAAMgD,EAAOlG,SAC/BpD,IACX,CAOAmL,SAAAA,CAAmD7E,GAC/C,OAAWtG,MAAK,EAASoE,IAAIkC,IAAU,IAC3C,CAMAkL,UAAAA,CAAoDC,GAChD,OAAkBzR,KAAKuJ,QAAQmI,QAAQC,GAAOA,EAAErL,KAAK7K,MAAM,KAAK,KAAOgW,GAC3E,CAKArO,KAAAA,GACI,MAAMA,EAAQ,IAAI8N,GAAQlR,KAAKsG,KAAMtG,KAAKuP,SAI1C,OAHAvP,KAAKuJ,QAAQlM,SAASiM,IAClBlG,EAAMmO,aAAajI,EAAOlG,QAAQ,IAE/BA,CACX,CAQAwO,mBAAAA,CAAoBpC,GAChB,MAAMiB,EAAQzQ,KAAKmL,UAAyB,uCAA0C,IAAI8E,GAE1F,IAAI4B,EAAMpB,EAAMN,OAEhB,GADa,MAATX,EAAGlB,KAAcuD,GAAOpB,EAAML,UAC9BZ,EAAG9Q,KACH,IAAK,IAAIE,EAAI,EAAGA,EAAI4Q,EAAG9Q,KAAKC,OAAQC,GAAK,EACD,OAAhC4Q,EAAG9Q,KAAK6I,UAAU3I,EAAGA,EAAI,GACzBiT,GAAOpB,EAAMJ,WAEbwB,GAAOpB,EAAMH,cAKzB,GAAId,EAAGT,WAAY,CACf,MAAMA,GAAaC,EAAAA,EAAAA,GAAcQ,EAAGT,YACpC,IAAK,MAAM1D,KAAQ0D,EACf8C,GAAOpB,EAAMD,oBAAsBC,EAAMF,uBAAyBxB,EAAW1D,GAAMyG,YAAYnT,M,CAIvG,OAAOkT,CACX,CAKA,WAAOhV,CAAKmO,GAIR,GA4HR,WACI,GAAI+G,GAAY,OAIhB,SAASC,EAAY1L,EAAciJ,EAAiBtU,GAChD,MAAMyJ,EAAO,WACT,MAAMsG,EAAU,IAAIkG,GAAQ5K,EAAMiJ,GAalC,OAV0B,MAAtBtU,EAAQgX,YACRjH,EAAQuG,aAAa,IAAIV,GAAU,KAAM5V,EAAQgX,aAGrDjH,EAAQuG,aAAa,IAAItB,KAExBhV,EAAQsO,SAAW,IAAIlM,SAASiM,IAC7B0B,EAAQuG,aAAajI,EAAO,IAGzB0B,CACX,EAGAkG,GAAQgB,SAAS5L,EAAM5B,GACvBwM,GAAQgB,SAAS3C,EAAS7K,GAEtBzJ,EAAQkR,UACRlR,EAAQkR,SAAS9O,SAASiJ,IACtB4K,GAAQgB,SAAS5L,EAAM5B,EAAK,GAGxC,CA9BAqN,IAAW,EAgCXC,EAAY,UAAW,EAAG,CAAEC,WAAY,EAAG9F,SAAU,CAAE,eACvD6F,EAAY,UAAW,EAAG,CAAEC,WAAY,IACxCD,EAAY,UAAW,EAAG,CAAEC,WAAY,IACxCD,EAAY,SAAU,EAAG,CAAEC,WAAY,IACvCD,EAAY,QAAS,GAAI,CAAEC,WAAY,KACvCD,EAAY,UAAW,SAAU,CAAEC,WAAY,WAC/CD,EAAY,UAAW,KAAO,CAAEC,WAAY,OAE5CD,EAAY,UAAW,GAAI,CAAC,GAC5BA,EAAY,eAAgB,EAAG,CAAC,GAEhCA,EAAY,WAAY,MAAO,CAC3BC,WAAY,IAEhBD,EAAY,kBAAmB,OAAQ,CAAC,GACxCA,EAAY,mBAAoB,OAAQ,CAAC,GAEzCA,EAAY,OAAQ,KAAM,CAAEC,WAAY,IACxCD,EAAY,cAAe,MAAO,CAAC,GACnCA,EAAY,eAAgB,MAAO,CAAC,GAEpCA,EAAY,MAAO,GAAI,CAAEC,WAAY,IACrCD,EAAY,OAAQ,GAAI,CAAC,GAEzBA,EAAY,QAAS,MAAO,CAAEC,WAAY,IAC1CD,EAAY,eAAgB,MAAO,CAAC,GACpCA,EAAY,gBAAiB,MAAO,CAAC,GAErCA,EAAY,QAAS,IAAK,CACtBC,WAAY,EACZ1I,QAAS,CACL4I,GAAoB,+CAG5BH,EAAY,aAAc,MAAO,CAAC,GAClCA,EAAY,eAAgB,MAAO,CAC/B7F,SAAU,CAAE,cAAe,YAC3B5C,QAAS,CACL4I,GAAoB,uDAI5BH,EAAY,WAAY,GAAI,CACxBC,WAAY,EACZ1I,QAAS,KAEbyI,EAAY,kBAAmB,IAAK,CAAC,GACrCA,EAAY,mBAAoB,SAAU,CAAC,GAE3CA,EAAY,OAAQ,IAAK,CAAEC,WAAY,GAC3C,CAnNQG,GAGe,MAAXpH,EAAmB,OAAOkG,GAAQrU,KAAK,WAI3C,GADwB,kBAAbmO,IAAyBA,EAAUW,OAAOX,IAC7B,kBAAbA,GAA6C,kBAAbA,EAAuB,CAC9D,MAAMqH,EAAcrB,GAAS5M,IAAI4G,GACjC,GAAIqH,EAAe,OAAOA,IAC1B,GAAwB,kBAAbrH,EACP,OAAO,IAAIkG,GAAQ,UAAWlG,IAGlCrJ,EAAAA,EAAAA,KAAe,EAAO,kBAAmB,UAAWqJ,E,CAIxD,GAAyC,oBAApBA,EAAS5H,MAAuB,CAIjD,OAHwB4H,EAAS5H,O,CAOrC,GAAwB,kBAAb4H,EAAuB,EAC9BrJ,EAAAA,EAAAA,IAAwC,kBAAlBqJ,EAAQ1E,MAAkD,kBAArB0E,EAAQuE,QAC/D,yCAA0C,UAAWvE,GAEzD,MAAMsH,EAAS,IAAIpB,GAAiBlG,EAAQ1E,KAAgB0E,EAAQuE,SAUpE,OARUvE,EAASuH,YAA2C,MAAvBvH,EAASiH,aAC5CK,EAAOf,aAAa,IAAIV,GAAgB7F,EAASuH,WAAkBvH,EAASiH,aAOzEK,C,EAGX3Q,EAAAA,EAAAA,KAAe,EAAO,kBAAmB,UAAWqJ,EACxD,CAMA,eAAOkH,CAASM,EAAyCH,GACvB,kBAAnBG,IAA+BA,EAAgB7G,OAAO6G,IACjE,MAAMC,EAAWzB,GAAS5M,IAAIoO,GAC1BC,IACA9Q,EAAAA,EAAAA,KAAe,EAAO,2BAA4BtB,KAAKC,UAAUmS,EAASnM,QAAU,gBAAiBkM,GAEzGxB,GAAS/Q,IAAIuS,EAAeH,EAChC,EAcJ,SAASK,GAAWC,EAAyBC,GACzC,MAAMtV,EAAQ8B,OAAOuT,GACrB,IAAKrV,EAAMe,MAAM,aACb,MAAM,IAAIC,MAAM,uBAAwBqU,KAI5C,MAAMjM,EAAQpJ,EAAM7B,MAAM,KAI1B,GAHqB,IAAjBiL,EAAM/H,QAAgB+H,EAAMvG,KAAK,IAGhB,IAAjBuG,EAAM/H,OACN,MAAM,IAAIL,MAAM,uBAAwBqU,KAI5C,KAAOjM,EAAM,GAAG/H,OAASiU,GAAYlM,EAAM,IAAM,IAGjD,GAAIA,EAAM,GAAG/H,OAAS,EAAG,CACrB,IAAIkU,EAAOlH,OAAOjF,EAAM,GAAGa,UAAU,EAAG,IACnCb,EAAM,GAAGa,UAAU,GAAGlJ,MAAM,SAAWwU,IAC5CnM,EAAM,GAAKmM,EAAKxQ,U,CAGpB,OAAOsJ,OAAOjF,EAAM,GAAKA,EAAM,GACnC,CAGA,SAASyL,GAAoB3W,GACzB,OAAO,IAAIuV,GAA6BvV,GAAKN,MAAO4X,EAAc3K,EAAUpI,KAKxE,IAAIwD,EAFJxD,EAAQiB,UAAU,aAAc,UAGhC,IACI,MAAQ6B,EAAWkQ,SAAmB9P,QAAQ/D,IAAI,CAC9Ca,EAAQmE,OAAQ4O,MAEpBvP,EAAWV,EACX,MAAMmQ,EAAUzP,EAAS2B,SAAS+N,SAMlC,MALgB,CACZ/D,SAAU6D,EAAS7D,SACnBE,aAAcsD,GAAWM,EAAQE,OAAQ,GACzC/D,qBAAsBuD,GAAWM,EAAQG,eAAgB,G,CAG/D,MAAOpX,IACLV,EAAAA,EAAAA,KAAO,EAAO,+CAAgDgF,KAAKC,UAAUP,EAAQvE,QAAU,eAAgB,CAAEuE,UAASwD,WAAUxH,S,IAGhJ,CAGA,IAAIgW,IAAW,E,gBCxVf,SAASqB,GAAKC,GACV,OAAOhT,KAAK8E,MAAM9E,KAAKC,UAAU+S,GACrC,CAwBM,MAAOC,GACT,GACA,GAEA,GAIA,GAKAxT,WAAAA,CAAYqI,GACRnI,MAAK,EAAYmI,EACjBnI,MAAK,EAAU,KACfA,MAAK,EAAY,IAEjBA,MAAK,GAAgB,CACzB,CAKA,mBAAIuT,GAA4B,OAAOvT,MAAK,CAAW,CACvD,mBAAIuT,CAAgBjW,GAAiB0C,MAAK,EAAY1C,CAAO,CAE7D,OAAM,GACF,IACI,MAAMqP,QAAoB3M,MAAK,EAAUwT,iBAGzC,IAA2B,IAAvBxT,MAAK,EAEL,YADAA,MAAK,EAAe2M,GAMxB,GAAIA,IAAgB3M,MAAK,EAAc,CACnC,IAAK,IAAIyT,EAAIzT,MAAK,EAAe,EAAGyT,GAAK9G,EAAa8G,IAAK,CAEvD,GAAoB,MAAhBzT,MAAK,EAAmB,aAEtBA,MAAK,EAAU0T,KAAK,QAASD,E,CAGvCzT,MAAK,EAAe2M,C,EAG1B,MAAO5Q,GAGL,CAIgB,MAAhBiE,MAAK,IAETA,MAAK,EAAUA,MAAK,EAAU2T,YAAY3T,MAAK,EAAM4T,KAAK5T,MAAOA,MAAK,GAC1E,CAEA6T,KAAAA,GACQ7T,MAAK,IACTA,MAAK,EAAUA,MAAK,EAAU2T,YAAY3T,MAAK,EAAM4T,KAAK5T,MAAOA,MAAK,GACtEA,MAAK,IACT,CAEA8T,IAAAA,GACS9T,MAAK,IACVA,MAAK,EAAU+T,cAAc/T,MAAK,GAClCA,MAAK,EAAU,KACnB,CAEAgU,KAAAA,CAAMC,GACFjU,KAAK8T,OACDG,IAAmBjU,MAAK,GAAgB,EAChD,CAEAkU,MAAAA,GACIlU,KAAK6T,OACT,EAUE,MAAOM,GACT,GACA,GACA,GAKArU,WAAAA,CAAYqI,GACRnI,MAAK,EAAYmI,EACjBnI,MAAK,GAAW,EAChBA,MAAK,EAAS2M,IACV3M,KAAKoU,MAAMzH,EAAa3M,MAAK,EAAU,CAE/C,CAKA,WAAMoU,CAAMzH,EAAqBxE,GAC7B,MAAM,IAAI7J,MAAM,iCACpB,CAEAuV,KAAAA,GACQ7T,MAAK,IACTA,MAAK,GAAW,EAEhBA,MAAK,GAAO,GACZA,MAAK,EAAUqU,GAAG,QAASrU,MAAK,GACpC,CAEA8T,IAAAA,GACS9T,MAAK,IACVA,MAAK,GAAW,EAEhBA,MAAK,EAAUsU,IAAI,QAAStU,MAAK,GACrC,CAEAgU,KAAAA,CAAMC,GAAmCjU,KAAK8T,MAAQ,CACtDI,MAAAA,GAAiBlU,KAAK6T,OAAS,EAG7B,MAAOU,WAAkCJ,GAClC,GACT,GAEArU,WAAAA,CAAYqI,EAA4BqM,GACpC9D,MAAMvI,GACNnI,MAAK,EAAOwU,EACZxU,MAAK,GAAc,CACvB,CAEAgU,KAAAA,CAAMC,GACEA,IAAmBjU,MAAK,GAAc,GAC1C0Q,MAAMsD,MAAMC,EAChB,CAEA,WAAMG,CAAMzH,EAAqBxE,GAC7B,MAAMsM,QAActM,EAASuM,SAAS1U,MAAK,GAC9B,MAATyU,KAEqB,IAArBzU,MAAK,EACLA,MAAK,EAAayU,EAAMpH,OACjBoH,EAAMpH,OAASrN,MAAK,IAC3BmI,EAASuL,KAAK1T,MAAK,EAAMyU,EAAMpH,QAC/BrN,MAAK,EAAayU,EAAMpH,QAEhC,EASE,MAAOsH,WAAgCR,GACzC,GAEArU,WAAAA,CAAYqI,EAA4BuJ,GACpChB,MAAMvI,GACNnI,MAAK,EAAUoT,GAAK1B,EACxB,CAEA,WAAM0C,CAAMzH,EAAqBxE,GAC7B,MAAM,IAAI7J,MAAM,QAEpB,EASE,MAAOsW,WAAqCT,GAC9C,GAMArU,WAAAA,CAAYqI,EAA4B+E,GACpCwD,MAAMvI,GACNnI,MAAK,EAAQkN,CACjB,CAEA,WAAMkH,CAAMzH,EAAqBxE,GAC7B,MAAMqH,QAAWrH,EAAS0M,sBAAsB7U,MAAK,GACjDwP,GAAMrH,EAASuL,KAAK1T,MAAK,EAAOwP,EACxC,EAQE,MAAOsF,GACT,GACA,GACA,GAEA,GAIA,GAMAhV,WAAAA,CAAYqI,EAA4BuJ,GACpC1R,MAAK,EAAYmI,EACjBnI,MAAK,EAAUoT,GAAK1B,GACpB1R,MAAK,EAAUA,MAAK,EAAM4T,KAAK5T,MAC/BA,MAAK,GAAW,EAChBA,MAAK,GAAgB,CACzB,CAEA,OAAM,CAAM2M,GAER,IAA2B,IAAvB3M,MAAK,EAAuB,OAEhC,MAAM0R,EAAS0B,GAAKpT,MAAK,GACzB0R,EAAOqD,UAAY/U,MAAK,EAAe,EACvC0R,EAAOsD,QAAUrI,EAEjB,MAAM+B,QAAa1O,MAAK,EAAUiV,QAAQvD,GAI1C,GAAoB,IAAhBhD,EAAK/P,OAOT,IAAK,MAAMuW,KAAOxG,EACd1O,MAAK,EAAU0T,KAAK1T,MAAK,EAASkV,GAKlClV,MAAK,EAAekV,EAAIvI,iBAZpB3M,MAAK,EAAe2M,EAAc,KAClC3M,MAAK,EAAe2M,EAAc,GAa9C,CAEAkH,KAAAA,GACQ7T,MAAK,IACTA,MAAK,GAAW,GAEW,IAAvBA,MAAK,GACLA,MAAK,EAAUwT,iBAAiB2B,MAAMxI,IAClC3M,MAAK,EAAe2M,CAAW,IAGvC3M,MAAK,EAAUqU,GAAG,QAASrU,MAAK,GACpC,CAEA8T,IAAAA,GACS9T,MAAK,IACVA,MAAK,GAAW,EAEhBA,MAAK,EAAUsU,IAAI,QAAStU,MAAK,GACrC,CAEAgU,KAAAA,CAAMC,GACFjU,KAAK8T,OACDG,IAAmBjU,MAAK,GAAgB,EAChD,CAEAkU,MAAAA,GACIlU,KAAK6T,OACT,EC/PJ,MAAMuB,GAAOzJ,OAAO,GAIpB,SAAS0J,GAAmB/X,GACxB,OAAQA,GAAgC,oBAAhBA,EAAM6X,IAClC,CAEA,SAASG,GAAOC,EAAgBjY,GAC5B,OAAOiY,EAAS,IAAMlV,KAAKC,UAAUhD,GAAO,CAACgI,EAAGkQ,KAC5C,GAAS,MAALA,EAAa,MAAO,OACxB,GAAkB,kBAAPA,EAAmB,MAAO,UAAWA,EAAEnT,aAClD,GAAkB,kBAAPmT,EAAmB,OAAOA,EAAE9Z,cAGvC,GAAkB,kBAAP8Z,IAAoB5Y,MAAMqP,QAAQuJ,GAAI,CAC7C,MAAMpU,EAAOX,OAAOW,KAAKoU,GAEzB,OADApU,EAAKqU,OACErU,EAAKgE,QAAO,CAACC,EAAO9H,KACvB8H,EAAM9H,GAAOiY,EAAEjY,GACR8H,IACH,CAAC,E,CAGb,OAAOmQ,CAAC,GAEhB,CAoGM,MAAOE,GAITpP,KAKAxG,WAAAA,CAAYwG,IAAgBX,EAAAA,EAAAA,GAAsC3F,KAAM,CAAEsG,QAAS,CAEnFuN,KAAAA,GAAgB,CAChBC,IAAAA,GAAe,CAEfE,KAAAA,CAAMC,GAAmC,CACzCC,MAAAA,GAAiB,EAkBrB,SAASyB,GAAUC,GAGf,OAFAA,EAAQhZ,MAAMC,KAAM,IAAIgZ,IAAID,GAAQtE,WAC9BmE,OACCG,CACX,CAGA1a,eAAe4a,GAAgBC,EAAuB5N,GAClD,GAAc,MAAV4N,EAAkB,MAAM,IAAIzX,MAAM,iBAKtC,GAFI1B,MAAMqP,QAAQ8J,KAAWA,EAAS,CAAEjJ,OAAQiJ,IAEzB,kBAAZA,EACP,OAAQA,GACJ,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,YACL,IAAK,UACL,IAAK,UACL,IAAK,OACD,MAAO,CAAE/L,KAAM+L,EAAQvB,IAAKuB,GAKxC,IAAI3M,EAAAA,EAAAA,IAAY2M,EAAQ,IAAK,CACzB,MAAM7I,EAAO6I,EAAOra,cACpB,MAAO,CAAEsO,KAAM,cAAewK,IAAKc,GAAO,KAAM,CAAEpI,SAASA,O,CAG/D,GAAU6I,EAAQC,OAAQ,CACtB,MAAMC,EAAsBF,EAE5B,MAAO,CAAE/L,KAAM,SAAUwK,IAAKc,GAAO,SAAUW,GAAQvE,QAvCxCpU,EAuCqD2Y,EAtCjE5V,KAAK8E,MAAM9E,KAAKC,UAAUhD,K,CADrC,IAAuBA,EA0CnB,GAAWyY,EAAQjO,SAAiBiO,EAAQjJ,OAAS,CACjD,MAAMmJ,EAAqBF,EAErBrE,EAAc,CAChB5E,QAAUmJ,EAAMnJ,QAAU,IAAI3F,KAAK+O,GACtB,MAALA,EAAoB,KACpBtZ,MAAMqP,QAAQiK,GACPP,GAAUO,EAAE/O,KAAK+O,GAAMA,EAAExa,iBAE7Bwa,EAAExa,iBAIjB,GAAIua,EAAMnO,QAAS,CACf,MAAMqO,EAA2B,GAC3BC,EAAiC,GAEjCC,EAAchL,KACZjC,EAAAA,EAAAA,IAAYiC,GACZ8K,EAAUhW,KAAKkL,GAEf+K,EAASjW,KAAK,WACVgW,EAAUhW,WAAWmW,EAAAA,EAAAA,IAAejL,EAAMlD,GAC7C,EAFa,G,EAMlBvL,MAAMqP,QAAQgK,EAAMnO,SACpBmO,EAAMnO,QAAQzK,QAAQgZ,GAEtBA,EAAWJ,EAAMnO,SAEjBsO,EAASzX,cAAgBsE,QAAQ/D,IAAIkX,GACzC1E,EAAO5J,QAAU6N,GAAUQ,EAAUhP,KAAKoP,GAAMA,EAAE7a,gB,CAGtD,MAAO,CAAEgW,SAAQ8C,IAAKc,GAAO,QAAS5D,GAAS1H,KAAM,Q,EAGzDrI,EAAAA,EAAAA,KAAe,EAAO,wBAAyB,QAASoU,EAC5D,CAEA,SAAShT,KAAoB,OAAQ,IAAIkD,MAAQlD,SAAW,CA0H5D,MAAMyT,GAAiB,CACnBC,aAAc,IACdlD,gBAAiB,KAkBf,MAAOmD,GAET,GACA,GAGA,GAEA,GAEA,GACS,GAET,GAGA,GAEA,GACA,GAEA,GAEA,GAOA5W,WAAAA,CAAY6W,EAA+B1b,GAGvC,GAFA+E,MAAK,EAAWS,OAAOC,OAAO,CAAC,EAAI8V,GAAgBvb,GAAW,CAAC,GAE9C,QAAb0b,EACA3W,MAAK,GAAc,EACnBA,MAAK,EAAkB,UACpB,GAAI2W,EAAU,CACjB,MAAM3L,EAAUkG,GAAQrU,KAAK8Z,GAC7B3W,MAAK,GAAc,EACnBA,MAAK,EAAkBiD,QAAQC,QAAQ8H,GACvC7O,YAAW,KAAQ6D,KAAK0T,KAAK,UAAW1I,EAAS,KAAK,GAAK,E,MAE3DhL,MAAK,GAAc,EACnBA,MAAK,EAAkB,KAG3BA,MAAK,GAAoB,EAEzBA,MAAK,EAAgB,IAAIiR,IAEzBjR,MAAK,EAAQ,IAAIiR,IACjBjR,MAAK,EAAW,IAAIiR,IACpBjR,MAAK,EAAe,KAEpBA,MAAK,GAAa,EAElBA,MAAK,EAAa,EAClBA,MAAK,EAAU,IAAIiR,IAEnBjR,MAAK,GAAmB,CAC5B,CAEA,mBAAIuT,GAA4B,OAAOvT,MAAK,EAASuT,eAAiB,CAMtE,YAAIpL,GAAmB,OAAOnI,IAAM,CAKpC,WAAIuJ,GACA,OAAO3M,MAAMC,KAAKmD,MAAK,EAASsR,SACpC,CAKAC,YAAAA,CAAajI,GACT,GAAItJ,MAAK,EAASoE,IAAIkF,EAAOhD,MACzB,MAAM,IAAIhI,MAAM,mCAAoCgL,EAAOhD,SAG/D,OADAtG,MAAK,EAASC,IAAIqJ,EAAOhD,KAAOgD,EAAO7B,QAAQzH,OACxCA,IACX,CAKAmL,SAAAA,CAAqE7E,GACjE,OAAWtG,MAAK,EAASoE,IAAIkC,IAAU,IAC3C,CAMA,mBAAIsQ,GAA6B,OAAO5W,MAAK,CAAkB,CAC/D,mBAAI4W,CAAgBtZ,GAAkB0C,MAAK,IAAqB1C,CAAO,CAGvE,OAAM,CAAkBnC,GACpB,MAAMmB,EAAU0D,MAAK,EAASyW,aAG9B,GAAIna,EAAU,EAAK,aAAa0D,KAAK6W,SAAS1b,GAG9C,MAAMqZ,EAAMc,GAAOna,EAAIsB,OAAQtB,GAE/B,IAAI2b,EAAU9W,MAAK,EAAcoE,IAAIoQ,GAarC,OAZKsC,IACDA,EAAU9W,KAAK6W,SAAS1b,GAExB6E,MAAK,EAAcC,IAAIuU,EAAKsC,GAE5B3a,YAAW,KACH6D,MAAK,EAAcoE,IAAIoQ,KAASsC,GAChC9W,MAAK,EAAc+W,OAAOvC,E,GAE/BlY,UAGMwa,CACjB,CAKA,mBAAME,CAAcxH,EAA8ByH,EAAkBC,GAChE,GAAIlX,KAAK4W,iBAAmC,IAAhBM,EAAKvY,QAAyB,MAAT6Q,EAAGlB,GAAc,OAAO,KAEzE,MAAM6I,EAAS3H,EAAGlB,GAAG5S,cACfgD,EAAOuY,EAASvb,cAEhB0b,EAA+B,GAErC,IAAK,IAAIxY,EAAI,EAAGA,EAAIsY,EAAKvY,OAAQC,IAAK,CAClC,MAAMpD,EAAM0b,EAAKtY,GAGXyY,EAAO7b,EAAIyD,QAAQ,WAAYkY,GAAQlY,QAAQ,SAAUP,GASzDqB,EAAU,IAAIR,EAAa8X,IACF,IAA3B7b,EAAI8b,QAAQ,YACZvX,EAAQjD,KAAO,CAAE4B,OAAMyY,WAG3BnX,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,2BAA4BxX,UAASsB,MAAOzC,EAAGsY,SAE5E,IAGIja,EAHAua,EAAe,gBAInB,IACIva,QAAa8C,EAAQmE,M,CACvB,MAAOnI,GAGLqb,EAAcjX,KAAKpE,EAAMwJ,SACzBvF,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,4BAA6BxX,UAASuD,OAAQ,CAAEvH,WAC7E,Q,CAGJ,IACI,MAAMuH,EAASrG,EAAKiI,SACpB,GAAI5B,EAAO5E,KAEP,OADAsB,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,6BAA8BxX,UAASuD,WAC7DA,EAAO5E,KAEd4E,EAAOiC,UAAWiS,EAAelU,EAAOiC,SAC5CvF,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,4BAA6BxX,UAASuD,U,CACrE,MAAOvH,GAAQ,EAGjBV,EAAAA,EAAAA,IAAO4B,EAAKU,WAAa,KAAOV,EAAKU,YAAc,IAAK,yCAA0C6Z,IAC9F,iBAAkB,CAAExU,OAAQ,uBAAwByU,YAAajI,EAAI7T,KAAM,CAAEH,MAAKgc,kBAGtFJ,EAAcjX,KAAKqX,E,EAGvBnc,EAAAA,EAAAA,KAAO,EAAO,wCAAyC+b,EAAcjQ,KAAKuQ,GAAMrX,KAAKC,UAAUoX,KAAIjM,KAAK,QAAU,iBAAkB,CAChIzI,OAAQ,mBACRyU,YAAajI,EAAI7T,KAAM,CAAEub,OAAME,kBAEvC,CAOAO,UAAAA,CAAWra,EAAoB0N,GAC3B,OAAO,IAAI4M,GAAAA,GL7fb,SAAsBta,GACxB,MAAMgG,EAAS2J,EAAa3P,GAK5B,OAJAgG,EAAOuU,aAAeva,EAAMua,aAAa1Q,KAAKqI,GACvB,kBAARA,EAA2BA,EAC/BV,GAA0BU,KAE9BlM,CACX,CKsfyBwU,CAAYxa,GAAQ0C,KACzC,CAOA+X,QAAAA,CAASza,EAAkB0N,GACvB,OAAO,IAAIgN,GAAAA,GLviBb,SAAoB1a,GACtB,OAAOmP,EAAWnP,EACtB,CKqiBuB2a,CAAU3a,GAAQ0C,KACrC,CAOAkY,uBAAAA,CAAwB5a,EAAiC0N,GACrD,OAAO,IAAImN,GAAAA,GL3db,SAAmC7a,GACrC,OAAO+Q,GAA0B/Q,EACrC,CKydsC8a,CAAyB9a,GAAQ0C,KACnE,CAOAqY,wBAAAA,CAAyB7I,EAA+BxE,GACpD,OAAO,IAAIsN,GAAAA,GAAoBxJ,GAA0BU,GAAKxP,KAClE,CAQAuY,cAAAA,IACIld,EAAAA,EAAAA,KAAO,EAAO,kCAAmC,wBAAyB,CACtEO,UAAW,kBAEnB,CAQA,cAAMib,CAAkB1b,IACpBE,EAAAA,EAAAA,KAAO,EAAO,uBAAwBF,EAAIsB,SAAW,wBAAyB,CAC1Eb,UAAWT,EAAIsB,OACfd,KAAMR,GAEd,CAIA,oBAAMqY,GACF,MAAM7G,GAAcC,EAAAA,EAAAA,UAAgB5M,MAAK,EAAS,CAAEvD,OAAQ,mBAAqB,aAEjF,OADIuD,MAAK,GAAoB,IAAKA,MAAK,EAAmB2M,GACnDA,CACX,CAOA6L,WAAAA,CAAY1Q,GACR,OAAOwO,EAAAA,EAAAA,IAAexO,EAAS9H,KACnC,CAMAyY,YAAAA,CAAaC,GACT,GAAgB,MAAZA,EAAoB,MAAO,SAE/B,OAAQA,GACJ,IAAK,WACD,MAAO,MACX,IAAK,YACL,IAAK,SACL,IAAK,UACL,IAAK,OACD,OAAOA,EAIf,OAAItP,EAAAA,EAAAA,IAAYsP,IACRtP,EAAAA,EAAAA,IAAYsP,EAAU,IAAcA,GACjCC,EAAAA,EAAAA,IAAWD,IAGG,kBAAdA,IACPA,GAAW9L,EAAAA,EAAAA,IAAU8L,EAAU,aAGV,kBAAdA,EACHA,GAAY,GAAYC,EAAAA,EAAAA,IAAWD,GACnC1Y,MAAK,GAAoB,GAAY2Y,EAAAA,EAAAA,IAAW3Y,MAAK,EAAmB0Y,GACrE1Y,KAAKwT,iBAAiB2B,MAAM1B,IAAMkF,EAAAA,EAAAA,IAAWlF,EAAYiF,UAGpE/W,EAAAA,EAAAA,KAAe,EAAO,mBAAoB,WAAY+W,GAC1D,CAOAE,UAAAA,CAAWlH,GAGP,MAAM5E,GAAU4E,EAAO5E,QAAU,IAAK3F,KAAK+O,GAC9B,MAALA,EAAoB,KACpBtZ,MAAMqP,QAAQiK,GACPP,GAAUO,EAAE/O,KAAK+O,GAAMA,EAAExa,iBAE7Bwa,EAAExa,gBAGPgR,EAAa,cAAegF,EAAUA,EAAOhF,eAAW3P,EAExDmG,EAAUA,CAAC2V,EAAyB9D,EAAoBC,KAC1D,IAAIlN,EACJ,OAAQ+Q,EAASla,QACb,KAAK,EAAG,MACR,KAAK,EACDmJ,EAAU+Q,EAAS,GACnB,MACJ,QACIA,EAASpD,OACT3N,EAAU+Q,EAGlB,GAAInM,IACiB,MAAbqI,GAAgC,MAAXC,GACrB,MAAM,IAAI1W,MAAM,kBAIxB,MAAMoT,EAAc,CAAC,EAOrB,OANI5J,IAAW4J,EAAO5J,QAAUA,GAC5BgF,EAAOnO,SAAU+S,EAAO5E,OAASA,GACjCiI,IAAarD,EAAOqD,UAAYA,GAChCC,IAAWtD,EAAOsD,QAAUA,GAC5BtI,IAAagF,EAAOhF,UAAYA,GAE7BgF,CAAM,EAIjB,IASIqD,EAGAC,EAZAlN,EAA2C,GAC/C,GAAI4J,EAAO5J,QACP,GAAIlL,MAAMqP,QAAQyF,EAAO5J,SACrB,IAAK,MAAMuD,KAAQqG,EAAO5J,QAAWA,EAAQ3H,KAAKH,KAAKwY,YAAYnN,SAEnEvD,EAAQ3H,KAAKH,KAAKwY,YAAY9G,EAAO5J,UAU7C,MALI,cAAe4J,IAAUqD,EAAY/U,KAAKyY,aAAa/G,EAAOqD,YAG9D,YAAarD,IAAUsD,EAAUhV,KAAKyY,aAAa/G,EAAOsD,UAE1DlN,EAAQ4J,QAAQ6E,GAAqB,kBAAPA,IAAkB5X,QAClC,MAAboW,GAA2C,kBAAfA,GACjB,MAAXC,GAAuC,kBAAbA,EAEpB/R,QAAQ/D,IAAI,CAAE+D,QAAQ/D,IAAI4I,GAAUiN,EAAWC,IAAWG,MAAM7R,GAC5DJ,EAAQI,EAAO,GAAIA,EAAO,GAAIA,EAAO,MAI7CJ,EAAuB4E,EAASiN,EAAWC,EACtD,CAOA8D,sBAAAA,CAAuBlW,GACnB,MAAM7C,GAAoCgZ,EAAAA,GAAAA,IAAYnW,GAEhDwT,EAAiC,GAYvC,GAXA,CAAE,KAAM,QAAS/Y,SAASE,IACtB,GAA2B,MAAjBwC,EAASxC,GAAgB,OAEnC,MAAM8N,GAAOiL,EAAAA,EAAAA,IAAqBvW,EAASxC,GAAMyC,MAC7CqV,GAAUhK,GACV+K,EAASjW,KAAMjF,iBAAyB6E,EAASxC,SAAa8N,CAAM,CAArDnQ,IAET6E,EAASxC,GAAO8N,C,IAIN,MAApBtL,EAAQ2Y,SAAkB,CAC1B,MAAMA,EAAW1Y,KAAKyY,aAAa1Y,EAAQ2Y,UACvCrD,GAAUqD,GACVtC,EAASjW,KAAMjF,iBAAmB6E,EAAQ2Y,eAAiBA,CAAU,CAAtDxd,IAEf6E,EAAQ2Y,SAAWA,C,CAI3B,OAAItC,EAASzX,OACDzD,iBAEJ,aADM+H,QAAQ/D,IAAIkX,GACXrW,CACX,CAHQ7E,GAML6E,CACX,CAEA,gBAAMkL,GAGF,GAA4B,MAAxBjL,MAAK,EAAyB,CAG9B,MAAMgZ,EAAgB,WAClB,IACI,MAAMhO,QAAgBhL,KAAKuY,iBAE3B,OADAvY,KAAK0T,KAAK,UAAW1I,EAAS,MACvBA,C,CACT,MAAOjP,GAIL,MAHIiE,MAAK,IAAoBgZ,IACzBhZ,MAAK,EAAkB,MAErBjE,C,CAEb,EAXqB,GActB,OADAiE,MAAK,EAAkBgZ,SACTA,GAAe5V,O,CAGjC,MAAM6V,EAAiBjZ,MAAK,GAEpBkZ,EAAUC,SAAiBlW,QAAQ/D,IAAI,CAC3C+Z,EACAjZ,KAAKuY,mBAoBT,OAjBIW,EAAS3J,UAAY4J,EAAO5J,UACxBvP,MAAK,GAELA,KAAK0T,KAAK,UAAWyF,EAAQD,GAGzBlZ,MAAK,IAAoBiZ,IACzBjZ,MAAK,EAAkBiD,QAAQC,QAAQiW,MAI3C9d,EAAAA,EAAAA,KAAO,EAAO,oBAAqB6d,EAAS3J,cAAgB4J,EAAO5J,WAAa,gBAAiB,CAC7F0G,MAAO,aAKZiD,EAAS9V,OACpB,CAEA,gBAAMgW,GACF,MAAMpO,QAAgBhL,KAAKiL,aAErBoO,EAAiBne,UACnB,MAAM,OAAEoe,EAAM,SAAEpK,EAAQ,YAAEqK,SAAsBC,EAAAA,EAAAA,GAAkB,CAC9DF,OAAQtZ,MAAK,EAAU,UAAU,GACjCkP,SAAW,WACP,IACI,MAAM5R,QAAc0C,MAAK,EAAS,CAAEvD,OAAQ,gBAC5C,OAAOgR,EAAAA,EAAAA,IAAUnQ,EAAO,Y,CAC1B,MAAOvB,GAAQ,CACjB,OAAO,IACV,EANU,GAOXwd,YAAc,WACV,IACI,MAAMjc,QAAc0C,MAAK,EAAS,CAAEvD,OAAQ,mBAC5C,OAAOgR,EAAAA,EAAAA,IAAUnQ,EAAO,Y,CAC1B,MAAOvB,GAAQ,CACjB,OAAO,IACV,EANa,KASlB,IAAIqT,EAA8B,KAC9BD,EAAsC,KAG1C,MAAMsF,EAAQzU,KAAK2X,WAAW2B,EAAQtO,GAMtC,OALIyJ,GAASA,EAAMtG,gBACfgB,EAAuC,MAAfoK,EAAuBA,EAAa5N,OAAO,cACnEyD,EAAgBqF,EAAMtG,cAAgBiH,GAAQjG,GAG3C,IAAIsK,GAAAA,GAAQvK,EAAUE,EAAcD,EAAqB,EAI9D7F,EAAuC0B,EAAQG,UAAU,oDAC/D,GAAI7B,EAAQ,CACR,MAAMnO,EAAM,IAAIoE,EAAa+J,EAAO9N,KAC9Bke,QAAgBpQ,EAAOxH,YAAYuX,EAAgBrZ,KAAM7E,GAC/D,OAAO,IAAIse,GAAAA,GAAQC,EAAQxK,SAAUwK,EAAQtK,aAAcsK,EAAQvK,qB,CAGvE,aAAakK,GACjB,CAGA,iBAAMM,CAAYC,GACd,IAAIpK,EAAKxP,KAAK8Y,uBAAuBc,GAErC,OADIvE,GAAU7F,KAAOA,QAAWA,IACzB/B,EAAAA,EAAAA,UAAgBzN,MAAK,EAAS,CACjCvD,OAAQ,cAAegb,YAAajI,IACpC,YACR,CAEA,OAAM,CAAMA,EAA8BkJ,EAAkBjW,IACxDpH,EAAAA,EAAAA,IAAQoH,EA74BW,GA64BmB,0CAA2C,iBAAkB,CAC9FO,OAAQ,qBACRyU,YAAahX,OAAOC,OAAO,CAAC,EAAI8O,EAAI,CAAEkJ,WAAU3P,gBAAgB,MAIpE,MAAM0O,GAAwCsB,EAAAA,GAAAA,IAAYvJ,GAE1D,IACI,OAAOlN,EAAAA,EAAAA,UAActC,KAAK6W,SAAS,CAAEpa,OAAQ,OAAQgb,cAAaiB,a,CAEpE,MAAO3c,GAEL,IAAKiE,KAAK4W,kBAAmBiD,EAAAA,EAAAA,GAAgB9d,IAAUA,EAAM2C,MAAQ+D,GAAW,GAAkB,WAAbiW,GAA2C,MAAlBjB,EAAYnJ,IAA8C,gBAAhCoB,EAAAA,EAAAA,IAAU3T,EAAM2C,KAAM,EAAG,GAAqB,CAClL,MAAMA,EAAO3C,EAAM2C,KAEbob,QAAiBxD,EAAAA,EAAAA,IAAemB,EAAYnJ,GAAItO,MAGtD,IAAI+Z,EACJ,IACIA,EA4rBrB,SAA6Brb,GACzB,MAAM4E,EAAmB,CACrB6T,OAAQ,GAAID,KAAM,GAAKD,SAAU,GAAI/M,SAAU,GAAIgE,UAAW,GAAI8L,UAAW,KAGjF3e,EAAAA,EAAAA,KAAO4e,EAAAA,EAAAA,IAAWvb,IAAS,IAAQ,mCAAoC,iBAAkB,CACrFsE,OAAQ,qCAGZ,MAAMmU,GAASzH,EAAAA,EAAAA,IAAUhR,EAAM,EAAG,KAClCrD,EAAAA,EAAAA,KAAOqU,EAAAA,EAAAA,IAAUyH,EAAQ,EAAG,OAAQzH,EAAAA,EAAAA,IAAUwK,GAAO,EAAG,IAAK,gCAAiC,iBAAkB,CAC5GlX,OAAQ,kCAEZM,EAAO6T,QAASzH,EAAAA,EAAAA,IAAUyH,EAAQ,IAGlC,IACI,MAAMD,EAAsB,GACtBiD,GAAavN,EAAAA,EAAAA,KAAU8C,EAAAA,EAAAA,IAAUhR,EAAM,GAAI,KAC3C0b,GAAaxN,EAAAA,EAAAA,KAAU8C,EAAAA,EAAAA,IAAUhR,EAAMyb,EAAYA,EAAa,KAChEE,GAAW3K,EAAAA,EAAAA,IAAUhR,EAAMyb,EAAa,IAC9C,IAAK,IAAIG,EAAI,EAAGA,EAAIF,EAAYE,IAAK,CACjC,MAAM9e,EAAM+e,GAAaF,EAAc,GAAJC,GACnC,GAAW,MAAP9e,EAAe,MAAM,IAAI8C,MAAM,SACnC4Y,EAAK/W,KAAK3E,E,CAEd8H,EAAO4T,KAAOA,C,CAChB,MAAOnb,IACLV,EAAAA,EAAAA,KAAO,EAAO,8BAA+B,iBAAkB,CAC3D2H,OAAQ,+B,CAKhB,IACI,MAAMiU,EAAWuD,GAAY9b,EAAM,IACnC,GAAgB,MAAZuY,EAAoB,MAAM,IAAI3Y,MAAM,SACxCgF,EAAO2T,SAAWA,C,CACpB,MAAOlb,IACLV,EAAAA,EAAAA,KAAO,EAAO,kCAAmC,iBAAkB,CAC/D2H,OAAQ,mC,EAKhB3H,EAAAA,EAAAA,KAAOqU,EAAAA,EAAAA,IAAUhR,EAAM,IAAK,QAASgR,EAAAA,EAAAA,IAAUwK,GAAO,EAAG,IAAK,2CAA4C,iBAAkB,CACxHlX,OAAQ,6CAEZM,EAAO4G,UAAWwF,EAAAA,EAAAA,IAAUhR,EAAM,GAAI,KAGtC,IACI,MAAMwP,EAAYsM,GAAY9b,EAAM,KACpC,GAAiB,MAAbwP,EAAqB,MAAM,IAAI5P,MAAM,SACzCgF,EAAO4K,UAAYA,C,CACrB,MAAOnS,IACLV,EAAAA,EAAAA,KAAO,EAAO,mCAAoC,iBAAkB,CAChE2H,OAAQ,oC,CAMhB,OAFAM,EAAO0W,UAAY,0CAA0Cve,MAAM,KAAK0L,KAAK7B,GAAYhC,EAAQgC,KAE1FhC,CACX,CA5vBgCmX,EAAoB/K,EAAAA,EAAAA,IAAU3T,EAAM2C,KAAM,G,CACvD,MAAO3C,IACLV,EAAAA,EAAAA,KAAO,EAAOU,EAAMwJ,QAAS,iBAAkB,CAC3CvC,OAAQ,WAAYyU,cAAa9b,KAAM,CAAE+C,S,EAIjDrD,EAAAA,EAAAA,IAAO0e,EAAS5C,OAAOzb,gBAAkBoe,EAASpe,cAC9C,4BAA6B,iBAAkB,CAC3C6b,OAAQ,OACR7Y,OACAsE,OAAQ,iBACRyU,YAAkBA,EAClBiD,WAAY,KACZC,OAAQ,CACJ9K,UAAW,sDACXvJ,KAAM,iBACNsU,KAAMb,EAASC,aAI3B,MAAMa,QAAmB7a,KAAKgX,cAAcS,EAAasC,EAAS9C,SAAU8C,EAAS7C,OACrF7b,EAAAA,EAAAA,IAAqB,MAAdwf,EAAoB,iCAAkC,iBAAkB,CAC3E7X,OAAQ,eAAgByU,cAAa9b,KAAM,CAAE+C,KAAM3C,EAAM2C,KAAMsb,UAAWD,EAASC,aAEvF,MAAMxK,EAAK,CACPlB,GAAIwL,EACJpb,MAAMqI,EAAAA,EAAAA,IAAO,CAAEgT,EAAS7P,SAAU4Q,GAAY,CAAED,EAAYd,EAAS7L,eAGzElO,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,mBAAoBE,YAAajI,IAC9D,IACI,MAAMlM,QAAetD,MAAK,EAAMwP,EAAIkJ,EAAUjW,EAAU,GAExD,OADAzC,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,4BAA6BE,YAAahX,OAAOC,OAAO,CAAC,EAAI8O,GAAKlM,WACxFA,C,CACT,MAAOvH,GAEL,MADAiE,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,2BAA4BE,YAAahX,OAAOC,OAAO,CAAC,EAAI8O,GAAKzT,UACxFA,C,EAId,MAAMA,C,CAEf,CAEA,QAAM,CAAiBgf,GACnB,MAAM,MAAEzd,SAAgBkc,EAAAA,EAAAA,GAAkB,CACtCxO,QAAShL,KAAKiL,aACd3N,MAAOyd,IAEX,OAAOzd,CACX,CAEA,UAAM0d,CAAKpB,GACP,MAAM,GAAEpK,EAAE,SAAEkJ,SAAmBc,EAAAA,EAAAA,GAAkB,CAC7ChK,GAAIxP,KAAK8Y,uBAAuBc,GAChClB,SAAU1Y,KAAKyY,aAAamB,EAAIlB,YAGpC,aAAa1Y,MAAK,GAAcA,MAAK,EAAMwP,EAAIkJ,EAAUkB,EAAI7Q,eAAiB,GAAI,GACtF,CAGA,QAAM,CAAiBhJ,EAAiC8Y,EAAuBoC,GAC3E,IAAInT,EAAoC9H,KAAKwY,YAAYK,GACrDH,EAAqC1Y,KAAKyY,aAAawC,GAM3D,MAJwB,kBAAbnT,GAA8C,kBAAd4Q,KACrC5Q,EAAS4Q,SAAmBzV,QAAQ/D,IAAI,CAAE4I,EAAS4Q,WAG5C1Y,MAAK,GAAcA,MAAK,EAASS,OAAOC,OAAOX,EAAS,CAAE+H,UAAS4Q,cACpF,CAEA,gBAAMwC,CAAWpT,EAAsB4Q,GACnC,OAAOjL,EAAAA,EAAAA,UAAgBzN,MAAK,GAAiB,CAAEvD,OAAQ,cAAgBqL,EAAS4Q,GAAW,YAC/F,CAEA,yBAAMyC,CAAoBrT,EAAsB4Q,GAC5C,OAAO9L,EAAAA,EAAAA,UAAgB5M,MAAK,GAAiB,CAAEvD,OAAQ,uBAAyBqL,EAAS4Q,GAAW,YACxG,CAEA,aAAM0C,CAAQtT,EAAsB4Q,GAChC,OAAOpW,EAAAA,EAAAA,UAActC,MAAK,GAAiB,CAAEvD,OAAQ,WAAaqL,EAAS4Q,GAC/E,CAEA,gBAAM2C,CAAWvT,EAAsBwT,EAAyB5C,GAC5D,MAAM6C,GAAW9N,EAAAA,EAAAA,IAAU6N,EAAW,YACtC,OAAOhZ,EAAAA,EAAAA,UAActC,MAAK,GAAiB,CAAEvD,OAAQ,aAAc8e,YAAYzT,EAAS4Q,GAC5F,CAGA,0BAAM8C,CAAqBC,GACvB,MAAM,YAAE9O,EAAW,KAAEO,EAAI,QAAElC,SAAkBwO,EAAAA,EAAAA,GAAkB,CAC1D7M,YAAa3M,KAAKwT,iBAClBtG,KAAMlN,KAAK6W,SAAS,CAChBpa,OAAQ,uBACRif,kBAAmBD,IAEvBzQ,QAAShL,KAAKiL,eAGbuE,EAAKmM,EAAAA,EAAY9e,KAAK4e,GAC5B,GAAIjM,EAAGtC,OAASA,EACZ,MAAM,IAAI5O,MAAM,0CAGpB,OAAO0B,KAAKqY,yBAA8B7I,EAAIxE,GAAS4Q,uBAAuBjP,EAClF,CAEA,OAAM,CAAU8H,EAA0BoH,GAGtC,IAAIzS,EAAAA,EAAAA,IAAYqL,EAAO,IACnB,aAAazU,MAAK,EAAS,CACvBvD,OAAQ,WAAYiQ,UAAW+H,EAAOoH,wBAI9C,IAAInD,EAAW1Y,KAAKyY,aAAahE,GAGjC,MAFyB,kBAAdiE,IAA0BA,QAAiBA,SAEzC1Y,MAAK,EAAS,CACvBvD,OAAQ,WAAYic,WAAUmD,uBAEtC,CAGA,cAAMnH,CAASD,EAA0BqH,GACrC,MAAM,QAAE9Q,EAAO,OAAExI,SAAiBgX,EAAAA,EAAAA,GAAkB,CAChDxO,QAAShL,KAAKiL,aACdzI,OAAQxC,MAAK,EAAUyU,IAASqH,KAEpC,OAAc,MAAVtZ,EAAyB,KAEtBxC,KAAK2X,WAAWnV,EAAQwI,EACnC,CAEA,oBAAM+Q,CAAe7O,GACjB,MAAM,QAAElC,EAAO,OAAExI,SAAiBgX,EAAAA,EAAAA,GAAkB,CAChDxO,QAAShL,KAAKiL,aACdzI,OAAQxC,MAAK,EAAS,CAAEvD,OAAQ,iBAAkByQ,WAEtD,OAAc,MAAV1K,EAAyB,KAEtBxC,KAAKqY,yBAAyB7V,EAAQwI,EACjD,CAEA,2BAAM6J,CAAsB3H,GACxB,MAAM,QAAElC,EAAO,OAAExI,SAAiBgX,EAAAA,EAAAA,GAAkB,CAChDxO,QAAShL,KAAKiL,aACdzI,OAAQxC,MAAK,EAAS,CAAEvD,OAAQ,wBAAyByQ,WAE7D,GAAc,MAAV1K,EAAkB,OAAO,KAI7B,GAAuB,MAAnBA,EAAO0M,UAAgD,MAA5B1M,EAAOoM,kBAA2B,CAC7D,MAAMY,QAAWxP,MAAK,EAAS,CAAEvD,OAAQ,iBAAkByQ,SAC3D,GAAU,MAANsC,EAAc,MAAM,IAAIlR,MAAM,uDAClCkE,EAAOoM,kBAAoBY,EAAGN,Q,CAGlC,OAAOlP,KAAKkY,wBAAwB1V,EAAQwI,EAChD,CAEA,0BAAMgR,CAAqB9O,GACvB,MAAM,OAAE5J,SAAiBkW,EAAAA,EAAAA,GAAkB,CACvCxO,QAAShL,KAAKiL,aACd3H,OAAQtD,MAAK,EAAS,CAAEvD,OAAQ,uBAAwByQ,WAE5D,OAAc,MAAV5J,EAAyB,MACtBhB,EAAAA,EAAAA,IAAQgB,EACnB,CAGA,aAAM2R,CAAQgH,GACV,IAAIvK,EAAS1R,KAAK4Y,WAAWqD,GACzB5G,GAAU3D,KAAWA,QAAeA,GAExC,MAAM,QAAE1G,EAAO,OAAExI,SAAiBgX,EAAAA,EAAAA,GAAkB,CAChDxO,QAAShL,KAAKiL,aACdzI,OAAQxC,MAAK,EAA2B,CAAEvD,OAAQ,UAAWiV,aAGjE,OAAOlP,EAAO2E,KAAKwK,GAAM3R,KAAK+X,SAASpG,EAAG3G,IAC9C,CAGAkR,YAAAA,CAAa3M,IACTlU,EAAAA,EAAAA,KAAO,EAAO,4CAA6C,wBAAyB,CAChFO,UAAW,kBAEnB,CAEA,iBAAMugB,CAAY7V,GACd,aAAa4B,EAAYqD,SAASvL,KAAMsG,EAC5C,CAEA,eAAMuD,CAAUvD,GACZ,MAAMgF,QAAiBtL,KAAKmc,YAAY7V,GACxC,OAAIgF,QAAyBA,EAASzB,YAC/B,IACX,CAEA,iBAAMuS,CAAY9V,GACd,MAAMgF,QAAiBtL,KAAKmc,YAAY7V,GACxC,OAAIgF,QAAyBA,EAASrC,aAC/B,IACX,CAEA,mBAAMoT,CAAcvU,GAEhB,MAAMwU,EAAOzV,GADbiB,GAAUmB,EAAAA,EAAAA,GAAWnB,IACSP,UAAU,GAAG7L,cAAgB,iBAE3D,IAEI,MAAM0P,QAAgBlD,EAAY6C,cAAc/K,MAC1Cuc,EAAc,IAAInU,EAAAA,GAASgD,EAAS,CACtC,qDACDpL,MAEGsL,QAAiBiR,EAAYjR,SAASgR,GAC5C,GAAgB,MAAZhR,GAAoBA,IAAapC,EAAAA,EAAe,OAAO,KAE3D,MAAMsT,EAAmB,IAAIpU,EAAAA,GAASkD,EAAU,CAC5C,gDACDtL,MACGsG,QAAakW,EAAiBlW,KAAKgW,GAIzC,aADoBtc,KAAKoc,YAAY9V,KACvBwB,EAAkB,KAEzBxB,C,CAET,MAAOvK,GAEL,IAAIwM,EAAAA,EAAAA,IAAQxM,EAAO,aAA+B,OAAhBA,EAAMuB,MACpC,OAAO,KAIX,IAAIiL,EAAAA,EAAAA,IAAQxM,EAAO,kBAAqB,OAAO,KAE/C,MAAMA,C,CAGV,OAAO,IACX,CAEA,wBAAM0gB,CAAmBvP,EAAcwP,EAA2BpgB,GAC9D,MAAMqgB,EAAyB,MAAbD,EAAqBA,EAAW,EAClD,OAAiB,IAAbC,EAAyB3c,KAAK6U,sBAAsB3H,GAEjD,IAAIjK,SAAQ/H,MAAOgI,EAAS0Z,KAC/B,IAAI1gB,EAAsB,KAE1B,MAAMgE,EAAYhF,UACd,IACI,MAAM2hB,QAAgB7c,KAAK6U,sBAAsB3H,GACjD,GAAe,MAAX2P,GACIlQ,EAAckQ,EAAQlQ,YAAc,GAAKgQ,EAOzC,OANAzZ,EAAQ2Z,QAEJ3gB,IACAkB,aAAalB,GACbA,EAAQ,M,CAKtB,MAAOH,GACL+gB,QAAQ5H,IAAI,MAAOnZ,E,CAEvBiE,KAAK+c,KAAK,QAAS7c,EAAS,EAGjB,MAAX5D,IACAJ,EAAQC,YAAW,KACF,MAATD,IACJA,EAAQ,KACR8D,KAAKsU,IAAI,QAASpU,GAClB0c,GAAOxgB,EAAAA,EAAAA,IAAU,UAAW,UAAW,CAAE4G,OAAQ,aAAa,GAC/D1G,IAGP4D,QAAeF,KAAKwT,iBAAiB,GAE7C,CAEA,kBAAMwJ,CAAatE,IACfrd,EAAAA,EAAAA,KAAO,EAAO,sBAAuB,kBAAmB,CACpDO,UAAW,gBAEnB,CAKAmY,aAAAA,CAAckJ,GACV,MAAM/gB,EAAQ8D,MAAK,EAAQoE,IAAI6Y,GAC1B/gB,IACDA,EAAMA,OAASkB,aAAalB,EAAMA,OACtC8D,MAAK,EAAQ+W,OAAOkG,GACxB,CAUAtJ,WAAAA,CAAYuJ,EAAmB5gB,GACZ,MAAXA,IAAmBA,EAAU,GACjC,MAAM2gB,EAAUjd,MAAK,IACf0E,EAAOA,KACT1E,MAAK,EAAQ+W,OAAOkG,GACpBC,GAAO,EAGX,GAAIld,KAAKmd,OACLnd,MAAK,EAAQC,IAAIgd,EAAS,CAAE/gB,MAAO,KAAMwI,OAAM0Y,KAAM9gB,QAClD,CACH,MAAMJ,EAAQC,WAAWuI,EAAMpI,GAC/B0D,MAAK,EAAQC,IAAIgd,EAAS,CAAE/gB,QAAOwI,OAAM0Y,KAAMra,M,CAGnD,OAAOka,CACX,CAKAI,kBAAAA,CAAmB3Y,GACf,IAAK,MAAM4Y,KAAOtd,MAAK,EAAMsR,SACzB5M,EAAK4Y,EAAIC,WAEjB,CAMAC,cAAAA,CAAeF,GACX,OAAQA,EAAItT,MACR,IAAK,QACL,IAAK,QACL,IAAK,UACD,OAAO,IAAI0L,GAAoB4H,EAAItT,MACvC,IAAK,QAAS,CACV,MAAMuT,EAAa,IAAIjK,GAAuBtT,MAE9C,OADAud,EAAWhK,gBAAkBvT,KAAKuT,gBAC3BgK,C,CAEX,IAAK,OAAQ,IAAK,YACd,OAAO,IAAIhJ,GAA0BvU,KAAMsd,EAAItT,MACnD,IAAK,QACD,OAAO,IAAI8K,GAAuB9U,KAAMsd,EAAI5L,QAChD,IAAK,cACD,OAAO,IAAIkD,GAA6B5U,KAAMsd,EAAIpQ,MACtD,IAAK,SACD,OAAO,IAAIyH,GAAwB3U,KAAMsd,EAAI5L,QAGrD,MAAM,IAAIpT,MAAM,sBAAuBgf,EAAItT,OAC/C,CAWAyT,kBAAAA,CAAmBC,EAAoBC,GACnC,IAAK,MAAML,KAAOtd,MAAK,EAAMsR,SACzB,GAAIgM,EAAIC,aAAeG,EAAQ,CACvBJ,EAAIM,SAAWN,EAAIC,WAAWzJ,OAClCwJ,EAAIC,WAAaI,EACbL,EAAIM,SAAWD,EAAO9J,QACD,MAArB7T,MAAK,GAAwB2d,EAAO3J,MAAMhU,MAAK,GACnD,K,CAGZ,CAEA,QAAM,CAAQiW,EAAsB4H,GAChC,IAAIP,QAAYxH,GAAgBG,EAAOjW,MAMvC,MAHiB,UAAbsd,EAAItT,MAAoB6T,GAAYA,EAASlf,OAAS,IAA6B,IAAxBkf,EAAS,GAAGhR,UACvEyQ,QAAYxH,GAAgB,CAAEE,OAAQ,WAAYd,IAAK2I,EAAS,IAAM7d,OAEnEA,MAAK,EAAMoE,IAAIkZ,EAAI9I,MAAQ,IACtC,CAEA,QAAM,CAAQyB,GACV,MAAM6H,QAAqBhI,GAAgBG,EAAOjW,MAG5CwU,EAAMsJ,EAAatJ,IAEzB,IAAI8I,EAAMtd,MAAK,EAAMoE,IAAIoQ,GACzB,IAAK8I,EAAK,CAKNA,EAAM,CAAEC,WAJWvd,KAAKwd,eAAeM,GAInBtJ,MAAKuJ,eAFF,IAAIne,QAEcoe,QADzB,IAAI/M,IAC8B2M,SAAS,EAAOK,UAAW,IAC7Eje,MAAK,EAAMC,IAAIuU,EAAK8I,E,CAGxB,OAAOA,CACX,CAEA,QAAMjJ,CAAG4B,EAAsB/V,GAC3B,MAAMod,QAAYtd,MAAK,GAAQiW,GAO/B,OANAqH,EAAIW,UAAU9d,KAAK,CAAED,WAAU6c,MAAM,IAChCO,EAAIM,UACLN,EAAIC,WAAW1J,QACfyJ,EAAIM,SAAU,EACW,MAArB5d,MAAK,GAAwBsd,EAAIC,WAAWvJ,MAAMhU,MAAK,IAExDA,IACX,CAEA,UAAM+c,CAAK9G,EAAsB/V,GAC7B,MAAMod,QAAYtd,MAAK,GAAQiW,GAO/B,OANAqH,EAAIW,UAAU9d,KAAK,CAAED,WAAU6c,MAAM,IAChCO,EAAIM,UACLN,EAAIC,WAAW1J,QACfyJ,EAAIM,SAAU,EACW,MAArB5d,MAAK,GAAwBsd,EAAIC,WAAWvJ,MAAMhU,MAAK,IAExDA,IACX,CAEA,UAAM0T,CAAKuC,KAAyB2E,GAChC,MAAM0C,QAAYtd,MAAK,GAAQiW,EAAO2E,GAGtC,IAAK0C,GAAgC,IAAzBA,EAAIW,UAAUtf,OAAgB,OAAO,EAEjD,MAAMuf,EAAQZ,EAAIW,UAAUtf,OAc5B,OAbA2e,EAAIW,UAAYX,EAAIW,UAAUvM,QAAO,EAAGxR,WAAU6c,WAC9C,MAAM/J,EAAU,IAAImL,EAAAA,EAAane,KAAO+c,EAAO,KAAM7c,EAAW+V,GAChE,IACI/V,EAAS8a,KAAKhb,QAAS4a,EAAM5H,E,CAC/B,MAAMjX,GAAQ,CAChB,OAAQghB,CAAI,IAGa,IAAzBO,EAAIW,UAAUtf,SACV2e,EAAIM,SAAWN,EAAIC,WAAWzJ,OAClC9T,MAAK,EAAM+W,OAAOuG,EAAI9I,MAGlB0J,EAAQ,CACpB,CAEA,mBAAME,CAAcnI,GAChB,GAAIA,EAAO,CACP,MAAMqH,QAAYtd,MAAK,GAAQiW,GAC/B,OAAKqH,EACEA,EAAIW,UAAUtf,OADF,C,CAIvB,IAAI0f,EAAQ,EACZ,IAAK,MAAM,UAAEJ,KAAeje,MAAK,EAAMsR,SACnC+M,GAASJ,EAAUtf,OAEvB,OAAO0f,CACX,CAEA,eAAMJ,CAAUhI,GACZ,GAAIA,EAAO,CACP,MAAMqH,QAAYtd,MAAK,GAAQiW,GAC/B,OAAKqH,EACEA,EAAIW,UAAU9W,KAAI,EAAGjH,cAAeA,IADvB,E,CAGxB,IAAIoD,EAA0B,GAC9B,IAAK,MAAM,UAAE2a,KAAeje,MAAK,EAAMsR,SACnChO,EAASA,EAAOyD,OAAOkX,EAAU9W,KAAI,EAAGjH,cAAeA,KAE3D,OAAOoD,CACX,CAEA,SAAMgR,CAAI2B,EAAsB/V,GAC5B,MAAMod,QAAYtd,MAAK,GAAQiW,GAC/B,IAAKqH,EAAO,OAAOtd,KAEnB,GAAIE,EAAU,CACV,MAAMmB,EAAQic,EAAIW,UAAU9W,KAAI,EAAGjH,cAAeA,IAAUoX,QAAQpX,GAChEmB,GAAS,GAAKic,EAAIW,UAAUK,OAAOjd,EAAO,E,CAQlD,OALKnB,GAAqC,IAAzBod,EAAIW,UAAUtf,SACvB2e,EAAIM,SAAWN,EAAIC,WAAWzJ,OAClC9T,MAAK,EAAM+W,OAAOuG,EAAI9I,MAGnBxU,IACX,CAEA,wBAAMue,CAAmBtI,GACrB,GAAIA,EAAO,CACP,MAAM,IAAEzB,EAAG,QAAEoJ,EAAO,WAAEL,SAAqBvd,MAAK,GAAQiW,GACpD2H,GAAWL,EAAWzJ,OAC1B9T,MAAK,EAAM+W,OAAOvC,E,MAElB,IAAK,MAAQA,GAAK,QAAEoJ,EAAO,WAAEL,MAAkBvd,MAAK,EAC5C4d,GAAWL,EAAWzJ,OAC1B9T,MAAK,EAAM+W,OAAOvC,GAG1B,OAAOxU,IACX,CAGA,iBAAMzD,CAAY0Z,EAAsB/V,GACrC,aAAaF,KAAKqU,GAAG4B,EAAO/V,EAC/B,CAGA,oBAAMse,CAAevI,EAAsB/V,GACxC,OAAOF,KAAKsU,IAAI2B,EAAO/V,EAC1B,CASA,aAAIue,GACA,OAAOze,MAAK,CAChB,CAQA0e,OAAAA,GAEI1e,KAAKue,qBAGL,IAAK,MAAMtB,KAAWjd,MAAK,EAAQoB,OAC/BpB,KAAK+T,cAAckJ,GAGvBjd,MAAK,GAAa,CACtB,CAaA,UAAImd,GAAoB,OAA6B,MAArBnd,MAAK,CAAuB,CAC5D,UAAImd,CAAOnJ,KACDA,IAAUhU,KAAKmd,SAEjBnd,KAAKmd,OACLnd,KAAKkU,SAELlU,KAAKgU,OAAM,GAEnB,CAOAA,KAAAA,CAAMC,GAGF,GAFAjU,MAAK,GAAoB,EAEA,MAArBA,MAAK,EAAsB,CAC3B,GAAIA,MAAK,KAAkBiU,EAAmB,QAC9C5Y,EAAAA,EAAAA,KAAO,EAAO,yCAA0C,wBAAyB,CAC7EO,UAAW,S,CAInBoE,KAAKqd,oBAAoBsB,GAAMA,EAAE3K,MAAMC,KACvCjU,MAAK,IAAiBiU,EAEtB,IAAK,MAAM/X,KAAS8D,MAAK,EAAQsR,SAEzBpV,EAAMA,OAASkB,aAAalB,EAAMA,OAGtCA,EAAMkhB,KAAOra,KAAY7G,EAAMkhB,IAEvC,CAKAlJ,MAAAA,GACI,GAAyB,MAArBlU,MAAK,EAAT,CAEAA,KAAKqd,oBAAoBsB,GAAMA,EAAEzK,WACjClU,MAAK,EAAe,KACpB,IAAK,MAAM9D,KAAS8D,MAAK,EAAQsR,SAAU,CAEvC,IAAIhV,EAAUJ,EAAMkhB,KAChB9gB,EAAU,IAAKA,EAAU,GAG7BJ,EAAMkhB,KAAOra,KAGb5G,WAAWD,EAAMwI,KAAMpI,E,EAE/B,EAIJ,SAASie,GAAajX,EAAgBuQ,GAClC,IACI,MAAMtN,EAAQiU,GAAYlX,EAAQuQ,GAClC,GAAItN,EAAS,OAAOtB,EAAAA,EAAAA,IAAasB,E,CACnC,MAAMxK,GAAQ,CAChB,OAAO,IACX,CAEA,SAASye,GAAYlX,EAAgBuQ,GACjC,GAAe,OAAXvQ,EAAmB,OAAO,KAC9B,IACI,MAAMsb,GAAShS,EAAAA,EAAAA,KAAU8C,EAAAA,EAAAA,IAAUpM,EAAQuQ,EAAOA,EAAQ,KACpDlV,GAASiO,EAAAA,EAAAA,KAAU8C,EAAAA,EAAAA,IAAUpM,EAAQsb,EAAQA,EAAS,KAE5D,OAAOlP,EAAAA,EAAAA,IAAUpM,EAAQsb,EAAS,GAAIA,EAAS,GAAKjgB,E,CACtD,MAAO5C,GAAQ,CACjB,OAAO,IACX,CAEA,SAAS8iB,GAAOvhB,GACZ,MAAMgG,GAASwb,EAAAA,EAAAA,IAAUxhB,GACzB,GAAIgG,EAAO3E,OAAS,GAAM,MAAM,IAAIL,MAAM,+BAE1C,MAAMygB,EAAS,IAAIrhB,WAAW,IAE9B,OADAqhB,EAAO9e,IAAIqD,EAAQ,GAAKA,EAAO3E,QACxBogB,CACX,CAEA,SAASC,GAAS1hB,GACd,GAAKA,EAAMqB,OAAS,KAAQ,EAAK,OAAOrB,EAExC,MAAMgG,EAAS,IAAI5F,WAA0C,GAA/BoG,KAAKmb,KAAK3hB,EAAMqB,OAAS,KAEvD,OADA2E,EAAOrD,IAAI3C,GACJgG,CACX,CAEA,MAAM4b,GAAoB,IAAIxhB,WAAW,IAGzC,SAASod,GAAYqE,GACjB,MAAM7b,EAA4B,GAElC,IAAI8b,EAAY,EAGhB,IAAK,IAAIxgB,EAAI,EAAGA,EAAIugB,EAAMxgB,OAAQC,IAC9B0E,EAAOnD,KAAK+e,IACZE,GAAa,GAGjB,IAAK,IAAIxgB,EAAI,EAAGA,EAAIugB,EAAMxgB,OAAQC,IAAK,CACnC,MAAMF,GAAOI,EAAAA,EAAAA,IAASqgB,EAAMvgB,IAG5B0E,EAAO1E,GAAKigB,GAAOO,GAGnB9b,EAAOnD,KAAK0e,GAAOngB,EAAKC,SACxB2E,EAAOnD,KAAK6e,GAAStgB,IACrB0gB,GAAa,GAAmC,GAA9Btb,KAAKmb,KAAKvgB,EAAKC,OAAS,G,CAG9C,OAAOoI,EAAAA,EAAAA,IAAOzD,EAClB,CAEA,MAAM4W,GAAQ,qE,gBCxoDR,MAAOmF,GACT,GAEA,IACA,GAEA,GAEA,IAEA,IAOAvf,WAAAA,CAAYqI,GACRnI,MAAK,EAAYmI,EAEjBnI,MAAK,GAAmB,KACxBA,MAAK,EAAUA,MAAK,EAAM4T,KAAK5T,MAE/BA,MAAK,GAAW,EAEhBA,MAAK,GAAW,KAEhBA,MAAK,IAAS,CAClB,CAKAsf,UAAAA,CAAWnX,GACP,MAAM,IAAI7J,MAAM,gCACpB,CAKAihB,YAAAA,CAAapX,EAA4B7E,GACrC,MAAM,IAAIhF,MAAM,gCACpB,CAKAkhB,QAAAA,CAASrX,GACL,MAAM,IAAI7J,MAAM,gCACpB,CAEA,OAAM,CAAMqO,GACR,IAEiC,MAAzB3M,MAAK,KACLA,MAAK,GAAmBA,KAAKsf,WAAWtf,MAAK,IAIjD,IAAIyf,EAA0B,KAC9B,IACIA,QAAiBzf,MAAK,E,CACxB,MAAOjE,GACL,KAAKwM,EAAAA,EAAAA,IAAQxM,EAAO,0BAAgD,kBAApBA,EAAMH,UAClD,MAAMG,C,CAMd,GAAgB,MAAZ0jB,EAGA,OAFAzf,MAAK,GAAmB,UACxBA,MAAK,EAAUyd,mBAAmBzd,KAAMA,KAAKwf,SAASxf,MAAK,IAI/D,MAAMgL,QAAgBhL,MAAK,EAAUiL,aAGrC,GAFKjL,MAAK,KAAYA,MAAK,GAAWgL,GAEjChL,MAAK,GAAqBuP,UAAYvE,EAAQuE,QAC/C,MAAM,IAAIjR,MAAM,iBAGpB,GAAI0B,MAAK,GAAU,OAEnB,MAAMsD,QAAetD,MAAK,EAAUkE,KAAK,uBAAwB,CAAEub,UAC7Dzf,KAAKuf,aAAavf,MAAK,EAAWsD,E,CAC1C,MAAOvH,GAAS+gB,QAAQ5H,IAAI,QAASnZ,E,CAEvCiE,MAAK,EAAU+c,KAAK,QAAS/c,MAAK,EACtC,CAEA,MACI,MAAM0f,EAAkB1f,MAAK,GACzB0f,IACA1f,MAAK,GAAmB,KACxB0f,EAAgBvK,MAAMsK,IACdzf,MAAK,EAAUye,WACnBze,MAAK,EAAUkE,KAAK,sBAAuB,CAAEub,GAAW,IAGpE,CAEA5L,KAAAA,GACQ7T,MAAK,IACTA,MAAK,GAAW,EAEhBA,MAAK,GAAO,GAChB,CAEA8T,IAAAA,GACS9T,MAAK,IACVA,MAAK,GAAW,EAEhBA,MAAK,IAAS,EACdA,MAAK,KACLA,MAAK,EAAUsU,IAAI,QAAStU,MAAK,GACrC,CAEAgU,KAAAA,CAAMC,GACEA,GAAkBjU,MAAK,KAC3BA,MAAK,EAAUsU,IAAI,QAAStU,MAAK,EACrC,CAEAkU,MAAAA,GAAiBlU,KAAK6T,OAAS,EAQ7B,MAAO8L,WAAgCN,GACzC,IAMAvf,WAAAA,CAAYqI,EAA8BuJ,GAzJ9C,IAAc2B,EA0JN3C,MAAMvI,GACNnI,MAAK,IA3JCqT,EA2Ja3B,EA1JhBrR,KAAK8E,MAAM9E,KAAKC,UAAU+S,IA2JjC,CAEAmM,QAAAA,CAASrX,GACL,OAAO,IAAI2M,GAAuB3M,EAAUnI,MAAK,GACrD,CAEA,gBAAMsf,CAAWnX,GAEb,aADuBA,EAASjE,KAAK,gBAAiB,CAAElE,MAAK,IAEjE,CAEA,kBAAMuf,CAAapX,EAA8ByX,GAC7C,IAAK,MAAMtc,KAAUsc,EACjBzX,EAASuL,KAAK1T,MAAK,GAAQmI,EAAS4P,SAASzU,EAAQ6E,EAASwO,UAEtE,EAQE,MAAOkJ,WAAkCR,GAC3C,gBAAMC,CAAWnX,GACb,aAAaA,EAASjE,KAAK,kCAAmC,GAClE,CAEA,kBAAMqb,CAAapX,EAA8ByX,GAC7C,IAAK,MAAMtc,KAAUsc,EACjBzX,EAASuL,KAAK,UAAWpQ,EAEjC,EC1JJ,MAAMwc,GAAY,+CAA+CrkB,MAAM,MAEvE,SAASskB,GAAkBziB,GACvB,GAAa,MAATA,GAAiBwiB,GAAUxI,eAAeha,IAAW,EACrD,OAAOA,EAIX,GAAwC,oBAAvBA,EAAO2L,WACpB,OAAO3L,EAGX,GAAIV,MAAMqP,QAAQ3O,GAAU,OAAaA,EAAM6J,IAAI4Y,IAEnD,GAAsB,kBAAXziB,EACP,OAAOmD,OAAOW,KAAK9D,GAAO8H,QAAO,CAACC,EAAO9H,KACrC8H,EAAM9H,GAAaD,EAAOC,GACnB8H,IACH,CAAC,GAGb,MAAM,IAAI/G,MAAM,sBAAuBhB,aAAmBA,KAC9D,CAEA,SAASmG,GAAMuc,GACX,OAAO,IAAI/c,SAASC,IAAc/G,WAAW+G,EAAS8c,EAAS,GACnE,CAEA,SAASC,GAAa3iB,GAClB,OAAIA,EAAgBA,EAAM5B,cACnB4B,CACX,CAMA,SAAS4iB,GAAW5iB,GAChB,OAAQA,GAA2C,kBAA3BA,EAAMiW,eAClC,CAsHA,MAAMiD,GAAiB,CACnB2J,SAAS,EACTC,cAAe,KAEfC,eAAgB,GAChBC,aAAe,GAAK,GACpBC,cAAe,IAEf9J,aAAc,IACdlD,gBAAiB,KA0Ef,MAAOiN,WAAsBC,GAAAA,EAC/B3Y,QAEAhI,WAAAA,CAAYqI,EAA8BL,GACtC4I,MAAMvI,GACNL,GAAUmB,EAAAA,EAAAA,GAAWnB,IACrBnC,EAAAA,EAAAA,GAAgC3F,KAAM,CAAE8H,WAC5C,CAEAL,OAAAA,CAAQU,IACJ9M,EAAAA,EAAAA,KAAO,EAAO,iCAAkC,wBAAyB,CACrEO,UAAW,kBAEnB,CAEA,gBAAMqN,GACF,OAAOjJ,KAAK8H,OAChB,CAGA,yBAAM4Y,CAAoBlR,GACtB,aAAaxP,KAAK2gB,aAAanR,EACnC,CAIA,8BAAMoR,CAAyBhH,GAC3B,MAAMpK,EAAKuQ,GAASnG,GAEdxD,EAAiC,GAGvC,GAAI5G,EAAG3S,KAAM,CACT,MAAMgkB,EAAQrR,EAAG3S,KACjBuZ,EAASjW,KAAK,WACV,MAAMtD,QAAayZ,EAAAA,EAAAA,IAAeuK,EAAO7gB,KAAKmI,WAC9CxG,EAAAA,EAAAA,IAAuB,MAAR9E,GAAgBA,EAAKnB,gBAAkBsE,KAAK8H,QAAQpM,cAC/D,wBAAyB,cAAeke,GAC5CpK,EAAG3S,KAAOA,CACb,EALa,G,MAOd2S,EAAG3S,KAAOmD,KAAK8H,QAanB,GAPmB,MAAf0H,EAAG9B,UACH0I,EAASjW,KAAK,WACVqP,EAAG9B,eAAiB1N,KAAKmI,SAASwR,YAAY,IAAKnK,EAAI3S,KAAMmD,KAAK8H,SACrE,EAFa,IAML,MAAT0H,EAAGlB,GAAY,CACf,MAAMwS,EAAMtR,EAAGlB,GACf8H,EAASjW,KAAK,WACVqP,EAAGlB,SAAWgI,EAAAA,EAAAA,IAAewK,EAAK9gB,KAAKmI,SAC1C,EAFa,G,CAMdiO,EAASzX,cAAgBsE,QAAQ/D,IAAIkX,GAEzC,MAAM2K,EAAQ/gB,KAAKmI,SAAS6Y,kBAAkBxR,GAE9C,OAAOxP,KAAKmI,SAASjE,KAAK,sBAAuB,CAAE6c,GACvD,CAEA,qBAAME,CAAgBzR,GAElB,MAAM7C,QAAoB3M,KAAKmI,SAASqL,iBAGlCtG,QAAalN,KAAK4gB,yBAAyBpR,GAKjD,aAAc,IAAIvM,SAAQ,CAACC,EAAS0Z,KAChC,MAAMsE,EAAW,CAAE,IAAM,KACzB,IAAIC,EAAW,EAEf,MAAMC,EAAUlmB,UAEZ,IAEI,MAAMsU,QAAWxP,KAAKmI,SAAS4T,eAAe7O,GAE9C,GAAU,MAANsC,EAEA,YADAtM,EAAQsM,EAAGoM,uBAAuBjP,G,CAIxC,MAAO5Q,GAML,IAAIwM,EAAAA,EAAAA,IAAQxM,EAAO,eAAgBwM,EAAAA,EAAAA,IAAQxM,EAAO,cAC9CwM,EAAAA,EAAAA,IAAQxM,EAAO,mBAAoBwM,EAAAA,EAAAA,IAAQxM,EAAO,yBAMlD,OAJkB,MAAdA,EAAMJ,OAAgBI,EAAMJ,KAAO,CAAC,GACxCI,EAAMJ,KAAK0lB,oBAAsBnU,OAEjC0P,EAAO7gB,GAKX,IAAIwM,EAAAA,EAAAA,IAAQxM,EAAO,sBACfolB,IACkB,MAAdplB,EAAMJ,OAAgBI,EAAMJ,KAAO,CAAC,GACxCI,EAAMJ,KAAK0lB,oBAAsBnU,EAC7BiU,EAAW,IAEX,YADAvE,EAAO7gB,GAOfiE,KAAKmI,SAASuL,KAAK,SAAStX,EAAAA,EAAAA,IAAU,4DAA6D,gBAAiB,CAAEL,U,CAI1HiE,KAAKmI,SAASwL,aAAY,KAAQyN,GAAS,GAAKF,EAASla,OAAS,IAAK,EAE3Eoa,GAAS,GAEjB,CAEA,qBAAME,CAAgB1H,GAClB,MAAMpK,EAAKuQ,GAASnG,GAGpB,GAAIpK,EAAG3S,KAAM,CACT,MAAMA,QAAayZ,EAAAA,EAAAA,IAAe9G,EAAG3S,KAAMmD,KAAKmI,WAChDxG,EAAAA,EAAAA,IAAuB,MAAR9E,GAAgBA,EAAKnB,gBAAkBsE,KAAK8H,QAAQpM,cAC/D,wBAAyB,cAAeke,GAC5CpK,EAAG3S,KAAOA,C,MAEV2S,EAAG3S,KAAOmD,KAAK8H,QAGnB,MAAMiZ,EAAQ/gB,KAAKmI,SAAS6Y,kBAAkBxR,GAC9C,aAAaxP,KAAKmI,SAASjE,KAAK,sBAAuB,CAAE6c,GAC7D,CAGA,iBAAMQ,CAAYC,GACd,MAAMjc,EAAiC,kBAAdic,GAA0BxiB,EAAAA,EAAAA,IAAYwiB,GAAWA,EAC1E,aAAaxhB,KAAKmI,SAASjE,KAAK,gBAAiB,EAC7C5B,EAAAA,EAAAA,IAAQiD,GAAUvF,KAAK8H,QAAQpM,eACvC,CAEA,mBAAM+lB,CAAcC,EAAyBC,EAA8ChP,GACvF,MAAMrV,EAAQyiB,GAASpN,GAGjBiP,QAAkBC,EAAAA,EAAiBC,aAAaJ,EAAQC,EAAOrkB,GAAOpC,UACxE,MAAM4M,QAAgBwO,EAAAA,EAAAA,IAAehZ,GAErC,OADAqE,EAAAA,EAAAA,IAA0B,MAAXmG,EAAiB,0CAA2C,QAASxK,GAC7EwK,CAAO,IAGlB,aAAa9H,KAAKmI,SAASjE,KAAK,uBAAwB,CACpDlE,KAAK8H,QAAQpM,cACb2E,KAAKC,UAAUuhB,EAAAA,EAAiBE,WAAWH,EAAUF,OAAQC,EAAOC,EAAUtkB,SAEtF,CAEA,YAAM0kB,CAAOtgB,GACT,OAAO1B,KAAKmI,SAASjE,KAAK,yBAA0B,CAChDlE,KAAK8H,QAAQpM,cAAegG,EAAU,MAC9C,CAGA,wBAAMugB,CAAmBT,GACrB,MAAMjc,EAAiC,kBAAdic,GAA0BxiB,EAAAA,EAAAA,IAAYwiB,GAAWA,EAC1E,aAAaxhB,KAAKmI,SAASjE,KAAK,WAAY,CACxClE,KAAK8H,QAAQpM,eAAe4G,EAAAA,EAAAA,IAAQiD,IAC5C,EAkBE,MAAgB2c,WAA2BxL,GAE7C,GAGA,IAGA,IACA,IAEA,IAKA,IACA,IAEA,MACI,GAAI1W,MAAK,GAAe,OAGxB,MAAMmiB,EAAkD,IAArCniB,KAAKoiB,WAAW,iBAA0B,EAAGpiB,KAAKoiB,WAAW,kBAEhFpiB,MAAK,GAAc7D,YAAW,KAC1B6D,MAAK,GAAc,KAEnB,MAAMqiB,EAAWriB,MAAK,GAGtB,IAFAA,MAAK,GAAY,GAEVqiB,EAAS1jB,QAAQ,CAGpB,MAAM2jB,EAAQ,CAAYD,EAASE,SACnC,KAAOF,EAAS1jB,QACR2jB,EAAM3jB,SAAWqB,MAAK,EAASugB,eADf,CAEpB+B,EAAMniB,KAAekiB,EAASE,SAE9B,GADcliB,KAAKC,UAAUgiB,EAAMnb,KAAKwK,GAAMA,EAAEqB,WACtCrU,OAASqB,MAAK,EAASsgB,aAAc,CAC3C+B,EAAS1Z,QAAkB2Z,EAAMtb,OACjC,K,EAKR,WACI,MAAMgM,EAA6B,IAAjBsP,EAAM3jB,OAAgB2jB,EAAM,GAAGtP,QAASsP,EAAMnb,KAAKwK,GAAMA,EAAEqB,UAE7EhT,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,iBAAkBvE,YAE/C,IACI,MAAM1P,QAAetD,KAAKwiB,MAAMxP,GAChChT,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,mBAAoBjU,WAGjD,IAAK,MAAM,QAAEJ,EAAO,OAAE0Z,EAAM,QAAE5J,KAAasP,EAAO,CAE9C,GAAItiB,KAAKye,UAAW,CAChB7B,GAAOxgB,EAAAA,EAAAA,IAAU,wCAAyC,wBAAyB,CAAER,UAAWoX,EAAQvW,UACxG,Q,CAIJ,MAAMQ,EAAOqG,EAAOoO,QAAQ+Q,GAAOA,EAAEC,KAAO1P,EAAQ0P,KAAK,GAGzD,GAAY,MAARzlB,EAUA,UAAWA,EACX2f,EAAO5c,KAAK2iB,YAAY3P,EAAS/V,IAKrCiG,EAAQjG,EAAKqG,YAhBb,CACI,MAAMvH,GAAQK,EAAAA,EAAAA,IAAU,+BAAgC,WAAY,CAChEkB,MAAOgG,EAAQ3H,KAAM,CAAEqX,aAE3BhT,KAAK0T,KAAK,QAAS3X,GACnB6gB,EAAO7gB,E,GAcjB,MAAOA,GACLiE,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,kBAAmBxb,UAEhD,IAAK,MAAM,OAAE6gB,KAAY0F,EAErB1F,EAAO7gB,E,CAGlB,EAhDD,E,IAkDLomB,EACP,CAEAriB,WAAAA,CAAYkL,EAAsB/P,GAC9ByV,MAAM1F,EAAS/P,GAEf+E,MAAK,GAAU,EACfA,MAAK,EAAWS,OAAOC,OAAO,CAAC,EAAI8V,GAAgBvb,GAAW,CAAC,GAE/D+E,MAAK,GAAY,GACjBA,MAAK,GAAc,KAEnBA,MAAK,GAAW,KAChBA,MAAK,GAAwB,KAE7B,CACI,IAAIkD,EAA0C,KAC9C,MAAM6X,EAAU,IAAI9X,SAAS2f,IACzB1f,EAAU0f,CAAQ,IAEtB5iB,MAAK,GAAY,CAAE+a,UAAS7X,U,CAGhC,MAAMkd,EAAgBpgB,KAAKoiB,WAAW,iBACR,mBAAnBhC,IACPze,EAAAA,EAAAA,KAAgBye,GAA6B,QAAZpV,EAAmB,wDAAyD,UAAW/P,GACpHmlB,GAA4B,MAAXpV,IACjBhL,MAAK,GAAWkR,GAAQrU,KAAKmO,KAG1BoV,KAEPze,EAAAA,EAAAA,IAA0B,MAAXqJ,GAAmBoV,EAAchP,QAAQpG,GACpD,0CAA2C,UAAW/P,GAC1D+E,MAAK,GAAWogB,EAExB,CAOAgC,UAAAA,CAAsD7kB,GAClD,OAAOyC,MAAK,EAASzC,EACzB,CAMA,YAAIoZ,GAEA,OADAtb,EAAAA,EAAAA,IAAQ2E,MAAK,GAAU,+BAAgC,iBAChDA,MAAK,EAChB,CAgBA,cAAM6W,CAAS1b,GAIX,GAAmB,SAAfA,EAAIsB,QAAoC,gBAAftB,EAAIsB,OAA0B,CACvD,IAAI+S,EAAKrU,EAAIsc,YACb,GAAIjI,GAAiB,MAAXA,EAAGxF,OAAgByD,EAAAA,EAAAA,IAAU+B,EAAGxF,OAEf,MAAnBwF,EAAGJ,cAAmD,MAA3BI,EAAGL,qBAA8B,CAC5D,MAAMuK,QAAgB1Z,KAAKoZ,aACC,MAAxBM,EAAQtK,cAAwD,MAAhCsK,EAAQvK,uBAExChU,EAAMsF,OAAOC,OAAO,CAAC,EAAIvF,EAAK,CAC1Bsc,YAAahX,OAAOC,OAAO,CAAC,EAAI8O,EAAI,CAAExF,UAAMjN,M,EAOhE,MAAMgD,EAAUC,KAAK6iB,cAAc1nB,GAEnC,OAAe,MAAX4E,QACaC,KAAKkE,KAAKnE,EAAQtD,OAAQsD,EAAQ6a,MAG5ClK,MAAMmG,SAAS1b,EAC1B,CASA,oBAAMod,GACF,MAAMvN,EAAUhL,KAAKoiB,WAAW,iBAChC,GAAIpX,EAAS,CACT,IAAgB,IAAZA,EAGA,OAAOA,EAFP,GAAIhL,MAAK,GAAY,OAAOA,MAAK,E,CAMzC,OAAIA,MAAK,SACQA,MAAK,GAIlBA,KAAK8iB,OACL9iB,MAAK,GAAwB,WACzB,IACI,MAAMsD,EAAS4N,GAAQrU,MAAK4Q,EAAAA,EAAAA,UAAgBzN,KAAKkE,KAAK,cAAe,MAErE,OADAlE,MAAK,GAAwB,KACtBsD,C,CACT,MAAOvH,GAEL,MADAiE,MAAK,GAAwB,KACvBjE,C,CAEb,EAT4B,SAUhBiE,MAAK,KAItBA,MAAK,GAAwB,WACzB,MAAMgT,EAA0B,CAC5B0P,GAAI1iB,MAAK,KAAWvD,OAAQ,cAAe+F,OAAQ,GAAKugB,QAAS,OAKrE,IAAIzf,EAFJtD,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,iBAAkBvE,YAG/C,IACI1P,SAAgBtD,KAAKwiB,MAAMxP,IAAU,GACrChT,MAAK,GAAwB,I,CAC/B,MAAOjE,GAGL,MAFAiE,MAAK,GAAwB,KAC7BA,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,kBAAmBxb,UAC1CA,C,CAKV,GAFAiE,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,mBAAoBjU,WAE7C,WAAYA,EACZ,OAAO4N,GAAQrU,MAAK4Q,EAAAA,EAAAA,IAAUnK,EAAOA,SAGzC,MAAMtD,KAAK2iB,YAAY3P,EAAS1P,EACnC,EAxB4B,SA0BhBtD,MAAK,GACtB,CASAgjB,MAAAA,GAC0B,MAAlBhjB,MAAK,IAA+C,MAA1BA,MAAK,GAAUkD,UAE7ClD,MAAK,GAAUkD,UACflD,MAAK,GAAY,KAEjB,WAGI,KAAwB,MAAjBA,MAAK,KAAqBA,KAAKye,WAClC,IACIze,MAAK,SAAiBA,KAAKuY,gB,CAC7B,MAAOxc,GACL,GAAIiE,KAAKye,UAAa,MACtB3B,QAAQ5H,IAAI,mIACZlV,KAAK0T,KAAK,SAAStX,EAAAA,EAAAA,IAAU,wCAAyC,gBAAiB,CAAE6Z,MAAO,4BAA6Bta,KAAM,CAAEI,kBAC/H0H,GAAM,I,CAKpBzD,MAAK,IACR,EAhBD,GAiBJ,CAOA,qBAAMijB,GACF,GAAsB,MAAlBjjB,MAAK,GACT,aAAaA,MAAK,GAAU+a,OAChC,CASAyC,cAAAA,CAAeF,GAGX,MAAiB,YAAbA,EAAItT,KAA6B,IAAI6V,GAA0B7f,MAElD,UAAbsd,EAAItT,KACAhK,KAAKoiB,WAAW,WACT,IAAItN,GAAuB9U,KAAMsd,EAAI5L,QAEzC,IAAIiO,GAAwB3f,KAAMsd,EAAI5L,QAKhC,WAAb4L,EAAItT,MAA2C,aAAtBsT,EAAI5L,OAAOsE,OAC7B,IAAIN,GAAoB,UAG5BhF,MAAM8M,eAAeF,EAChC,CAKA,SAAIwF,GAAmB,OAAyB,MAAlB9iB,MAAK,EAAmB,CAOtDghB,iBAAAA,CAAkBxR,GACd,MAAMlM,EAAoC,CAAC,EA+B3C,MA5BA,CAAC,UAAW,WAAY,WAAY,OAAQ,eAAgB,uBAAwB,QAAS,SAASjG,SAASE,IAC3G,GAAsB,MAAZiS,EAAIjS,GAAgB,OAC9B,IAAI2lB,EAAS3lB,EACD,aAARA,IAAsB2lB,EAAS,OAC7B5f,EAAQ4f,IAAUvK,EAAAA,EAAAA,KAAWlL,EAAAA,EAAAA,IAAgB+B,EAAIjS,GAAM,MAAOA,KAAQ,IAIhF,CAAC,OAAQ,KAAM,QAAQF,SAASE,IACN,MAAZiS,EAAIjS,KACR+F,EAAQ/F,IAAO+E,EAAAA,EAAAA,IAAckN,EAAIjS,IAAK,IAI5CiS,EAAGT,aACHzL,EAAmB,YAAI0L,EAAAA,EAAAA,GAAcQ,EAAGT,aAGxCS,EAAGP,sBAEG3L,EAA6B,oBAAIkM,EAAGP,oBAAoB9H,KAAIgc,GAAKA,EAAEznB,iBAQtE4H,CACX,CAMAuf,aAAAA,CAAc1nB,GACV,OAAQA,EAAIsB,QACR,IAAK,UACD,MAAO,CAAEA,OAAQ,cAAeme,KAAM,IAE1C,IAAK,iBACD,MAAO,CAAEne,OAAQ,kBAAmBme,KAAM,IAE9C,IAAK,cACD,MAAO,CAAEne,OAAQ,eAAgBme,KAAM,IAE3C,IAAK,iBACD,MAAO,CAAEne,OAAQ,2BAA4Bme,KAAM,IAEvD,IAAK,aACD,MAAO,CACHne,OAAQ,iBACRme,KAAM,CAAEqF,GAAa9kB,EAAI2M,SAAU3M,EAAIud,WAG/C,IAAK,sBACD,MAAO,CACHjc,OAAQ,0BACRme,KAAM,CAAEqF,GAAa9kB,EAAI2M,SAAU3M,EAAIud,WAG/C,IAAK,UACD,MAAO,CACHjc,OAAQ,cACRme,KAAM,CAAEqF,GAAa9kB,EAAI2M,SAAU3M,EAAIud,WAG/C,IAAK,aACD,MAAO,CACHjc,OAAQ,mBACRme,KAAM,CACFqF,GAAa9kB,EAAI2M,SAChB,KAAO3M,EAAIogB,SAASlZ,SAAS,IAC9BlH,EAAIud,WAIhB,IAAK,uBACD,MAAO,CACHjc,OAAQ,yBACRme,KAAM,CAAEzf,EAAIugB,oBAGpB,IAAK,WACD,GAAI,aAAcvgB,EACd,MAAO,CACHsB,OAAQ,uBACRme,KAAM,CAAEzf,EAAIud,WAAYvd,EAAI0gB,sBAE7B,GAAI,cAAe1gB,EACtB,MAAO,CACHsB,OAAQ,qBACRme,KAAM,CAAEzf,EAAIuR,YAAavR,EAAI0gB,sBAGrC,MAEJ,IAAK,iBACD,MAAO,CACHpf,OAAQ,2BACRme,KAAM,CAAEzf,EAAI+R,OAGpB,IAAK,wBACD,MAAO,CACHzQ,OAAQ,4BACRme,KAAM,CAAEzf,EAAI+R,OAGpB,IAAK,OACD,MAAO,CACHzQ,OAAQ,WACRme,KAAM,CAAE5a,KAAKghB,kBAAkB7lB,EAAIsc,aAActc,EAAIud,WAG7D,IAAK,cACD,MAAO,CACHjc,OAAQ,kBACRme,KAAM,CAAE5a,KAAKghB,kBAAkB7lB,EAAIsc,eAI3C,IAAK,UAQD,OAPItc,EAAIuW,QAAgC,MAAtBvW,EAAIuW,OAAO5J,UACrBlL,MAAMqP,QAAQ9Q,EAAIuW,OAAO5J,SACzB3M,EAAIuW,OAAO5J,QAAU3M,EAAIuW,OAAO5J,QAAQX,IAAI8Y,IAE5C9kB,EAAIuW,OAAO5J,QAAUmY,GAAa9kB,EAAIuW,OAAO5J,UAG9C,CAAErL,OAAQ,cAAeme,KAAM,CAAEzf,EAAIuW,SAGpD,OAAO,IACX,CAQAiR,WAAAA,CAAY3P,EAAyB7V,GACjC,MAAM,OAAEV,GAAWuW,GACb,MAAEjX,GAAUoB,EAElB,GAAe,oBAAXV,GAAgCV,EAAMwJ,QAAS,CAC/C,MAAM6d,EAAMrnB,EAAMwJ,QAClB,IAAK6d,EAAI/kB,MAAM,YAAc+kB,EAAI/kB,MAAM,uBACnC,OAAOjC,EAAAA,EAAAA,IAAU,qBAAsB,qBAAsB,CACzDqb,YAAoBzE,EAASxQ,OAAO,GACpC7G,KAAM,CAAEqX,UAASjX,U,CAK7B,GAAe,aAAXU,GAAoC,oBAAXA,EAA8B,CACvD,MAAM6G,EAAS+f,GAAYtnB,GAErBgK,EAAIud,EAAAA,EAASC,wBACH,aAAX9mB,EAAyB,OAAQ,cAC3BuW,EAASxQ,OAAO,GACtBc,EAASA,EAAO5E,KAAM,MAG3B,OADAqH,EAAEpK,KAAO,CAAEI,QAAOiX,WACXjN,C,CAMX,MAAMR,EAAUlF,KAAKC,UA+S7B,SAAwBhD,GACpB,MAAMgG,EAAwB,GAE9B,OADAkgB,GAAgBlmB,EAAOgG,GAChBA,CACX,CAnTuCmgB,CAAe1nB,IAE9C,GAA8B,kBAAnBA,EAAMwJ,SAAyBxJ,EAAMwJ,QAAQlH,MAAM,mCAAoC,CAC9F,MAAMqlB,EAAuH,CACzHC,SAAU,cACVC,cAAe,cACfC,qBAAsB,gBACtBC,oBAAqB,kBACrBC,oBAAqB,kBACrBC,oBAAqB,gBACrBC,uBAAwB,iBAG5B,OAAO7nB,EAAAA,EAAAA,IAAU,uBAAwB,kBAAmB,CACxDmb,OAASmM,EAAUjnB,IAAW,UAC9BuG,OAAQ,WACRrH,KAAM,CAAEqX,UAASjX,U,CAIzB,GAAe,2BAAXU,GAAkD,wBAAXA,EAAkC,CACzE,MAAMgb,EAA8CzE,EAASxQ,OAAO,GAEpE,GAAI+C,EAAQlH,MAAM,kDACd,OAAOjC,EAAAA,EAAAA,IAAU,oDAAqD,qBAAsB,CACxFqb,cAAa9b,KAAM,CAAEI,WAI7B,GAAIwJ,EAAQlH,MAAM,WAAakH,EAAQlH,MAAM,YACzC,OAAOjC,EAAAA,EAAAA,IAAU,8BAA+B,gBAAiB,CAAEqb,cAAa9b,KAAM,CAAEI,WAI5F,GAAIwJ,EAAQlH,MAAM,6BAA+BkH,EAAQlH,MAAM,gBAC3D,OAAOjC,EAAAA,EAAAA,IAAU,0BAA2B,0BAA2B,CAAEqb,cAAa9b,KAAM,CAAEI,WAGlG,GAAIwJ,EAAQlH,MAAM,0BACd,OAAOjC,EAAAA,EAAAA,IAAU,gDAAiD,wBAAyB,CACvFR,UAAWa,EAAQd,KAAM,CAAE8b,cAAa9b,KAAM,CAAEI,W,CAK5D,IAAImoB,IAAgB3e,EAAQlH,MAAM,iCAOlC,OANK6lB,GACGnoB,GAAeA,EAAOooB,SAAiBpoB,EAAOooB,QAAQC,WAAW,0BACjEF,GAAc,GAIlBA,GACO9nB,EAAAA,EAAAA,IAAU,wBAAyB,wBAAyB,CAC/DR,UAAWoX,EAAQvW,OAAQd,KAAM,CAAEI,QAAOiX,cAI3C5W,EAAAA,EAAAA,IAAU,2BAA4B,gBAAiB,CAAEL,QAAOiX,WAC3E,CAgBA9O,IAAAA,CAAKzH,EAAgB+F,GAIjB,GAAIxC,KAAKye,UACL,OAAOxb,QAAQ2Z,QAAOxgB,EAAAA,EAAAA,IAAU,wCAAyC,wBAAyB,CAAER,UAAWa,KAGnH,MAAMimB,EAAK1iB,MAAK,KACV+a,EAAU,IAAI9X,SAAQ,CAACC,EAAS0Z,KAClC5c,MAAK,GAAUG,KAAK,CAChB+C,UAAS0Z,SACT5J,QAAS,CAAEvW,SAAQ+F,SAAQkgB,KAAIK,QAAS,QAC1C,IAMN,OAFA/iB,MAAK,KAE0B+a,CACnC,CAcA,eAAMsJ,CAAUvc,GACG,MAAXA,IAAmBA,EAAU,GAEjC,MAAMwc,EAAkBtkB,KAAKkE,KAAK,eAAgB,IAGlD,GAAwB,kBAAb4D,EAAuB,CAC9B,MAAMyc,QAAiCD,EACvC,GAAIxc,GAAWyc,EAAS5lB,OAAU,MAAM,IAAIL,MAAM,mBAClD,OAAO,IAAIkiB,GAAcxgB,KAAMukB,EAASzc,G,CAG5C,MAAM,SAAEyc,SAAmB/K,EAAAA,EAAAA,GAAkB,CACzCxO,QAAShL,KAAKiL,aACdsZ,SAAUD,IAIdxc,GAAUmB,EAAAA,EAAAA,GAAWnB,GACrB,IAAK,MAAM0c,KAAWD,EAClB,IAAItb,EAAAA,EAAAA,GAAWub,KAAa1c,EACxB,OAAO,IAAI0Y,GAAcxgB,KAAM8H,GAIvC,MAAM,IAAIxJ,MAAM,kBACpB,CAEA,kBAAMmmB,GAEF,aADsCzkB,KAAKkE,KAAK,eAAgB,KAChDiD,KAAKoP,GAAM,IAAIiK,GAAcxgB,KAAMuW,IACvD,CAEAmI,OAAAA,GAGQ1e,MAAK,KACL5C,aAAa4C,MAAK,IAClBA,MAAK,GAAc,MAIvB,IAAK,MAAM,QAAEgT,EAAO,OAAE4J,KAAY5c,MAAK,GACnC4c,GAAOxgB,EAAAA,EAAAA,IAAU,wCAAyC,wBAAyB,CAAER,UAAWoX,EAAQvW,UAG5GuD,MAAK,GAAY,GAGjB0Q,MAAMgO,SAEV,EASE,MAAgBgG,WAAkCxC,GACpD,IACApiB,WAAAA,CAAYkL,EAAsB/P,GAC9ByV,MAAM1F,EAAS/P,GAEf,IAAIsY,EAAkBvT,KAAKoiB,WAAW,mBACf,MAAnB7O,IAA2BA,EAAkBiD,GAAejD,iBAEhEvT,MAAK,GAAmBuT,CAC5B,CAEAiK,cAAAA,CAAeF,GACX,MAAMC,EAAa7M,MAAM8M,eAAeF,GAIxC,OAHI4C,GAAW3C,KACXA,EAAWhK,gBAAkBvT,MAAK,IAE/Bud,CACX,CAKA,mBAAIhK,GAA4B,OAAOvT,MAAK,EAAkB,CAC9D,mBAAIuT,CAAgBjW,GAChB,IAAKmI,OAAOC,UAAUpI,IAAUA,EAAQ,EAAK,MAAM,IAAIgB,MAAM,oBAC7D0B,MAAK,GAAmB1C,EACxB0C,KAAKqd,oBAAoBC,IACjB4C,GAAW5C,KACXA,EAAI/J,gBAAkBvT,MAAK,G,GAGvC,EAqDJ,SAASqjB,GAAY/lB,GACjB,GAAa,MAATA,EAAiB,OAAO,KAG5B,GAA8B,kBAAnBA,EAAMiI,SAAyBjI,EAAMiI,QAAQlH,MAAM,aAAc+K,EAAAA,EAAAA,IAAY9L,EAAMoB,MAC1F,MAAO,CAAE6G,QAASjI,EAAMiI,QAAS7G,KAAMpB,EAAMoB,MAIjD,GAAsB,kBAAXpB,EAAqB,CAC5B,IAAK,MAAMC,KAAOD,EAAO,CACrB,MAAMgG,EAAS+f,GAAY/lB,EAAMC,IACjC,GAAI+F,EAAU,OAAOA,C,CAEzB,OAAO,I,CAIX,GAAsB,kBAAXhG,EACP,IACI,OAAO+lB,GAAYhjB,KAAK8E,MAAM7H,G,CAChC,MAAOvB,GAAQ,CAGrB,OAAO,IACX,CAEA,SAASynB,GAAgBlmB,EAAYgG,GACjC,GAAa,MAAThG,EAAJ,CAQA,GAL8B,kBAAnBA,EAAMiI,SACbjC,EAAOnD,KAAK7C,EAAMiI,SAIA,kBAAXjI,EACP,IAAK,MAAMC,KAAOD,EACdkmB,GAAgBlmB,EAAMC,GAAM+F,GAKpC,GAAsB,kBAAXhG,EACP,IACI,OAAOkmB,GAAgBnjB,KAAK8E,MAAM7H,GAAQgG,E,CAC5C,MAAOvH,GAAQ,C,CAEzB,CCluCM,MAAO4oB,WAAwBD,GACjC,GAMA5kB,WAAAA,CAAY8kB,EAA2B5Z,EAAsB6Z,GAEzD,MAAM5pB,EAAqCwF,OAAOC,OAAO,CAAC,EAC1C,MAAZmkB,EAAoBA,EAAU,CAAC,EACjC,CAAEtE,cAAe,KAEnB5e,EAAAA,EAAAA,IAAeijB,GAAYA,EAAS7kB,QAAS,4BAA6B,WAAY6kB,GAEtFlU,MAAM1F,EAAS/P,GAEf+E,MAAK,EAAW9E,MAAOuB,EAAgB+F,KACnC,MAAMwQ,EAAU,CAAEvW,SAAQ+F,UAC1BxC,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,qBAAsBvE,YACnD,IACI,MAAM1P,QAAeshB,EAAS7kB,QAAQiT,GAEtC,OADAhT,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,uBAAwBjU,WAC9CA,C,CACT,MAAOyC,GACL,MAAMhK,EAAQ,IAAIuC,MAAMyH,EAAER,SAK1B,MAJMxJ,EAAOoD,KAAO4G,EAAE5G,KAChBpD,EAAO2C,KAAOqH,EAAErH,KAChB3C,EAAOiX,QAAUA,EACvBhT,KAAK0T,KAAK,QAAS,CAAE6D,OAAQ,sBAAuBxb,UAC9CA,C,EAGlB,CAEA,UAAMmI,CAAKzH,EAAgB+F,GAGvB,aAFMxC,KAAKgjB,eAEEtS,MAAMxM,KAAKzH,EAAQ+F,EACpC,CAEA,WAAMggB,CAAMxP,IACRrR,EAAAA,EAAAA,KAAgB/E,MAAMqP,QAAQ+G,GAAU,0CAA2C,UAAWA,GAE9F,IACI,MAAM1P,QAAetD,MAAK,EAASgT,EAAQvW,OAAQuW,EAAQxQ,QAAU,IACrE,MAAO,CAAE,CAAEkgB,GAAI1P,EAAQ0P,GAAIpf,U,CAC7B,MAAOyC,GACL,MAAO,CAAE,CACL2c,GAAI1P,EAAQ0P,GACZ3mB,MAAO,CAAEoD,KAAM4G,EAAE5G,KAAMT,KAAMqH,EAAErH,KAAM6G,QAASQ,EAAER,U,CAG5D,CAEAod,WAAAA,CAAY3P,EAAyBjX,GAMjC,QAJAA,EAAQsE,KAAK8E,MAAM9E,KAAKC,UAAUvE,KAIpBA,MAAMoD,OAAS,GACzB,KAAK,KACDpD,EAAMA,MAAMwJ,QAAU,uBAAwBxJ,EAAMA,MAAMwJ,UAC1D,MACJ,KAAK,KACDxJ,EAAMA,MAAMwJ,QAAU,uBAAwBxJ,EAAMA,MAAMwJ,UAIlE,OAAOmL,MAAMiS,YAAY3P,EAASjX,EACtC,CAKA,eAAM+oB,CAAUhd,GACG,MAAXA,IAAmBA,EAAU,GAEjC,MAAMyc,QAAiBvkB,KAAKkE,KAAK,eAAgB,IACjD,MAAwB,kBAAb4D,EACCyc,EAAS5lB,OAASmJ,GAG9BA,EAAUA,EAAQpM,cAC8D,IAAzE6oB,EAAS7S,QAAQ6E,GAAeA,EAAE7a,gBAAkBoM,IAAUnJ,OACzE,CAEA,eAAM0lB,CAAUvc,GAGZ,GAFe,MAAXA,IAAmBA,EAAU,UAErB9H,KAAK8kB,UAAUhd,GACvB,UAEU9H,MAAK,EAAS,sBAAuB,G,CAG7C,MAAOjE,GACL,MAAMiX,EAAUjX,EAAMiX,QACtB,MAAMhT,KAAK2iB,YAAY3P,EAAS,CAAE0P,GAAI1P,EAAQ0P,GAAI3mB,S,CAI1D,aAAa2U,MAAM2T,UAAUvc,EACjC,E","sources":["../node_modules/ethers/src.ts/utils/geturl-browser.ts","../node_modules/ethers/src.ts/utils/fetch.ts","../node_modules/ethers/src.ts/utils/base64-browser.ts","../node_modules/ethers/src.ts/hash/namehash.ts","../node_modules/ethers/src.ts/providers/ens-resolver.ts","../node_modules/ethers/src.ts/providers/format.ts","../node_modules/ethers/src.ts/address/contract-address.ts","../node_modules/ethers/src.ts/providers/plugins-network.ts","../node_modules/ethers/src.ts/providers/network.ts","../node_modules/ethers/src.ts/providers/subscriber-polling.ts","../node_modules/ethers/src.ts/providers/abstract-provider.ts","../node_modules/ethers/src.ts/providers/subscriber-filterid.ts","../node_modules/ethers/src.ts/providers/provider-jsonrpc.ts","../node_modules/ethers/src.ts/providers/provider-browser.ts"],"sourcesContent":["import { assert, makeError } from \"./errors.js\";\n\nimport type {\n    FetchGetUrlFunc, FetchRequest, FetchCancelSignal, GetUrlResponse\n} from \"./fetch.js\";\n\nexport function createGetUrl(options?: Record<string, any>): FetchGetUrlFunc {\n\n    async function getUrl(req: FetchRequest, _signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n        assert(_signal == null || !_signal.cancelled, \"request cancelled before sending\", \"CANCELLED\");\n\n        const protocol = req.url.split(\":\")[0].toLowerCase();\n\n        assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${ protocol }`, \"UNSUPPORTED_OPERATION\", {\n            info: { protocol },\n            operation: \"request\"\n        });\n\n        assert(protocol === \"https\" || !req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"request\"\n        });\n\n        let error: null | Error = null;\n\n        const controller = new AbortController();\n\n        const timer = setTimeout(() => {\n            error = makeError(\"request timeout\", \"TIMEOUT\");\n            controller.abort();\n        }, req.timeout);\n\n        if (_signal) {\n            _signal.addListener(() => {\n                error = makeError(\"request cancelled\", \"CANCELLED\");\n                controller.abort();\n            });\n        }\n\n        const init = {\n            method: req.method,\n            headers: new Headers(Array.from(req)),\n            body: req.body || undefined,\n            signal: controller.signal\n        };\n\n        let resp: Awaited<ReturnType<typeof fetch>>;\n        try {\n            resp = await fetch(req.url, init);\n        } catch (_error) {\n            clearTimeout(timer);\n            if (error) { throw error; }\n            throw _error;\n        }\n\n        clearTimeout(timer);\n\n        const headers: Record<string, string> = { };\n        resp.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n\n        const respBody = await resp.arrayBuffer();\n        const body = (respBody == null) ? null: new Uint8Array(respBody);\n\n        return {\n            statusCode: resp.status,\n            statusMessage: resp.statusText,\n            headers, body\n        };\n    }\n\n    return getUrl;\n}\n\n// @TODO: remove in v7; provided for backwards compat\nconst defaultGetUrl: FetchGetUrlFunc = createGetUrl({ });\n\nexport async function getUrl(req: FetchRequest, _signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n    return defaultGetUrl(req, _signal);\n}\n\n","/**\n *  Fetching content from the web is environment-specific, so Ethers\n *  provides an abstraction that each environment can implement to provide\n *  this service.\n *\n *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to\n *  create a request object, register event listeners and process data\n *  and populate the [[FetchResponse]].\n *\n *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting\n *  ``Promise`` is waited on to retrieve the payload.\n *\n *  The [[FetchRequest]] is responsible for handling many common situations,\n *  such as redirects, server throttling, authentication, etc.\n *\n *  It also handles common gateways, such as IPFS and data URIs.\n *\n *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]\n */\nimport { decodeBase64, encodeBase64 } from \"./base64.js\";\nimport { hexlify } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nimport { defineProperties } from \"./properties.js\";\nimport { toUtf8Bytes, toUtf8String } from \"./utf8.js\";\n\nimport { createGetUrl } from \"./geturl.js\";\n\n/**\n *  An environment's implementation of ``getUrl`` must return this type.\n */\nexport type GetUrlResponse = {\n    statusCode: number,\n    statusMessage: string,\n    headers: Record<string, string>,\n    body: null | Uint8Array\n};\n\n/**\n *  This can be used to control how throttling is handled in\n *  [[FetchRequest-setThrottleParams]].\n */\nexport type FetchThrottleParams = {\n    maxAttempts?: number;\n    slotInterval?: number;\n};\n\n/**\n *  Called before any network request, allowing updated headers (e.g. Bearer tokens), etc.\n */\nexport type FetchPreflightFunc = (req: FetchRequest) => Promise<FetchRequest>;\n\n/**\n *  Called on the response, allowing client-based throttling logic or post-processing.\n */\nexport type FetchProcessFunc = (req: FetchRequest, resp: FetchResponse) => Promise<FetchResponse>;\n\n/**\n *  Called prior to each retry; return true to retry, false to abort.\n */\nexport type FetchRetryFunc = (req: FetchRequest, resp: FetchResponse, attempt: number) => Promise<boolean>;\n\n/**\n *  Called on Gateway URLs.\n */\nexport type FetchGatewayFunc = (url: string, signal?: FetchCancelSignal) => Promise<FetchRequest | FetchResponse>;\n\n/**\n *  Used to perform a fetch; use this to override the underlying network\n *  fetch layer. In NodeJS, the default uses the \"http\" and \"https\" libraries\n *  and in the browser ``fetch`` is used. If you wish to use Axios, this is\n *  how you would register it.\n */\nexport type FetchGetUrlFunc = (req: FetchRequest, signal?: FetchCancelSignal) => Promise<GetUrlResponse>;\n\n\nconst MAX_ATTEMPTS = 12;\nconst SLOT_INTERVAL = 250;\n\n// The global FetchGetUrlFunc implementation.\nlet defaultGetUrlFunc: FetchGetUrlFunc = createGetUrl();\n\nconst reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\nconst reIpfs = new RegExp(\"^ipfs:/\\/(ipfs/)?(.*)$\", \"i\");\n\n// If locked, new Gateways cannot be added\nlet locked = false;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs\nasync function dataGatewayFunc(url: string, signal?: FetchCancelSignal): Promise<FetchResponse> {\n    try {\n        const match = url.match(reData);\n        if (!match) { throw new Error(\"invalid data\"); }\n        return new FetchResponse(200, \"OK\", {\n            \"content-type\": (match[1] || \"text/plain\"),\n        }, (match[2] ? decodeBase64(match[3]): unpercent(match[3])));\n    } catch (error) {\n        return new FetchResponse(599, \"BAD REQUEST (invalid data: URI)\", { }, null, new FetchRequest(url));\n    }\n}\n\n/**\n *  Returns a [[FetchGatewayFunc]] for fetching content from a standard\n *  IPFS gateway hosted at %%baseUrl%%.\n */\nfunction getIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc {\n    async function gatewayIpfs(url: string, signal?: FetchCancelSignal): Promise<FetchRequest | FetchResponse> {\n        try {\n            const match = url.match(reIpfs);\n            if (!match) { throw new Error(\"invalid link\"); }\n            return new FetchRequest(`${ baseUrl }${ match[2] }`);\n        } catch (error) {\n            return new FetchResponse(599, \"BAD REQUEST (invalid IPFS URI)\", { }, null, new FetchRequest(url));\n        }\n    }\n\n    return gatewayIpfs;\n}\n\nconst Gateways: Record<string, FetchGatewayFunc> = {\n    \"data\": dataGatewayFunc,\n    \"ipfs\": getIpfsGatewayFunc(\"https:/\\/gateway.ipfs.io/ipfs/\")\n};\n\nconst fetchSignals: WeakMap<FetchRequest, () => void> = new WeakMap();\n\n/**\n *  @_ignore\n */\nexport class FetchCancelSignal {\n    #listeners: Array<() => void>;\n    #cancelled: boolean;\n\n    constructor(request: FetchRequest) {\n        this.#listeners = [ ];\n        this.#cancelled = false;\n\n        fetchSignals.set(request, () => {\n            if (this.#cancelled) { return; }\n            this.#cancelled = true;\n\n            for (const listener of this.#listeners) {\n                setTimeout(() => { listener(); }, 0);\n            }\n            this.#listeners = [ ];\n        });\n    }\n\n    addListener(listener: () => void): void {\n        assert(!this.#cancelled, \"singal already cancelled\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fetchCancelSignal.addCancelListener\"\n        });\n        this.#listeners.push(listener);\n    }\n\n    get cancelled(): boolean { return this.#cancelled; }\n\n    checkSignal(): void {\n        assert(!this.cancelled, \"cancelled\", \"CANCELLED\", { });\n    }\n}\n\n// Check the signal, throwing if it is cancelled\nfunction checkSignal(signal?: FetchCancelSignal): FetchCancelSignal {\n    if (signal == null) { throw new Error(\"missing signal; should not happen\"); }\n    signal.checkSignal();\n    return signal;\n}\n\n/**\n *  Represents a request for a resource using a URI.\n *\n *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,\n *  and ``IPFS:``.\n *\n *  Additional schemes can be added globally using [[registerGateway]].\n *\n *  @example:\n *    req = new FetchRequest(\"https://www.ricmoo.com\")\n *    resp = await req.send()\n *    resp.body.length\n *    //_result:\n */\nexport class FetchRequest implements Iterable<[ key: string, value: string ]> {\n    #allowInsecure: boolean;\n    #gzip: boolean;\n    #headers: Record<string, string>;\n    #method: string;\n    #timeout: number;\n    #url: string;\n\n    #body?: Uint8Array;\n    #bodyType?: string;\n    #creds?: string;\n\n    // Hooks\n    #preflight?: null | FetchPreflightFunc;\n    #process?: null | FetchProcessFunc;\n    #retry?: null | FetchRetryFunc;\n\n    #signal?: FetchCancelSignal;\n\n    #throttle: Required<FetchThrottleParams>;\n\n    #getUrlFunc: null | FetchGetUrlFunc;\n\n    /**\n     *  The fetch URL to request.\n     */\n    get url(): string { return this.#url; }\n    set url(url: string) {\n        this.#url = String(url);\n    }\n\n    /**\n     *  The fetch body, if any, to send as the request body. //(default: null)//\n     *\n     *  When setting a body, the intrinsic ``Content-Type`` is automatically\n     *  set and will be used if **not overridden** by setting a custom\n     *  header.\n     *\n     *  If %%body%% is null, the body is cleared (along with the\n     *  intrinsic ``Content-Type``).\n     *\n     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to\n     *  ``text/plain``.\n     *\n     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to\n     *  ``application/octet-stream``.\n     *\n     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is\n     *  set to ``application/json``.\n     */\n    get body(): null | Uint8Array {\n        if (this.#body == null) { return null; }\n        return new Uint8Array(this.#body);\n    }\n    set body(body: null | string | Readonly<object> | Readonly<Uint8Array>) {\n        if (body == null) {\n            this.#body = undefined;\n            this.#bodyType = undefined;\n        } else if (typeof(body) === \"string\") {\n            this.#body = toUtf8Bytes(body);\n            this.#bodyType = \"text/plain\";\n        } else if (body instanceof Uint8Array) {\n            this.#body = body;\n            this.#bodyType = \"application/octet-stream\";\n        } else if (typeof(body) === \"object\") {\n            this.#body = toUtf8Bytes(JSON.stringify(body));\n            this.#bodyType = \"application/json\";\n        } else {\n            throw new Error(\"invalid body\");\n        }\n    }\n\n    /**\n     *  Returns true if the request has a body.\n     */\n    hasBody(): this is (FetchRequest & { body: Uint8Array }) {\n        return (this.#body != null);\n    }\n\n    /**\n     *  The HTTP method to use when requesting the URI. If no method\n     *  has been explicitly set, then ``GET`` is used if the body is\n     *  null and ``POST`` otherwise.\n     */\n    get method(): string {\n        if (this.#method) { return this.#method; }\n        if (this.hasBody()) { return \"POST\"; }\n        return \"GET\";\n    }\n    set method(method: null | string) {\n        if (method == null) { method = \"\"; }\n        this.#method = String(method).toUpperCase();\n    }\n\n    /**\n     *  The headers that will be used when requesting the URI. All\n     *  keys are lower-case.\n     *\n     *  This object is a copy, so any changes will **NOT** be reflected\n     *  in the ``FetchRequest``.\n     *\n     *  To set a header entry, use the ``setHeader`` method.\n     */\n    get headers(): Record<string, string> {\n        const headers = Object.assign({ }, this.#headers);\n\n        if (this.#creds) {\n            headers[\"authorization\"] = `Basic ${ encodeBase64(toUtf8Bytes(this.#creds)) }`;\n        };\n\n        if (this.allowGzip) {\n            headers[\"accept-encoding\"] = \"gzip\";\n        }\n\n        if (headers[\"content-type\"] == null && this.#bodyType) {\n            headers[\"content-type\"] = this.#bodyType;\n        }\n        if (this.body) { headers[\"content-length\"] = String(this.body.length); }\n\n        return headers;\n    }\n\n    /**\n     *  Get the header for %%key%%, ignoring case.\n     */\n    getHeader(key: string): string {\n        return this.headers[key.toLowerCase()];\n    }\n\n    /**\n     *  Set the header for %%key%% to %%value%%. All values are coerced\n     *  to a string.\n     */\n    setHeader(key: string, value: string | number): void {\n        this.#headers[String(key).toLowerCase()] = String(value);\n    }\n\n    /**\n     *  Clear all headers, resetting all intrinsic headers.\n     */\n    clearHeaders(): void {\n        this.#headers = { };\n    }\n\n    [Symbol.iterator](): Iterator<[ key: string, value: string ]> {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [ key, headers[key] ], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    /**\n     *  The value that will be sent for the ``Authorization`` header.\n     *\n     *  To set the credentials, use the ``setCredentials`` method.\n     */\n    get credentials(): null | string {\n        return this.#creds || null;\n    }\n\n    /**\n     *  Sets an ``Authorization`` for %%username%% with %%password%%.\n     */\n    setCredentials(username: string, password: string): void {\n        assertArgument(!username.match(/:/), \"invalid basic authentication username\", \"username\", \"[REDACTED]\");\n        this.#creds = `${ username }:${ password }`;\n    }\n\n    /**\n     *  Enable and request gzip-encoded responses. The response will\n     *  automatically be decompressed. //(default: true)//\n     */\n    get allowGzip(): boolean {\n        return this.#gzip;\n    }\n    set allowGzip(value: boolean) {\n        this.#gzip = !!value;\n    }\n\n    /**\n     *  Allow ``Authentication`` credentials to be sent over insecure\n     *  channels. //(default: false)//\n     */\n    get allowInsecureAuthentication(): boolean {\n        return !!this.#allowInsecure;\n    }\n    set allowInsecureAuthentication(value: boolean) {\n        this.#allowInsecure = !!value;\n    }\n\n    /**\n     *  The timeout (in milliseconds) to wait for a complete response.\n     *  //(default: 5 minutes)//\n     */\n    get timeout(): number { return this.#timeout; }\n    set timeout(timeout: number) {\n        assertArgument(timeout >= 0, \"timeout must be non-zero\", \"timeout\", timeout);\n        this.#timeout = timeout;\n    }\n\n    /**\n     *  This function is called prior to each request, for example\n     *  during a redirection or retry in case of server throttling.\n     *\n     *  This offers an opportunity to populate headers or update\n     *  content before sending a request.\n     */\n    get preflightFunc(): null | FetchPreflightFunc {\n        return this.#preflight || null;\n    }\n    set preflightFunc(preflight: null | FetchPreflightFunc) {\n        this.#preflight = preflight;\n    }\n\n    /**\n     *  This function is called after each response, offering an\n     *  opportunity to provide client-level throttling or updating\n     *  response data.\n     *\n     *  Any error thrown in this causes the ``send()`` to throw.\n     *\n     *  To schedule a retry attempt (assuming the maximum retry limit\n     *  has not been reached), use [[response.throwThrottleError]].\n     */\n    get processFunc(): null | FetchProcessFunc {\n        return this.#process || null;\n    }\n    set processFunc(process: null | FetchProcessFunc) {\n        this.#process = process;\n    }\n\n    /**\n     *  This function is called on each retry attempt.\n     */\n    get retryFunc(): null | FetchRetryFunc {\n        return this.#retry || null;\n    }\n    set retryFunc(retry: null | FetchRetryFunc) {\n        this.#retry = retry;\n    }\n\n    /**\n     *  This function is called to fetch content from HTTP and\n     *  HTTPS URLs and is platform specific (e.g. nodejs vs\n     *  browsers).\n     *\n     *  This is by default the currently registered global getUrl\n     *  function, which can be changed using [[registerGetUrl]].\n     *  If this has been set, setting is to ``null`` will cause\n     *  this FetchRequest (and any future clones) to revert back to\n     *  using the currently registered global getUrl function.\n     *\n     *  Setting this is generally not necessary, but may be useful\n     *  for developers that wish to intercept requests or to\n     *  configurege a proxy or other agent.\n     */\n    get getUrlFunc(): FetchGetUrlFunc {\n        return this.#getUrlFunc || defaultGetUrlFunc;\n    }\n    set getUrlFunc(value: null | FetchGetUrlFunc) {\n        this.#getUrlFunc = value;\n    }\n\n    /**\n     *  Create a new FetchRequest instance with default values.\n     *\n     *  Once created, each property may be set before issuing a\n     *  ``.send()`` to make the request.\n     */\n    constructor(url: string) {\n        this.#url = String(url);\n\n        this.#allowInsecure = false;\n        this.#gzip = true;\n        this.#headers = { };\n        this.#method = \"\";\n        this.#timeout = 300000;\n\n        this.#throttle = {\n            slotInterval: SLOT_INTERVAL,\n            maxAttempts: MAX_ATTEMPTS\n        };\n\n        this.#getUrlFunc = null;\n    }\n\n    toString(): string {\n        return `<FetchRequest method=${ JSON.stringify(this.method) } url=${ JSON.stringify(this.url) } headers=${ JSON.stringify(this.headers) } body=${ this.#body ? hexlify(this.#body): \"null\" }>`;\n    }\n\n    /**\n     *  Update the throttle parameters used to determine maximum\n     *  attempts and exponential-backoff properties.\n     */\n    setThrottleParams(params: FetchThrottleParams): void {\n        if (params.slotInterval != null) {\n            this.#throttle.slotInterval = params.slotInterval;\n        }\n        if (params.maxAttempts != null) {\n            this.#throttle.maxAttempts = params.maxAttempts;\n        }\n    }\n\n    async #send(attempt: number, expires: number, delay: number, _request: FetchRequest, _response: FetchResponse): Promise<FetchResponse> {\n        if (attempt >= this.#throttle.maxAttempts) {\n            return _response.makeServerError(\"exceeded maximum retry limit\");\n        }\n\n        assert(getTime() <= expires, \"timeout\", \"TIMEOUT\", {\n            operation: \"request.send\", reason: \"timeout\", request: _request\n        });\n\n        if (delay > 0) { await wait(delay); }\n\n        let req = this.clone();\n        const scheme = (req.url.split(\":\")[0] || \"\").toLowerCase();\n\n        // Process any Gateways\n        if (scheme in Gateways) {\n            const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));\n            if (result instanceof FetchResponse) {\n                let response = result;\n\n                if (this.processFunc) {\n                    checkSignal(_request.#signal);\n                    try {\n                        response = await this.processFunc(req, response);\n                    } catch (error: any) {\n\n                        // Something went wrong during processing; throw a 5xx server error\n                        if (error.throttle == null || typeof(error.stall) !== \"number\") {\n                            response.makeServerError(\"error in post-processing function\", error).assertOk();\n                        }\n\n                        // Ignore throttling\n                    }\n                }\n\n                return response;\n            }\n            req = result;\n        }\n\n        // We have a preflight function; update the request\n        if (this.preflightFunc) { req = await this.preflightFunc(req); }\n\n        const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));\n        let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);\n\n        if (response.statusCode === 301 || response.statusCode === 302) {\n\n            // Redirect\n            try {\n                const location = response.headers.location || \"\";\n                return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);\n            } catch (error) { }\n\n            // Things won't get any better on another attempt; abort\n            return response;\n\n        } else if (response.statusCode === 429) {\n\n            // Throttle\n            if (this.retryFunc == null || (await this.retryFunc(req, response, attempt))) {\n                const retryAfter = response.headers[\"retry-after\"];\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));\n                if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                    delay = parseInt(retryAfter);\n                }\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n\n        if (this.processFunc) {\n            checkSignal(_request.#signal);\n            try {\n                response = await this.processFunc(req, response);\n            } catch (error: any) {\n\n                // Something went wrong during processing; throw a 5xx server error\n                if (error.throttle == null || typeof(error.stall) !== \"number\") {\n                    response.makeServerError(\"error in post-processing function\", error).assertOk();\n                }\n\n                // Throttle\n                let delay = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));;\n                if (error.stall >= 0) { delay = error.stall; }\n\n                return req.clone().#send(attempt + 1, expires, delay, _request, response);\n            }\n        }\n\n        return response;\n    }\n\n    /**\n     *  Resolves to the response by sending the request.\n     */\n    send(): Promise<FetchResponse> {\n        assert(this.#signal == null, \"request already sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.send\" });\n        this.#signal = new FetchCancelSignal(this);\n        return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, \"\", { }, null, this));\n    }\n\n    /**\n     *  Cancels the inflight response, causing a ``CANCELLED``\n     *  error to be rejected from the [[send]].\n     */\n    cancel(): void {\n        assert(this.#signal != null, \"request has not been sent\", \"UNSUPPORTED_OPERATION\", { operation: \"fetchRequest.cancel\" });\n        const signal = fetchSignals.get(this);\n        if (!signal) { throw new Error(\"missing signal; should not happen\"); }\n        signal();\n    }\n\n    /**\n     *  Returns a new [[FetchRequest]] that represents the redirection\n     *  to %%location%%.\n     */\n    redirect(location: string): FetchRequest {\n        // Redirection; for now we only support absolute locations\n        const current = this.url.split(\":\")[0].toLowerCase();\n        const target = location.split(\":\")[0].toLowerCase();\n\n        // Don't allow redirecting:\n        // - non-GET requests\n        // - downgrading the security (e.g. https => http)\n        // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]\n        assert(this.method === \"GET\" && (current !== \"https\" || target !== \"http\") && location.match(/^https?:/), `unsupported redirect`, \"UNSUPPORTED_OPERATION\", {\n            operation: `redirect(${ this.method } ${ JSON.stringify(this.url) } => ${ JSON.stringify(location) })`\n        });\n\n        // Create a copy of this request, with a new URL\n        const req = new FetchRequest(location);\n        req.method = \"GET\";\n        req.allowGzip = this.allowGzip;\n        req.timeout = this.timeout;\n        req.#headers = Object.assign({ }, this.#headers);\n        if (this.#body) { req.#body = new Uint8Array(this.#body); }\n        req.#bodyType = this.#bodyType;\n\n        // Do not forward credentials unless on the same domain; only absolute\n        //req.allowInsecure = false;\n        // paths are currently supported; may want a way to specify to forward?\n        //setStore(req.#props, \"creds\", getStore(this.#pros, \"creds\"));\n\n        return req;\n    }\n\n    /**\n     *  Create a new copy of this request.\n     */\n    clone(): FetchRequest {\n        const clone = new FetchRequest(this.url);\n\n        // Preserve \"default method\" (i.e. null)\n        clone.#method = this.#method;\n\n        // Preserve \"default body\" with type, copying the Uint8Array is present\n        if (this.#body) { clone.#body = this.#body; }\n        clone.#bodyType = this.#bodyType;\n\n        // Preserve \"default headers\"\n        clone.#headers = Object.assign({ }, this.#headers);\n\n        // Credentials is readonly, so we copy internally\n        clone.#creds = this.#creds;\n\n        if (this.allowGzip) { clone.allowGzip = true; }\n\n        clone.timeout = this.timeout;\n        if (this.allowInsecureAuthentication) { clone.allowInsecureAuthentication = true; }\n\n        clone.#preflight = this.#preflight;\n        clone.#process = this.#process;\n        clone.#retry = this.#retry;\n\n        clone.#throttle = Object.assign({ }, this.#throttle);\n\n        clone.#getUrlFunc = this.#getUrlFunc;\n\n        return clone;\n    }\n\n    /**\n     *  Locks all static configuration for gateways and FetchGetUrlFunc\n     *  registration.\n     */\n    static lockConfig(): void {\n        locked = true;\n    }\n\n    /**\n     *  Get the current Gateway function for %%scheme%%.\n     */\n    static getGateway(scheme: string): null | FetchGatewayFunc {\n        return Gateways[scheme.toLowerCase()] || null;\n    }\n\n    /**\n     *  Use the %%func%% when fetching URIs using %%scheme%%.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGateway(scheme: string, func: FetchGatewayFunc): void {\n        scheme = scheme.toLowerCase();\n        if (scheme === \"http\" || scheme === \"https\") {\n            throw new Error(`cannot intercept ${ scheme }; use registerGetUrl`);\n        }\n        if (locked) { throw new Error(\"gateways locked\"); }\n        Gateways[scheme] = func;\n    }\n\n    /**\n     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.\n     *\n     *  This method affects all requests globally.\n     *\n     *  If [[lockConfig]] has been called, no change is made and this\n     *  throws.\n     */\n    static registerGetUrl(getUrl: FetchGetUrlFunc): void {\n        if (locked) { throw new Error(\"gateways locked\"); }\n        defaultGetUrlFunc = getUrl;\n    }\n\n    /**\n     *  Creates a getUrl function that fetches content from HTTP and\n     *  HTTPS URLs.\n     *\n     *  The available %%options%% are dependent on the platform\n     *  implementation of the default getUrl function.\n     *\n     *  This is not generally something that is needed, but is useful\n     *  when trying to customize simple behaviour when fetching HTTP\n     *  content.\n     */\n    static createGetUrlFunc(options?: Record<string, any>): FetchGetUrlFunc {\n        return createGetUrl(options);\n    }\n\n    /**\n     *  Creates a function that can \"fetch\" data URIs.\n     *\n     *  Note that this is automatically done internally to support\n     *  data URIs, so it is not necessary to register it.\n     *\n     *  This is not generally something that is needed, but may\n     *  be useful in a wrapper to perfom custom data URI functionality.\n     */\n    static createDataGateway(): FetchGatewayFunc {\n        return dataGatewayFunc;\n    }\n\n    /**\n     *  Creates a function that will fetch IPFS (unvalidated) from\n     *  a custom gateway baseUrl.\n     *\n     *  The default IPFS gateway used internally is\n     *  ``\"https:/\\/gateway.ipfs.io/ipfs/\"``.\n     */\n    static createIpfsGatewayFunc(baseUrl: string): FetchGatewayFunc {\n        return getIpfsGatewayFunc(baseUrl);\n    }\n}\n\n\ninterface ThrottleError extends Error {\n    stall: number;\n    throttle: true;\n};\n\n/**\n *  The response for a FetchRequest.\n */\nexport class FetchResponse implements Iterable<[ key: string, value: string ]> {\n    #statusCode: number;\n    #statusMessage: string;\n    #headers: Record<string, string>;\n    #body: null | Readonly<Uint8Array>;\n    #request: null | FetchRequest;\n\n    #error: { error?: Error, message: string };\n\n    toString(): string {\n        return `<FetchResponse status=${ this.statusCode } body=${ this.#body ? hexlify(this.#body): \"null\" }>`;\n    }\n\n    /**\n     *  The response status code.\n     */\n    get statusCode(): number { return this.#statusCode; }\n\n    /**\n     *  The response status message.\n     */\n    get statusMessage(): string { return this.#statusMessage; }\n\n    /**\n     *  The response headers. All keys are lower-case.\n     */\n    get headers(): Record<string, string> { return Object.assign({ }, this.#headers); }\n\n    /**\n     *  The response body, or ``null`` if there was no body.\n     */\n    get body(): null | Readonly<Uint8Array> {\n        return (this.#body == null) ? null: new Uint8Array(this.#body);\n    }\n\n    /**\n     *  The response body as a UTF-8 encoded string, or the empty\n     *  string (i.e. ``\"\"``) if there was no body.\n     *\n     *  An error is thrown if the body is invalid UTF-8 data.\n     */\n    get bodyText(): string {\n        try {\n            return (this.#body == null) ? \"\": toUtf8String(this.#body);\n        } catch (error) {\n            assert(false, \"response body is not valid UTF-8 data\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyText\", info: { response: this }\n            });\n        }\n    }\n\n    /**\n     *  The response body, decoded as JSON.\n     *\n     *  An error is thrown if the body is invalid JSON-encoded data\n     *  or if there was no body.\n     */\n    get bodyJson(): any {\n        try {\n            return JSON.parse(this.bodyText);\n        } catch (error) {\n            assert(false, \"response body is not valid JSON\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"bodyJson\", info: { response: this }\n            });\n        }\n    }\n\n    [Symbol.iterator](): Iterator<[ key: string, value: string ]> {\n        const headers = this.headers;\n        const keys = Object.keys(headers);\n        let index = 0;\n        return {\n            next: () => {\n                if (index < keys.length) {\n                    const key = keys[index++];\n                    return {\n                        value: [ key, headers[key] ], done: false\n                    }\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n\n    constructor(statusCode: number, statusMessage: string, headers: Readonly<Record<string, string>>, body: null | Uint8Array, request?: FetchRequest) {\n        this.#statusCode = statusCode;\n        this.#statusMessage = statusMessage;\n        this.#headers = Object.keys(headers).reduce((accum, k) => {\n            accum[k.toLowerCase()] = String(headers[k]);\n            return accum;\n        }, <Record<string, string>>{ });\n        this.#body = ((body == null) ? null: new Uint8Array(body));\n        this.#request = (request || null);\n\n        this.#error = { message: \"\" };\n    }\n\n    /**\n     *  Return a Response with matching headers and body, but with\n     *  an error status code (i.e. 599) and %%message%% with an\n     *  optional %%error%%.\n     */\n    makeServerError(message?: string, error?: Error): FetchResponse {\n        let statusMessage: string;\n        if (!message) {\n            message = `${ this.statusCode } ${ this.statusMessage }`;\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${ message })`;\n        } else {\n            statusMessage = `CLIENT ESCALATED SERVER ERROR (${ this.statusCode } ${ this.statusMessage }; ${ message })`;\n        }\n        const response = new FetchResponse(599, statusMessage, this.headers,\n            this.body, this.#request || undefined);\n        response.#error = { message, error };\n        return response;\n    }\n\n    /**\n     *  If called within a [request.processFunc](FetchRequest-processFunc)\n     *  call, causes the request to retry as if throttled for %%stall%%\n     *  milliseconds.\n     */\n    throwThrottleError(message?: string, stall?: number): never {\n        if (stall == null) {\n            stall = -1;\n        } else {\n            assertArgument(Number.isInteger(stall) && stall >= 0, \"invalid stall timeout\", \"stall\", stall);\n        }\n\n        const error = new Error(message || \"throttling requests\");\n\n        defineProperties(<ThrottleError>error, { stall, throttle: true });\n\n        throw error;\n    }\n\n    /**\n     *  Get the header value for %%key%%, ignoring case.\n     */\n    getHeader(key: string): string {\n        return this.headers[key.toLowerCase()];\n    }\n\n    /**\n     *  Returns true if the response has a body.\n     */\n    hasBody(): this is (FetchResponse & { body: Uint8Array }) {\n        return (this.#body != null);\n    }\n\n    /**\n     *  The request made for this response.\n     */\n    get request(): null | FetchRequest { return this.#request; }\n\n    /**\n     *  Returns true if this response was a success statusCode.\n     */\n    ok(): boolean {\n        return (this.#error.message === \"\" && this.statusCode >= 200 && this.statusCode < 300);\n    }\n\n    /**\n     *  Throws a ``SERVER_ERROR`` if this response is not ok.\n     */\n    assertOk(): void {\n        if (this.ok()) { return; }\n        let { message, error } = this.#error;\n        if (message === \"\") {\n            message = `server response ${ this.statusCode } ${ this.statusMessage }`;\n        }\n\n        let requestUrl: null | string = null;\n        if (this.request) { requestUrl = this.request.url; }\n\n        let responseBody: null | string = null;\n        try {\n            if (this.#body) { responseBody = toUtf8String(this.#body); }\n        } catch (e) { }\n\n        assert(false, message, \"SERVER_ERROR\", {\n            request: (this.request || \"unknown request\"), response: this, error,\n            info: {\n                requestUrl, responseBody,\n                responseStatus: `${ this.statusCode } ${ this.statusMessage }` }\n        });\n    }\n}\n\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\nfunction wait(delay: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n}\n","\n// utils/base64-browser\n\nimport { getBytes } from \"./data.js\";\n\nimport type { BytesLike } from \"./data.js\";\n\n\nexport function decodeBase64(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = new Uint8Array(textData.length);\n    for (let i = 0; i < textData.length; i++) {\n        data[i] = textData.charCodeAt(i);\n    }\n    return getBytes(data);\n}\n\nexport function encodeBase64(_data: BytesLike): string {\n    const data = getBytes(_data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n","\nimport { keccak256 } from \"../crypto/index.js\";\nimport {\n    concat, hexlify, assertArgument, toUtf8Bytes\n} from \"../utils/index.js\";\n\n\nimport { ens_normalize } from \"@adraffy/ens-normalize\";\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nfunction checkComponent(comp: Uint8Array): Uint8Array {\n    assertArgument(comp.length !== 0, \"invalid ENS name; empty component\", \"comp\", comp)\n    return comp;\n}\n\nfunction ensNameSplit(name: string): Array<Uint8Array> {\n    const bytes = toUtf8Bytes(ensNormalize(name));\n    const comps: Array<Uint8Array> = [ ];\n\n    if (name.length === 0) { return comps; }\n\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n\n    // There was a stray separator at the end of the name\n    assertArgument(last < bytes.length, \"invalid ENS name; empty component\", \"name\", name);\n\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n\n/**\n *  Returns the ENS %%name%% normalized.\n */\nexport function ensNormalize(name: string): string {\n    try {\n        if (name.length === 0) { throw new Error(\"empty label\"); }\n        return ens_normalize(name);\n    } catch (error: any) {\n        assertArgument(false, `invalid ENS name (${ error.message })`, \"name\", name);\n    }\n}\n\n/**\n *  Returns ``true`` if %%name%% is a valid ENS name.\n */\nexport function isValidName(name: string): name is string {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}\n\n/**\n *  Returns the [[link-namehash]] for %%name%%.\n */\nexport function namehash(name: string): string {\n    assertArgument(typeof(name) === \"string\", \"invalid ENS name; not a string\", \"name\", name);\n\n    assertArgument(name.length, `invalid ENS name (empty label)`, \"name\", name);\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([ result, keccak256(<Uint8Array>(comps.pop()))] ));\n    }\n\n    return hexlify(result);\n}\n\n/**\n *  Returns the DNS encoded %%name%%.\n *\n *  This is used for various parts of ENS name resolution, such\n *  as the wildcard resolution.\n */\nexport function dnsEncode(name: string, _maxLength?: number): string {\n    const length = (_maxLength != null) ? _maxLength: 63;\n\n    assertArgument(length <= 255, \"DNS encoded label cannot exceed 255\", \"length\", length);\n\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        assertArgument(comp.length <= length, `label ${ JSON.stringify(name) } exceeds ${ length } bytes`, \"name\", name);\n\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n","/**\n *  ENS is a service which allows easy-to-remember names to map to\n *  network addresses.\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\n\nimport { getAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { dnsEncode, namehash } from \"../hash/index.js\";\nimport {\n    hexlify, isHexString, toBeHex,\n    defineProperties, encodeBase58,\n    assert, assertArgument, isError,\n    FetchRequest\n} from \"../utils/index.js\";\n\nimport type { FunctionFragment } from \"../abi/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport type { AbstractProvider, AbstractProviderPlugin } from \"./abstract-provider.js\";\nimport type { EnsPlugin } from \"./plugins-network.js\";\nimport type { Provider } from \"./provider.js\";\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        assertArgument(false, \"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\n/**\n *  The type of data found during a steip during avatar resolution.\n */\nexport type AvatarLinkageType = \"name\" | \"avatar\" | \"!avatar\" | \"url\" | \"data\" | \"ipfs\" |\n    \"erc721\" | \"erc1155\" | \"!erc721-caip\" | \"!erc1155-caip\" |\n    \"!owner\" | \"owner\" | \"!balance\" | \"balance\" |\n    \"metadata-url-base\" | \"metadata-url-expanded\" | \"metadata-url\" | \"!metadata-url\" |\n    \"!metadata\" | \"metadata\" |\n    \"!imageUrl\" | \"imageUrl-ipfs\" | \"imageUrl\" | \"!imageUrl-ipfs\";\n\n/**\n *  An individual record for each step during avatar resolution.\n */\nexport interface AvatarLinkage {\n    /**\n     *  The type of linkage.\n     */\n    type: AvatarLinkageType;\n\n    /**\n     *  The linkage value.\n     */\n    value: string;\n};\n\n/**\n *  When resolving an avatar for an ENS name, there are many\n *  steps involved, fetching metadata, validating results, et cetera.\n *\n *  Some applications may wish to analyse this data, or use this data\n *  to diagnose promblems, so an **AvatarResult** provides details of\n *  each completed step during avatar resolution.\n */\nexport interface AvatarResult {\n    /**\n     *  How the [[url]] was arrived at, resolving the many steps required\n     *  for an avatar URL.\n     */\n    linkage: Array<AvatarLinkage>;\n\n    /**\n     *  The avatar URL or null if the avatar was not set, or there was\n     *  an issue during validation (such as the address not owning the\n     *  avatar or a metadata error).\n     */\n    url: null | string;\n};\n\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nexport abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    /**\n     *  The name.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **MulticoinProviderPluing** for %%name%%.\n     */\n    constructor(name: string) {\n        defineProperties<MulticoinProviderPlugin>(this, { name });\n    }\n\n    connect(proivder: Provider): MulticoinProviderPlugin {\n        return this;\n    }\n\n    /**\n     *  Returns ``true`` if %%coinType%% is supported by this plugin.\n     */\n    supportsCoinType(coinType: number): boolean {\n        return false;\n    }\n\n    /**\n     *  Resolves to the encoded %%address%% for %%coinType%%.\n     */\n    async encodeAddress(coinType: number, address: string): Promise<string> {\n        throw new Error(\"unsupported coin\");\n    }\n\n    /**\n     *  Resolves to the decoded %%data%% for %%coinType%%.\n     */\n    async decodeAddress(coinType: number, data: BytesLike): Promise<string> {\n        throw new Error(\"unsupported coin\");\n    }\n}\n\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n\n/**\n *  A **BasicMulticoinProviderPlugin** provides service for common\n *  coin types, which do not require additional libraries to encode or\n *  decode.\n */\nexport class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    /**\n     *  Creates a new **BasicMulticoinProviderPlugin**.\n     */\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nexport class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resolver was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544: null | Promise<boolean>;\n\n    #resolver: Contract;\n\n    constructor(provider: AbstractProvider, address: string, name: string) {\n        defineProperties<EnsResolver>(this, { provider, address, name });\n        this.#supports2544 = null;\n\n        this.#resolver = new Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (bytes)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n\n    }\n\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard(): Promise<boolean> {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if (isError(error, \"CALL_EXCEPTION\")) { return false; }\n\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n\n                    throw error;\n                }\n            })();\n        }\n\n        return await this.#supports2544;\n    }\n\n    async #fetch(funcName: string, params?: Array<any>): Promise<null | any> {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n\n        // The first parameters is always the nodehash\n        params.unshift(namehash(this.name))\n\n        let fragment: null | FunctionFragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            assert(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n\n            params = [\n                dnsEncode(this.name, 255),\n                iface.encodeFunctionData(fragment, params)\n            ];\n\n            funcName = \"resolve(bytes,bytes)\";\n        }\n\n        params.push({\n            enableCcipRead: true\n        });\n\n        try {\n            const result = await this.#resolver[funcName](...params);\n\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n\n            return result;\n        } catch (error: any) {\n            if (!isError(error, \"CALL_EXCEPTION\")) { throw error; }\n        }\n\n        return null;\n    }\n\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType?: number): Promise<null | string> {\n        if (coinType == null) { coinType = 60; }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n\n                // No address\n                if (result == null || result === ZeroAddress) { return null; }\n\n                return result;\n            } catch (error: any) {\n                if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n                throw error;\n            }\n        }\n\n        // Try decoding its EVM canonical chain as an EVM chain address first\n        if (coinType >= 0 && coinType < 0x80000000) {\n            let ethCoinType = coinType + 0x80000000;\n\n            const data = await this.#fetch(\"addr(bytes32,uint)\", [ ethCoinType ]);\n            if (isHexString(data, 20)) { return getAddress(data); }\n        }\n\n        let coinPlugin: null | MulticoinProviderPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) { continue; }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n\n        if (coinPlugin == null) { return null; }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [ coinType ]);\n\n        // No address\n        if (data == null || data === \"0x\") { return null; }\n\n        // Compute the address\n        const address = await coinPlugin.decodeAddress(coinType, data);\n\n        if (address != null) { return address; }\n\n        assert(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${ coinType })`,\n            info: { coinType, data }\n        });\n    }\n\n    /**\n     *  Resolves to the EIP-634 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key: string): Promise<null | string> {\n        const data = await this.#fetch(\"text(bytes32,string)\", [ key ]);\n        if (data == null || data === \"0x\") { return null; }\n        return data;\n    }\n\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash(): Promise<null | string> {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n\n        // No contenthash\n        if (data == null || data === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\": \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${ scheme }:/\\/${ encodeBase58(\"0x\" + ipfs[2])}`;\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${ swarm[1] }`;\n        }\n\n        assert(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar(): Promise<null | string> {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar(): Promise<AvatarResult> {\n        const linkage: Array<AvatarLinkage> = [ { type: \"name\", value: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\": \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: <any>`!${ scheme }caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n\n                        const tokenId = comps[1];\n\n                        const contract = new Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", toBeHex(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n\n                        // Get the token metadata\n                        let metadata: any = { };\n                        const response = await (new FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n\n                        try {\n                            metadata = response.bodyJson;\n                        } catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            } catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: hexlify(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", value: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return { linkage, url: null };\n    }\n\n    static async getEnsAddress(provider: Provider): Promise<string> {\n        const network = await provider.getNetwork();\n\n        const ensPlugin = network.getPlugin<EnsPlugin>(\"org.ethers.plugins.network.Ens\");\n\n        // No ENS...\n        assert(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network } });\n\n        return ensPlugin.address;\n    }\n\n    static async #getResolver(provider: Provider, name: string): Promise<null | string> {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n\n        try {\n            const contract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n\n            const addr = await contract.resolver(namehash(name), {\n                enableCcipRead: true\n            });\n\n            if (addr === ZeroAddress) { return null; }\n            return addr;\n\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n\n        return null;\n    }\n\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider: AbstractProvider, name: string): Promise<null | EnsResolver> {\n\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\n","/**\n *  @_ignore\n */\nimport { getAddress, getCreateAddress } from \"../address/index.js\";\nimport { Signature } from \"../crypto/index.js\"\nimport { accessListify } from \"../transaction/index.js\";\nimport {\n    getBigInt, getNumber, hexlify, isHexString, zeroPadValue,\n    assert, assertArgument\n} from \"../utils/index.js\";\n\nimport type {\n    BlockParams, LogParams,\n    TransactionReceiptParams, TransactionResponseParams,\n} from \"./formatting.js\";\n\n\nconst BN_0 = BigInt(0);\n\nexport type FormatFunc = (value: any) => any;\n\nexport function allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n    return (function(value: any) {\n        if (value == null) { return nullValue; }\n        return format(value);\n    });\n}\n\nexport function arrayOf(format: FormatFunc, allowNull?: boolean): FormatFunc {\n    return ((array: any) => {\n        if (allowNull && array == null) { return null; }\n        if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n        return array.map((i) => format(i));\n    });\n}\n\n// Requires an object which matches a fleet of other formatters\n// Any FormatFunc may return `undefined` to have the value omitted\n// from the result object. Calls preserve `this`.\nexport function object(format: Record<string, FormatFunc>, altNames?: Record<string, Array<string>>): FormatFunc {\n    return ((value: any) => {\n        const result: any = { };\n        for (const key in format) {\n            let srcKey = key;\n            if (altNames && key in altNames && !(srcKey in value)) {\n                for (const altKey of altNames[key]) {\n                    if (altKey in value) {\n                        srcKey = altKey;\n                        break;\n                    }\n                }\n            }\n\n            try {\n                const nv = format[key](value[srcKey]);\n                if (nv !== undefined) { result[key] = nv; }\n            } catch (error) {\n                const message = (error instanceof Error) ? error.message: \"not-an-error\";\n                assert(false, `invalid value for value.${ key } (${ message })`, \"BAD_DATA\", { value })\n            }\n        }\n        return result;\n    });\n}\n\nexport function formatBoolean(value: any): boolean {\n    switch (value) {\n        case true: case \"true\":\n            return true;\n        case false: case \"false\":\n            return false;\n    }\n    assertArgument(false, `invalid boolean; ${ JSON.stringify(value) }`, \"value\", value);\n}\n\nexport function formatData(value: string): string {\n    assertArgument(isHexString(value, true), \"invalid data\", \"value\", value);\n    return value;\n}\n\nexport function formatHash(value: any): string {\n    assertArgument(isHexString(value, 32), \"invalid hash\", \"value\", value);\n    return value;\n}\n\nexport function formatUint256(value: any): string {\n    if (!isHexString(value)) {\n        throw new Error(\"invalid uint256\");\n    }\n    return zeroPadValue(value, 32);\n}\n\nconst _formatLog = object({\n    address: getAddress,\n    blockHash: formatHash,\n    blockNumber: getNumber,\n    data: formatData,\n    index: getNumber,\n    removed: allowNull(formatBoolean, false),\n    topics: arrayOf(formatHash),\n    transactionHash: formatHash,\n    transactionIndex: getNumber,\n}, {\n    index: [ \"logIndex\" ]\n});\n\nexport function formatLog(value: any): LogParams {\n    return _formatLog(value);\n}\n\nconst _formatBlock = object({\n    hash: allowNull(formatHash),\n    parentHash: formatHash,\n    parentBeaconBlockRoot: allowNull(formatHash, null),\n\n    number: getNumber,\n\n    timestamp: getNumber,\n    nonce: allowNull(formatData),\n    difficulty: getBigInt,\n\n    gasLimit: getBigInt,\n    gasUsed: getBigInt,\n\n    stateRoot: allowNull(formatHash, null),\n    receiptsRoot: allowNull(formatHash, null),\n\n    blobGasUsed: allowNull(getBigInt, null),\n    excessBlobGas: allowNull(getBigInt, null),\n\n    miner: allowNull(getAddress),\n    prevRandao: allowNull(formatHash, null),\n    extraData: formatData,\n\n    baseFeePerGas: allowNull(getBigInt)\n}, {\n    prevRandao: [ \"mixHash\" ]\n});\n\nexport function formatBlock(value: any): BlockParams {\n    const result = _formatBlock(value);\n    result.transactions = value.transactions.map((tx: string | TransactionResponseParams) => {\n        if (typeof(tx) === \"string\") { return tx; }\n        return formatTransactionResponse(tx);\n    });\n    return result;\n}\n\nconst _formatReceiptLog = object({\n    transactionIndex: getNumber,\n    blockNumber: getNumber,\n    transactionHash: formatHash,\n    address: getAddress,\n    topics: arrayOf(formatHash),\n    data: formatData,\n    index: getNumber,\n    blockHash: formatHash,\n}, {\n    index: [ \"logIndex\" ]\n});\n\nexport function formatReceiptLog(value: any): LogParams {\n    return _formatReceiptLog(value);\n}\n\nconst _formatTransactionReceipt = object({\n    to: allowNull(getAddress, null),\n    from: allowNull(getAddress, null),\n    contractAddress: allowNull(getAddress, null),\n    // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n    index: getNumber,\n    root: allowNull(hexlify),\n    gasUsed: getBigInt,\n    blobGasUsed: allowNull(getBigInt, null),\n    logsBloom: allowNull(formatData),\n    blockHash: formatHash,\n    hash: formatHash,\n    logs: arrayOf(formatReceiptLog),\n    blockNumber: getNumber,\n    //confirmations: allowNull(getNumber, null),\n    cumulativeGasUsed: getBigInt,\n    effectiveGasPrice: allowNull(getBigInt),\n    blobGasPrice: allowNull(getBigInt, null),\n    status: allowNull(getNumber),\n    type: allowNull(getNumber, 0)\n}, {\n    effectiveGasPrice: [ \"gasPrice\" ],\n    hash: [ \"transactionHash\" ],\n    index: [ \"transactionIndex\" ],\n});\n\nexport function formatTransactionReceipt(value: any): TransactionReceiptParams {\n    return _formatTransactionReceipt(value);\n}\n\nexport function formatTransactionResponse(value: any): TransactionResponseParams {\n\n    // Some clients (TestRPC) do strange things like return 0x0 for the\n    // 0 address; correct this to be a real address\n    if (value.to && getBigInt(value.to) === BN_0) {\n        value.to = \"0x0000000000000000000000000000000000000000\";\n    }\n\n    const result = object({\n        hash: formatHash,\n\n        // Some nodes do not return this, usually test nodes (like Ganache)\n        index: allowNull(getNumber, undefined),\n\n        type: (value: any) => {\n            if (value === \"0x\" || value == null) { return 0; }\n            return getNumber(value);\n        },\n        accessList: allowNull(accessListify, null),\n        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),\n\n        blockHash: allowNull(formatHash, null),\n        blockNumber: allowNull(getNumber, null),\n        transactionIndex: allowNull(getNumber, null),\n\n        from: getAddress,\n\n        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set\n        gasPrice: allowNull(getBigInt),\n        maxPriorityFeePerGas: allowNull(getBigInt),\n        maxFeePerGas: allowNull(getBigInt),\n        maxFeePerBlobGas: allowNull(getBigInt, null),\n\n        gasLimit: getBigInt,\n        to: allowNull(getAddress, null),\n        value: getBigInt,\n        nonce: getNumber,\n        data: formatData,\n\n        creates: allowNull(getAddress, null),\n\n        chainId: allowNull(getBigInt, null)\n    }, {\n        data: [ \"input\" ],\n        gasLimit: [ \"gas\" ],\n        index: [ \"transactionIndex\" ]\n    })(value);\n\n    // If to and creates are empty, populate the creates from the value\n    if (result.to == null && result.creates == null) {\n        result.creates = getCreateAddress(result);\n    }\n\n    // @TODO: Check fee data\n\n    // Add an access list to supported transaction types\n    if ((value.type === 1 || value.type === 2) && value.accessList == null) {\n        result.accessList = [ ];\n    }\n\n    // Compute the signature\n    if (value.signature) {\n        result.signature = Signature.from(value.signature);\n    } else {\n        result.signature = Signature.from(value);\n    }\n\n    // Some backends omit ChainId on legacy transactions, but we can compute it\n    if (result.chainId == null) {\n        const chainId = result.signature.legacyChainId;\n        if (chainId != null) { result.chainId = chainId; }\n    }\n\n\n    // @TODO: check chainID\n    /*\n    if (value.chainId != null) {\n        let chainId = value.chainId;\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        result.chainId = chainId;\n\n    } else {\n        let chainId = value.networkId;\n\n        // geth-etc returns chainId\n        if (chainId == null && result.v == null) {\n            chainId = value.chainId;\n        }\n\n        if (isHexString(chainId)) {\n            chainId = BigNumber.from(chainId).toNumber();\n        }\n\n        if (typeof(chainId) !== \"number\" && result.v != null) {\n            chainId = (result.v - 35) / 2;\n            if (chainId < 0) { chainId = 0; }\n            chainId = parseInt(chainId);\n        }\n\n        if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n        result.chainId = chainId;\n    }\n    */\n\n    // 0x0000... should actually be null\n    if (result.blockHash && getBigInt(result.blockHash) === BN_0) {\n        result.blockHash = null;\n    }\n\n    return result;\n}\n","import { keccak256 } from \"../crypto/index.js\";\nimport {\n    concat, dataSlice, getBigInt, getBytes, encodeRlp, assertArgument\n} from \"../utils/index.js\";\n\nimport { getAddress } from \"./address.js\";\n\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\n\n\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n\n/**\n *  Returns the address that would result from a ``CREATE`` for %%tx%%.\n *\n *  This can be used to compute the address a contract will be\n *  deployed to by an EOA when sending a deployment transaction (i.e.\n *  when the ``to`` address is ``null``).\n *\n *  This can also be used to compute the address a contract will be\n *  deployed to by a contract, by using the contract's address as the\n *  ``to`` and the contract's nonce.\n *\n *  @example\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\";\n *    nonce = 5;\n *\n *    getCreateAddress({ from, nonce });\n *    //_result:\n */\nexport function getCreateAddress(tx: { from: string, nonce: BigNumberish }): string {\n    const from = getAddress(tx.from);\n    const nonce = getBigInt(tx.nonce, \"tx.nonce\");\n\n    let nonceHex = nonce.toString(16);\n    if (nonceHex === \"0\") {\n        nonceHex = \"0x\";\n    } else if (nonceHex.length % 2) {\n        nonceHex = \"0x0\" + nonceHex;\n    } else {\n        nonceHex = \"0x\" + nonceHex;\n    }\n\n    return getAddress(dataSlice(keccak256(encodeRlp([ from, nonceHex ])), 12));\n}\n\n/**\n *  Returns the address that would result from a ``CREATE2`` operation\n *  with the given %%from%%, %%salt%% and %%initCodeHash%%.\n *\n *  To compute the %%initCodeHash%% from a contract's init code, use\n *  the [[keccak256]] function.\n *\n *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].\n *\n *  @example\n *    // The address of the contract\n *    from = \"0x8ba1f109551bD432803012645Ac136ddd64DBA72\"\n *\n *    // The salt\n *    salt = id(\"HelloWorld\")\n *\n *    // The hash of the initCode\n *    initCode = \"0x6394198df16000526103ff60206004601c335afa6040516060f3\";\n *    initCodeHash = keccak256(initCode)\n *\n *    getCreate2Address(from, salt, initCodeHash)\n *    //_result:\n */\nexport function getCreate2Address(_from: string, _salt: BytesLike, _initCodeHash: BytesLike): string {\n    const from = getAddress(_from);\n    const salt = getBytes(_salt, \"salt\");\n    const initCodeHash = getBytes(_initCodeHash, \"initCodeHash\");\n\n    assertArgument(salt.length === 32, \"salt must be 32 bytes\", \"salt\", _salt);\n\n    assertArgument(initCodeHash.length === 32, \"initCodeHash must be 32 bytes\", \"initCodeHash\", _initCodeHash);\n\n    return getAddress(dataSlice(keccak256(concat([ \"0xff\", from, salt, initCodeHash ])), 12))\n}\n","import { defineProperties } from \"../utils/properties.js\";\n\nimport { assertArgument } from \"../utils/index.js\";\n\nimport type { FeeData, Provider } from \"./provider.js\";\nimport type { FetchRequest } from \"../utils/fetch.js\";\n\n\nconst EnsAddress = \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\";\n\n/**\n *  A **NetworkPlugin** provides additional functionality on a [[Network]].\n */\nexport class NetworkPlugin {\n    /**\n     *  The name of the plugin.\n     *\n     *  It is recommended to use reverse-domain-notation, which permits\n     *  unique names with a known authority as well as hierarchal entries.\n     */\n    readonly name!: string;\n\n    /**\n     *  Creates a new **NetworkPlugin**.\n     */\n    constructor(name: string) {\n        defineProperties<NetworkPlugin>(this, { name });\n    }\n\n    /**\n     *  Creates a copy of this plugin.\n     */\n    clone(): NetworkPlugin {\n        return new NetworkPlugin(this.name);\n    }\n\n//    validate(network: Network): NetworkPlugin {\n//        return this;\n//    }\n}\n\n\n/**\n *  The gas cost parameters for a [[GasCostPlugin]].\n */\nexport type GasCostParameters = {\n    /**\n     *  The transactions base fee.\n     */\n    txBase?: number;\n\n    /**\n     *  The fee for creating a new account.\n     */\n    txCreate?: number;\n\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    txDataZero?: number;\n\n    /**\n     *  The fee per non-zero-byte in the data.\n     */\n    txDataNonzero?: number;\n\n    /**\n     *  The fee per storage key in the [[link-eip-2930]] access list.\n     */\n    txAccessListStorageKey?: number;\n\n    /**\n     *  The fee per address in the [[link-eip-2930]] access list.\n     */\n    txAccessListAddress?: number;\n};\n\n/**\n *  A **GasCostPlugin** allows a network to provide alternative values when\n *  computing the intrinsic gas required for a transaction.\n */\nexport class GasCostPlugin extends NetworkPlugin implements GasCostParameters {\n    /**\n     *  The block number to treat these values as valid from.\n     *\n     *  This allows a hardfork to have updated values included as well as\n     *  mulutiple hardforks to be supported.\n     */\n    readonly effectiveBlock!: number;\n\n    /**\n     *  The transactions base fee.\n     */\n    readonly txBase!: number;\n\n    /**\n     *  The fee for creating a new account.\n     */\n    readonly txCreate!: number;\n\n    /**\n     *  The fee per zero-byte in the data.\n     */\n    readonly txDataZero!: number;\n\n    /**\n     *  The fee per non-zero-byte in the data.\n     */\n    readonly txDataNonzero!: number;\n\n    /**\n     *  The fee per storage key in the [[link-eip-2930]] access list.\n     */\n    readonly txAccessListStorageKey!: number;\n\n    /**\n     *  The fee per address in the [[link-eip-2930]] access list.\n     */\n    readonly txAccessListAddress!: number;\n\n\n    /**\n     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the\n     *  latest block or another GasCostPlugin supercedes that block number,\n     *  with the associated %%costs%%.\n     */\n    constructor(effectiveBlock?: number, costs?: GasCostParameters) {\n        if (effectiveBlock == null) { effectiveBlock = 0; }\n        super(`org.ethers.network.plugins.GasCost#${ (effectiveBlock || 0) }`);\n\n        const props: Record<string, number> = { effectiveBlock };\n        function set(name: keyof GasCostParameters, nullish: number): void {\n            let value = (costs || { })[name];\n            if (value == null) { value = nullish; }\n            assertArgument(typeof(value) === \"number\", `invalud value for ${ name }`, \"costs\", costs);\n            props[name] = value;\n        }\n\n        set(\"txBase\", 21000);\n        set(\"txCreate\", 32000);\n        set(\"txDataZero\", 4);\n        set(\"txDataNonzero\", 16);\n        set(\"txAccessListStorageKey\", 1900);\n        set(\"txAccessListAddress\", 2400);\n\n        defineProperties<GasCostPlugin>(this, props);\n    }\n\n    clone(): GasCostPlugin {\n        return new GasCostPlugin(this.effectiveBlock, this);\n    }\n}\n\n/**\n *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry\n *  Contract address and the target network to use when using that\n *  contract.\n *\n *  Various testnets have their own instance of the contract to use, but\n *  in general, the mainnet instance supports multi-chain addresses and\n *  should be used.\n */\nexport class EnsPlugin extends NetworkPlugin {\n\n    /**\n     *  The ENS Registrty Contract address.\n     */\n    readonly address!: string;\n\n    /**\n     *  The chain ID that the ENS contract lives on.\n     */\n    readonly targetNetwork!: number;\n\n    /**\n     *  Creates a new **EnsPlugin** connected to %%address%% on the\n     *  %%targetNetwork%%. The default ENS address and mainnet is used\n     *  if unspecified.\n     */\n    constructor(address?: null | string, targetNetwork?: null | number) {\n        super(\"org.ethers.plugins.network.Ens\");\n        defineProperties<EnsPlugin>(this, {\n            address: (address || EnsAddress),\n            targetNetwork: ((targetNetwork == null) ? 1: targetNetwork)\n        });\n    }\n\n    clone(): EnsPlugin {\n        return new EnsPlugin(this.address, this.targetNetwork);\n    }\n}\n\n/**\n *  A **FeeDataNetworkPlugin** allows a network to provide and alternate\n *  means to specify its fee data.\n *\n *  For example, a network which does not support [[link-eip-1559]] may\n *  choose to use a Gas Station site to approximate the gas price.\n */\nexport class FeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #feeDataFunc: (provider: Provider) => Promise<FeeData>;\n\n    /**\n     *  The fee data function provided to the constructor.\n     */\n    get feeDataFunc(): (provider: Provider) => Promise<FeeData> {\n        return this.#feeDataFunc;\n    }\n\n    /**\n     *  Creates a new **FeeDataNetworkPlugin**.\n     */\n    constructor(feeDataFunc: (provider: Provider) => Promise<FeeData>) {\n        super(\"org.ethers.plugins.network.FeeData\");\n        this.#feeDataFunc = feeDataFunc;\n    }\n\n    /**\n     *  Resolves to the fee data.\n     */\n    async getFeeData(provider: Provider): Promise<FeeData> {\n        return await this.#feeDataFunc(provider);\n    }\n\n    clone(): FeeDataNetworkPlugin {\n        return new FeeDataNetworkPlugin(this.#feeDataFunc);\n    }\n}\n\nexport class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {\n    readonly #url: string;\n    readonly #processFunc: (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }>;\n\n    /**\n     *  The URL to initialize the FetchRequest with in %%processFunc%%.\n     */\n    get url(): string { return this.#url; }\n\n    /**\n     *  The callback to use when computing the FeeData.\n     */\n    get processFunc(): (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }> { return this.#processFunc; }\n\n    /**\n     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will\n     *  be used when computing the fee data for the network.\n     */\n    constructor(url: string, processFunc: (f: () => Promise<FeeData>, p: Provider, r: FetchRequest) => Promise<{ gasPrice?: null | bigint, maxFeePerGas?: null | bigint, maxPriorityFeePerGas?: null | bigint }>) {\n        super(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        this.#url = url;\n        this.#processFunc = processFunc;\n    }\n\n    // We are immutable, so we can serve as our own clone\n    clone(): FetchUrlFeeDataNetworkPlugin { return this; }\n}\n\n/*\nexport class CustomBlockNetworkPlugin extends NetworkPlugin {\n    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;\n    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;\n\n    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {\n        super(\"org.ethers.network-plugins.custom-block\");\n        this.#blockFunc = blockFunc;\n        this.#blockWithTxsFunc = blockWithTxsFunc;\n    }\n\n    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {\n        return await this.#blockFunc(provider, block);\n    }\n\n    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {\n        return await this.#blockWithTxsFunc(provider, block);\n    }\n\n    clone(): CustomBlockNetworkPlugin {\n        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);\n    }\n}\n*/\n","/**\n *  A **Network** encapsulates the various properties required to\n *  interact with a specific chain.\n *\n *  @_subsection: api/providers:Networks  [networks]\n */\n\nimport { accessListify } from \"../transaction/index.js\";\nimport { getBigInt, assert, assertArgument } from \"../utils/index.js\";\n\nimport {\n    EnsPlugin, FetchUrlFeeDataNetworkPlugin, GasCostPlugin\n} from \"./plugins-network.js\";\n\nimport type { BigNumberish } from \"../utils/index.js\";\nimport type { TransactionLike } from \"../transaction/index.js\";\n\nimport type { NetworkPlugin } from \"./plugins-network.js\";\n\n\n/**\n *  A Networkish can be used to allude to a Network, by specifing:\n *  - a [[Network]] object\n *  - a well-known (or registered) network name\n *  - a well-known (or registered) chain ID\n *  - an object with sufficient details to describe a network\n */\nexport type Networkish = Network | number | bigint | string | {\n    name?: string,\n    chainId?: number,\n    //layerOneConnection?: Provider,\n    ensAddress?: string,\n    ensNetwork?: number\n};\n\n\n\n\n/* * * *\n// Networks which operation against an L2 can use this plugin to\n// specify how to access L1, for the purpose of resolving ENS,\n// for example.\nexport class LayerOneConnectionPlugin extends NetworkPlugin {\n    readonly provider!: Provider;\n// @TODO: Rename to ChainAccess and allow for connecting to any chain\n    constructor(provider: Provider) {\n        super(\"org.ethers.plugins.layer-one-connection\");\n        defineProperties<LayerOneConnectionPlugin>(this, { provider });\n    }\n\n    clone(): LayerOneConnectionPlugin {\n        return new LayerOneConnectionPlugin(this.provider);\n    }\n}\n*/\n\n\nconst Networks: Map<string | bigint, () => Network> = new Map();\n\n\n/**\n *  A **Network** provides access to a chain's properties and allows\n *  for plug-ins to extend functionality.\n */\nexport class Network {\n    #name: string;\n    #chainId: bigint;\n\n    #plugins: Map<string, NetworkPlugin>;\n\n    /**\n     *  Creates a new **Network** for %%name%% and %%chainId%%.\n     */\n    constructor(name: string, chainId: BigNumberish) {\n        this.#name = name;\n        this.#chainId = getBigInt(chainId);\n        this.#plugins = new Map();\n    }\n\n    /**\n     *  Returns a JSON-compatible representation of a Network.\n     */\n    toJSON(): any {\n        return { name: this.name, chainId: String(this.chainId) };\n    }\n\n    /**\n     *  The network common name.\n     *\n     *  This is the canonical name, as networks migh have multiple\n     *  names.\n     */\n    get name(): string { return this.#name; }\n    set name(value: string) { this.#name =  value; }\n\n    /**\n     *  The network chain ID.\n     */\n    get chainId(): bigint { return this.#chainId; }\n    set chainId(value: BigNumberish) { this.#chainId = getBigInt(value, \"chainId\"); }\n\n    /**\n     *  Returns true if %%other%% matches this network. Any chain ID\n     *  must match, and if no chain ID is present, the name must match.\n     *\n     *  This method does not currently check for additional properties,\n     *  such as ENS address or plug-in compatibility.\n     */\n    matches(other: Networkish): boolean {\n        if (other == null) { return false; }\n\n        if (typeof(other) === \"string\") {\n            try {\n                return (this.chainId === getBigInt(other));\n            } catch (error) { }\n            return (this.name === other);\n        }\n\n        if (typeof(other) === \"number\" || typeof(other) === \"bigint\") {\n            try {\n                return (this.chainId === getBigInt(other));\n            } catch (error) { }\n            return false;\n        }\n\n        if (typeof(other) === \"object\") {\n            if (other.chainId != null) {\n                try {\n                    return (this.chainId === getBigInt(other.chainId));\n                } catch (error) { }\n                return false;\n            }\n            if (other.name != null) {\n                return (this.name === other.name);\n            }\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     *  Returns the list of plugins currently attached to this Network.\n     */\n    get plugins(): Array<NetworkPlugin> {\n        return Array.from(this.#plugins.values());\n    }\n\n    /**\n     *  Attach a new %%plugin%% to this Network. The network name\n     *  must be unique, excluding any fragment.\n     */\n    attachPlugin(plugin: NetworkPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name, plugin.clone());\n        return this;\n    }\n\n    /**\n     *  Return the plugin, if any, matching %%name%% exactly. Plugins\n     *  with fragments will not be returned unless %%name%% includes\n     *  a fragment.\n     */\n    getPlugin<T extends NetworkPlugin = NetworkPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }\n\n    /**\n     *  Gets a list of all plugins that match %%name%%, with otr without\n     *  a fragment.\n     */\n    getPlugins<T extends NetworkPlugin = NetworkPlugin>(basename: string): Array<T> {\n        return <Array<T>>(this.plugins.filter((p) => (p.name.split(\"#\")[0] === basename)));\n    }\n\n    /**\n     *  Create a copy of this Network.\n     */\n    clone(): Network {\n        const clone = new Network(this.name, this.chainId);\n        this.plugins.forEach((plugin) => {\n            clone.attachPlugin(plugin.clone());\n        });\n        return clone;\n    }\n\n    /**\n     *  Compute the intrinsic gas required for a transaction.\n     *\n     *  A GasCostPlugin can be attached to override the default\n     *  values.\n     */\n    computeIntrinsicGas(tx: TransactionLike): number {\n        const costs = this.getPlugin<GasCostPlugin>(\"org.ethers.plugins.network.GasCost\") || (new GasCostPlugin());\n\n        let gas = costs.txBase;\n        if (tx.to == null) { gas += costs.txCreate; }\n        if (tx.data) {\n            for (let i = 2; i < tx.data.length; i += 2) {\n                if (tx.data.substring(i, i + 2) === \"00\") {\n                    gas += costs.txDataZero;\n                } else {\n                    gas += costs.txDataNonzero;\n                }\n            }\n        }\n\n        if (tx.accessList) {\n            const accessList = accessListify(tx.accessList);\n            for (const addr in accessList) {\n                gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;\n            }\n        }\n\n        return gas;\n    }\n\n    /**\n     *  Returns a new Network for the %%network%% name or chainId.\n     */\n    static from(network?: Networkish): Network {\n        injectCommonNetworks();\n\n        // Default network\n        if (network == null) { return Network.from(\"mainnet\"); }\n\n        // Canonical name or chain ID\n        if (typeof(network) === \"number\") { network = BigInt(network); }\n        if (typeof(network) === \"string\" || typeof(network) === \"bigint\") {\n            const networkFunc = Networks.get(network);\n            if (networkFunc) { return networkFunc(); }\n            if (typeof(network) === \"bigint\") {\n                return new Network(\"unknown\", network);\n            }\n\n            assertArgument(false, \"unknown network\", \"network\", network);\n        }\n\n        // Clonable with network-like abilities\n        if (typeof((<Network>network).clone) === \"function\") {\n            const clone = (<Network>network).clone();\n            //if (typeof(network.name) !== \"string\" || typeof(network.chainId) !== \"number\") {\n            //}\n            return clone;\n        }\n\n        // Networkish\n        if (typeof(network) === \"object\") {\n            assertArgument(typeof(network.name) === \"string\" && typeof(network.chainId) === \"number\",\n                \"invalid network object name or chainId\", \"network\", network);\n\n            const custom = new Network(<string>(network.name), <number>(network.chainId));\n\n            if ((<any>network).ensAddress || (<any>network).ensNetwork != null) {\n                custom.attachPlugin(new EnsPlugin((<any>network).ensAddress, (<any>network).ensNetwork));\n            }\n\n            //if ((<any>network).layerOneConnection) {\n            //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));\n            //}\n\n            return custom;\n        }\n\n        assertArgument(false, \"invalid network\", \"network\", network);\n    }\n\n    /**\n     *  Register %%nameOrChainId%% with a function which returns\n     *  an instance of a Network representing that chain.\n     */\n    static register(nameOrChainId: string | number | bigint, networkFunc: () => Network): void {\n        if (typeof(nameOrChainId) === \"number\") { nameOrChainId = BigInt(nameOrChainId); }\n        const existing = Networks.get(nameOrChainId);\n        if (existing) {\n            assertArgument(false, `conflicting network for ${ JSON.stringify(existing.name) }`, \"nameOrChainId\", nameOrChainId);\n        }\n        Networks.set(nameOrChainId, networkFunc);\n    }\n}\n\n\ntype Options = {\n    ensNetwork?: number;\n    altNames?: Array<string>;\n    plugins?: Array<NetworkPlugin>;\n};\n\n// We don't want to bring in formatUnits because it is backed by\n// FixedNumber and we want to keep Networks tiny. The values\n// included by the Gas Stations are also IEEE 754 with lots of\n// rounding issues and exceed the strict checks formatUnits has.\nfunction parseUnits(_value: number | string, decimals: number): bigint {\n    const value = String(_value);\n    if (!value.match(/^[0-9.]+$/)) {\n        throw new Error(`invalid gwei value: ${ _value }`);\n    }\n\n    // Break into [ whole, fraction ]\n    const comps = value.split(\".\");\n    if (comps.length === 1) { comps.push(\"\"); }\n\n    // More than 1 decimal point or too many fractional positions\n    if (comps.length !== 2) {\n        throw new Error(`invalid gwei value: ${ _value }`);\n    }\n\n    // Pad the fraction to 9 decimalplaces\n    while (comps[1].length < decimals) { comps[1] += \"0\"; }\n\n    // Too many decimals and some non-zero ending, take the ceiling\n    if (comps[1].length > 9) {\n        let frac = BigInt(comps[1].substring(0, 9));\n        if (!comps[1].substring(9).match(/^0+$/)) { frac++; }\n        comps[1] = frac.toString();\n    }\n\n    return BigInt(comps[0] + comps[1]);\n}\n\n// Used by Polygon to use a gas station for fee data\nfunction getGasStationPlugin(url: string) {\n    return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {\n\n        // Prevent Cloudflare from blocking our request in node.js\n        request.setHeader(\"User-Agent\", \"ethers\");\n\n        let response;\n        try {\n            const [ _response, _feeData ] = await Promise.all([\n                request.send(), fetchFeeData()\n            ]);\n            response = _response;\n            const payload = response.bodyJson.standard;\n            const feeData = {\n                gasPrice: _feeData.gasPrice,\n                maxFeePerGas: parseUnits(payload.maxFee, 9),\n                maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),\n            };\n            return feeData;\n        } catch (error: any) {\n            assert(false, `error encountered with polygon gas station (${ JSON.stringify(request.url) })`, \"SERVER_ERROR\", { request, response, error });\n        }\n    });\n}\n\n// See: https://chainlist.org\nlet injected = false;\nfunction injectCommonNetworks(): void {\n    if (injected) { return; }\n    injected = true;\n\n    /// Register popular Ethereum networks\n    function registerEth(name: string, chainId: number, options: Options): void {\n        const func = function() {\n            const network = new Network(name, chainId);\n\n            // We use 0 to disable ENS\n            if (options.ensNetwork != null) {\n                network.attachPlugin(new EnsPlugin(null, options.ensNetwork));\n            }\n\n            network.attachPlugin(new GasCostPlugin());\n\n            (options.plugins || []).forEach((plugin) => {\n                network.attachPlugin(plugin);\n            });\n\n            return network;\n        };\n\n        // Register the network by name and chain ID\n        Network.register(name, func);\n        Network.register(chainId, func);\n\n        if (options.altNames) {\n            options.altNames.forEach((name) => {\n                Network.register(name, func);\n            });\n        }\n    }\n\n    registerEth(\"mainnet\", 1, { ensNetwork: 1, altNames: [ \"homestead\" ] });\n    registerEth(\"ropsten\", 3, { ensNetwork: 3 });\n    registerEth(\"rinkeby\", 4, { ensNetwork: 4 });\n    registerEth(\"goerli\", 5, { ensNetwork: 5 });\n    registerEth(\"kovan\", 42, { ensNetwork: 42 });\n    registerEth(\"sepolia\", 11155111, { ensNetwork: 11155111 });\n    registerEth(\"holesky\", 17000, { ensNetwork: 17000 });\n\n    registerEth(\"classic\", 61, { });\n    registerEth(\"classicKotti\", 6, { });\n\n    registerEth(\"arbitrum\", 42161, {\n        ensNetwork: 1,\n    });\n    registerEth(\"arbitrum-goerli\", 421613, { });\n    registerEth(\"arbitrum-sepolia\", 421614, { });\n\n    registerEth(\"base\", 8453, { ensNetwork: 1 });\n    registerEth(\"base-goerli\", 84531, { });\n    registerEth(\"base-sepolia\", 84532, { });\n\n    registerEth(\"bnb\", 56, { ensNetwork: 1 });\n    registerEth(\"bnbt\", 97, { });\n\n    registerEth(\"linea\", 59144, { ensNetwork: 1 });\n    registerEth(\"linea-goerli\", 59140, { });\n    registerEth(\"linea-sepolia\", 59141, { });\n\n    registerEth(\"matic\", 137, {\n        ensNetwork: 1,\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation.polygon.technology/v2\")\n        ]\n    });\n    registerEth(\"matic-amoy\", 80002, { });\n    registerEth(\"matic-mumbai\", 80001, {\n        altNames: [ \"maticMumbai\", \"maticmum\" ],  // @TODO: Future remove these alts\n        plugins: [\n            getGasStationPlugin(\"https:/\\/gasstation-testnet.polygon.technology/v2\")\n        ]\n    });\n\n    registerEth(\"optimism\", 10, {\n        ensNetwork: 1,\n        plugins: [ ]\n    });\n    registerEth(\"optimism-goerli\", 420, { });\n    registerEth(\"optimism-sepolia\", 11155420, { });\n\n    registerEth(\"xdai\", 100, { ensNetwork: 1 });\n}\n","import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Return the polling subscriber for common events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  A **PollingBlockSubscriber** polls at a regular interval for a change\n *  in the block number.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    /**\n     *  The polling interval.\n     */\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        try {\n            const blockNumber = await this.#provider.getBlockNumber();\n\n            // Bootstrap poll to setup our initial block number\n            if (this.#blockNumber === -2) {\n                this.#blockNumber = blockNumber;\n                return;\n            }\n\n            // @TODO: Put a cap on the maximum number of events per loop?\n\n            if (blockNumber !== this.#blockNumber) {\n                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                    // We have been stopped\n                    if (this.#poller == null) { return; }\n\n                    await this.#provider.emit(\"block\", b);\n                }\n\n                this.#blockNumber = blockNumber;\n            }\n\n        } catch (error) {\n            // @TODO: Minor bump, add an \"error\" event to let subscribers\n            //        know things went awry.\n            //console.log(error);\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { return; }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { return; }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n\n/**\n *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]\n *  implmentation which will be called on every new block.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    /**\n     *  Create a new **OnBlockSubscriber** attached to %%provider%%.\n     */\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    /**\n     *  Called on every new block.\n     */\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\nexport class PollingBlockTagSubscriber extends OnBlockSubscriber {\n    readonly #tag: string;\n    #lastBlock: number;\n\n    constructor(provider: AbstractProvider, tag: string) {\n        super(provider);\n        this.#tag = tag;\n        this.#lastBlock = -2;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused) { this.#lastBlock = -2; }\n        super.pause(dropWhilePaused);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const block = await provider.getBlock(this.#tag);\n        if (block == null) { return; }\n\n        if (this.#lastBlock === -2) {\n            this.#lastBlock = block.number;\n        } else if (block.number > this.#lastBlock) {\n            provider.emit(this.#tag, block.number);\n            this.#lastBlock = block.number;\n        }\n    }\n}\n\n\n/**\n *  @_ignore:\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  A **PollingTransactionSubscriber** will poll for a given transaction\n *  hash for its receipt.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%hash%%.\n     */\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  A **PollingEventSubscriber** will poll for a given filter for its logs.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    /**\n     *  Create a new **PollingTransactionSubscriber** attached to\n     *  %%provider%%, listening for %%filter%%.\n     */\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n\n            // Only advance the block number when logs were found to\n            // account for networks (like BNB and Polygon) which may\n            // sacrifice event consistency for block event speed\n            this.#blockNumber = log.blockNumber;\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n","/**\n *  The available providers should suffice for most developers purposes,\n *  but the [[AbstractProvider]] class has many features which enable\n *  sub-classing it for specific purposes.\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport {\n    concat, dataLength, dataSlice, hexlify, isHexString,\n    getBigInt, getBytes, getNumber,\n    isCallException, isError, makeError, assert, assertArgument,\n    FetchRequest,\n    toBeArray, toQuantity,\n    defineProperties, EventPayload, resolveProperties,\n    toUtf8String\n} from \"../utils/index.js\";\n\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport {\n    formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse\n} from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport {\n    PollingBlockSubscriber, PollingBlockTagSubscriber, PollingEventSubscriber,\n    PollingOrphanSubscriber, PollingTransactionSubscriber\n} from \"./subscriber-polling.js\";\n\nimport type { Addressable, AddressLike } from \"../address/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { FetchResponse, Listener } from \"../utils/index.js\";\n\nimport type { Networkish } from \"./network.js\";\nimport type { FetchUrlFeeDataNetworkPlugin } from \"./plugins-network.js\";\n//import type { MaxPriorityFeePlugin } from \"./plugins-network.js\";\nimport type {\n    BlockParams, LogParams, TransactionReceiptParams,\n    TransactionResponseParams\n} from \"./formatting.js\";\n\nimport type {\n    BlockTag, EventFilter, Filter, FilterByBlockHash, OrphanFilter,\n    PreparedTransactionRequest, Provider, ProviderEvent,\n    TransactionRequest\n} from \"./provider.js\";\n\ntype Timer = ReturnType<typeof setTimeout>;\n\n\n// Constants\nconst BN_2 = BigInt(2);\n\nconst MAX_CCIP_REDIRECTS = 10;\n\nfunction isPromise<T = any>(value: any): value is Promise<T> {\n    return (value && typeof(value.then) === \"function\");\n}\n\nfunction getTag(prefix: string, value: any): string {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) { return \"null\"; }\n        if (typeof(v) === \"bigint\") { return `bigint:${ v.toString() }`}\n        if (typeof(v) === \"string\") { return v.toLowerCase(); }\n\n        // Sort object keys\n        if (typeof(v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, <any>{ });\n        }\n\n        return v;\n    });\n}\n\n/**\n *  The types of additional event values that can be emitted for the\n *  ``\"debug\"`` event.\n */\nexport type DebugEventAbstractProvider = {\n    action: \"sendCcipReadFetchRequest\",\n    request: FetchRequest\n    index: number\n    urls: Array<string>\n} | {\n    action: \"receiveCcipReadFetchResult\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"receiveCcipReadFetchError\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"sendCcipReadCall\",\n    transaction: { to: string, data: string }\n} | {\n    action: \"receiveCcipReadCallResult\",\n    transaction: { to: string, data: string }\n    result: string\n} | {\n    action: \"receiveCcipReadCallError\",\n    transaction: { to: string, data: string }\n    error: Error\n};\n\n\n/**\n *  The value passed to the [[AbstractProvider-_getSubscriber]] method.\n *\n *  Only developers sub-classing [[AbstractProvider[[ will care about this,\n *  if they are modifying a low-level feature of how subscriptions operate.\n */\nexport type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"error\" | \"finalized\" | \"network\" | \"pending\" | \"safe\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n    tag: string,\n    filter: OrphanFilter\n};\n\n/**\n *  A **Subscriber** manages a subscription.\n *\n *  Only developers sub-classing [[AbstractProvider[[ will care about this,\n *  if they are modifying a low-level feature of how subscriptions operate.\n */\nexport interface Subscriber {\n    /**\n     *  Called initially when a subscriber is added the first time.\n     */\n    start(): void;\n\n    /**\n     *  Called when there are no more subscribers to the event.\n     */\n    stop(): void;\n\n    /**\n     *  Called when the subscription should pause.\n     *\n     *  If %%dropWhilePaused%%, events that occur while paused should not\n     *  be emitted [[resume]].\n     */\n    pause(dropWhilePaused?: boolean): void;\n\n    /**\n     *  Resume a paused subscriber.\n     */\n    resume(): void;\n\n    /**\n     *  The frequency (in ms) to poll for events, if polling is used by\n     *  the subscriber.\n     *\n     *  For non-polling subscribers, this must return ``undefined``.\n     */\n    pollingInterval?: number;\n}\n\n/**\n *  An **UnmanagedSubscriber** is useful for events which do not require\n *  any additional management, such as ``\"debug\"`` which only requires\n *  emit in synchronous event loop triggered calls.\n */\nexport class UnmanagedSubscriber implements Subscriber {\n    /**\n     *  The name fof the event.\n     */\n    name!: string;\n\n    /**\n     *  Create a new UnmanagedSubscriber with %%name%%.\n     */\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): void { }\n    stop(): void { }\n\n    pause(dropWhilePaused?: boolean): void { }\n    resume(): void { }\n}\n\ntype Sub = {\n    tag: string;\n    nameMap: Map<string, string>\n    addressableMap: WeakMap<Addressable, string>;\n    listeners: Array<{ listener: Listener, once: boolean }>;\n    // @TODO: get rid of this, as it is (and has to be)\n    // tracked in subscriber\n    started: boolean;\n    subscriber: Subscriber;\n};\n\nfunction copy<T = any>(value: T): T {\n    return JSON.parse(JSON.stringify(value));\n}\n\nfunction concisify(items: Array<string>): Array<string> {\n    items = Array.from((new Set(items)).values())\n    items.sort();\n    return items;\n}\n\n\nasync function getSubscription(_event: ProviderEvent, provider: AbstractProvider): Promise<Subscription> {\n    if (_event == null) { throw new Error(\"invalid event\"); }\n\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) { _event = { topics: _event }; }\n\n    if (typeof(_event) === \"string\") {\n        switch (_event) {\n            case \"block\":\n            case \"debug\":\n            case \"error\":\n            case \"finalized\":\n            case \"network\":\n            case \"pending\":\n            case \"safe\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n\n    if (isHexString(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n\n    if ((<any>_event).orphan) {\n        const event = <OrphanFilter>_event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n\n    if (((<any>_event).address || (<any>_event).topics)) {\n        const event = <EventFilter>_event;\n\n        const filter: any = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) { return null; }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n\n        if (event.address) {\n            const addresses: Array<string> = [ ];\n            const promises: Array<Promise<void>> = [ ];\n\n            const addAddress = (addr: AddressLike) => {\n                if (isHexString(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async () => {\n                        addresses.push(await resolveAddress(addr, provider));\n                    })());\n                }\n            }\n\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) { await Promise.all(promises); }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n\n    assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\n/**\n *  An **AbstractPlugin** is used to provide additional internal services\n *  to an [[AbstractProvider]] without adding backwards-incompatible changes\n *  to method signatures or other internal and complex logic.\n */\nexport interface AbstractProviderPlugin {\n    /**\n     *  The reverse domain notation of the plugin.\n     */\n    readonly name: string;\n\n    /**\n     *  Creates a new instance of the plugin, connected to %%provider%%.\n     */\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}\n\n/**\n *  A normalized filter used for [[PerformActionRequest]] objects.\n */\nexport type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};\n\n/**\n *  A normalized transactions used for [[PerformActionRequest]] objects.\n */\nexport interface PerformActionTransaction extends PreparedTransactionRequest {\n    /**\n     *  The ``to`` address of the transaction.\n     */\n    to?: string;\n\n    /**\n     *  The sender of the transaction.\n     */\n    from?: string;\n}\n\n/**\n *  The [[AbstractProvider]] methods will normalize all values and pass this\n *  type to [[AbstractProvider-_perform]].\n */\nexport type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n    method: \"getBalance\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getBlock\",\n    blockTag: BlockTag, includeTransactions: boolean\n} | {\n    method: \"getBlock\",\n    blockHash: string, includeTransactions: boolean\n} | {\n    method: \"getBlockNumber\"\n} | {\n    method: \"getCode\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getGasPrice\"\n} | {\n    method: \"getLogs\",\n    filter: PerformActionFilter\n} | {\n    method: \"getPriorityFee\"\n} | {\n    method: \"getStorage\",\n    address: string, position: bigint, blockTag: BlockTag\n} | {\n    method: \"getTransaction\",\n    hash: string\n} | {\n    method: \"getTransactionCount\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getTransactionReceipt\",\n    hash: string\n} | {\n    method: \"getTransactionResult\",\n    hash: string\n};\n\ntype _PerformAccountRequest = {\n    method: \"getBalance\" | \"getTransactionCount\" | \"getCode\"\n} | {\n    method: \"getStorage\", position: bigint\n}\n\n/**\n *  Options for configuring some internal aspects of an [[AbstractProvider]].\n *\n *  **``cacheTimeout``** - how long to cache a low-level ``_perform``\n *  for, based on input parameters. This reduces the number of calls\n *  to getChainId and getBlockNumber, but may break test chains which\n *  can perform operations (internally) synchronously. Use ``-1`` to\n *  disable, ``0`` will only buffer within the same event loop and\n *  any other value is in ms. (default: ``250``)\n */\nexport type AbstractProviderOptions = {\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};\n\nconst defaultOptions = {\n    cacheTimeout: 250,\n    pollingInterval: 4000\n};\n\ntype CcipArgs = {\n    sender: string;\n    urls: Array<string>;\n    calldata: string;\n    selector: string;\n    extraData: string;\n    errorArgs: Array<any>\n};\n\n/**\n *  An **AbstractProvider** provides a base class for other sub-classes to\n *  implement the [[Provider]] API by normalizing input arguments and\n *  formatting output results as well as tracking events for consistent\n *  behaviour on an eventually-consistent network.\n */\nexport class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #destroyed: boolean;\n\n    #networkPromise: null | Promise<Network>;\n    readonly #anyNetwork: boolean;\n\n    #performCache: Map<string, Promise<any>>;\n\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber: number;\n\n    #nextTimer: number;\n    #timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;\n\n    #disableCcipRead: boolean;\n\n    #options: Required<AbstractProviderOptions>;\n\n    /**\n     *  Create a new **AbstractProvider** connected to %%network%%, or\n     *  use the various network detection capabilities to discover the\n     *  [[Network]] if necessary.\n     */\n    constructor(_network?: \"any\" | Networkish, options?: AbstractProviderOptions) {\n        this.#options = Object.assign({ }, defaultOptions, options || { });\n\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n\n        this.#lastBlockNumber = -1;\n\n        this.#performCache = new Map();\n\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n\n        this.#destroyed = false;\n\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n\n        this.#disableCcipRead = false;\n    }\n\n    get pollingInterval(): number { return this.#options.pollingInterval; }\n\n    /**\n     *  Returns ``this``, to allow an **AbstractProvider** to implement\n     *  the [[ContractRunner]] interface.\n     */\n    get provider(): this { return this; }\n\n    /**\n     *  Returns all the registered plug-ins.\n     */\n    get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }\n\n    /**\n     *  Attach a new plug-in.\n     */\n    attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }\n\n    /**\n     *  Get a plugin by name.\n     */\n    getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }\n\n    /**\n     *  Prevent any CCIP-read operation, regardless of whether requested\n     *  in a [[call]] using ``enableCcipRead``.\n     */\n    get disableCcipRead(): boolean { return this.#disableCcipRead; }\n    set disableCcipRead(value: boolean) { this.#disableCcipRead = !!value; }\n\n    // Shares multiple identical requests made during the same 250ms\n    async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        const timeout = this.#options.cacheTimeout;\n\n        // Caching disabled\n        if (timeout < 0) { return await this._perform(req); }\n\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n\n            this.#performCache.set(tag, perform);\n\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, timeout);\n        }\n\n        return await perform;\n    }\n\n    /**\n     *  Resolves to the data for executing the CCIP-read operations.\n     */\n    async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n\n            let errorMessage = \"unknown error\";\n\n            // Fetch the resource...\n            let resp: FetchResponse;\n            try {\n                resp = await request.send();\n            } catch (error: any) {\n                // ...low-level fetch error (missing host, bad SSL, etc.),\n                // so try next URL\n                errorMessages.push(error.message);\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result: { error } });\n                continue;\n            }\n\n            try {\n                const result = resp.bodyJson;\n                if (result.data) {\n                    this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                    return result.data;\n                }\n                if (result.message) { errorMessage = result.message; }\n                this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            } catch (error) { }\n\n            // 4xx indicates the result is not present; stop\n            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${ errorMessage }`,\n                \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        assert(false, `error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a block before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Block]].\n     */\n    _wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a log before\n     *  returning it, to add additional properties or an alternate\n     *  sub-class of [[Log]].\n     */\n    _wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  receipt before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionReceipt]].\n     */\n    _wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n\n    /**\n     *  Provides the opportunity for a sub-class to wrap a transaction\n     *  response before returning it, to add additional properties or an\n     *  alternate sub-class of [[TransactionResponse]].\n     */\n    _wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n\n    /**\n     *  Resolves to the Network, forcing a network detection using whatever\n     *  technique the sub-class requires.\n     *\n     *  Sub-classes **must** override this.\n     */\n    _detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n\n    /**\n     *  Sub-classes should use this to perform all built-in operations. All\n     *  methods sanitizes and normalizes the values passed into this.\n     *\n     *  Sub-classes **must** override this.\n     */\n    async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n\n    // State\n\n    async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }\n\n    /**\n     *  Returns or resolves to the address for %%address%%, resolving ENS\n     *  names and [[Addressable]] objects and returning if already an\n     *  address.\n     */\n    _getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }\n\n    /**\n     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving\n     *  negative values and returning if already a valid block tag.\n     */\n    _getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"finalized\":\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n                return blockTag;\n        }\n\n\n        if (isHexString(blockTag)) {\n            if (isHexString(blockTag, 32)) { return blockTag; }\n            return toQuantity(blockTag);\n        }\n\n        if (typeof(blockTag) === \"bigint\") {\n            blockTag = getNumber(blockTag, \"blockTag\");\n        }\n\n        if (typeof(blockTag) === \"number\") {\n            if (blockTag >= 0) { return toQuantity(blockTag); }\n            if (this.#lastBlockNumber >= 0) { return toQuantity(this.#lastBlockNumber + blockTag); }\n            return this.getBlockNumber().then((b) => toQuantity(b + <number>blockTag));\n        }\n\n        assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n\n    /**\n     *  Returns or resolves to a filter for %%filter%%, resolving any ENS\n     *  names or [[Addressable]] object and returning if already a valid\n     *  filter.\n     */\n    _getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash: undefined;\n\n        const resolve = (_address: Array<string>, fromBlock?: string, toBlock?: string) => {\n            let address: undefined | string | Array<string> = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n\n            const filter = <any>{ };\n            if (address) { filter.address = address; }\n            if (topics.length) { filter.topics = topics; }\n            if (fromBlock) { filter.fromBlock = fromBlock; }\n            if (toBlock) { filter.toBlock = toBlock; }\n            if (blockHash) { filter.blockHash = blockHash; }\n\n            return filter;\n        };\n\n        // Addresses could be async (ENS names or Addressables)\n        let address: Array<string | Promise<string>> = [ ];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) { address.push(this._getAddress(addr)); }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n\n        let fromBlock: undefined | string | Promise<string> = undefined;\n        if (\"fromBlock\" in filter) { fromBlock = this._getBlockTag(filter.fromBlock); }\n\n        let toBlock: undefined | string | Promise<string> = undefined;\n        if (\"toBlock\" in filter) { toBlock = this._getBlockTag(filter.toBlock); }\n\n        if (address.filter((a) => (typeof(a) !== \"string\")).length ||\n            (fromBlock != null && typeof(fromBlock) !== \"string\") ||\n            (toBlock != null && typeof(toBlock) !== \"string\")) {\n\n            return Promise.all([ Promise.all(address), fromBlock, toBlock ]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n\n        return resolve(<Array<string>>address, fromBlock, toBlock);\n    }\n\n    /**\n     *  Returns or resolves to a transaction for %%request%%, resolving\n     *  any ENS names or [[Addressable]] and returning if already a valid\n     *  transaction.\n     */\n    _getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            if ((<any>request)[key] == null) { return; }\n\n            const addr = resolveAddress((<any>request)[key], this);\n            if (isPromise(addr)) {\n                promises.push((async function() { (<any>request)[key] = await addr; })());\n            } else {\n                (<any>request)[key] = addr;\n            }\n        });\n\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function() { request.blockTag = await blockTag; })());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n\n        if (promises.length) {\n            return (async function() {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n\n        return request;\n    }\n\n    async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = (async () => {\n                try {\n                    const network = await this._detectNetwork();\n                    this.emit(\"network\", network, null);\n                    return network;\n                } catch (error) {\n                    if (this.#networkPromise === detectNetwork!) {\n                        this.#networkPromise = null;\n                    }\n                    throw error;\n                }\n            })();\n\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n\n        const networkPromise = this.#networkPromise;\n\n        const [ expected, actual ] = await Promise.all([\n            networkPromise,          // Possibly an explicit Network\n            this._detectNetwork()    // The actual connected network\n        ]);\n\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                assert(false, `network changed: ${ expected.chainId } => ${ actual.chainId } `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n\n        return expected.clone();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        const network = await this.getNetwork();\n\n        const getFeeDataFunc = async () => {\n            const { _block, gasPrice, priorityFee } = await resolveProperties({\n                _block: this.#getBlock(\"latest\", false),\n                gasPrice: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getGasPrice\" });\n                        return getBigInt(value, \"%response\");\n                    } catch (error) { }\n                    return null\n                })()),\n                priorityFee: ((async () => {\n                    try {\n                        const value = await this.#perform({ method: \"getPriorityFee\" });\n                        return getBigInt(value, \"%response\");\n                    } catch (error) { }\n                    return null;\n                })())\n            });\n\n            let maxFeePerGas: null | bigint = null;\n            let maxPriorityFeePerGas: null | bigint = null;\n\n            // These are the recommended EIP-1559 heuristics for fee data\n            const block = this._wrapBlock(_block, network);\n            if (block && block.baseFeePerGas) {\n                maxPriorityFeePerGas = (priorityFee != null) ? priorityFee: BigInt(\"1000000000\");\n                maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n            }\n\n            return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n        };\n\n        // Check for a FeeDataNetWorkPlugin\n        const plugin = <FetchUrlFeeDataNetworkPlugin>network.getPlugin(\"org.ethers.plugins.network.FetchUrlFeeDataPlugin\");\n        if (plugin) {\n            const req = new FetchRequest(plugin.url);\n            const feeData = await plugin.processFunc(getFeeDataFunc, this, req);\n            return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);\n        }\n\n        return await getFeeDataFunc();\n    }\n\n\n    async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n\n    async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { blockTag, enableCcipRead: true })\n         });\n\n         // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n         const transaction = <PerformActionTransaction>copyRequest(tx);\n\n         try {\n             return hexlify(await this._perform({ method: \"call\", transaction, blockTag }));\n\n         } catch (error: any) {\n             // CCIP Read OffchainLookup\n             if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n                 const data = error.data;\n\n                 const txSender = await resolveAddress(transaction.to, this);\n\n                 // Parse the CCIP Read Arguments\n                 let ccipArgs: CcipArgs;\n                 try {\n                     ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n                 } catch (error: any) {\n                     assert(false, error.message, \"OFFCHAIN_FAULT\", {\n                         reason: \"BAD_DATA\", transaction, info: { data } });\n                 }\n\n                 // Check the sender of the OffchainLookup matches the transaction\n                 assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),\n                     \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                         action: \"call\",\n                         data,\n                         reason: \"OffchainLookup\",\n                         transaction: <any>transaction, // @TODO: populate data?\n                         invocation: null,\n                         revert: {\n                             signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                             name: \"OffchainLookup\",\n                             args: ccipArgs.errorArgs\n                         }\n                     });\n\n                 const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                 assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                     reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs } });\n\n                 const tx = {\n                     to: txSender,\n                     data: concat([ ccipArgs.selector, encodeBytes([ ccipResult, ccipArgs.extraData ]) ])\n                 };\n\n                 this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                 try {\n                     const result = await this.#call(tx, blockTag, attempt + 1);\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({ }, tx), result });\n                     return result;\n                 } catch (error) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({ }, tx), error });\n                     throw error;\n                 }\n             }\n\n             throw error;\n         }\n    }\n\n    async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n\n    async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0: -1));\n    }\n\n    // Account\n    async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address) !== \"string\" || typeof(blockTag) !== \"string\") {\n            [ address, blockTag ] = await Promise.all([ address, blockTag ]);\n        }\n\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n\n    async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n\n    async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n\n    async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n\n    async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n\n    // Write\n    async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 signedTransaction: signedTx\n             }),\n             network: this.getNetwork()\n        });\n\n        const tx = Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n\n        return this._wrapTransactionResponse(<any>tx, network).replaceableTransaction(blockNumber);\n    }\n\n    async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n\n        let blockTag = this._getBlockTag(block);\n        if (typeof(blockTag) !== \"string\") { blockTag = await blockTag; }\n\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n\n    // Queries\n    async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return null; }\n\n        return this._wrapBlock(params, network);\n    }\n\n    async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null; }\n\n        return this._wrapTransactionResponse(params, network);\n    }\n\n    async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) { return null; }\n\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) { throw new Error(\"report this; could not find tx or effectiveGasPrice\"); }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n\n        return this._wrapTransactionReceipt(params, network);\n    }\n\n    async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n        return hexlify(result);\n    }\n\n    // Bloom-filter Queries\n    async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform<Array<LogParams>>({ method: \"getLogs\", filter })\n        });\n\n        return params.map((p) => this._wrapLog(p, network));\n    }\n\n    // ENS\n    _getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n\n    async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }\n\n    async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }\n\n    async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }\n\n    async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === ZeroAddress) { return null; }\n\n            const resolverContract = new Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) { return null; }\n\n            return name;\n\n        } catch (error) {\n            // No data was returned from the resolver\n            if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n\n            // Something reerted\n            if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n\n            throw error;\n        }\n\n        return null;\n    }\n\n    async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (resolve, reject) => {\n            let timer: null | Timer = null;\n\n            const listener = (async (blockNumber: number) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject(makeError(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n\n            listener(await this.getBlockNumber());\n        });\n    }\n\n    async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n\n    /**\n     *  Clear a timer created using the [[_setTimeout]] method.\n     */\n    _clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }\n\n    /**\n     *  Create a timer that will execute %%func%% after at least %%timeout%%\n     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute\n     *  in the next event loop.\n     *\n     *  [Pausing](AbstractProvider-paused) the provider will pause any\n     *  associated timers.\n     */\n    _setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n\n        return timerId;\n    }\n\n    /**\n     *  Perform %%func%% on each subscriber.\n     */\n    _forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n\n    /**\n     *  Sub-classes may override this to customize subscription\n     *  implementations.\n     */\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"error\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\": {\n                const subscriber = new PollingBlockSubscriber(this);\n                subscriber.pollingInterval = this.pollingInterval;\n                return subscriber;\n            }\n            case \"safe\": case \"finalized\":\n                return new PollingBlockTagSubscriber(this, sub.type);\n            case \"event\":\n                return new PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new PollingOrphanSubscriber(this, sub.filter);\n        }\n\n        throw new Error(`unsupported event: ${ sub.type }`);\n    }\n\n    /**\n     *  If a [[Subscriber]] fails and needs to replace itself, this\n     *  method may be used.\n     *\n     *  For example, this is used for providers when using the\n     *  ``eth_getFilterChanges`` method, which can return null if state\n     *  filters are not supported by the backend, allowing the Subscriber\n     *  to swap in a [[PollingEventSubscriber]].\n     */\n    _recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { newSub.start(); }\n                if (this.#pausedState != null) { newSub.pause(this.#pausedState); }\n                break;\n            }\n        }\n    }\n\n    async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n\n    async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [ ] };\n            this.#subs.set(tag, sub);\n        }\n\n        return sub;\n    }\n\n    async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) { return false; };\n\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new EventPayload(this, (once ? null: listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch(error) { }\n            return !once;\n        });\n\n        if (sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return (count > 0);\n    }\n\n    async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { started, subscriber } ] of this.#subs) {\n                if (started) { subscriber.stop(); }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }\n\n    /**\n     *  If this provider has been destroyed using the [[destroy]] method.\n     *\n     *  Once destroyed, all resources are reclaimed, internal event loops\n     *  and timers are cleaned up and no further requests may be sent to\n     *  the provider.\n     */\n    get destroyed(): boolean {\n        return this.#destroyed;\n    }\n\n    /**\n     *  Sub-classes may use this to shutdown any sockets or release their\n     *  resources and reject any pending requests.\n     *\n     *  Sub-classes **must** call ``super.destroy()``.\n     */\n    destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n\n        this.#destroyed = true;\n    }\n\n    /**\n     *  Whether the provider is currently paused.\n     *\n     *  A paused provider will not emit any events, and generally should\n     *  not make any requests to the network, but that is up to sub-classes\n     *  to manage.\n     *\n     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,\n     *  which will buffer any events that occur while paused until the\n     *  provider is unpaused.\n     */\n    get paused(): boolean { return (this.#pausedState != null); }\n    set paused(pause: boolean) {\n        if (!!pause === this.paused) { return; }\n\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n\n    /**\n     *  Pause the provider. If %%dropWhilePaused%%, any events that occur\n     *  while paused are dropped, otherwise all events will be emitted once\n     *  the provider is unpaused.\n     */\n    pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) { clearTimeout(timer.timer); }\n\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n\n    /**\n     *  Resume the provider.\n     */\n    resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) { timeout = 0; }\n\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\n\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) { return toUtf8String(bytes); }\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n    try {\n        const offset = getNumber(dataSlice(result, start, start + 32));\n        const length = getNumber(dataSlice(result, offset, offset + 32));\n\n        return dataSlice(result, offset + 32, offset + 32 + length);\n    } catch (error) { }\n    return null;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = toBeArray(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\nconst empty: Uint8Array = new Uint8Array([ ]);\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>): string {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = getBytes(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return concat(result);\n}\n\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\"\nfunction parseOffchainLookup(data: string): CcipArgs {\n    const result: CcipArgs = {\n        sender: \"\", urls: [ ], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: [ ]\n    };\n\n    assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n\n    const sender = dataSlice(data, 0, 32);\n    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = dataSlice(sender, 12);\n\n    // Read the URLs from the response\n    try {\n        const urls: Array<string> = [];\n        const urlsOffset = getNumber(dataSlice(data, 32, 64));\n        const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n        const urlsData = dataSlice(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) { throw new Error(\"abort\"); }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) { throw new Error(\"abort\"); }\n        result.calldata = calldata;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n\n    // Get the callbackSelector (bytes4)\n    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = dataSlice(data, 96, 100);\n\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) { throw new Error(\"abort\"); }\n        result.extraData = extraData;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => (<any>result)[k])\n\n    return result;\n}\n","import { isError } from \"../utils/index.js\";\n\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { Network } from \"./network.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber implements Subscriber {\n    #provider: JsonRpcApiProvider;\n\n    #filterIdPromise: null | Promise<string>;\n    #poller: (b: number) => Promise<void>;\n\n    #running: boolean;\n\n    #network: null | Network;\n\n    #hault: boolean;\n\n    /**\n     *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]\n     *  and [[_emitResults]] to setup the subscription and provide the event\n     *  to the %%provider%%.\n     */\n    constructor(provider: JsonRpcApiProvider) {\n        this.#provider = provider;\n\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n\n        this.#running = false;\n\n        this.#network = null;\n\n        this.#hault = false;\n    }\n\n    /**\n     *  Sub-classes **must** override this to begin the subscription.\n     */\n    _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    /**\n     *  Sub-classes **must** override this handle the events.\n     */\n    _emitResults(provider: AbstractProvider, result: Array<any>): Promise<void> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    /**\n     *  Sub-classes **must** override this handle recovery on errors.\n     */\n    _recover(provider: AbstractProvider): Subscriber {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        try {\n            // Subscribe if necessary\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n\n            // Get the Filter ID\n            let filterId: null | string = null;\n            try {\n                filterId = await this.#filterIdPromise;\n            } catch (error) {\n                if (!isError(error, \"UNSUPPORTED_OPERATION\") || error.operation !== \"eth_newFilter\") {\n                    throw error;\n                }\n            }\n\n            // The backend does not support Filter ID; downgrade to\n            // polling\n            if (filterId == null) {\n                this.#filterIdPromise = null;\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) { this.#network = network; }\n\n            if ((this.#network as Network).chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n\n            if (this.#hault) { return; }\n\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [ filterId ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) { console.log(\"@TODO\", error); }\n\n        this.#provider.once(\"block\", this.#poller);\n    }\n\n    #teardown(): void {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                if (this.#provider.destroyed) { return; }\n                this.#provider.send(\"eth_uninstallFilter\", [ filterId ]);\n            });\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused){ this.#teardown(); }\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    resume(): void { this.start(); }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event: EventFilter;\n\n    /**\n     *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%\n     *  listening for %%filter%%.\n     */\n    constructor(provider: JsonRpcApiProvider, filter: EventFilter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n\n    _recover(provider: AbstractProvider): Subscriber {\n        return new PollingEventSubscriber(provider, this.#event);\n    }\n\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        const filterId = await provider.send(\"eth_newFilter\", [ this.#event ]);\n        return filterId;\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        return await provider.send(\"eth_newPendingTransactionFilter\", [ ]);\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n","/**\n *  One of the most common ways to interact with the blockchain is\n *  by a node running a JSON-RPC interface which can be connected to,\n *  based on the transport, using:\n *\n *  - HTTP or HTTPS - [[JsonRpcProvider]]\n *  - WebSocket - [[WebSocketProvider]]\n *  - IPC - [[IpcSocketProvider]]\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n\n// @TODO:\n// - Add the batching API\n\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\n\nimport { AbiCoder } from \"../abi/index.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { TypedDataEncoder } from \"../hash/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nimport {\n    defineProperties, getBigInt, hexlify, isHexString, toQuantity, toUtf8Bytes,\n    isError, makeError, assert, assertArgument,\n    FetchRequest, resolveProperties\n} from \"../utils/index.js\";\n\nimport { AbstractProvider, UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\nimport { Network } from \"./network.js\";\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \"./subscriber-filterid.js\";\nimport { PollingEventSubscriber } from \"./subscriber-polling.js\";\n\nimport type { TypedDataDomain, TypedDataField } from \"../hash/index.js\";\nimport type { TransactionLike } from \"../transaction/index.js\";\n\nimport type { PerformActionRequest, Subscriber, Subscription } from \"./abstract-provider.js\";\nimport type { Networkish } from \"./network.js\";\nimport type { Provider, TransactionRequest, TransactionResponse } from \"./provider.js\";\nimport type { Signer } from \"./signer.js\";\n\ntype Timer = ReturnType<typeof setTimeout>;\n\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g);\n//const Methods = \"getAddress,then\".split(/,/g);\nfunction deepCopy<T = any>(value: T): T {\n    if (value == null || Primitive.indexOf(typeof(value)) >= 0) {\n        return value;\n    }\n\n    // Keep any Addressable\n    if (typeof((<any>value).getAddress) === \"function\") {\n        return value;\n    }\n\n    if (Array.isArray(value)) { return <any>(value.map(deepCopy)); }\n\n    if (typeof(value) === \"object\") {\n        return Object.keys(value).reduce((accum, key) => {\n            accum[key] = (<any>value)[key];\n            return accum;\n        }, <any>{ });\n    }\n\n    throw new Error(`should not happen: ${ value } (${ typeof(value) })`);\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\ninterface Pollable {\n    pollingInterval: number;\n}\n\nfunction isPollable(value: any): value is Pollable {\n    return (value && typeof(value.pollingInterval) === \"number\");\n}\n\n/**\n *  A JSON-RPC payload, which are sent to a JSON-RPC server.\n */\nexport type JsonRpcPayload = {\n    /**\n     *  The JSON-RPC request ID.\n     */\n    id: number;\n\n    /**\n     *  The JSON-RPC request method.\n     */\n    method: string;\n\n    /**\n     *  The JSON-RPC request parameters.\n     */\n    params: Array<any> | Record<string, any>;\n\n    /**\n     *  A required constant in the JSON-RPC specification.\n     */\n    jsonrpc: \"2.0\";\n};\n\n/**\n *  A JSON-RPC result, which are returned on success from a JSON-RPC server.\n */\nexport type JsonRpcResult = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response result.\n     */\n    result: any;\n};\n\n/**\n *  A JSON-RPC error, which are returned on failure from a JSON-RPC server.\n */\nexport type JsonRpcError = {\n    /**\n     *  The response ID to match it to the relevant request.\n     */\n    id: number;\n\n    /**\n     *  The response error.\n     */\n    error: {\n        code: number;\n        message?: string;\n        data?: any;\n    }\n};\n\n/**\n *  When subscribing to the ``\"debug\"`` event, the [[Listener]] will\n *  receive this object as the first parameter.\n */\nexport type DebugEventJsonRpcApiProvider = {\n    action: \"sendRpcPayload\",\n    payload: JsonRpcPayload | Array<JsonRpcPayload>\n} | {\n    action: \"receiveRpcResult\",\n    result: Array<JsonRpcResult | JsonRpcError>\n} | {\n    action: \"receiveRpcError\",\n    error: Error\n};\n\n/**\n *  Options for configuring a [[JsonRpcApiProvider]]. Much of this\n *  is targetted towards sub-classes, which often will not expose\n *  any of these options to their consumers.\n *\n *  **``polling``** - use the polling strategy is used immediately\n *  for events; otherwise, attempt to use filters and fall back onto\n *  polling (default: ``false``)\n *\n *  **``staticNetwork``** - do not request chain ID on requests to\n *  validate the underlying chain has not changed (default: ``null``)\n *\n *  This should **ONLY** be used if it is **certain** that the network\n *  cannot change, such as when using INFURA (since the URL dictates the\n *  network). If the network is assumed static and it does change, this\n *  can have tragic consequences. For example, this **CANNOT** be used\n *  with MetaMask, since the user can select a new network from the\n *  drop-down at any time.\n *\n *  **``batchStallTime``** - how long (ms) to aggregate requests into a\n *  single batch. ``0`` indicates batching will only encompass the current\n *  event loop. If ``batchMaxCount = 1``, this is ignored. (default: ``10``)\n *\n *  **``batchMaxSize``** - target maximum size (bytes) to allow per batch\n *  request (default: 1Mb)\n *\n *  **``batchMaxCount``** - maximum number of requests to allow in a batch.\n *  If ``batchMaxCount = 1``, then batching is disabled. (default: ``100``)\n *\n *  **``cacheTimeout``** - passed as [[AbstractProviderOptions]].\n */\nexport type JsonRpcApiProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n    batchStallTime?: number;\n    batchMaxSize?: number;\n    batchMaxCount?: number;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};\n\nconst defaultOptions = {\n    polling: false,\n    staticNetwork: null,\n\n    batchStallTime: 10,      // 10ms\n    batchMaxSize: (1 << 20), // 1Mb\n    batchMaxCount: 100,      // 100 requests\n\n    cacheTimeout: 250,\n    pollingInterval: 4000\n}\n\n/**\n *  A **JsonRpcTransactionRequest** is formatted as needed by the JSON-RPC\n *  Ethereum API specification.\n */\nexport interface JsonRpcTransactionRequest {\n     /**\n      *  The sender address to use when signing.\n      */\n     from?: string;\n\n     /**\n      *  The target address.\n      */\n     to?: string;\n\n     /**\n      *  The transaction data.\n      */\n     data?: string;\n\n     /**\n      *  The chain ID the transaction is valid on.\n      */\n     chainId?: string;\n\n     /**\n      *  The [[link-eip-2718]] transaction type.\n      */\n     type?: string;\n\n     /**\n      *  The maximum amount of gas to allow a transaction to consume.\n      *\n      *  In most other places in ethers, this is called ``gasLimit`` which\n      *  differs from the JSON-RPC Ethereum API specification.\n      */\n     gas?: string;\n\n     /**\n      *  The gas price per wei for transactions prior to [[link-eip-1559]].\n      */\n     gasPrice?: string;\n\n     /**\n      *  The maximum fee per gas for [[link-eip-1559]] transactions.\n      */\n     maxFeePerGas?: string;\n\n     /**\n      *  The maximum priority fee per gas for [[link-eip-1559]] transactions.\n      */\n     maxPriorityFeePerGas?: string;\n\n     /**\n      *  The nonce for the transaction.\n      */\n     nonce?: string;\n\n     /**\n      *  The transaction value (in wei).\n      */\n     value?: string;\n\n     /**\n      *  The transaction access list.\n      */\n     accessList?: Array<{ address: string, storageKeys: Array<string> }>;\n}\n\n// @TODO: Unchecked Signers\n\nexport class JsonRpcSigner extends AbstractSigner<JsonRpcApiProvider> {\n    address!: string;\n\n    constructor(provider: JsonRpcApiProvider, address: string) {\n        super(provider);\n        address = getAddress(address);\n        defineProperties<JsonRpcSigner>(this, { address });\n    }\n\n    connect(provider: null | Provider): Signer {\n        assert(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"signer.connect\"\n        });\n    }\n\n    async getAddress(): Promise<string> {\n        return this.address;\n    }\n\n    // JSON-RPC will automatially fill in nonce, etc. so we just check from\n    async populateTransaction(tx: TransactionRequest): Promise<TransactionLike<string>> {\n        return await this.populateCall(tx);\n    }\n\n    // Returns just the hash of the transaction after sent, which is what\n    // the bare JSON-RPC API does;\n    async sendUncheckedTransaction(_tx: TransactionRequest): Promise<string> {\n        const tx = deepCopy(_tx);\n\n        const promises: Array<Promise<void>> = [];\n\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const _from = tx.from;\n            promises.push((async () => {\n                const from = await resolveAddress(_from, this.provider);\n                assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(),\n                    \"from address mismatch\", \"transaction\", _tx);\n                tx.from = from;\n            })());\n        } else {\n            tx.from = this.address;\n        }\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (tx.gasLimit == null) {\n            promises.push((async () => {\n                tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address});\n            })());\n        }\n\n        // The address may be an ENS name or Addressable\n        if (tx.to != null) {\n            const _to = tx.to;\n            promises.push((async () => {\n                tx.to = await resolveAddress(_to, this.provider);\n            })());\n        }\n\n        // Wait until all of our properties are filled in\n        if (promises.length) { await Promise.all(promises); }\n\n        const hexTx = this.provider.getRpcTransaction(tx);\n\n        return this.provider.send(\"eth_sendTransaction\", [ hexTx ]);\n    }\n\n    async sendTransaction(tx: TransactionRequest): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider.getBlockNumber();\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(tx);\n\n        // Unfortunately, JSON-RPC only provides and opaque transaction hash\n        // for a response, and we need the actual transaction, so we poll\n        // for it; it should show up very quickly\n        return await (new Promise((resolve, reject) => {\n            const timeouts = [ 1000, 100 ];\n            let invalids = 0;\n\n            const checkTx = async () => {\n\n                try {\n                    // Try getting the transaction\n                    const tx = await this.provider.getTransaction(hash);\n\n                    if (tx != null) {\n                        resolve(tx.replaceableTransaction(blockNumber));\n                        return;\n                    }\n\n                } catch (error) {\n\n                    // If we were cancelled: stop polling.\n                    // If the data is bad: the node returns bad transactions\n                    // If the network changed: calling again will also fail\n                    // If unsupported: likely destroyed\n                    if (isError(error, \"CANCELLED\") || isError(error, \"BAD_DATA\") ||\n                        isError(error, \"NETWORK_ERROR\") || isError(error, \"UNSUPPORTED_OPERATION\")) {\n\n                        if (error.info == null) { error.info = { }; }\n                        error.info.sendTransactionHash = hash;\n\n                        reject(error);\n                        return;\n                    }\n\n                    // Stop-gap for misbehaving backends; see #4513\n                    if (isError(error, \"INVALID_ARGUMENT\")) {\n                        invalids++;\n                        if (error.info == null) { error.info = { }; }\n                        error.info.sendTransactionHash = hash;\n                        if (invalids > 10) {\n                            reject(error);\n                            return;\n                        }\n                    }\n\n                    // Notify anyone that cares; but we will try again, since\n                    // it is likely an intermittent service error\n                    this.provider.emit(\"error\", makeError(\"failed to fetch transation after sending (will try again)\", \"UNKNOWN_ERROR\", { error }));\n                }\n\n                // Wait another 4 seconds\n                this.provider._setTimeout(() => { checkTx(); }, timeouts.pop() || 4000);\n            };\n            checkTx();\n        }));\n    }\n\n    async signTransaction(_tx: TransactionRequest): Promise<string> {\n        const tx = deepCopy(_tx);\n\n        // Make sure the from matches the sender\n        if (tx.from) {\n            const from = await resolveAddress(tx.from, this.provider);\n            assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(),\n                \"from address mismatch\", \"transaction\", _tx);\n            tx.from = from;\n        } else {\n            tx.from = this.address;\n        }\n\n        const hexTx = this.provider.getRpcTransaction(tx);\n        return await this.provider.send(\"eth_signTransaction\", [ hexTx ]);\n    }\n\n\n    async signMessage(_message: string | Uint8Array): Promise<string> {\n        const message = ((typeof(_message) === \"string\") ? toUtf8Bytes(_message): _message);\n        return await this.provider.send(\"personal_sign\", [\n            hexlify(message), this.address.toLowerCase() ]);\n    }\n\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, _value: Record<string, any>): Promise<string> {\n        const value = deepCopy(_value);\n\n        // Populate any ENS names (in-place)\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (value: string) => {\n            const address = await resolveAddress(value);\n            assertArgument(address != null, \"TypedData does not support null address\", \"value\", value);\n            return address;\n        });\n\n        return await this.provider.send(\"eth_signTypedData_v4\", [\n            this.address.toLowerCase(),\n            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n        ]);\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        return this.provider.send(\"personal_unlockAccount\", [\n            this.address.toLowerCase(), password, null ]);\n    }\n\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    async _legacySignMessage(_message: string | Uint8Array): Promise<string> {\n        const message = ((typeof(_message) === \"string\") ? toUtf8Bytes(_message): _message);\n        return await this.provider.send(\"eth_sign\", [\n            this.address.toLowerCase(), hexlify(message) ]);\n    }\n}\n\ntype ResolveFunc = (result: JsonRpcResult) => void;\ntype RejectFunc = (error: Error) => void;\n\ntype Payload = { payload: JsonRpcPayload, resolve: ResolveFunc, reject: RejectFunc };\n\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\nexport abstract class JsonRpcApiProvider extends AbstractProvider {\n\n    #options: Required<JsonRpcApiProviderOptions>;\n\n    // The next ID to use for the JSON-RPC ID field\n    #nextId: number;\n\n    // Payloads are queued and triggered in batches using the drainTimer\n    #payloads: Array<Payload>;\n    #drainTimer: null | Timer;\n\n    #notReady: null | {\n        promise: Promise<void>,\n        resolve: null | ((v: void) => void)\n    };\n\n    #network: null | Network;\n    #pendingDetectNetwork: null | Promise<Network>;\n\n    #scheduleDrain(): void {\n        if (this.#drainTimer) { return; }\n\n        // If we aren't using batching, no harm in sending it immediately\n        const stallTime = (this._getOption(\"batchMaxCount\") === 1) ? 0: this._getOption(\"batchStallTime\");\n\n        this.#drainTimer = setTimeout(() => {\n            this.#drainTimer = null;\n\n            const payloads = this.#payloads;\n            this.#payloads = [ ];\n\n            while (payloads.length) {\n\n                // Create payload batches that satisfy our batch constraints\n                const batch = [ <Payload>(payloads.shift()) ];\n                while (payloads.length) {\n                    if (batch.length === this.#options.batchMaxCount) { break; }\n                    batch.push(<Payload>(payloads.shift()));\n                    const bytes = JSON.stringify(batch.map((p) => p.payload));\n                    if (bytes.length > this.#options.batchMaxSize) {\n                        payloads.unshift(<Payload>(batch.pop()));\n                        break;\n                    }\n                }\n\n                // Process the result to each payload\n                (async () => {\n                    const payload = ((batch.length === 1) ? batch[0].payload: batch.map((p) => p.payload));\n\n                    this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n\n                    try {\n                        const result = await this._send(payload);\n                        this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n\n                        // Process results in batch order\n                        for (const { resolve, reject, payload } of batch) {\n\n                            if (this.destroyed) {\n                                reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n                                continue;\n                            }\n\n                            // Find the matching result\n                            const resp = result.filter((r) => (r.id === payload.id))[0];\n\n                            // No result; the node failed us in unexpected ways\n                            if (resp == null) {\n                                const error = makeError(\"missing response for request\", \"BAD_DATA\", {\n                                    value: result, info: { payload }\n                                });\n                                this.emit(\"error\", error);\n                                reject(error);\n                                continue;\n                            }\n\n                            // The response is an error\n                            if (\"error\" in resp) {\n                                reject(this.getRpcError(payload, resp));\n                                continue;\n                            }\n\n                            // All good; send the result\n                            resolve(resp.result);\n                        }\n\n                    } catch (error: any) {\n                        this.emit(\"debug\", { action: \"receiveRpcError\", error });\n\n                        for (const { reject } of batch) {\n                            // @TODO: augment the error with the payload\n                            reject(error);\n                        }\n                    }\n                })();\n            }\n        }, stallTime);\n    }\n\n    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n\n        this.#nextId = 1;\n        this.#options = Object.assign({ }, defaultOptions, options || { });\n\n        this.#payloads = [ ];\n        this.#drainTimer = null;\n\n        this.#network = null;\n        this.#pendingDetectNetwork = null;\n\n        {\n            let resolve: null | ((value: void) => void) = null;\n            const promise = new Promise((_resolve: (value: void) => void) => {\n                resolve = _resolve;\n            });\n            this.#notReady = { promise, resolve };\n        }\n\n        const staticNetwork = this._getOption(\"staticNetwork\");\n        if (typeof(staticNetwork) === \"boolean\") {\n            assertArgument(!staticNetwork || network !== \"any\", \"staticNetwork cannot be used on special network 'any'\", \"options\", options);\n            if (staticNetwork && network != null) {\n                this.#network = Network.from(network);\n            }\n\n        } else if (staticNetwork) {\n            // Make sure any static network is compatbile with the provided netwrok\n            assertArgument(network == null || staticNetwork.matches(network),\n                \"staticNetwork MUST match network object\", \"options\", options);\n            this.#network = staticNetwork;\n        }\n    }\n\n    /**\n     *  Returns the value associated with the option %%key%%.\n     *\n     *  Sub-classes can use this to inquire about configuration options.\n     */\n    _getOption<K extends keyof JsonRpcApiProviderOptions>(key: K): JsonRpcApiProviderOptions[K] {\n        return this.#options[key];\n    }\n\n    /**\n     *  Gets the [[Network]] this provider has committed to. On each call, the network\n     *  is detected, and if it has changed, the call will reject.\n     */\n    get _network(): Network {\n        assert (this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n        return this.#network;\n    }\n\n    /**\n     *  Sends a JSON-RPC %%payload%% (or a batch) to the underlying channel.\n     *\n     *  Sub-classes **MUST** override this.\n     */\n    abstract _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>>;\n\n\n    /**\n     *  Resolves to the non-normalized value by performing %%req%%.\n     *\n     *  Sub-classes may override this to modify behavior of actions,\n     *  and should generally call ``super._perform`` as a fallback.\n     */\n    async _perform(req: PerformActionRequest): Promise<any> {\n\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (req.method === \"call\" || req.method === \"estimateGas\") {\n            let tx = req.transaction;\n            if (tx && tx.type != null && getBigInt(tx.type)) {\n                // If there are no EIP-1559 or newer properties, it might be pre-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        req = Object.assign({ }, req, {\n                            transaction: Object.assign({ }, tx, { type: undefined })\n                        });\n                    }\n                }\n            }\n        }\n\n        const request = this.getRpcRequest(req);\n\n        if (request != null) {\n            return await this.send(request.method, request.args);\n        }\n\n        return super._perform(req);\n    }\n\n    /**\n     *  Sub-classes may override this; it detects the *actual* network that\n     *  we are **currently** connected to.\n     *\n     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n     *  _send primitive must be used instead.\n     */\n    async _detectNetwork(): Promise<Network> {\n        const network = this._getOption(\"staticNetwork\");\n        if (network) {\n            if (network === true) {\n                if (this.#network) { return this.#network; }\n            } else {\n                return network;\n            }\n        }\n\n        if (this.#pendingDetectNetwork) {\n            return await this.#pendingDetectNetwork;\n        }\n\n        // If we are ready, use ``send``, which enabled requests to be batched\n        if (this.ready) {\n            this.#pendingDetectNetwork = (async () => {\n                try {\n                    const result = Network.from(getBigInt(await this.send(\"eth_chainId\", [ ])));\n                    this.#pendingDetectNetwork = null;\n                    return result;\n                } catch (error) {\n                    this.#pendingDetectNetwork = null;\n                    throw error;\n                }\n            })();\n            return await this.#pendingDetectNetwork;\n        }\n\n        // We are not ready yet; use the primitive _send\n        this.#pendingDetectNetwork = (async () => {\n            const payload: JsonRpcPayload = {\n                id: this.#nextId++, method: \"eth_chainId\", params: [ ], jsonrpc: \"2.0\"\n            };\n\n            this.emit(\"debug\", { action: \"sendRpcPayload\", payload });\n\n            let result: JsonRpcResult | JsonRpcError;\n            try {\n                result = (await this._send(payload))[0];\n                this.#pendingDetectNetwork = null;\n            } catch (error) {\n                this.#pendingDetectNetwork = null;\n                this.emit(\"debug\", { action: \"receiveRpcError\", error });\n                throw error;\n            }\n\n            this.emit(\"debug\", { action: \"receiveRpcResult\", result });\n\n            if (\"result\" in result) {\n                return Network.from(getBigInt(result.result));\n            }\n\n            throw this.getRpcError(payload, result);\n        })();\n\n        return await this.#pendingDetectNetwork;\n    }\n\n    /**\n     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n     *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n     *  ``super._start()`` **MUST** be called.\n     *\n     *  Calling it multiple times is safe and has no effect.\n     */\n    _start(): void {\n        if (this.#notReady == null || this.#notReady.resolve == null) { return; }\n\n        this.#notReady.resolve();\n        this.#notReady = null;\n\n        (async () => {\n\n            // Bootstrap the network\n            while (this.#network == null && !this.destroyed) {\n                try {\n                    this.#network = await this._detectNetwork();\n                } catch (error) {\n                    if (this.destroyed) { break; }\n                    console.log(\"JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)\");\n                    this.emit(\"error\", makeError(\"failed to bootstrap network detection\", \"NETWORK_ERROR\", { event: \"initial-network-discovery\", info: { error } }));\n                    await stall(1000);\n                }\n            }\n\n            // Start dispatching requests\n            this.#scheduleDrain();\n        })();\n    }\n\n    /**\n     *  Resolves once the [[_start]] has been called. This can be used in\n     *  sub-classes to defer sending data until the connection has been\n     *  established.\n     */\n    async _waitUntilReady(): Promise<void> {\n        if (this.#notReady == null) { return; }\n        return await this.#notReady.promise;\n    }\n\n\n    /**\n     *  Return a Subscriber that will manage the %%sub%%.\n     *\n     *  Sub-classes may override this to modify the behavior of\n     *  subscription management.\n     */\n    _getSubscriber(sub: Subscription): Subscriber {\n\n        // Pending Filters aren't availble via polling\n        if (sub.type === \"pending\") { return new FilterIdPendingSubscriber(this); }\n\n        if (sub.type === \"event\") {\n            if (this._getOption(\"polling\")) {\n                return new PollingEventSubscriber(this, sub.filter);\n            }\n            return new FilterIdEventSubscriber(this, sub.filter);\n        }\n\n        // Orphaned Logs are handled automatically, by the filter, since\n        // logs with removed are emitted by it\n        if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n            return new UnmanagedSubscriber(\"orphan\");\n        }\n\n        return super._getSubscriber(sub);\n    }\n\n    /**\n     *  Returns true only if the [[_start]] has been called.\n     */\n    get ready(): boolean { return this.#notReady == null; }\n\n    /**\n     *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n     *  which has all values hexlified and any numeric values converted\n     *  to Quantity values.\n     */\n    getRpcTransaction(tx: TransactionRequest): JsonRpcTransactionRequest {\n        const result: JsonRpcTransactionRequest = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            let dstKey = key;\n            if (key === \"gasLimit\") { dstKey = \"gas\"; }\n            (<any>result)[dstKey] = toQuantity(getBigInt((<any>tx)[key], `tx.${ key }`));\n        });\n\n        // Make sure addresses and data are lowercase\n        [\"from\", \"to\", \"data\"].forEach((key) => {\n            if ((<any>tx)[key] == null) { return; }\n            (<any>result)[key] = hexlify((<any>tx)[key]);\n        });\n\n        // Normalize the access list object\n        if (tx.accessList) {\n            result[\"accessList\"] = accessListify(tx.accessList);\n        }\n\n        if (tx.blobVersionedHashes) {\n            // @TODO: Remove this <any> case once EIP-4844 added to prepared tx\n            (<any>result)[\"blobVersionedHashes\"] = tx.blobVersionedHashes.map(h => h.toLowerCase());\n        }\n\n        // @TODO: blobs should probably also be copied over, optionally\n        // accounting for the kzg property to backfill blobVersionedHashes\n        // using the commitment. Or should that be left as an exercise to\n        // the caller?\n\n        return result;\n    }\n\n    /**\n     *  Returns the request method and arguments required to perform\n     *  %%req%%.\n     */\n    getRpcRequest(req: PerformActionRequest): null | { method: string, args: Array<any> } {\n        switch (req.method) {\n            case \"chainId\":\n                return { method: \"eth_chainId\", args: [ ] };\n\n            case \"getBlockNumber\":\n                return { method: \"eth_blockNumber\", args: [ ] };\n\n            case \"getGasPrice\":\n                return { method: \"eth_gasPrice\", args: [] };\n\n            case \"getPriorityFee\":\n                return { method: \"eth_maxPriorityFeePerGas\", args: [ ] };\n\n            case \"getBalance\":\n                return {\n                    method: \"eth_getBalance\",\n                    args: [ getLowerCase(req.address), req.blockTag ]\n                };\n\n            case \"getTransactionCount\":\n                return {\n                    method: \"eth_getTransactionCount\",\n                    args: [ getLowerCase(req.address), req.blockTag ]\n                };\n\n            case \"getCode\":\n                return {\n                    method: \"eth_getCode\",\n                    args: [ getLowerCase(req.address), req.blockTag ]\n                };\n\n            case \"getStorage\":\n                return {\n                    method: \"eth_getStorageAt\",\n                    args: [\n                        getLowerCase(req.address),\n                        (\"0x\" + req.position.toString(16)),\n                        req.blockTag\n                    ]\n                };\n\n            case \"broadcastTransaction\":\n                return {\n                    method: \"eth_sendRawTransaction\",\n                    args: [ req.signedTransaction ]\n                };\n\n            case \"getBlock\":\n                if (\"blockTag\" in req) {\n                    return {\n                        method: \"eth_getBlockByNumber\",\n                        args: [ req.blockTag, !!req.includeTransactions ]\n                    };\n                } else if (\"blockHash\" in req) {\n                    return {\n                        method: \"eth_getBlockByHash\",\n                        args: [ req.blockHash, !!req.includeTransactions ]\n                    };\n                }\n                break;\n\n            case \"getTransaction\":\n                return {\n                    method: \"eth_getTransactionByHash\",\n                    args: [ req.hash ]\n                };\n\n            case \"getTransactionReceipt\":\n                return {\n                    method: \"eth_getTransactionReceipt\",\n                    args: [ req.hash ]\n                };\n\n            case \"call\":\n                return {\n                    method: \"eth_call\",\n                    args: [ this.getRpcTransaction(req.transaction), req.blockTag ]\n                };\n\n            case \"estimateGas\": {\n                return {\n                    method: \"eth_estimateGas\",\n                    args: [ this.getRpcTransaction(req.transaction) ]\n                };\n            }\n\n            case \"getLogs\":\n                if (req.filter && req.filter.address != null) {\n                    if (Array.isArray(req.filter.address)) {\n                        req.filter.address = req.filter.address.map(getLowerCase);\n                    } else {\n                        req.filter.address = getLowerCase(req.filter.address);\n                    }\n                }\n                return { method: \"eth_getLogs\", args: [ req.filter ] };\n        }\n\n        return null;\n    }\n\n    /**\n     *  Returns an ethers-style Error for the given JSON-RPC error\n     *  %%payload%%, coalescing the various strings and error shapes\n     *  that different nodes return, coercing them into a machine-readable\n     *  standardized error.\n     */\n    getRpcError(payload: JsonRpcPayload, _error: JsonRpcError): Error {\n        const { method } = payload;\n        const { error } = _error;\n\n        if (method === \"eth_estimateGas\" && error.message) {\n            const msg = error.message;\n            if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n                return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n                    transaction: ((<any>payload).params[0]),\n                    info: { payload, error }\n                });\n            }\n        }\n\n        if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n            const result = spelunkData(error);\n\n            const e = AbiCoder.getBuiltinCallException(\n                (method === \"eth_call\") ? \"call\": \"estimateGas\",\n                ((<any>payload).params[0]),\n                (result ? result.data: null)\n            );\n            e.info = { error, payload };\n            return e;\n        }\n\n        // Only estimateGas and call can return arbitrary contract-defined text, so now we\n        // we can process text safely.\n\n        const message = JSON.stringify(spelunkMessage(error));\n\n        if (typeof(error.message) === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n            const actionMap: Record<string, \"requestAccess\" | \"sendTransaction\" | \"signMessage\" | \"signTransaction\" | \"signTypedData\"> = {\n                eth_sign: \"signMessage\",\n                personal_sign: \"signMessage\",\n                eth_signTypedData_v4: \"signTypedData\",\n                eth_signTransaction: \"signTransaction\",\n                eth_sendTransaction: \"sendTransaction\",\n                eth_requestAccounts: \"requestAccess\",\n                wallet_requestAccounts: \"requestAccess\",\n            };\n\n            return makeError(`user rejected action`, \"ACTION_REJECTED\", {\n                action: (actionMap[method] || \"unknown\") ,\n                reason: \"rejected\",\n                info: { payload, error }\n            });\n        }\n\n        if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n            const transaction = <TransactionLike<string>>((<any>payload).params[0]);\n\n            if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n                return makeError(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n                    transaction, info: { error }\n                });\n            }\n\n            if (message.match(/nonce/i) && message.match(/too low/i)) {\n                return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", { transaction, info: { error } });\n            }\n\n            // \"replacement transaction underpriced\"\n            if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n                return makeError(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", { transaction, info: { error } });\n            }\n\n            if (message.match(/only replay-protected/i)) {\n                return makeError(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n                    operation: method, info: { transaction, info: { error } }\n                });\n            }\n        }\n\n        let unsupported = !!message.match(/the method .* does not exist/i);\n        if (!unsupported) {\n            if (error && (<any>error).details && (<any>error).details.startsWith(\"Unauthorized method:\")) {\n                unsupported = true;\n            }\n        }\n\n        if (unsupported) {\n            return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n                operation: payload.method, info: { error, payload }\n            });\n        }\n\n        return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", { error, payload });\n    }\n\n\n    /**\n     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n     *  over the underlying channel. This can be used to call methods\n     *  on the backend that do not have a high-level API within the Provider\n     *  API.\n     *\n     *  This method queues requests according to the batch constraints\n     *  in the options, assigns the request a unique ID.\n     *\n     *  **Do NOT override** this method in sub-classes; instead\n     *  override [[_send]] or force the options values in the\n     *  call to the constructor to modify this method's behavior.\n     */\n    send(method: string, params: Array<any> | Record<string, any>): Promise<any> {\n        // @TODO: cache chainId?? purge on switch_networks\n\n        // We have been destroyed; no operations are supported anymore\n        if (this.destroyed) {\n            return Promise.reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: method }));\n        }\n\n        const id = this.#nextId++;\n        const promise = new Promise((resolve, reject) => {\n            this.#payloads.push({\n                resolve, reject,\n                payload: { method, params, id, jsonrpc: \"2.0\" }\n            });\n        });\n\n        // If there is not a pending drainTimer, set one\n        this.#scheduleDrain();\n\n        return <Promise<JsonRpcResult>>promise;\n    }\n\n    /**\n     *  Resolves to the [[Signer]] account for  %%address%% managed by\n     *  the client.\n     *\n     *  If the %%address%% is a number, it is used as an index in the\n     *  the accounts from [[listAccounts]].\n     *\n     *  This can only be used on clients which manage accounts (such as\n     *  Geth with imported account or MetaMask).\n     *\n     *  Throws if the account doesn't exist.\n     */\n    async getSigner(address?: number | string): Promise<JsonRpcSigner> {\n        if (address == null) { address = 0; }\n\n        const accountsPromise = this.send(\"eth_accounts\", [ ]);\n\n        // Account index\n        if (typeof(address) === \"number\") {\n            const accounts = <Array<string>>(await accountsPromise);\n            if (address >= accounts.length) { throw new Error(\"no such account\"); }\n            return new JsonRpcSigner(this, accounts[address]);\n        }\n\n        const { accounts } = await resolveProperties({\n            network: this.getNetwork(),\n            accounts: accountsPromise\n        });\n\n        // Account address\n        address = getAddress(address);\n        for (const account of accounts) {\n            if (getAddress(account) === address) {\n                return new JsonRpcSigner(this, address);\n            }\n        }\n\n        throw new Error(\"invalid account\");\n    }\n\n    async listAccounts(): Promise<Array<JsonRpcSigner>> {\n        const accounts: Array<string> = await this.send(\"eth_accounts\", [ ]);\n        return accounts.map((a) => new JsonRpcSigner(this, a));\n    }\n\n    destroy(): void {\n\n        // Stop processing requests\n        if (this.#drainTimer) {\n            clearTimeout(this.#drainTimer);\n            this.#drainTimer = null;\n        }\n\n        // Cancel all pending requests\n        for (const { payload, reject } of this.#payloads) {\n            reject(makeError(\"provider destroyed; cancelled request\", \"UNSUPPORTED_OPERATION\", { operation: payload.method }));\n        }\n\n        this.#payloads = [ ];\n\n        // Parent clean-up\n        super.destroy();\n\n    }\n}\n\n// @TODO: remove this in v7, it is not exported because this functionality\n// is exposed in the JsonRpcApiProvider by setting polling to true. It should\n// be safe to remove regardless, because it isn't reachable, but just in case.\n/**\n *  @_ignore:\n */\nexport abstract class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n    #pollingInterval: number;\n    constructor(network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        super(network, options);\n\n        let pollingInterval = this._getOption(\"pollingInterval\");\n        if (pollingInterval == null) { pollingInterval = defaultOptions.pollingInterval; }\n\n        this.#pollingInterval = pollingInterval;\n    }\n\n    _getSubscriber(sub: Subscription): Subscriber {\n        const subscriber = super._getSubscriber(sub);\n        if (isPollable(subscriber)) {\n            subscriber.pollingInterval = this.#pollingInterval;\n        }\n        return subscriber;\n    }\n\n    /**\n     *  The polling interval (default: 4000 ms)\n     */\n    get pollingInterval(): number { return this.#pollingInterval; }\n    set pollingInterval(value: number) {\n        if (!Number.isInteger(value) || value < 0) { throw new Error(\"invalid interval\"); }\n        this.#pollingInterval = value;\n        this._forEachSubscriber((sub) => {\n            if (isPollable(sub)) {\n                sub.pollingInterval = this.#pollingInterval;\n            }\n        });\n    }\n}\n\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\nexport class JsonRpcProvider extends JsonRpcApiPollingProvider {\n    #connect: FetchRequest;\n\n    constructor(url?: string | FetchRequest, network?: Networkish, options?: JsonRpcApiProviderOptions) {\n        if (url == null) { url = \"http:/\\/localhost:8545\"; }\n        super(network, options);\n\n        if (typeof(url) === \"string\") {\n            this.#connect = new FetchRequest(url);\n        } else {\n            this.#connect = url.clone();\n        }\n    }\n\n    _getConnection(): FetchRequest {\n        return this.#connect.clone();\n    }\n\n    async send(method: string, params: Array<any> | Record<string, any>): Promise<any> {\n        // All requests are over HTTP, so we can just start handling requests\n        // We do this here rather than the constructor so that we don't send any\n        // requests to the network (i.e. eth_chainId) until we absolutely have to.\n        await this._start();\n\n        return await super.send(method, params);\n    }\n\n    async _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult>> {\n        // Configure a POST connection for the requested method\n        const request = this._getConnection();\n        request.body = JSON.stringify(payload);\n        request.setHeader(\"content-type\", \"application/json\");\n        const response = await request.send();\n        response.assertOk();\n\n        let resp = response.bodyJson;\n        if (!Array.isArray(resp)) { resp = [ resp ]; }\n\n        return resp;\n    }\n}\n\nfunction spelunkData(value: any): null | { message: string, data: string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(/revert/i) && isHexString(value.data)) {\n        return { message: value.message, data: value.data };\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunkData(value[key]);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunkData(JSON.parse(value));\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction _spelunkMessage(value: any, result: Array<string>): void {\n    if (value == null) { return; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\") {\n        result.push(value.message);\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            _spelunkMessage(value[key], result);\n        }\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return _spelunkMessage(JSON.parse(value), result);\n        } catch (error) { }\n    }\n}\n\nfunction spelunkMessage(value: any): Array<string> {\n    const result: Array<string> = [ ];\n    _spelunkMessage(value, result);\n    return result;\n}\n","import { assertArgument } from \"../utils/index.js\";\n\nimport { JsonRpcApiPollingProvider } from \"./provider-jsonrpc.js\";\n\nimport type {\n    JsonRpcApiProviderOptions,\n    JsonRpcError, JsonRpcPayload, JsonRpcResult,\n    JsonRpcSigner\n} from \"./provider-jsonrpc.js\";\nimport type { Network, Networkish } from \"./network.js\";\n\n/**\n *  The interface to an [[link-eip-1193]] provider, which is a standard\n *  used by most injected providers, which the [[BrowserProvider]] accepts\n *  and exposes the API of.\n */\nexport interface Eip1193Provider {\n    /**\n     *  See [[link-eip-1193]] for details on this method.\n     */\n    request(request: { method: string, params?: Array<any> | Record<string, any> }): Promise<any>;\n};\n\n/**\n *  The possible additional events dispatched when using the ``\"debug\"``\n *  event on a [[BrowserProvider]].\n */\nexport type DebugEventBrowserProvider = {\n    action: \"sendEip1193Payload\",\n    payload: { method: string, params: Array<any> }\n} | {\n    action: \"receiveEip1193Result\",\n    result: any\n} | {\n    action: \"receiveEip1193Error\",\n    error: Error\n};\n\nexport type BrowserProviderOptions = {\n    polling?: boolean;\n    staticNetwork?: null | boolean | Network;\n\n    cacheTimeout?: number;\n    pollingInterval?: number;\n};\n\n/**\n *  A **BrowserProvider** is intended to wrap an injected provider which\n *  adheres to the [[link-eip-1193]] standard, which most (if not all)\n *  currently do.\n */\nexport class BrowserProvider extends JsonRpcApiPollingProvider {\n    #request: (method: string, params: Array<any> | Record<string, any>) => Promise<any>;\n\n    /**\n     *  Connnect to the %%ethereum%% provider, optionally forcing the\n     *  %%network%%.\n     */\n    constructor(ethereum: Eip1193Provider, network?: Networkish, _options?: BrowserProviderOptions) {\n        // Copy the options\n        const options: JsonRpcApiProviderOptions = Object.assign({ },\n          ((_options != null) ? _options: { }),\n          { batchMaxCount: 1 });\n\n        assertArgument(ethereum && ethereum.request, \"invalid EIP-1193 provider\", \"ethereum\", ethereum);\n\n        super(network, options);\n\n        this.#request = async (method: string, params: Array<any> | Record<string, any>) => {\n            const payload = { method, params };\n            this.emit(\"debug\", { action: \"sendEip1193Request\", payload });\n            try {\n                const result = await ethereum.request(payload);\n                this.emit(\"debug\", { action: \"receiveEip1193Result\", result });\n                return result;\n            } catch (e: any) {\n                const error = new Error(e.message);\n                (<any>error).code = e.code;\n                (<any>error).data = e.data;\n                (<any>error).payload = payload;\n                this.emit(\"debug\", { action: \"receiveEip1193Error\", error });\n                throw error;\n            }\n        };\n    }\n\n    async send(method: string, params: Array<any> | Record<string, any>): Promise<any> {\n        await this._start();\n\n        return await super.send(method, params);\n    }\n\n    async _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>> {\n        assertArgument(!Array.isArray(payload), \"EIP-1193 does not support batch request\", \"payload\", payload);\n\n        try {\n            const result = await this.#request(payload.method, payload.params || [ ]);\n            return [ { id: payload.id, result } ];\n        } catch (e: any) {\n            return [ {\n                id: payload.id,\n                error: { code: e.code, data: e.data, message: e.message }\n            } ];\n        }\n    }\n\n    getRpcError(payload: JsonRpcPayload, error: JsonRpcError): Error {\n\n        error = JSON.parse(JSON.stringify(error));\n\n        // EIP-1193 gives us some machine-readable error codes, so rewrite\n        // them into \n        switch (error.error.code || -1) {\n            case 4001:\n                error.error.message = `ethers-user-denied: ${ error.error.message }`;\n                break;\n            case 4200:\n                error.error.message = `ethers-unsupported: ${ error.error.message }`;\n                break;\n        }\n\n        return super.getRpcError(payload, error);\n    }\n\n    /**\n     *  Resolves to ``true`` if the provider manages the %%address%%.\n     */\n    async hasSigner(address: number | string): Promise<boolean> {\n        if (address == null) { address = 0; }\n\n        const accounts = await this.send(\"eth_accounts\", [ ]);\n        if (typeof(address) === \"number\") {\n            return (accounts.length > address);\n        }\n\n        address = address.toLowerCase();\n        return accounts.filter((a: string) => (a.toLowerCase() === address)).length !== 0;\n    }\n\n    async getSigner(address?: number | string): Promise<JsonRpcSigner> {\n        if (address == null) { address = 0; }\n\n        if (!(await this.hasSigner(address))) {\n            try {\n                //const resp = \n                await this.#request(\"eth_requestAccounts\", [ ]);\n                //console.log(\"RESP\", resp);\n\n            } catch (error: any) {\n                const payload = error.payload;\n                throw this.getRpcError(payload, { id: payload.id, error });\n            }\n        }\n\n        return await super.getSigner(address);\n    }\n}\n"],"names":["createGetUrl","options","async","req","_signal","assert","cancelled","protocol","url","split","toLowerCase","info","operation","credentials","allowInsecureAuthentication","error","controller","AbortController","timer","setTimeout","makeError","abort","timeout","addListener","init","method","headers","Headers","Array","from","body","undefined","signal","resp","fetch","_error","clearTimeout","forEach","value","key","respBody","arrayBuffer","Uint8Array","statusCode","status","statusMessage","statusText","defaultGetUrlFunc","reData","RegExp","reIpfs","locked","dataGatewayFunc","match","Error","FetchResponse","textData","atob","data","length","i","charCodeAt","getBytes","decodeBase64","toUtf8Bytes","replace","all","code","String","fromCharCode","parseInt","FetchRequest","getIpfsGatewayFunc","baseUrl","Gateways","fetchSignals","WeakMap","FetchCancelSignal","constructor","request","this","set","listener","push","checkSignal","JSON","stringify","hasBody","toUpperCase","Object","assign","_data","btoa","encodeBase64","allowGzip","getHeader","setHeader","clearHeaders","Symbol","iterator","keys","index","next","done","setCredentials","username","password","assertArgument","preflightFunc","preflight","processFunc","process","retryFunc","retry","getUrlFunc","slotInterval","maxAttempts","toString","hexlify","setThrottleParams","params","attempt","expires","delay","_request","_response","makeServerError","getTime","reason","Promise","resolve","wait","clone","scheme","result","response","throttle","stall","assertOk","location","redirect","retryAfter","Math","trunc","random","pow","send","cancel","get","current","target","lockConfig","getGateway","registerGateway","func","registerGetUrl","getUrl","createGetUrlFunc","createDataGateway","createIpfsGatewayFunc","bodyText","toUtf8String","bodyJson","parse","reduce","accum","k","message","throwThrottleError","Number","isInteger","defineProperties","ok","requestUrl","responseBody","e","responseStatus","Date","Zeros","checkComponent","comp","ensNameSplit","name","bytes","ens_normalize","ensNormalize","comps","last","slice","namehash","keccak256","concat","pop","dnsEncode","_maxLength","map","fill","getIpfsLink","link","substring","MulticoinProviderPlugin","connect","proivder","supportsCoinType","coinType","encodeAddress","address","decodeAddress","matcherIpfs","matchers","EnsResolver","provider","Contract","supportsWildcard","supportsInterface","isError","funcName","iface","interface","unshift","fragment","getFunction","encodeFunctionData","enableCcipRead","decodeFunctionResult","getAddress","ZeroAddress","ethCoinType","isHexString","coinPlugin","plugin","plugins","getText","getContentHash","ipfs","encodeBase58","swarm","getAvatar","_getAvatar","linkage","type","avatar","selector","owner","tokenId","contract","tokenOwner","ownerOf","balance","balanceOf","metadataUrl","toBeHex","metadata","imageUrl","image","getEnsAddress","network","getNetwork","ensPlugin","getPlugin","ensAddr","addr","resolver","fromName","currentName","join","BN_0","BigInt","allowNull","format","nullValue","arrayOf","array","isArray","object","altNames","srcKey","altKey","nv","formatData","formatHash","_formatLog","blockHash","blockNumber","getNumber","removed","topics","transactionHash","transactionIndex","_formatBlock","hash","parentHash","parentBeaconBlockRoot","number","timestamp","nonce","difficulty","getBigInt","gasLimit","gasUsed","stateRoot","receiptsRoot","blobGasUsed","excessBlobGas","miner","prevRandao","extraData","baseFeePerGas","_formatReceiptLog","_formatTransactionReceipt","to","contractAddress","root","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","blobGasPrice","formatTransactionResponse","accessList","accessListify","blobVersionedHashes","gasPrice","maxPriorityFeePerGas","maxFeePerGas","maxFeePerBlobGas","creates","chainId","tx","nonceHex","dataSlice","encodeRlp","getCreateAddress","signature","Signature","legacyChainId","NetworkPlugin","GasCostPlugin","effectiveBlock","txBase","txCreate","txDataZero","txDataNonzero","txAccessListStorageKey","txAccessListAddress","costs","super","props","nullish","EnsPlugin","targetNetwork","FetchUrlFeeDataNetworkPlugin","Networks","Map","Network","toJSON","matches","other","values","attachPlugin","getPlugins","basename","filter","p","computeIntrinsicGas","gas","storageKeys","injected","registerEth","ensNetwork","register","getGasStationPlugin","injectCommonNetworks","networkFunc","custom","ensAddress","nameOrChainId","existing","parseUnits","_value","decimals","frac","fetchFeeData","_feeData","payload","standard","maxFee","maxPriorityFee","copy","obj","PollingBlockSubscriber","pollingInterval","getBlockNumber","b","emit","_setTimeout","bind","start","stop","_clearTimeout","pause","dropWhilePaused","resume","OnBlockSubscriber","_poll","on","off","PollingBlockTagSubscriber","tag","block","getBlock","PollingOrphanSubscriber","PollingTransactionSubscriber","getTransactionReceipt","PollingEventSubscriber","fromBlock","toBlock","getLogs","log","then","BN_2","isPromise","getTag","prefix","v","sort","UnmanagedSubscriber","concisify","items","Set","getSubscription","_event","orphan","event","t","addresses","promises","addAddress","resolveAddress","a","defaultOptions","cacheTimeout","AbstractProvider","_network","disableCcipRead","_perform","perform","delete","ccipReadFetch","calldata","urls","sender","errorMessages","href","indexOf","action","errorMessage","transaction","m","_wrapBlock","Block","transactions","formatBlock","_wrapLog","Log","formatLog","_wrapTransactionReceipt","TransactionReceipt","formatTransactionReceipt","_wrapTransactionResponse","TransactionResponse","_detectNetwork","_getAddress","_getBlockTag","blockTag","toQuantity","_getFilter","_address","_getTransactionRequest","copyRequest","detectNetwork","networkPromise","expected","actual","getFeeData","getFeeDataFunc","_block","priorityFee","resolveProperties","FeeData","feeData","estimateGas","_tx","isCallException","txSender","ccipArgs","errorArgs","dataLength","zeros","urlsOffset","urlsLength","urlsData","u","_parseString","_parseBytes","parseOffchainLookup","invocation","revert","args","ccipResult","encodeBytes","promise","call","_blockTag","getBalance","getTransactionCount","getCode","getStorage","_position","position","broadcastTransaction","signedTx","signedTransaction","Transaction","replaceableTransaction","includeTransactions","prefetchTxs","getTransaction","getTransactionResult","_filter","_getProvider","getResolver","resolveName","lookupAddress","node","ensContract","resolverContract","waitForTransaction","_confirms","confirms","reject","receipt","console","once","waitForBlock","timerId","_func","paused","time","_forEachSubscriber","sub","subscriber","_getSubscriber","_recoverSubscriber","oldSub","newSub","started","emitArgs","subscription","addressableMap","nameMap","listeners","count","EventPayload","listenerCount","total","splice","removeAllListeners","removeListener","destroyed","destroy","s","offset","numPad","toBeArray","padded","bytesPad","ceil","empty","datas","byteCount","FilterIdSubscriber","_subscribe","_emitResults","_recover","filterId","filterIdPromise","FilterIdEventSubscriber","results","FilterIdPendingSubscriber","Primitive","deepCopy","duration","getLowerCase","isPollable","polling","staticNetwork","batchStallTime","batchMaxSize","batchMaxCount","JsonRpcSigner","AbstractSigner","populateTransaction","populateCall","sendUncheckedTransaction","_from","_to","hexTx","getRpcTransaction","sendTransaction","timeouts","invalids","checkTx","sendTransactionHash","signTransaction","signMessage","_message","signTypedData","domain","types","populated","TypedDataEncoder","resolveNames","getPayload","unlock","_legacySignMessage","JsonRpcApiProvider","stallTime","_getOption","payloads","batch","shift","_send","r","id","getRpcError","_resolve","getRpcRequest","ready","jsonrpc","_start","_waitUntilReady","dstKey","h","msg","spelunkData","AbiCoder","getBuiltinCallException","_spelunkMessage","spelunkMessage","actionMap","eth_sign","personal_sign","eth_signTypedData_v4","eth_signTransaction","eth_sendTransaction","eth_requestAccounts","wallet_requestAccounts","unsupported","details","startsWith","getSigner","accountsPromise","accounts","account","listAccounts","JsonRpcApiPollingProvider","BrowserProvider","ethereum","_options","hasSigner"],"sourceRoot":""}