"use strict";(globalThis.webpackChunkwinbit32=globalThis.webpackChunkwinbit32||[]).push([[36],{83036:(e,t,a)=>{var r;a.d(t,{BCHToolbox:()=>fe,getToolboxByChain:()=>ve});var s,n,i=a(32460),o=a(60415),c=a(45370),d=a(56498),u=a(64029),h=a(32871),p=a(53731),l=a(96762),f=a(48950),w=a(11352),y=a(74248).Buffer,m=a(28819),x=e=>`https://api.blockchair.com/${g(e)}`,v=e=>{switch(e){case o.sW.Bitcoin:return 5;case o.sW.Dogecoin:return 1e4;case o.sW.Litecoin:return 1;default:return 2}},g=e=>{switch(e){case o.sW.BitcoinCash:return"bitcoin-cash";case o.sW.Litecoin:return"litecoin";case o.sW.Dash:return"dash";case o.sW.Dogecoin:return"dogecoin";case o.sW.Polkadot:return"polkadot";default:return"bitcoin"}},b=async(e,t)=>{try{const t=await o.R0.get(e);if(!t||200!==t.context.code)throw new Error(`failed to query ${e}`);return t.data}catch(n){if(!t)throw n;const r=await o.R0.get(`${e}${t?`&key=${t}`:""}`);if(!r||200!==r.context.code)throw new Error(`failed to query ${e}`);return r.data}},K={utxo:[],address:{balance:0,transaction_count:0}},k=async({address:e,chain:t,apiKey:a})=>{if(!e)throw new Error("address is required");try{return(await b(`${x(t)}/dashboards/address/${e}?transaction_details=true`,a))[e]}catch(r){return K}},W=async({chain:e,apiKey:t,txHash:a})=>{if(!a)throw new Error("txHash is required");try{return(await b(`${x(e)}/raw/transaction/${a}`,t))?.[a]?.raw_transaction}catch(r){return console.error(r),""}},C=async({chain:e,address:t,apiKey:a,offset:r=0})=>{if(!t)throw new Error("address is required");try{const s=await b(`${x(e)}/outputs?q=is_spent(false),recipient(${t})&limit=100&offset=${r}`,a),n=s.filter((({is_spent:e})=>!e)).map((({script_hex:e,block_id:t,transaction_hash:a,index:r,value:s,spending_signature_hex:n})=>({hash:a,index:r,value:s,txHex:n,script_hex:e,is_confirmed:-1!==t})));if(100!==s.length)return n;const i=await C({address:t,chain:e,apiKey:a,offset:s?.[99]?.transaction_id});return n.concat(i)}catch(s){return console.error(s),[]}},P=({apiKey:e,chain:t})=>({getConfirmedBalance:a=>(async({chain:e,address:t,apiKey:a})=>{if(!t)throw new Error("address is required");try{return(await b(`${x(e)}/addresses/balances?addresses=${t}`,a))[t]||0}catch(r){return 0}})({chain:t,address:a,apiKey:e}),getRawTx:a=>W({txHash:a,chain:t,apiKey:e}),getSuggestedTxFee:()=>(async e=>{try{const{feePerKb:t}=await o.R0.get(`https://app.bitgo.com/api/v2/${e.toLowerCase()}/tx/fee`),a=t/1e3;return Math.max(a,v(e))}catch(t){return v(e)}})(t),getBalance:a=>(async({address:e,chain:t,apiKey:a})=>(await k({address:e,chain:t,apiKey:a}))?.address.balance)({address:a,chain:t,apiKey:e}),getAddressData:a=>k({address:a,chain:t,apiKey:e}),scanUTXOs:a=>(async({address:e,chain:t,apiKey:a,fetchTxHex:r=!0})=>{const s=await C({chain:t,address:e,apiKey:a}),n=[];for(let{hash:i,index:o,script_hex:c,value:d}of s){let s;r&&(s=await W({txHash:i,chain:t,apiKey:a})),n.push({address:e,hash:i,index:o,txHex:s,value:d,witnessUtxo:{value:d,script:y.from(c,"hex")}})}return n})({...a,chain:t,apiKey:e})}),T="undefined"!==typeof m&&m.pid?m.pid.toString(36):"",H=e=>{switch(e){case o.sW.Bitcoin:return i.o8.bitcoin;case o.sW.BitcoinCash:return c.bitcoincash.main.toBitcoinJS();case o.sW.Dash:return c.dash.main.toBitcoinJS();case o.sW.Litecoin:return c.litecoin.main.toBitcoinJS();case o.sW.Dogecoin:{const e={private:70615956,public:70617039};return c.dogecoin.test.versions.bip32=e,c.dogecoin.main.toBitcoinJS()}default:throw new Error("Invalid chain")}},B=0,R=()=>T+(()=>{const e=Date.now(),t=B||e;return e>(B=t)?e:t+1})().toString(36),E=async({txHash:e,rpcUrl:t})=>{const a=JSON.stringify({jsonrpc:"2.0",method:"sendrawtransaction",params:[e],id:R()}),r=await o.R0.post(t,{headers:{"Content-Type":"application/json"},body:a});if(r.error)throw new Error(`failed to broadcast a transaction: ${r.error?.message}`);if(r.result.includes('"code":-26'))throw new Error("Invalid transaction: the transaction amount was too low");return r.result},F=function(e){const t=A(e);return"legacy"===t?.format?e:I(t)},$=function(e){const t=A(e);return S(t)},A=function(e){try{return D(e)}catch(t){}try{return O(e)}catch(t){}throw Error("Received an invalid Bitcoin Cash address as input.")},D=function(e){try{const t=l.A.decode(e);if(21!==t.length)throw Error("Received an invalid Bitcoin Cash address as input.");const a=t[0],r=Array.prototype.slice.call(t,1);switch(a){case _.legacy.mainnet.p2pkh:return{hash:r,format:"legacy",network:"mainnet",type:"p2pkh"};case _.legacy.mainnet.p2sh:return{hash:r,format:"legacy",network:"mainnet",type:"p2sh"};case _.legacy.testnet.p2pkh:return{hash:r,format:"legacy",network:"testnet",type:"p2pkh"};case _.legacy.testnet.p2sh:return{hash:r,format:"legacy",network:"testnet",type:"p2sh"};case _.bitpay.mainnet.p2pkh:return{hash:r,format:"bitpay",network:"mainnet",type:"p2pkh"};case _.bitpay.mainnet.p2sh:return{hash:r,format:"bitpay",network:"mainnet",type:"p2sh"};default:throw Error("Received an invalid Bitcoin Cash address as input.")}}catch(t){throw Error("Received an invalid Bitcoin Cash address as input.")}},O=function(e){if(-1!==e.indexOf(":"))try{return U(e)}catch(t){}else{const t=["bitcoincash","bchtest","bchreg"];for(let r of t)try{return U(`${r}:${e}`)}catch(a){}}throw Error("Received an invalid Bitcoin Cash address as input.")},U=function(e){try{const{hash:t,prefix:a,type:r}=f.decode(e);return{format:"cashaddr",hash:Array.prototype.slice.call(t,0),network:"bitcoincash"===a?"mainnet":"testnet",type:"P2PKH"===r?"p2pkh":"p2sh"}}catch(t){throw Error("Received an invalid Bitcoin Cash address as input.")}},I=function(e){const t=_.legacy[e.network][e.type],a=y.alloc(1+e.hash.length);return a[0]=t,a.set(e.hash,1),l.A.encode(a)},S=function(e){const t="mainnet"===e.network?"bitcoincash":"bchtest",a="p2pkh"===e.type?"P2PKH":"P2SH",r=new Uint8Array(e.hash);return f.encode(t,a,r)};(n=s||={}).Mainnet="mainnet",n.Testnet="testnet";var V,_={legacy:{mainnet:{p2pkh:0,p2sh:5},testnet:{p2pkh:111,p2sh:196}},bitpay:{mainnet:{p2pkh:28,p2sh:40},testnet:{p2pkh:111,p2sh:196}}},M=e=>{switch(e){case o.sW.Bitcoin:case o.sW.BitcoinCash:return 550;case o.sW.Dash:case o.sW.Litecoin:return 5500;case o.sW.Dogecoin:return 1e5;default:throw new Error("Invalid Chain")}},L=({inputs:e,outputs:t,feeRate:a=1,chain:r=o.sW.Bitcoin})=>{const s=Math.ceil(a),n=e[0]&&"address"in e[0]&&e[0].address?z(e[0].address):"P2PKH",i=e.filter((e=>Z(e)*s<=e.value)),c=q+t.reduce(((e,t)=>e+G(t,n)),0),d=t.reduce(((e,t)=>e+t.value),0);let u=c*s,h=0;const p=[];for(let o of i){const e=Z(o);u+=s*e,h+=o.value,p.push(o);const a=u+d;if(h<a)continue;const i=h-a,c=s*G({address:"",value:0},n);if(i>c){const e=c+u,a=h-(d+e);if(a>Math.max(Z({})*s,M(r)))return{inputs:p,outputs:t.concat({value:a,address:""}),fee:e}}return{inputs:p,outputs:t,fee:u}}return{fee:s*j({inputs:e,outputs:t,feeRate:s})}},q=10,N=e=>{const t=y.from(e,"utf8");return i.K$.compile([i.Ez.OP_RETURN,t])};(e=>{e.P2PKH="P2PKH",e.P2WPKH="P2WPKH"})(V||={});var J={P2PKH:148,P2WPKH:68},X={P2PKH:34,P2WPKH:31},z=e=>{if(e.startsWith("bc1")||e.startsWith("ltc1"))return"P2WPKH";if(e.startsWith("1")||e.startsWith("3")||e.startsWith("L")||e.startsWith("M")||e.startsWith("X")||e.startsWith("D")||e.startsWith("bitcoincash:q")||e.startsWith("q"))return"P2PKH";throw new Error("Invalid address")},j=({inputs:e,outputs:t,feeRate:a})=>{const r=e[0]&&"address"in e[0]&&e[0].address?z(e[0].address):"P2PKH",s=e.filter((e=>e.value>=J["type"in e?e.type:"P2PKH"]*Math.ceil(a))).reduce(((e,t)=>e+Z(t)),0),n=t?.reduce(((e,t)=>e+G(t)),0)||X[r];return q+s+n},Z=e=>"type"in e?J[e.type]:"address"in e&&e.address?J[z(e.address)]:148,G=(e,t)=>e?.script?10+e.script.length+(e.script.length>=74?2:1):t?X[t]:X.P2PKH,Q=[o.sW.Dash,o.sW.Dogecoin],Y=({phrase:e,wif:t,derivationPath:s,chain:n})=>{if(!t&&!e)throw new Error("Either phrase or wif must be provided");const i=(0,p.dg)(r||(r=a.t(d,2))),o=H(n);if(t)return i.fromWIF(t,o);const c=(0,h.kw)(e),u=w.c.fromMasterSeed(c,o).derive(s);if(!u.privateKey)throw new Error("Could not get private key from phrase");return i.fromPrivateKey(y.from(u.privateKey),{network:o})},ee=({address:e,chain:t})=>{try{return(0,i.f0)(r||(r=a.t(d,2))),i.hl.toOutputScript(e,H(t)),!0}catch(n){return!1}},te=async e=>(e=>({[o.ok.Average]:e,[o.ok.Fast]:1.5*e,[o.ok.Fastest]:2*e}))(await e.getSuggestedTxFee()),ae=async({assetValue:e,recipient:t,memo:a,sender:r,fetchTxHex:s=!1,apiClient:n})=>({inputs:await n.scanUTXOs({address:r,fetchTxHex:s}),outputs:[{address:t,value:Number(e.bigIntValue)},...a?[{address:"",script:N(a),value:0}]:[]]}),re=async({assetValue:e,recipient:t,memo:s,feeRate:n,sender:c,fetchTxHex:u=!1,apiClient:h,chain:p})=>{const l=s?N(s):null,f=await ae({assetValue:e,recipient:t,memo:s,sender:c,fetchTxHex:u,apiClient:h}),{inputs:w,outputs:m}=L({...f,feeRate:n,chain:p});if(!w||!m)throw new Error("Insufficient Balance for transaction");const x=new i.iL({network:H(p)});p===o.sW.Dogecoin&&x.setMaximumFeeRate(65e7);for(let a of w)x.addInput({hash:a.hash,index:a.index,...!!a.witnessUtxo&&!Q.includes(p)&&{witnessUtxo:a.witnessUtxo},...Q.includes(p)&&{nonWitnessUtxo:a.txHex?y.from(a.txHex,"hex"):void 0}});for(let o of m){const e="address"in o&&o.address?o.address:c,t=o.script?l?{script:l,value:0}:void 0:{address:e,value:o.value};t&&((0,i.f0)(r||(r=a.t(d,2))),x.addOutput(t))}return{psbt:x,utxos:f.inputs,inputs:w}},se=async({assetValue:e,apiClient:t,chain:a,feeOptionKey:r=o.ok.Fast,feeRate:s,fetchTxHex:n=!1,memo:i,recipient:c,from:d})=>{const u=await ae({assetValue:e,recipient:c,memo:i,sender:d,fetchTxHex:n,apiClient:t}),h=s?Math.floor(s):(await te(t))[r];return L({...u,feeRate:h,chain:a})},ne=e=>({accumulative:L,apiClient:e.apiClient,broadcastTx:e.broadcastTx,calculateTxSize:j,buildTx:t=>re({...t,...e}),getAddressFromKeys:t=>(({keys:e,chain:t})=>{if(!e)throw new Error("Keys must be provided");const a=Q.includes(t)?i.KT.p2pkh:i.KT.p2wpkh,{address:r}=a({pubkey:e.publicKey,network:H(t)});if(!r)throw new Error("Address not defined");return r})({keys:t,...e}),validateAddress:t=>ee({address:t,...e}),createKeysForPath:t=>Y({...t,...e}),getPrivateKeyFromMnemonic:async t=>Y({...e,...t}).toWIF(),getBalance:async(t,a)=>(async({address:e,chain:t,apiClient:a})=>{const r=(await a.getBalance(e)||0)/10**o.Z$[t];return[await o.An.from({asset:`${t}.${t}`,value:r})]})({address:t,...e}),getFeeRates:()=>te(e.apiClient),transfer:t=>(async({signTransaction:e,from:t,memo:a,recipient:r,chain:s,apiClient:n,feeOptionKey:i,broadcastTx:c,feeRate:d,assetValue:u})=>{if(!t)throw new Error("From address must be provided");if(!r)throw new Error("Recipient address must be provided");const h=d||(await te(n))[i||o.ok.Fast],{psbt:p}=await re({recipient:r,feeRate:h,sender:t,fetchTxHex:Q.includes(s),chain:s,apiClient:n,assetValue:u,memo:a}),l=await e(p);return l.finalizeAllInputs(),c(l.extractTransaction().toHex())})({...t,...e}),getInputsOutputsFee:t=>se({...t,...e}),estimateTransactionFee:async t=>o.An.from({chain:e.chain,value:new o.Lm({value:(await se({...t,...e})).fee,decimal:8}).getValue("string")}),estimateMaxSendableAmount:async t=>(async({from:e,memo:t,feeRate:a,feeOptionKey:r=o.ok.Fast,recipients:s=1,chain:n,apiClient:i})=>{const c=await i.getAddressData(e),d=a?Math.ceil(a):(await te(i))[r],u=c?.utxo.map((e=>({...e,type:"P2PKH",hash:""}))).filter((e=>e.value>Math.max(M(n),Z(e)*d)));if(!u?.length)return o.An.from({chain:n});const h=o.An.from({chain:n,value:u.reduce(((e,t)=>e+t.value),0)}),p="number"===typeof s?Array.from({length:s},(()=>({address:e,value:0}))):s;if(t){const a=N(t);p.push({address:e,script:a,value:0})}const l=j({inputs:u,outputs:p,feeRate:d})*d;return h.sub(l)})({...t,...e})}),ie=o.sW.BitcoinCash,oe=e=>de($(e)),ce=async({assetValue:e,recipient:t,memo:a,feeRate:r,sender:s,apiClient:n})=>{if(!ue(t))throw new Error("Invalid address");const i=await n.scanUTXOs({address:oe(s),fetchTxHex:!0}),o=a?N(a):null,c=[];c.push({address:t,value:e.getBaseValue("number")});const{inputs:d,outputs:h}=L({inputs:i,outputs:c,feeRate:r,chain:ie});if(!d||!h)throw new Error("Balance insufficient for transaction");const p=new u.TransactionBuilder(H(ie));await Promise.all(d.map((async e=>{const t=await n.getRawTx(e.hash);p.addInput(u.Transaction.fromBuffer(y.from(t,"hex")),e.index)})));for(let l of h){const e="address"in l&&l.address?l.address:F(s),t=u.address.toOutputScript(F(e),H(ie));p.addOutput(t,l.value)}return o&&p.addOutput(o,0),{builder:p,utxos:d}},de=e=>e.replace(/(bchtest:|bitcoincash:)/,""),ue=e=>{const t=de(e);return function(e){try{return A(e),!0}catch(t){return!1}}(t)&&"mainnet"===function(e){return A(e)?.network}(t)},he=({phrase:e,derivationPath:t=`${o.Rz.BCH}/0`,wif:s})=>{const n=H(ie);if(s)return(0,p.dg)(r||(r=a.t(d,2))).fromWIF(s,n);if(!e)throw new Error("No phrase provided");return u.HDNode.fromSeedBuffer(y.from((0,h.kw)(e)),n).derivePath(t).keyPair},pe=e=>{const t=e.getAddress(0);return oe(t)},le=e=>({apiKey:t,rpcUrl:a=o.OV[e],apiClient:r})=>ne({chain:e,broadcastTx:e=>E({txHash:e,rpcUrl:a}),apiClient:r||P({apiKey:t,chain:e})}),fe=({apiKey:e,rpcUrl:t=o.vl.BitcoinCash,apiClient:a})=>{const r=a||P({apiKey:e,chain:ie}),{getBalance:s,...n}=ne({chain:ie,apiClient:r,broadcastTx:e=>E({txHash:e,rpcUrl:t})});return{...n,stripPrefix:de,stripToCashAddress:oe,validateAddress:ue,createKeysForPath:he,getAddressFromKeys:pe,buildBCHTx:e=>ce({...e,apiClient:r}),getBalance:(e,t)=>s(de($(e))),buildTx:e=>(async({assetValue:e,recipient:t,memo:a,feeRate:r,sender:s,apiClient:n})=>{const o=$(t);if(!ue(o))throw new Error("Invalid address");const c=await n.scanUTXOs({address:oe(s),fetchTxHex:!0}),d=Number(r.toFixed(0)),u=a?N(a):null,h=[];h.push({address:F(t),value:e.getBaseValue("number")}),u&&h.push({script:u,value:0});const{inputs:p,outputs:l}=L({inputs:c,outputs:h,feeRate:d,chain:ie});if(!p||!l)throw new Error("Balance insufficient for transaction");const f=new i.iL({network:H(ie)});for(let{hash:i,index:w,witnessUtxo:y}of p)f.addInput({hash:i,index:w,witnessUtxo:y});for(let i of l){const e="address"in i&&i.address?i.address:F(s),t=i.script?u?{script:u,value:0}:void 0:{address:e,value:i.value};t&&f.addOutput(t)}return{psbt:f,utxos:c,inputs:p}})({...e,apiClient:r}),transfer:e=>(async({signTransaction:e,from:t,recipient:a,assetValue:r,apiClient:s,broadcastTx:n,getFeeRates:i,...c})=>{if(!t)throw new Error("From address must be provided");if(!a)throw new Error("Recipient address must be provided");if(!e)throw new Error("signTransaction must be provided");const d=c.feeRate||(await i())[o.ok.Fast],{builder:u,utxos:h}=await ce({...c,assetValue:r,feeRate:d,recipient:a,sender:t,apiClient:s});return n(e({builder:u,utxos:h}).toHex())})({...e,getFeeRates:n.getFeeRates,broadcastTx:n.broadcastTx,apiClient:r})}},we=le(o.sW.Bitcoin),ye=le(o.sW.Dash),me=le(o.sW.Dogecoin),xe=le(o.sW.Litecoin),ve=e=>{switch(e){case o.sW.BitcoinCash:return fe;case o.sW.Bitcoin:return we;case o.sW.Dogecoin:return me;case o.sW.Litecoin:return xe;case o.sW.Dash:return ye;default:throw new Error(`Chain ${e} is not supported`)}}}}]);
//# sourceMappingURL=36.bec51eba.chunk.js.map