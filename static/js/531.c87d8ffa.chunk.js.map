{"version":3,"file":"static/js/531.c87d8ffa.chunk.js","mappings":"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","sources":["../node_modules/@bitcoinerlab/secp256k1/dist/index.js","../node_modules/@noble/secp256k1/lib/index.js"],"sourcesContent":["'use strict';\n\nvar necc = require('@noble/secp256k1');\nvar hmac = require('@noble/hashes/hmac');\nvar sha256 = require('@noble/hashes/sha256');\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar necc__namespace = /*#__PURE__*/_interopNamespaceDefault(necc);\n\n/*\n * Copyright (c) 2023 Jose-Luis Landabaso\n * Distributed under the MIT software license.\n *\n * This file includes code from the following sources:\n *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,\n *    privateNegate, pointAddScalar, and pointMultiply functions).\n *  * Some pieces from tiny-secp256k1\n *    (https://github.com/bitcoinjs/tiny-secp256k1)\n *  * It also uses code from BitGo's BitGoJS library\n *    (https://github.com/BitGo/BitGoJS)\n *\n * This package's tests are based on modified versions of tests from\n * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).\n */\n\nconst THROW_BAD_PRIVATE = 'Expected Private';\nconst THROW_BAD_POINT = 'Expected Point';\nconst THROW_BAD_TWEAK = 'Expected Tweak';\nconst THROW_BAD_HASH = 'Expected Hash';\nconst THROW_BAD_SIGNATURE = 'Expected Signature';\nconst THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)';\nconst THROW_BAD_SCALAR = 'Expected Scalar';\nconst THROW_BAD_RECOVERY_ID = 'Bad Recovery Id';\n\nnecc__namespace.utils.hmacSha256Sync = (key, ...msgs) =>\n  hmac.hmac(sha256.sha256, key, necc__namespace.utils.concatBytes(...msgs));\nnecc__namespace.utils.sha256Sync = (...msgs) => sha256.sha256(necc__namespace.utils.concatBytes(...msgs));\n\nconst normalizePrivateKey = necc__namespace.utils._normalizePrivateKey;\n\nconst HASH_SIZE = 32;\nconst TWEAK_SIZE = 32;\nconst BN32_N = new Uint8Array([\n  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n  254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65\n]);\nconst EXTRA_DATA_SIZE = 32;\n\nconst BN32_ZERO = new Uint8Array(32);\nconst BN32_P_MINUS_N = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,\n  196, 64, 45, 161, 114, 47, 201, 186, 238,\n]);\n\nfunction isUint8Array(value) {\n  return value instanceof Uint8Array;\n}\n\nfunction cmpBN32(data1, data2) {\n  for (let i = 0; i < 32; ++i) {\n    if (data1[i] !== data2[i]) {\n      return data1[i] < data2[i] ? -1 : 1;\n    }\n  }\n  return 0;\n}\n\nfunction isZero(x) {\n  return cmpBN32(x, BN32_ZERO) === 0;\n}\n\n\nfunction isTweak(tweak) {\n  // Check that the tweak is a Uint8Array of the correct length\n  if (\n    !(tweak instanceof Uint8Array) ||\n    tweak.length !== TWEAK_SIZE ||\n    cmpBN32(tweak, BN32_N) >= 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isSignature(signature) {\n  return (\n    signature instanceof Uint8Array &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&\n    cmpBN32(signature.subarray(32, 64), BN32_N) < 0\n  );\n}\n\nfunction isSigrLessThanPMinusN(signature) {\n  return (\n    isUint8Array(signature) &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0\n  );\n}\n\nfunction isSignatureNonzeroRS(signature) {\n  return !(isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64)))\n}\n\nfunction isHash(h) {\n  return h instanceof Uint8Array && h.length === HASH_SIZE;\n}\n\nfunction isExtraData(e) {\n  return (\n    e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE)\n  );\n}\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n  }\n  return BigInt(`0x${hex}`);\n}\n\nfunction bytesToNumber(bytes) {\n  return hexToNumber(necc__namespace.utils.bytesToHex(bytes));\n}\n\nfunction normalizeScalar(scalar) {\n  let num;\n  if (typeof scalar === 'bigint') {\n    num = scalar;\n  } else if (\n    typeof scalar === 'number' &&\n    Number.isSafeInteger(scalar) &&\n    scalar >= 0\n  ) {\n    num = BigInt(scalar);\n  } else if (typeof scalar === 'string') {\n    if (scalar.length !== 64)\n      throw new Error('Expected 32 bytes of private scalar');\n    num = hexToNumber(scalar);\n  } else if (scalar instanceof Uint8Array) {\n    if (scalar.length !== 32)\n      throw new Error('Expected 32 bytes of private scalar');\n    num = bytesToNumber(scalar);\n  } else {\n    throw new TypeError('Expected valid private scalar');\n  }\n  if (num < 0) throw new Error('Expected private scalar >= 0');\n  return num;\n}\n\nconst _privateAdd = (privateKey, tweak) => {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const add = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(p + t, necc__namespace.CURVE.n));\n  if (necc__namespace.utils.isValidPrivateKey(add)) return add;\n  else return null;\n};\n\nconst _privateSub = (privateKey, tweak) => {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const sub = necc__namespace.utils._bigintTo32Bytes(necc__namespace.utils.mod(p - t, necc__namespace.CURVE.n));\n  if (necc__namespace.utils.isValidPrivateKey(sub)) return sub;\n  else return null;\n};\n\nconst _privateNegate = privateKey => {\n  const p = normalizePrivateKey(privateKey);\n  const not = necc__namespace.utils._bigintTo32Bytes(necc__namespace.CURVE.n - p);\n  if (necc__namespace.utils.isValidPrivateKey(not)) return not;\n  else return null;\n};\n\nconst _pointAddScalar = (p, tweak, isCompressed) => {\n  const P = necc__namespace.Point.fromHex(p);\n  const t = normalizeScalar(tweak);\n  const Q = necc__namespace.Point.BASE.multiplyAndAddUnsafe(P, t, BigInt(1));\n  if (!Q) throw new Error('Tweaked point at infinity');\n  return Q.toRawBytes(isCompressed);\n};\n\nconst _pointMultiply = (p, tweak, isCompressed) => {\n  const P = necc__namespace.Point.fromHex(p);\n  const h = typeof tweak === 'string' ? tweak : necc__namespace.utils.bytesToHex(tweak);\n  const t = BigInt(`0x${h}`);\n  return P.multiply(t).toRawBytes(isCompressed);\n};\n\nfunction assumeCompression(compressed, p) {\n  if (compressed === undefined) {\n    return p !== undefined ? isPointCompressed(p) : true;\n  }\n  return compressed ? true : false;\n}\n\nfunction throwToNull(fn) {\n  try {\n    return fn();\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction _isPoint(p, xOnly) {\n  if ((p.length === 32) !== xOnly) return false;\n  try {\n    return !!necc__namespace.Point.fromHex(p);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPoint(p) {\n  return _isPoint(p, false);\n}\n\nfunction isPointCompressed(p) {\n  const PUBLIC_KEY_COMPRESSED_SIZE = 33;\n  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;\n}\n\nfunction isPrivate(d) {\n  return necc__namespace.utils.isValidPrivateKey(d);\n}\n\nfunction isXOnlyPoint(p) {\n  return _isPoint(p, true);\n}\n\nfunction xOnlyPointAddTweak(p, tweak) {\n  if (!isXOnlyPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => {\n    const P = _pointAddScalar(p, tweak, true);\n    const parity = P[0] % 2 === 1 ? 1 : 0;\n    return { parity, xOnlyPubkey: P.slice(1) };\n  });\n}\n\nfunction xOnlyPointFromPoint(p) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return p.slice(1, 33);\n}\n\nfunction pointFromScalar(sk, compressed) {\n  if (!isPrivate(sk)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return throwToNull(() =>\n    necc__namespace.getPublicKey(sk, assumeCompression(compressed))\n  );\n}\n\nfunction xOnlyPointFromScalar(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return xOnlyPointFromPoint(pointFromScalar(d));\n}\n\nfunction pointCompress(p, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return necc__namespace.Point.fromHex(p).toRawBytes(assumeCompression(compressed, p));\n}\n\nfunction pointMultiply(a, tweak, compressed) {\n  if (!isPoint(a)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointMultiply(a, tweak, assumeCompression(compressed, a))\n  );\n}\n\nfunction pointAdd(a, b, compressed) {\n  if (!isPoint(a) || !isPoint(b)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return throwToNull(() => {\n    const A = necc__namespace.Point.fromHex(a);\n    const B = necc__namespace.Point.fromHex(b);\n    if (A.equals(B.negate())) {\n      //https://github.com/paulmillr/noble-secp256k1/issues/91\n      return null;\n    } else {\n      return A.add(B).toRawBytes(assumeCompression(compressed, a));\n    }\n  });\n}\nfunction pointAddScalar(p, tweak, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointAddScalar(p, tweak, assumeCompression(compressed, p))\n  );\n}\n\nfunction privateAdd(d, tweak) {\n  if (isPrivate(d) === false) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (isTweak(tweak) === false) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateAdd(d, tweak));\n}\n\nfunction privateSub(d, tweak) {\n  if (isPrivate(d) === false) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (isTweak(tweak) === false) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateSub(d, tweak));\n}\n\nfunction privateNegate(d) {\n  if (isPrivate(d) === false) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return _privateNegate(d);\n}\n\nfunction sign(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return necc__namespace.signSync(h, d, { der: false, extraEntropy: e });\n}\n\nfunction signRecoverable(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  const [signature, recoveryId] = necc__namespace.signSync(h, d, { der: false, extraEntropy: e, recovered: true });\n  return { signature, recoveryId }\n}\n\nfunction signSchnorr(h, d, e = Buffer.alloc(32, 0x00)) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return necc__namespace.schnorr.signSync(h, d, e);\n}\n\nfunction recover(h, signature, recoveryId, compressed){\n  if (!isHash(h)){\n    throw new Error(THROW_BAD_HASH);\n  }\n\n  if(!isSignature(signature) || !isSignatureNonzeroRS(signature)){\n    throw new Error(THROW_BAD_SIGNATURE)\n  }\n\n  if (recoveryId & 2) {\n    if (!isSigrLessThanPMinusN(signature)) throw new Error(THROW_BAD_RECOVERY_ID)\n  }\n  \n  if (!isXOnlyPoint(signature.subarray(0, 32))){\n    throw new Error(THROW_BAD_SIGNATURE)\n  }\n\n  return necc__namespace.recoverPublicKey(h, signature, recoveryId, assumeCompression(compressed));\n}\n\nfunction verify(h, Q, signature, strict) {\n  if (!isPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return necc__namespace.verify(signature, h, Q, { strict });\n}\n\nfunction verifySchnorr(h, Q, signature) {\n  if (!isXOnlyPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return necc__namespace.schnorr.verifySync(signature, h, Q);\n}\n\nexports.isPoint = isPoint;\nexports.isPointCompressed = isPointCompressed;\nexports.isPrivate = isPrivate;\nexports.isXOnlyPoint = isXOnlyPoint;\nexports.pointAdd = pointAdd;\nexports.pointAddScalar = pointAddScalar;\nexports.pointCompress = pointCompress;\nexports.pointFromScalar = pointFromScalar;\nexports.pointMultiply = pointMultiply;\nexports.privateAdd = privateAdd;\nexports.privateNegate = privateNegate;\nexports.privateSub = privateSub;\nexports.recover = recover;\nexports.sign = sign;\nexports.signRecoverable = signRecoverable;\nexports.signSchnorr = signSchnorr;\nexports.verify = verify;\nexports.verifySchnorr = verifySchnorr;\nexports.xOnlyPointAddTweak = xOnlyPointAddTweak;\nexports.xOnlyPointFromPoint = xOnlyPointFromPoint;\nexports.xOnlyPointFromScalar = xOnlyPointFromScalar;\n","\"use strict\";\n/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;\nconst nodeCrypto = require(\"crypto\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _3n = BigInt(3);\nconst _8n = BigInt(8);\nconst CURVE = Object.freeze({\n    a: _0n,\n    b: BigInt(7),\n    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n    h: _1n,\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n});\nexports.CURVE = CURVE;\nconst divNearest = (a, b) => (a + b / _2n) / b;\nconst endo = {\n    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n    splitScalar(k) {\n        const { n } = CURVE;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000');\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n            k1 = n - k1;\n        if (k2neg)\n            k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n            throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n    },\n};\nconst fieldLen = 32;\nconst groupLen = 32;\nconst hashLen = 32;\nconst compressedLen = fieldLen + 1;\nconst uncompressedLen = 2 * fieldLen + 1;\nfunction weierstrass(x) {\n    const { a, b } = CURVE;\n    const x2 = mod(x * x);\n    const x3 = mod(x2 * x);\n    return mod(x3 + a * x + b);\n}\nconst USE_ENDOMORPHISM = CURVE.a === _0n;\nclass ShaError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction assertJacPoint(other) {\n    if (!(other instanceof JacobianPoint))\n        throw new TypeError('JacobianPoint expected');\n}\nclass JacobianPoint {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('JacobianPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return JacobianPoint.ZERO;\n        return new JacobianPoint(p.x, p.y, _1n);\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);\n    }\n    equals(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        return U1 === U2 && S1 === S2;\n    }\n    negate() {\n        return new JacobianPoint(this.x, mod(-this.y), this.z);\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const A = mod(X1 * X1);\n        const B = mod(Y1 * Y1);\n        const C = mod(B * B);\n        const x1b = X1 + B;\n        const D = mod(_2n * (mod(x1b * x1b) - A - C));\n        const E = mod(_3n * A);\n        const F = mod(E * E);\n        const X3 = mod(F - _2n * D);\n        const Y3 = mod(E * (D - X3) - _8n * C);\n        const Z3 = mod(_2n * Y1 * Z1);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    add(other) {\n        assertJacPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        if (X2 === _0n || Y2 === _0n)\n            return this;\n        if (X1 === _0n || Y1 === _0n)\n            return other;\n        const Z1Z1 = mod(Z1 * Z1);\n        const Z2Z2 = mod(Z2 * Z2);\n        const U1 = mod(X1 * Z2Z2);\n        const U2 = mod(X2 * Z1Z1);\n        const S1 = mod(mod(Y1 * Z2) * Z2Z2);\n        const S2 = mod(mod(Y2 * Z1) * Z1Z1);\n        const H = mod(U2 - U1);\n        const r = mod(S2 - S1);\n        if (H === _0n) {\n            if (r === _0n) {\n                return this.double();\n            }\n            else {\n                return JacobianPoint.ZERO;\n            }\n        }\n        const HH = mod(H * H);\n        const HHH = mod(H * HH);\n        const V = mod(U1 * HH);\n        const X3 = mod(r * r - HHH - _2n * V);\n        const Y3 = mod(r * (V - X3) - S1 * HHH);\n        const Z3 = mod(Z1 * Z2 * H);\n        return new JacobianPoint(X3, Y3, Z3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiplyUnsafe(scalar) {\n        const P0 = JacobianPoint.ZERO;\n        if (typeof scalar === 'bigint' && scalar === _0n)\n            return P0;\n        let n = normalizeScalar(scalar);\n        if (n === _1n)\n            return this;\n        if (!USE_ENDOMORPHISM) {\n            let p = P0;\n            let d = this;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        }\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = P0;\n        let k2p = P0;\n        let d = this;\n        while (k1 > _0n || k2 > _0n) {\n            if (k1 & _1n)\n                k1p = k1p.add(d);\n            if (k2 & _1n)\n                k2p = k2p.add(d);\n            d = d.double();\n            k1 >>= _1n;\n            k2 >>= _1n;\n        }\n        if (k1neg)\n            k1p = k1p.negate();\n        if (k2neg)\n            k2p = k2p.negate();\n        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n        return k1p.add(k2p);\n    }\n    precomputeWindow(W) {\n        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(JacobianPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = JacobianPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = JacobianPoint.ZERO;\n        let f = JacobianPoint.BASE;\n        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return { p, f };\n    }\n    multiply(scalar, affinePoint) {\n        let n = normalizeScalar(scalar);\n        let point;\n        let fake;\n        if (USE_ENDOMORPHISM) {\n            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);\n            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);\n            k1p = constTimeNegate(k1neg, k1p);\n            k2p = constTimeNegate(k2neg, k2p);\n            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);\n            point = k1p.add(k2p);\n            fake = f1p.add(f2p);\n        }\n        else {\n            const { p, f } = this.wNAF(n, affinePoint);\n            point = p;\n            fake = f;\n        }\n        return JacobianPoint.normalizeZ([point, fake])[0];\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(JacobianPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const iz1 = invZ;\n        const iz2 = mod(iz1 * iz1);\n        const iz3 = mod(iz2 * iz1);\n        const ax = mod(x * iz2);\n        const ay = mod(y * iz3);\n        const zz = mod(z * iz1);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n}\nJacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);\nJacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    hasEvenY() {\n        return this.y % _2n === _0n;\n    }\n    static fromCompressedHex(bytes) {\n        const isShort = bytes.length === 32;\n        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));\n        if (!isValidFieldElement(x))\n            throw new Error('Point is not on curve');\n        const y2 = weierstrass(x);\n        let y = sqrtMod(y2);\n        const isYOdd = (y & _1n) === _1n;\n        if (isShort) {\n            if (isYOdd)\n                y = mod(-y);\n        }\n        else {\n            const isFirstByteOdd = (bytes[0] & 1) === 1;\n            if (isFirstByteOdd !== isYOdd)\n                y = mod(-y);\n        }\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromUncompressedHex(bytes) {\n        const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));\n        const y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));\n        const point = new Point(x, y);\n        point.assertValidity();\n        return point;\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        const len = bytes.length;\n        const header = bytes[0];\n        if (len === fieldLen)\n            return this.fromCompressedHex(bytes);\n        if (len === compressedLen && (header === 0x02 || header === 0x03)) {\n            return this.fromCompressedHex(bytes);\n        }\n        if (len === uncompressedLen && header === 0x04)\n            return this.fromUncompressedHex(bytes);\n        throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);\n    }\n    static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(normalizePrivateKey(privateKey));\n    }\n    static fromSignature(msgHash, signature, recovery) {\n        const { r, s } = normalizeSignature(signature);\n        if (![0, 1, 2, 3].includes(recovery))\n            throw new Error('Cannot recover: invalid recovery bit');\n        const h = truncateHash(ensureBytes(msgHash));\n        const { n } = CURVE;\n        const radj = recovery === 2 || recovery === 3 ? r + n : r;\n        const rinv = invert(radj, n);\n        const u1 = mod(-h * rinv, n);\n        const u2 = mod(s * rinv, n);\n        const prefix = recovery & 1 ? '03' : '02';\n        const R = Point.fromHex(prefix + numTo32bStr(radj));\n        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n            throw new Error('Cannot recover signature: point at infinify');\n        Q.assertValidity();\n        return Q;\n    }\n    toRawBytes(isCompressed = false) {\n        return hexToBytes(this.toHex(isCompressed));\n    }\n    toHex(isCompressed = false) {\n        const x = numTo32bStr(this.x);\n        if (isCompressed) {\n            const prefix = this.hasEvenY() ? '02' : '03';\n            return `${prefix}${x}`;\n        }\n        else {\n            return `04${x}${numTo32bStr(this.y)}`;\n        }\n    }\n    toHexX() {\n        return this.toHex(true).slice(2);\n    }\n    toRawX() {\n        return this.toRawBytes(true).slice(1);\n    }\n    assertValidity() {\n        const msg = 'Point is not on elliptic curve';\n        const { x, y } = this;\n        if (!isValidFieldElement(x) || !isValidFieldElement(y))\n            throw new Error(msg);\n        const left = mod(y * y);\n        const right = weierstrass(x);\n        if (mod(left - right) !== _0n)\n            throw new Error(msg);\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(this.x, mod(-this.y));\n    }\n    double() {\n        return JacobianPoint.fromAffine(this).double().toAffine();\n    }\n    add(other) {\n        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n    multiplyAndAddUnsafe(Q, a, b) {\n        const P = JacobianPoint.fromAffine(this);\n        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);\n        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);\n        const sum = aP.add(bQ);\n        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _0n);\nfunction sliceDER(s) {\n    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;\n}\nfunction parseDERInt(data) {\n    if (data.length < 2 || data[0] !== 0x02) {\n        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);\n    }\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) {\n        throw new Error(`Invalid signature integer: wrong length`);\n    }\n    if (res[0] === 0x00 && res[1] <= 0x7f) {\n        throw new Error('Invalid signature integer: trailing length');\n    }\n    return { data: bytesToNumber(res), left: data.subarray(len + 2) };\n}\nfunction parseDERSignature(data) {\n    if (data.length < 2 || data[0] != 0x30) {\n        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);\n    }\n    if (data[1] !== data.length - 2) {\n        throw new Error('Invalid signature: incorrect length');\n    }\n    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));\n    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);\n    if (rBytesLeft.length) {\n        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);\n    }\n    return { r, s };\n}\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromCompact(hex) {\n        const arr = hex instanceof Uint8Array;\n        const name = 'Signature.fromCompact';\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`${name}: Expected string or Uint8Array`);\n        const str = arr ? bytesToHex(hex) : hex;\n        if (str.length !== 128)\n            throw new Error(`${name}: Expected 64-byte hex`);\n        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));\n    }\n    static fromDER(hex) {\n        const arr = hex instanceof Uint8Array;\n        if (typeof hex !== 'string' && !arr)\n            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);\n        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));\n        return new Signature(r, s);\n    }\n    static fromHex(hex) {\n        return this.fromDER(hex);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isWithinCurveOrder(r))\n            throw new Error('Invalid Signature: r must be 0 < r < n');\n        if (!isWithinCurveOrder(s))\n            throw new Error('Invalid Signature: s must be 0 < s < n');\n    }\n    hasHighS() {\n        const HALF = CURVE.n >> _1n;\n        return this.s > HALF;\n    }\n    normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;\n    }\n    toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n        const sHex = sliceDER(numberToHexUnpadded(this.s));\n        const rHex = sliceDER(numberToHexUnpadded(this.r));\n        const sHexL = sHex.length / 2;\n        const rHexL = rHex.length / 2;\n        const sLen = numberToHexUnpadded(sHexL);\n        const rLen = numberToHexUnpadded(rHexL);\n        const length = numberToHexUnpadded(rHexL + sHexL + 4);\n        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;\n    }\n    toRawBytes() {\n        return this.toDERRawBytes();\n    }\n    toHex() {\n        return this.toDERHex();\n    }\n    toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n    if (!arrays.every((b) => b instanceof Uint8Array))\n        throw new Error('Uint8Array list expected');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nfunction numTo32bStr(num) {\n    if (typeof num !== 'bigint')\n        throw new Error('Expected bigint');\n    if (!(_0n <= num && num < POW_2_256))\n        throw new Error('Expected number 0 <= n < 2^256');\n    return num.toString(16).padStart(64, '0');\n}\nfunction numTo32b(num) {\n    const b = hexToBytes(numTo32bStr(num));\n    if (b.length !== 32)\n        throw new Error('Error: expected 32 bytes');\n    return b;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);\n    }\n    return BigInt(`0x${hex}`);\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction bytesToNumber(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction ensureBytes(hex) {\n    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n}\nfunction normalizeScalar(num) {\n    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)\n        return BigInt(num);\n    if (typeof num === 'bigint' && isWithinCurveOrder(num))\n        return num;\n    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');\n}\nfunction mod(a, b = CURVE.P) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction sqrtMod(x) {\n    const { P } = CURVE;\n    const _6n = BigInt(6);\n    const _11n = BigInt(11);\n    const _22n = BigInt(22);\n    const _23n = BigInt(23);\n    const _44n = BigInt(44);\n    const _88n = BigInt(88);\n    const b2 = (x * x * x) % P;\n    const b3 = (b2 * b2 * x) % P;\n    const b6 = (pow2(b3, _3n) * b3) % P;\n    const b9 = (pow2(b6, _3n) * b3) % P;\n    const b11 = (pow2(b9, _2n) * b2) % P;\n    const b22 = (pow2(b11, _11n) * b11) % P;\n    const b44 = (pow2(b22, _22n) * b22) % P;\n    const b88 = (pow2(b44, _44n) * b44) % P;\n    const b176 = (pow2(b88, _88n) * b88) % P;\n    const b220 = (pow2(b176, _44n) * b44) % P;\n    const b223 = (pow2(b220, _3n) * b3) % P;\n    const t1 = (pow2(b223, _23n) * b22) % P;\n    const t2 = (pow2(t1, _6n) * b2) % P;\n    const rt = pow2(t2, _2n);\n    const xc = (rt * rt) % P;\n    if (xc !== x)\n        throw new Error('Cannot find square root');\n    return rt;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const scratch = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        scratch[i] = mod(acc * scratch[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return scratch;\n}\nfunction bits2int_2(bytes) {\n    const delta = bytes.length * 8 - groupLen * 8;\n    const num = bytesToNumber(bytes);\n    return delta > 0 ? num >> BigInt(delta) : num;\n}\nfunction truncateHash(hash, truncateOnly = false) {\n    const h = bits2int_2(hash);\n    if (truncateOnly)\n        return h;\n    const { n } = CURVE;\n    return h >= n ? h - n : h;\n}\nlet _sha256Sync;\nlet _hmacSha256Sync;\nclass HmacDrbg {\n    constructor(hashLen, qByteLen) {\n        this.hashLen = hashLen;\n        this.qByteLen = qByteLen;\n        if (typeof hashLen !== 'number' || hashLen < 2)\n            throw new Error('hashLen must be a number');\n        if (typeof qByteLen !== 'number' || qByteLen < 2)\n            throw new Error('qByteLen must be a number');\n        this.v = new Uint8Array(hashLen).fill(1);\n        this.k = new Uint8Array(hashLen).fill(0);\n        this.counter = 0;\n    }\n    hmac(...values) {\n        return exports.utils.hmacSha256(this.k, ...values);\n    }\n    hmacSync(...values) {\n        return _hmacSha256Sync(this.k, ...values);\n    }\n    checkSync() {\n        if (typeof _hmacSha256Sync !== 'function')\n            throw new ShaError('hmacSha256Sync needs to be set');\n    }\n    incr() {\n        if (this.counter >= 1000)\n            throw new Error('Tried 1,000 k values for sign(), all were invalid');\n        this.counter += 1;\n    }\n    async reseed(seed = new Uint8Array()) {\n        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);\n        this.v = await this.hmac(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);\n        this.v = await this.hmac(this.v);\n    }\n    reseedSync(seed = new Uint8Array()) {\n        this.checkSync();\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);\n        this.v = this.hmacSync(this.v);\n        if (seed.length === 0)\n            return;\n        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);\n        this.v = this.hmacSync(this.v);\n    }\n    async generate() {\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = await this.hmac(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n    generateSync() {\n        this.checkSync();\n        this.incr();\n        let len = 0;\n        const out = [];\n        while (len < this.qByteLen) {\n            this.v = this.hmacSync(this.v);\n            const sl = this.v.slice();\n            out.push(sl);\n            len += this.v.length;\n        }\n        return concatBytes(...out);\n    }\n}\nfunction isWithinCurveOrder(num) {\n    return _0n < num && num < CURVE.n;\n}\nfunction isValidFieldElement(num) {\n    return _0n < num && num < CURVE.P;\n}\nfunction kmdToSig(kBytes, m, d, lowS = true) {\n    const { n } = CURVE;\n    const k = truncateHash(kBytes, true);\n    if (!isWithinCurveOrder(k))\n        return;\n    const kinv = invert(k, n);\n    const q = Point.BASE.multiply(k);\n    const r = mod(q.x, n);\n    if (r === _0n)\n        return;\n    const s = mod(kinv * mod(m + d * r, n), n);\n    if (s === _0n)\n        return;\n    let sig = new Signature(r, s);\n    let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);\n    if (lowS && sig.hasHighS()) {\n        sig = sig.normalizeS();\n        recovery ^= 1;\n    }\n    return { sig, recovery };\n}\nfunction normalizePrivateKey(key) {\n    let num;\n    if (typeof key === 'bigint') {\n        num = key;\n    }\n    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {\n        num = BigInt(key);\n    }\n    else if (typeof key === 'string') {\n        if (key.length !== 2 * groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = hexToNumber(key);\n    }\n    else if (key instanceof Uint8Array) {\n        if (key.length !== groupLen)\n            throw new Error('Expected 32 bytes of private key');\n        num = bytesToNumber(key);\n    }\n    else {\n        throw new TypeError('Expected valid private key');\n    }\n    if (!isWithinCurveOrder(num))\n        throw new Error('Expected private key: 0 < key < n');\n    return num;\n}\nfunction normalizePublicKey(publicKey) {\n    if (publicKey instanceof Point) {\n        publicKey.assertValidity();\n        return publicKey;\n    }\n    else {\n        return Point.fromHex(publicKey);\n    }\n}\nfunction normalizeSignature(signature) {\n    if (signature instanceof Signature) {\n        signature.assertValidity();\n        return signature;\n    }\n    try {\n        return Signature.fromDER(signature);\n    }\n    catch (error) {\n        return Signature.fromCompact(signature);\n    }\n}\nfunction getPublicKey(privateKey, isCompressed = false) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n}\nexports.getPublicKey = getPublicKey;\nfunction recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {\n    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);\n}\nexports.recoverPublicKey = recoverPublicKey;\nfunction isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr)\n        return len === compressedLen || len === uncompressedLen;\n    if (str)\n        return len === compressedLen * 2 || len === uncompressedLen * 2;\n    if (item instanceof Point)\n        return true;\n    return false;\n}\nfunction getSharedSecret(privateA, publicB, isCompressed = false) {\n    if (isProbPub(privateA))\n        throw new TypeError('getSharedSecret: first arg must be private key');\n    if (!isProbPub(publicB))\n        throw new TypeError('getSharedSecret: second arg must be public key');\n    const b = normalizePublicKey(publicB);\n    b.assertValidity();\n    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);\n}\nexports.getSharedSecret = getSharedSecret;\nfunction bits2int(bytes) {\n    const slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;\n    return bytesToNumber(slice);\n}\nfunction bits2octets(bytes) {\n    const z1 = bits2int(bytes);\n    const z2 = mod(z1, CURVE.n);\n    return int2octets(z2 < _0n ? z1 : z2);\n}\nfunction int2octets(num) {\n    return numTo32b(num);\n}\nfunction initSigArgs(msgHash, privateKey, extraEntropy) {\n    if (msgHash == null)\n        throw new Error(`sign: expected valid message hash, not \"${msgHash}\"`);\n    const h1 = ensureBytes(msgHash);\n    const d = normalizePrivateKey(privateKey);\n    const seedArgs = [int2octets(d), bits2octets(h1)];\n    if (extraEntropy != null) {\n        if (extraEntropy === true)\n            extraEntropy = exports.utils.randomBytes(fieldLen);\n        const e = ensureBytes(extraEntropy);\n        if (e.length !== fieldLen)\n            throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);\n        seedArgs.push(e);\n    }\n    const seed = concatBytes(...seedArgs);\n    const m = bits2int(h1);\n    return { seed, m, d };\n}\nfunction finalizeSig(recSig, opts) {\n    const { sig, recovery } = recSig;\n    const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);\n    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();\n    return recovered ? [hashed, recovery] : hashed;\n}\nasync function sign(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    await drbg.reseed(seed);\n    let sig;\n    while (!(sig = kmdToSig(await drbg.generate(), m, d, opts.canonical)))\n        await drbg.reseed();\n    return finalizeSig(sig, opts);\n}\nexports.sign = sign;\nfunction signSync(msgHash, privKey, opts = {}) {\n    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);\n    const drbg = new HmacDrbg(hashLen, groupLen);\n    drbg.reseedSync(seed);\n    let sig;\n    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))\n        drbg.reseedSync();\n    return finalizeSig(sig, opts);\n}\nexports.signSync = signSync;\nconst vopts = { strict: true };\nfunction verify(signature, msgHash, publicKey, opts = vopts) {\n    let sig;\n    try {\n        sig = normalizeSignature(signature);\n        msgHash = ensureBytes(msgHash);\n    }\n    catch (error) {\n        return false;\n    }\n    const { r, s } = sig;\n    if (opts.strict && sig.hasHighS())\n        return false;\n    const h = truncateHash(msgHash);\n    let P;\n    try {\n        P = normalizePublicKey(publicKey);\n    }\n    catch (error) {\n        return false;\n    }\n    const { n } = CURVE;\n    const sinv = invert(s, n);\n    const u1 = mod(h * sinv, n);\n    const u2 = mod(r * sinv, n);\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);\n    if (!R)\n        return false;\n    const v = mod(R.x, n);\n    return v === r;\n}\nexports.verify = verify;\nfunction schnorrChallengeFinalize(ch) {\n    return mod(bytesToNumber(ch), CURVE.n);\n}\nclass SchnorrSignature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex);\n        if (bytes.length !== 64)\n            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);\n        const r = bytesToNumber(bytes.subarray(0, 32));\n        const s = bytesToNumber(bytes.subarray(32, 64));\n        return new SchnorrSignature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))\n            throw new Error('Invalid signature');\n    }\n    toHex() {\n        return numTo32bStr(this.r) + numTo32bStr(this.s);\n    }\n    toRawBytes() {\n        return hexToBytes(this.toHex());\n    }\n}\nfunction schnorrGetPublicKey(privateKey) {\n    return Point.fromPrivateKey(privateKey).toRawX();\n}\nclass InternalSchnorrSignature {\n    constructor(message, privateKey, auxRand = exports.utils.randomBytes()) {\n        if (message == null)\n            throw new TypeError(`sign: Expected valid message, not \"${message}\"`);\n        this.m = ensureBytes(message);\n        const { x, scalar } = this.getScalar(normalizePrivateKey(privateKey));\n        this.px = x;\n        this.d = scalar;\n        this.rand = ensureBytes(auxRand);\n        if (this.rand.length !== 32)\n            throw new TypeError('sign: Expected 32 bytes of aux randomness');\n    }\n    getScalar(priv) {\n        const point = Point.fromPrivateKey(priv);\n        const scalar = point.hasEvenY() ? priv : CURVE.n - priv;\n        return { point, scalar, x: point.toRawX() };\n    }\n    initNonce(d, t0h) {\n        return numTo32b(d ^ bytesToNumber(t0h));\n    }\n    finalizeNonce(k0h) {\n        const k0 = mod(bytesToNumber(k0h), CURVE.n);\n        if (k0 === _0n)\n            throw new Error('sign: Creation of signature failed. k is zero');\n        const { point: R, x: rx, scalar: k } = this.getScalar(k0);\n        return { R, rx, k };\n    }\n    finalizeSig(R, k, e, d) {\n        return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();\n    }\n    error() {\n        throw new Error('sign: Invalid signature produced');\n    }\n    async calc() {\n        const { m, d, px, rand } = this;\n        const tag = exports.utils.taggedHash;\n        const t = this.initNonce(d, await tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(await tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(await tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!(await schnorrVerify(sig, m, px)))\n            this.error();\n        return sig;\n    }\n    calcSync() {\n        const { m, d, px, rand } = this;\n        const tag = exports.utils.taggedHashSync;\n        const t = this.initNonce(d, tag(TAGS.aux, rand));\n        const { R, rx, k } = this.finalizeNonce(tag(TAGS.nonce, t, px, m));\n        const e = schnorrChallengeFinalize(tag(TAGS.challenge, rx, px, m));\n        const sig = this.finalizeSig(R, k, e, d);\n        if (!schnorrVerifySync(sig, m, px))\n            this.error();\n        return sig;\n    }\n}\nasync function schnorrSign(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calc();\n}\nfunction schnorrSignSync(msg, privKey, auxRand) {\n    return new InternalSchnorrSignature(msg, privKey, auxRand).calcSync();\n}\nfunction initSchnorrVerify(signature, message, publicKey) {\n    const raw = signature instanceof SchnorrSignature;\n    const sig = raw ? signature : SchnorrSignature.fromHex(signature);\n    if (raw)\n        sig.assertValidity();\n    return {\n        ...sig,\n        m: ensureBytes(message),\n        P: normalizePublicKey(publicKey),\n    };\n}\nfunction finalizeSchnorrVerify(r, P, s, e) {\n    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));\n    if (!R || !R.hasEvenY() || R.x !== r)\n        return false;\n    return true;\n}\nasync function schnorrVerify(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        return false;\n    }\n}\nfunction schnorrVerifySync(signature, message, publicKey) {\n    try {\n        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);\n        const e = schnorrChallengeFinalize(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));\n        return finalizeSchnorrVerify(r, P, s, e);\n    }\n    catch (error) {\n        if (error instanceof ShaError)\n            throw error;\n        return false;\n    }\n}\nexports.schnorr = {\n    Signature: SchnorrSignature,\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    signSync: schnorrSignSync,\n    verifySync: schnorrVerifySync,\n};\nPoint.BASE._setWindowSize(8);\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nconst TAGS = {\n    challenge: 'BIP0340/challenge',\n    aux: 'BIP0340/aux',\n    nonce: 'BIP0340/nonce',\n};\nconst TAGGED_HASH_PREFIXES = {};\nexports.utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    mod,\n    invert,\n    isValidPrivateKey(privateKey) {\n        try {\n            normalizePrivateKey(privateKey);\n            return true;\n        }\n        catch (error) {\n            return false;\n        }\n    },\n    _bigintTo32Bytes: numTo32b,\n    _normalizePrivateKey: normalizePrivateKey,\n    hashToPrivateKey: (hash) => {\n        hash = ensureBytes(hash);\n        const minLen = groupLen + 8;\n        if (hash.length < minLen || hash.length > 1024) {\n            throw new Error(`Expected valid bytes of private key as per FIPS 186`);\n        }\n        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;\n        return numTo32b(num);\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return Uint8Array.from(randomBytes(bytesLength));\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => exports.utils.hashToPrivateKey(exports.utils.randomBytes(groupLen + 8)),\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point === Point.BASE ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_3n);\n        return cached;\n    },\n    sha256: async (...messages) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHash } = crypto.node;\n            const hash = createHash('sha256');\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha256 function\");\n        }\n    },\n    hmacSha256: async (key, ...messages) => {\n        if (crypto.web) {\n            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);\n            const message = concatBytes(...messages);\n            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            const { createHmac } = crypto.node;\n            const hash = createHmac('sha256', key);\n            messages.forEach((m) => hash.update(m));\n            return Uint8Array.from(hash.digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have hmac-sha256 function\");\n        }\n    },\n    sha256Sync: undefined,\n    hmacSha256Sync: undefined,\n    taggedHash: async (tag, ...messages) => {\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return exports.utils.sha256(tagP, ...messages);\n    },\n    taggedHashSync: (tag, ...messages) => {\n        if (typeof _sha256Sync !== 'function')\n            throw new ShaError('sha256Sync is undefined, you need to set it');\n        let tagP = TAGGED_HASH_PREFIXES[tag];\n        if (tagP === undefined) {\n            const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n            tagP = concatBytes(tagH, tagH);\n            TAGGED_HASH_PREFIXES[tag] = tagP;\n        }\n        return _sha256Sync(tagP, ...messages);\n    },\n    _JacobianPoint: JacobianPoint,\n};\nObject.defineProperties(exports.utils, {\n    sha256Sync: {\n        configurable: false,\n        get() {\n            return _sha256Sync;\n        },\n        set(val) {\n            if (!_sha256Sync)\n                _sha256Sync = val;\n        },\n    },\n    hmacSha256Sync: {\n        configurable: false,\n        get() {\n            return _hmacSha256Sync;\n        },\n        set(val) {\n            if (!_hmacSha256Sync)\n                _hmacSha256Sync = val;\n        },\n    },\n});\n"],"names":["necc","require","hmac","sha256","_interopNamespaceDefault","e","n","Object","create","keys","forEach","k","d","getOwnPropertyDescriptor","defineProperty","get","enumerable","default","freeze","necc__namespace","THROW_BAD_PRIVATE","THROW_BAD_POINT","THROW_BAD_TWEAK","THROW_BAD_SIGNATURE","THROW_BAD_EXTRA_DATA","THROW_BAD_SCALAR","utils","hmacSha256Sync","key","msgs","concatBytes","sha256Sync","normalizePrivateKey","_normalizePrivateKey","HASH_SIZE","TWEAK_SIZE","BN32_N","Uint8Array","EXTRA_DATA_SIZE","BN32_ZERO","BN32_P_MINUS_N","cmpBN32","data1","data2","i","isZero","x","isTweak","tweak","length","isSignature","signature","subarray","isSigrLessThanPMinusN","isHash","h","isExtraData","undefined","hexToNumber","hex","TypeError","BigInt","normalizeScalar","scalar","num","Number","isSafeInteger","Error","bytes","bytesToHex","_pointAddScalar","p","isCompressed","P","Point","fromHex","t","Q","BASE","multiplyAndAddUnsafe","toRawBytes","assumeCompression","compressed","isPointCompressed","throwToNull","fn","_isPoint","xOnly","isPoint","isPrivate","isValidPrivateKey","isXOnlyPoint","xOnlyPointFromPoint","slice","pointFromScalar","sk","getPublicKey","exports","pointAdd","a","b","A","B","equals","negate","add","pointAddScalar","pointCompress","pointMultiply","_pointMultiply","multiply","privateAdd","_privateAdd","privateKey","_bigintTo32Bytes","mod","CURVE","privateNegate","not","_privateNegate","privateSub","_privateSub","sub","recover","recoveryId","isSignatureNonzeroRS","recoverPublicKey","sign","signSync","der","extraEntropy","signRecoverable","recovered","signSchnorr","Buffer","alloc","schnorr","verify","strict","verifySchnorr","verifySync","xOnlyPointAddTweak","parity","xOnlyPubkey","xOnlyPointFromScalar","value","getSharedSecret","Signature","nodeCrypto","_0n","_1n","_2n","_3n","_8n","Gx","Gy","beta","divNearest","endo","splitScalar","a1","b1","a2","b2","POW_2_128","c1","c2","k1","k2","k1neg","k2neg","fieldLen","groupLen","compressedLen","uncompressedLen","weierstrass","x2","x3","USE_ENDOMORPHISM","ShaError","constructor","message","super","assertJacPoint","other","JacobianPoint","y","z","this","fromAffine","ZERO","toAffineBatch","points","toInv","nums","scratch","Array","inverted","invert","reduce","acc","reduceRight","invertBatch","map","toAffine","normalizeZ","X1","Y1","Z1","X2","Y2","Z2","Z1Z1","Z2Z2","U1","U2","S1","S2","double","C","x1b","D","E","F","X3","Y3","Z3","H","r","HH","HHH","V","subtract","multiplyUnsafe","P0","k1p","k2p","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","_WINDOW_SIZE","precomputes","pointPrecomputes","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","offset1","offset2","Math","abs","cond1","cond2","constTimeNegate","point","fake","f1p","f2p","invZ","is0","iz1","iz2","iz3","ax","ay","zz","condition","item","neg","WeakMap","_setWindowSize","delete","hasEvenY","fromCompressedHex","isShort","bytesToNumber","isValidFieldElement","_6n","_11n","_22n","_23n","_44n","_88n","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","rt","sqrtMod","isYOdd","assertValidity","fromUncompressedHex","ensureBytes","len","header","fromPrivateKey","fromSignature","msgHash","recovery","s","normalizeSignature","includes","truncateHash","radj","rinv","u1","u2","prefix","R","numTo32bStr","hexToBytes","toHex","toHexX","toRawX","msg","left","aP","bQ","sum","sliceDER","parseInt","parseDERInt","data","res","fromCompact","arr","name","str","fromDER","sBytes","rBytesLeft","parseDERSignature","isWithinCurveOrder","hasHighS","HALF","normalizeS","toDERRawBytes","toDERHex","sHex","numberToHexUnpadded","rHex","sHexL","rHexL","sLen","rLen","toCompactRawBytes","toCompactHex","arrays","every","result","pad","hexes","from","v","toString","padStart","uint8a","POW_2_256","numTo32b","array","j","hexByte","byte","isNaN","power","number","modulo","u","q","m","hash","truncateOnly","delta","bits2int_2","_sha256Sync","_hmacSha256Sync","HmacDrbg","hashLen","qByteLen","fill","counter","values","hmacSha256","hmacSync","checkSync","incr","reseed","seed","reseedSync","generate","out","sl","generateSync","kmdToSig","kBytes","lowS","kinv","sig","normalizePublicKey","publicKey","error","isProbPub","bits2int","bits2octets","z1","z2","int2octets","initSigArgs","h1","seedArgs","randomBytes","finalizeSig","recSig","opts","assign","canonical","hashed","privateA","publicB","async","privKey","drbg","vopts","schnorrChallengeFinalize","ch","sinv","SchnorrSignature","InternalSchnorrSignature","auxRand","getScalar","px","rand","priv","initNonce","t0h","finalizeNonce","k0h","k0","rx","calc","tag","taggedHash","TAGS","aux","nonce","challenge","schnorrVerify","calcSync","taggedHashSync","schnorrVerifySync","initSchnorrVerify","raw","finalizeSchnorrVerify","crypto","node","web","self","TAGGED_HASH_PREFIXES","hashToPrivateKey","minLen","bytesLength","getRandomValues","randomPrivateKey","precompute","cached","messages","buffer","subtle","digest","createHash","update","ckey","importKey","createHmac","tagP","tagH","c","charCodeAt","_JacobianPoint","defineProperties","configurable","val"],"sourceRoot":""}