{"version":3,"file":"static/js/435.d8699759.chunk.js","mappings":"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","sources":["../node_modules/@ledgerhq/hw-app-btc/src/bip32.ts","../node_modules/@ledgerhq/hw-app-btc/src/buffertools.ts","../node_modules/@ledgerhq/hw-app-btc/src/constants.ts","../node_modules/@ledgerhq/hw-app-btc/src/hashPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/accounttype.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkle.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/policy.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtv2.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtFinalizer.ts","../node_modules/@ledgerhq/hw-app-btc/src/varint.ts","../node_modules/@ledgerhq/hw-app-btc/src/serializeTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/BtcNew.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/psbtExtractor.ts","../node_modules/@ledgerhq/hw-app-btc/src/getWalletPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/getTrustedInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/startUntrustedHashTransactionInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/getTrustedInputBIP143.ts","../node_modules/@ledgerhq/hw-app-btc/src/compressPublicKey.ts","../node_modules/@ledgerhq/hw-app-btc/src/signTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/finalizeInput.ts","../node_modules/@ledgerhq/hw-app-btc/src/getAppAndVersion.ts","../node_modules/@ledgerhq/hw-app-btc/src/createTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/shouldUseTrustedInputForSegwit.ts","../node_modules/@ledgerhq/hw-app-btc/src/BtcOld.ts","../node_modules/@ledgerhq/hw-app-btc/src/signMessage.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkleMap.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/merkelizedPsbt.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/clientCommands.ts","../node_modules/@ledgerhq/hw-app-btc/src/newops/appClient.ts","../node_modules/@ledgerhq/hw-app-btc/src/debug.ts","../node_modules/@ledgerhq/hw-app-btc/src/signP2SHTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/src/Btc.ts","../node_modules/@ledgerhq/hw-app-btc/src/splitTransaction.ts","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/address.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/block.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/bufferutils.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/classify.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/crypto.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/ecpair.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/networks.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/embed.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/lazy.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2ms.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2pk.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2pkh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2sh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/payments/p2wsh.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/psbt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script_number.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/script_signature.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/multisig/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/nulldata.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkey/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/pubkeyhash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/scripthash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesscommitment/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnesspubkeyhash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/templates/witnessscripthash/output.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/transaction.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/transaction_builder.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bitcoinjs-lib/src/types.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58check/base.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/bs58check/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/comparator.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/range.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/classes/semver.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/clean.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/cmp.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/coerce.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare-build.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare-loose.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/compare.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/diff.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/eq.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/gt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/gte.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/inc.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/lt.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/lte.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/major.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/minor.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/neq.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/parse.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/patch.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/prerelease.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/rcompare.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/rsort.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/satisfies.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/sort.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/functions/valid.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/index.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/constants.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/debug.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/identifiers.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/lrucache.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/parse-options.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/internal/re.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/gtr.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/intersects.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/ltr.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/max-satisfying.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/min-satisfying.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/min-version.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/outside.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/simplify.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/subset.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/to-comparators.js","../node_modules/@ledgerhq/hw-app-btc/node_modules/semver/ranges/valid.js","../node_modules/@ledgerhq/logs/src/index.ts","../node_modules/bip32-path/index.js","../node_modules/bip32/node_modules/bs58check/base.js","../node_modules/bip32/node_modules/bs58check/index.js","../node_modules/bip32/src/bip32.js","../node_modules/bip32/src/crypto.js","../node_modules/bip32/src/index.js","../node_modules/bitcoin-ops/map.js","../node_modules/invariant/browser.js","../node_modules/pushdata-bitcoin/index.js"],"sourcesContent":["/**\n * @file bip32.ts\n * @description BIP32 Path Handling for Bitcoin Wallets\n *\n * This file provides utility functions to handle BIP32 paths,\n * which are commonly used in hierarchical deterministic (HD) wallets.\n * It includes functions to convert BIP32 paths to and from different formats,\n * extract components from extended public keys (xpubs), and manipulate path elements.\n */\n\nimport bippath from \"bip32-path\";\nimport bs58check from \"bs58check\";\n\nexport function pathElementsToBuffer(paths: number[]): Buffer {\n  const buffer = Buffer.alloc(1 + paths.length * 4);\n  buffer[0] = paths.length;\n  paths.forEach((element, index) => {\n    buffer.writeUInt32BE(element, 1 + 4 * index);\n  });\n  return buffer;\n}\n\nexport function bip32asBuffer(path: string): Buffer {\n  const pathElements = !path ? [] : pathStringToArray(path);\n  return pathElementsToBuffer(pathElements);\n}\n\nexport function pathArrayToString(pathElements: number[]): string {\n  // Limitation: bippath can't handle and empty path. It shouldn't affect us\n  // right now, but might in the future.\n  // TODO: Fix support for empty path.\n  return bippath.fromPathArray(pathElements).toString();\n}\n\nexport function pathStringToArray(path: string): number[] {\n  return bippath.fromString(path).toPathArray();\n}\n\nexport function pubkeyFromXpub(xpub: string): Buffer {\n  const xpubBuf = bs58check.decode(xpub);\n  return xpubBuf.slice(xpubBuf.length - 33);\n}\n\nexport function getXpubComponents(xpub: string): {\n  chaincode: Buffer;\n  pubkey: Buffer;\n  version: number;\n} {\n  const xpubBuf: Buffer = bs58check.decode(xpub);\n  return {\n    chaincode: xpubBuf.slice(13, 13 + 32),\n    pubkey: xpubBuf.slice(xpubBuf.length - 33),\n    version: xpubBuf.readUInt32BE(0),\n  };\n}\n\nexport function hardenedPathOf(pathElements: number[]): number[] {\n  for (let i = pathElements.length - 1; i >= 0; i--) {\n    if (pathElements[i] >= 0x80000000) {\n      return pathElements.slice(0, i + 1);\n    }\n  }\n  return [];\n}\n","import varuint from \"varuint-bitcoin\";\n\nexport function unsafeTo64bitLE(n: number): Buffer {\n  // we want to represent the input as a 8-bytes array\n  if (n > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"Can't convert numbers > MAX_SAFE_INT\");\n  }\n  const byteArray = Buffer.alloc(8, 0);\n  for (let index = 0; index < byteArray.length; index++) {\n    const byte = n & 0xff;\n    byteArray[index] = byte;\n    n = (n - byte) / 256;\n  }\n  return byteArray;\n}\n\nexport function unsafeFrom64bitLE(byteArray: Buffer): number {\n  let value = 0;\n  if (byteArray.length != 8) {\n    throw new Error(\"Expected Bufffer of lenght 8\");\n  }\n  if (byteArray[7] != 0) {\n    throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n  }\n  if (byteArray[6] > 0x1f) {\n    throw new Error(\"Can't encode numbers > MAX_SAFE_INT\");\n  }\n  for (let i = byteArray.length - 1; i >= 0; i--) {\n    value = value * 256 + byteArray[i];\n  }\n  return value;\n}\n\nexport class BufferWriter {\n  private bufs: Buffer[] = [];\n\n  write(alloc: number, fn: (b: Buffer) => void): void {\n    const b = Buffer.alloc(alloc);\n    fn(b);\n    this.bufs.push(b);\n  }\n\n  writeUInt8(i: number): void {\n    this.write(1, b => b.writeUInt8(i, 0));\n  }\n\n  writeInt32(i: number): void {\n    this.write(4, b => b.writeInt32LE(i, 0));\n  }\n\n  writeUInt32(i: number): void {\n    this.write(4, b => b.writeUInt32LE(i, 0));\n  }\n\n  writeUInt64(i: number): void {\n    const bytes = unsafeTo64bitLE(i);\n    this.writeSlice(bytes);\n  }\n\n  writeVarInt(i: number): void {\n    this.bufs.push(varuint.encode(i));\n  }\n\n  writeSlice(slice: Buffer): void {\n    this.bufs.push(Buffer.from(slice));\n  }\n\n  writeVarSlice(slice: Buffer): void {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n\n  buffer(): Buffer {\n    return Buffer.concat(this.bufs);\n  }\n}\n\nexport class BufferReader {\n  constructor(\n    public buffer: Buffer,\n    public offset: number = 0,\n  ) {}\n\n  available(): number {\n    return this.buffer.length - this.offset;\n  }\n\n  readUInt8(): number {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n\n  readInt32(): number {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt32(): number {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  readUInt64(): number {\n    const buf = this.readSlice(8);\n    const n = unsafeFrom64bitLE(buf);\n    return n;\n  }\n\n  readVarInt(): number {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  readSlice(n: number): Buffer {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error(\"Cannot read slice out of bounds\");\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n\n  readVarSlice(): Buffer {\n    return this.readSlice(this.readVarInt());\n  }\n\n  readVector(): Buffer[] {\n    const count = this.readVarInt();\n    const vector: Buffer[] = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\n","// the maximum number of bytes allowed in a single chunk when processing bitcoin script data.\n// if the Bitcoin script is too large, we will process it in several chunks.\nexport const MAX_SCRIPT_BLOCK = 50;\nexport const DEFAULT_VERSION = 1;\nexport const DEFAULT_LOCKTIME = 0;\n// input sequence for non-rbf transactions\nexport const DEFAULT_SEQUENCE = 0xffffffff;\n// SIGHASH flags(Sign all inputs and outputs)\n// refer to https://wiki.bitcoinsv.io/index.php/SIGHASH_flags for more details\nexport const SIGHASH_ALL = 1;\n// refer to https://en.bitcoin.it/wiki/Script for Opcodes(OP_DUP, OP_HASH160...) that are used in bitcoin script\nexport const OP_DUP = 0x76;\nexport const OP_HASH160 = 0xa9;\nexport const HASH_SIZE = 0x14;\nexport const OP_EQUAL = 0x87;\nexport const OP_EQUALVERIFY = 0x88;\nexport const OP_CHECKSIG = 0xac;\nexport const OP_RETURN = 0x6a;\n","import RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nexport function hashPublicKey(buffer: Buffer): Buffer {\n  return new RIPEMD160().update(sha(\"sha256\").update(buffer).digest()).digest();\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pointAddScalar } from \"tiny-secp256k1\";\nimport { BufferWriter } from \"../buffertools\";\nimport { HASH_SIZE, OP_CHECKSIG, OP_DUP, OP_EQUAL, OP_EQUALVERIFY, OP_HASH160 } from \"../constants\";\nimport { hashPublicKey } from \"../hashPublicKey\";\nimport { DefaultDescriptorTemplate } from \"./policy\";\nimport { PsbtV2 } from \"./psbtv2\";\n\nexport type SpendingCondition = {\n  scriptPubKey: Buffer;\n  redeemScript?: Buffer;\n  // Possible future extension:\n  // witnessScript?: Buffer; // For p2wsh witnessScript\n  // tapScript?: {tapPath: Buffer[], script: Buffer} // For taproot\n};\n\nexport type SpentOutput = { cond: SpendingCondition; amount: Buffer };\n\n/**\n * Encapsulates differences between account types, for example p2wpkh,\n * p2wpkhWrapped, p2tr.\n */\nexport interface AccountType {\n  /**\n   * Generates a scriptPubKey (output script) from a list of public keys. If a\n   * p2sh redeemScript or a p2wsh witnessScript is needed it will also be set on\n   * the returned SpendingCondition.\n   *\n   * The pubkeys are expected to be 33 byte ecdsa compressed pubkeys.\n   */\n  spendingCondition(pubkeys: Buffer[]): SpendingCondition;\n\n  /**\n   * Populates the psbt with account type-specific data for an input.\n   * @param i The index of the input map to populate\n   * @param inputTx The full transaction containing the spent output. This may\n   * be omitted for taproot.\n   * @param spentOutput The amount and spending condition of the spent output\n   * @param pubkeys The 33 byte ecdsa compressed public keys involved in the input\n   * @param pathElems The paths corresponding to the pubkeys, in same order.\n   */\n  setInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkeys: Buffer[],\n    pathElems: number[][],\n  ): void;\n\n  /**\n   * Populates the psbt with account type-specific data for an output. This is typically\n   * done for change outputs and other outputs that goes to the same account as\n   * being spent from.\n   * @param i The index of the output map to populate\n   * @param cond The spending condition for this output\n   * @param pubkeys The 33 byte ecdsa compressed public keys involved in this output\n   * @param paths The paths corresponding to the pubkeys, in same order.\n   */\n  setOwnOutput(i: number, cond: SpendingCondition, pubkeys: Buffer[], paths: number[][]): void;\n\n  /**\n   * Returns the descriptor template for this account type. Currently only\n   * DefaultDescriptorTemplates are allowed, but that might be changed in the\n   * future. See class WalletPolicy for more information on descriptor\n   * templates.\n   */\n  getDescriptorTemplate(): DefaultDescriptorTemplate;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface BaseAccount extends AccountType {}\n\nabstract class BaseAccount implements AccountType {\n  constructor(\n    protected psbt: PsbtV2,\n    protected masterFp: Buffer,\n  ) {}\n}\n\n/**\n * Superclass for single signature accounts. This will make sure that the pubkey\n * arrays and path arrays in the method arguments contains exactly one element\n * and calls an abstract method to do the actual work.\n */\nabstract class SingleKeyAccount extends BaseAccount {\n  spendingCondition(pubkeys: Buffer[]): SpendingCondition {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    return this.singleKeyCondition(pubkeys[0]);\n  }\n  protected abstract singleKeyCondition(pubkey: Buffer): SpendingCondition;\n\n  setInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkeys: Buffer[],\n    pathElems: number[][],\n  ) {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    if (pathElems.length != 1) {\n      throw new Error(\"Expected single path, got \" + pathElems.length);\n    }\n    this.setSingleKeyInput(i, inputTx, spentOutput, pubkeys[0], pathElems[0]);\n  }\n  protected abstract setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  );\n\n  setOwnOutput(i: number, cond: SpendingCondition, pubkeys: Buffer[], paths: number[][]) {\n    if (pubkeys.length != 1) {\n      throw new Error(\"Expected single key, got \" + pubkeys.length);\n    }\n    if (paths.length != 1) {\n      throw new Error(\"Expected single path, got \" + paths.length);\n    }\n    this.setSingleKeyOutput(i, cond, pubkeys[0], paths[0]);\n  }\n  protected abstract setSingleKeyOutput(\n    i: number,\n    cond: SpendingCondition,\n    pubkey: Buffer,\n    path: number[],\n  );\n}\n\nexport class p2pkh extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const pubkeyHash = hashPublicKey(pubkey);\n    buf.writeSlice(Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]));\n    buf.writeSlice(pubkeyHash);\n    buf.writeSlice(Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]));\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    _spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"pkh(@0)\";\n  }\n}\n\nexport class p2tr extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const xonlyPubkey = pubkey.slice(1); // x-only pubkey\n    const buf = new BufferWriter();\n    const outputKey = this.getTaprootOutputKey(xonlyPubkey);\n    buf.writeSlice(Buffer.from([0x51, 32])); // push1, pubkeylen\n    buf.writeSlice(outputKey);\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    _inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    const xonly = pubkey.slice(1);\n    this.psbt.setInputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    const xonly = pubkey.slice(1);\n    this.psbt.setOutputTapBip32Derivation(i, xonly, [], this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"tr(@0)\";\n  }\n\n  /*\n  The following two functions are copied from wallet-btc and adapted.\n  They should be moved to a library to avoid code reuse.\n  */\n  private hashTapTweak(x: Buffer): Buffer {\n    // hash_tag(x) = SHA256(SHA256(tag) || SHA256(tag) || x), see BIP340\n    // See https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification\n    const h = crypto.sha256(Buffer.from(\"TapTweak\", \"utf-8\"));\n    return crypto.sha256(Buffer.concat([h, h, x]));\n  }\n\n  /**\n   * Calculates a taproot output key from an internal key. This output key will be\n   * used as witness program in a taproot output. The internal key is tweaked\n   * according to recommendation in BIP341:\n   * https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_ref-22-0\n   *\n   * @param internalPubkey A 32 byte x-only taproot internal key\n   * @returns The output key\n   */\n  getTaprootOutputKey(internalPubkey: Buffer): Buffer {\n    if (internalPubkey.length != 32) {\n      throw new Error(\"Expected 32 byte pubkey. Got \" + internalPubkey.length);\n    }\n    // A BIP32 derived key can be converted to a schnorr pubkey by dropping\n    // the first byte, which represent the oddness/evenness. In schnorr all\n    // pubkeys are even.\n    // https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#public-key-conversion\n    const evenEcdsaPubkey = Buffer.concat([Buffer.from([0x02]), internalPubkey]);\n    const tweak = this.hashTapTweak(internalPubkey);\n\n    // Q = P + int(hash_TapTweak(bytes(P)))G\n    const outputEcdsaKey = Buffer.from(pointAddScalar(evenEcdsaPubkey, tweak));\n    // Convert to schnorr.\n    const outputSchnorrKey = outputEcdsaKey.slice(1);\n    // Create address\n    return outputSchnorrKey;\n  }\n}\n\nexport class p2wpkhWrapped extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const redeemScript = this.createRedeemScript(pubkey);\n    const scriptHash = hashPublicKey(redeemScript);\n    buf.writeSlice(Buffer.from([OP_HASH160, HASH_SIZE]));\n    buf.writeSlice(scriptHash);\n    buf.writeUInt8(OP_EQUAL);\n    return { scriptPubKey: buf.buffer(), redeemScript: redeemScript };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n\n    const userSuppliedRedeemScript = spentOutput.cond.redeemScript;\n    const expectedRedeemScript = this.createRedeemScript(pubkey);\n    if (userSuppliedRedeemScript && !expectedRedeemScript.equals(userSuppliedRedeemScript)) {\n      // At what point might a user set the redeemScript on its own?\n      throw new Error(`User-supplied redeemScript ${userSuppliedRedeemScript.toString(\n        \"hex\",\n      )} doesn't\n       match expected ${expectedRedeemScript.toString(\"hex\")} for input ${i}`);\n    }\n    this.psbt.setInputRedeemScript(i, expectedRedeemScript);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputRedeemScript(i, cond.redeemScript!);\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"sh(wpkh(@0))\";\n  }\n\n  private createRedeemScript(pubkey: Buffer): Buffer {\n    const pubkeyHash = hashPublicKey(pubkey);\n    return Buffer.concat([Buffer.from(\"0014\", \"hex\"), pubkeyHash]);\n  }\n}\n\nexport class p2wpkh extends SingleKeyAccount {\n  singleKeyCondition(pubkey: Buffer): SpendingCondition {\n    const buf = new BufferWriter();\n    const pubkeyHash = hashPublicKey(pubkey);\n    buf.writeSlice(Buffer.from([0, HASH_SIZE]));\n    buf.writeSlice(pubkeyHash);\n    return { scriptPubKey: buf.buffer() };\n  }\n\n  setSingleKeyInput(\n    i: number,\n    inputTx: Buffer | undefined,\n    spentOutput: SpentOutput,\n    pubkey: Buffer,\n    path: number[],\n  ) {\n    if (!inputTx) {\n      throw new Error(\"Full input base transaction required\");\n    }\n    this.psbt.setInputNonWitnessUtxo(i, inputTx);\n    this.psbt.setInputBip32Derivation(i, pubkey, this.masterFp, path);\n    this.psbt.setInputWitnessUtxo(i, spentOutput.amount, spentOutput.cond.scriptPubKey);\n  }\n\n  setSingleKeyOutput(i: number, cond: SpendingCondition, pubkey: Buffer, path: number[]) {\n    this.psbt.setOutputBip32Derivation(i, pubkey, this.masterFp, path);\n  }\n\n  getDescriptorTemplate(): DefaultDescriptorTemplate {\n    return \"wpkh(@0)\";\n  }\n}\n","import { crypto } from \"bitcoinjs-lib\";\n\n/**\n * This class implements the merkle tree used by Ledger Bitcoin app v2+,\n * which is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md\n */\nexport class Merkle {\n  private leaves: Buffer[];\n  private rootNode: Node;\n  private leafNodes: Node[];\n  private h: (buf: Buffer) => Buffer;\n  constructor(leaves: Buffer[], hasher: (buf: Buffer) => Buffer = crypto.sha256) {\n    this.leaves = leaves;\n    this.h = hasher;\n    const nodes = this.calculateRoot(leaves);\n    this.rootNode = nodes.root;\n    this.leafNodes = nodes.leaves;\n  }\n  getRoot(): Buffer {\n    return this.rootNode.hash;\n  }\n  size(): number {\n    return this.leaves.length;\n  }\n  getLeaves(): Buffer[] {\n    return this.leaves;\n  }\n  getLeafHash(index: number): Buffer {\n    return this.leafNodes[index].hash;\n  }\n  getProof(index: number): Buffer[] {\n    if (index >= this.leaves.length) throw Error(\"Index out of bounds\");\n    return proveNode(this.leafNodes[index]);\n  }\n\n  calculateRoot(leaves: Buffer[]): { root: Node; leaves: Node[] } {\n    const n = leaves.length;\n    if (n == 0) {\n      return {\n        root: new Node(undefined, undefined, Buffer.alloc(32, 0)),\n        leaves: [],\n      };\n    }\n    if (n == 1) {\n      const newNode = new Node(undefined, undefined, leaves[0]);\n      return { root: newNode, leaves: [newNode] };\n    }\n    const leftCount = highestPowerOf2LessThan(n);\n    const leftBranch = this.calculateRoot(leaves.slice(0, leftCount));\n    const rightBranch = this.calculateRoot(leaves.slice(leftCount));\n    const leftChild = leftBranch.root;\n    const rightChild = rightBranch.root;\n    const hash = this.hashNode(leftChild.hash, rightChild.hash);\n    const node = new Node(leftChild, rightChild, hash);\n    leftChild.parent = node;\n    rightChild.parent = node;\n    return { root: node, leaves: leftBranch.leaves.concat(rightBranch.leaves) };\n  }\n\n  hashNode(left: Buffer, right: Buffer): Buffer {\n    return this.h(Buffer.concat([Buffer.from([1]), left, right]));\n  }\n}\n\nexport function hashLeaf(\n  buf: Buffer,\n  hashFunction: (buf: Buffer) => Buffer = crypto.sha256,\n): Buffer {\n  return hashConcat(Buffer.from([0]), buf, hashFunction);\n}\n\nfunction hashConcat(bufA: Buffer, bufB: Buffer, hashFunction: (buf: Buffer) => Buffer): Buffer {\n  return hashFunction(Buffer.concat([bufA, bufB]));\n}\n\nclass Node {\n  leftChild?: Node;\n  rightChild?: Node;\n  parent?: Node;\n  hash: Buffer;\n  constructor(left: Node | undefined, right: Node | undefined, hash: Buffer) {\n    this.leftChild = left;\n    this.rightChild = right;\n    this.hash = hash;\n  }\n  isLeaf(): boolean {\n    return this.leftChild == undefined;\n  }\n}\n\nfunction proveNode(node: Node): Buffer[] {\n  if (!node.parent) {\n    return [];\n  }\n  if (node.parent.leftChild == node) {\n    if (!node.parent.rightChild) {\n      throw new Error(\"Expected right child to exist\");\n    }\n    return [node.parent.rightChild.hash, ...proveNode(node.parent)];\n  } else {\n    if (!node.parent.leftChild) {\n      throw new Error(\"Expected left child to exist\");\n    }\n    return [node.parent.leftChild.hash, ...proveNode(node.parent)];\n  }\n}\n\nfunction highestPowerOf2LessThan(n: number) {\n  if (n < 2) {\n    throw Error(\"Expected n >= 2\");\n  }\n  if (isPowerOf2(n)) {\n    return n / 2;\n  }\n  return 1 << Math.floor(Math.log2(n));\n}\n\nfunction isPowerOf2(n: number): boolean {\n  return (n & (n - 1)) == 0;\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pathArrayToString } from \"../bip32\";\nimport { BufferWriter } from \"../buffertools\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\nexport type DefaultDescriptorTemplate = \"pkh(@0)\" | \"sh(wpkh(@0))\" | \"wpkh(@0)\" | \"tr(@0)\";\n\n/**\n * The Bitcon hardware app uses a descriptors-like thing to describe\n * how to construct output scripts from keys. A \"Wallet Policy\" consists\n * of a \"Descriptor Template\" and a list of \"keys\". A key is basically\n * a serialized BIP32 extended public key with some added derivation path\n * information. This is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/wallet.md\n */\nexport class WalletPolicy {\n  descriptorTemplate: string;\n  keys: string[];\n  /**\n   * For now, we only support default descriptor templates.\n   */\n  constructor(descriptorTemplate: DefaultDescriptorTemplate, key: string) {\n    this.descriptorTemplate = descriptorTemplate;\n    this.keys = [key];\n  }\n\n  getWalletId(): Buffer {\n    // wallet_id (sha256 of the wallet serialization),\n    return crypto.sha256(this.serialize());\n  }\n\n  serialize(): Buffer {\n    const keyBuffers = this.keys.map(k => {\n      return Buffer.from(k, \"ascii\");\n    });\n    const m = new Merkle(keyBuffers.map(k => hashLeaf(k)));\n\n    const buf = new BufferWriter();\n    buf.writeUInt8(0x01); // wallet type (policy map)\n    buf.writeUInt8(0); // length of wallet name (empty string for default wallets)\n    buf.writeVarSlice(Buffer.from(this.descriptorTemplate, \"ascii\"));\n    buf.writeVarInt(this.keys.length), buf.writeSlice(m.getRoot());\n    return buf.buffer();\n  }\n}\n\nexport function createKey(masterFingerprint: Buffer, path: number[], xpub: string): string {\n  const accountPath = pathArrayToString(path);\n  return `[${masterFingerprint.toString(\"hex\")}${accountPath.substring(1)}]${xpub}/**`;\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { BufferReader, BufferWriter, unsafeFrom64bitLE, unsafeTo64bitLE } from \"../buffertools\";\n\nexport enum psbtGlobal {\n  TX_VERSION = 0x02,\n  FALLBACK_LOCKTIME = 0x03,\n  INPUT_COUNT = 0x04,\n  OUTPUT_COUNT = 0x05,\n  TX_MODIFIABLE = 0x06,\n  VERSION = 0xfb,\n}\nexport enum psbtIn {\n  NON_WITNESS_UTXO = 0x00,\n  WITNESS_UTXO = 0x01,\n  PARTIAL_SIG = 0x02,\n  SIGHASH_TYPE = 0x03,\n  REDEEM_SCRIPT = 0x04,\n  BIP32_DERIVATION = 0x06,\n  FINAL_SCRIPTSIG = 0x07,\n  FINAL_SCRIPTWITNESS = 0x08,\n  PREVIOUS_TXID = 0x0e,\n  OUTPUT_INDEX = 0x0f,\n  SEQUENCE = 0x10,\n  TAP_KEY_SIG = 0x13,\n  TAP_BIP32_DERIVATION = 0x16,\n}\nexport enum psbtOut {\n  REDEEM_SCRIPT = 0x00,\n  BIP_32_DERIVATION = 0x02,\n  AMOUNT = 0x03,\n  SCRIPT = 0x04,\n  TAP_BIP32_DERIVATION = 0x07,\n}\n\nconst PSBT_MAGIC_BYTES = Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]);\n\nexport class NoSuchEntry extends Error {}\n\n/**\n * Implements Partially Signed Bitcoin Transaction version 2, BIP370, as\n * documented at https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki\n * and https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki\n *\n * A psbt is a data structure that can carry all relevant information about a\n * transaction through all stages of the signing process. From constructing an\n * unsigned transaction to extracting the final serialized transaction ready for\n * broadcast.\n *\n * This implementation is limited to what's needed in ledgerjs to carry out its\n * duties, which means that support for features like multisig or taproot script\n * path spending are not implemented. Specifically, it supports p2pkh,\n * p2wpkhWrappedInP2sh, p2wpkh and p2tr key path spending.\n *\n * This class is made purposefully dumb, so it's easy to add support for\n * complemantary fields as needed in the future.\n */\nexport class PsbtV2 {\n  protected globalMap: Map<string, Buffer> = new Map();\n  protected inputMaps: Map<string, Buffer>[] = [];\n  protected outputMaps: Map<string, Buffer>[] = [];\n\n  setGlobalTxVersion(version: number) {\n    this.setGlobal(psbtGlobal.TX_VERSION, uint32LE(version));\n  }\n  getGlobalTxVersion(): number {\n    return this.getGlobal(psbtGlobal.TX_VERSION).readUInt32LE(0);\n  }\n  setGlobalFallbackLocktime(locktime: number) {\n    this.setGlobal(psbtGlobal.FALLBACK_LOCKTIME, uint32LE(locktime));\n  }\n  getGlobalFallbackLocktime(): number | undefined {\n    return this.getGlobalOptional(psbtGlobal.FALLBACK_LOCKTIME)?.readUInt32LE(0);\n  }\n  setGlobalInputCount(inputCount: number) {\n    this.setGlobal(psbtGlobal.INPUT_COUNT, varint(inputCount));\n  }\n  getGlobalInputCount(): number {\n    return fromVarint(this.getGlobal(psbtGlobal.INPUT_COUNT));\n  }\n  setGlobalOutputCount(outputCount: number) {\n    this.setGlobal(psbtGlobal.OUTPUT_COUNT, varint(outputCount));\n  }\n  getGlobalOutputCount(): number {\n    return fromVarint(this.getGlobal(psbtGlobal.OUTPUT_COUNT));\n  }\n  setGlobalTxModifiable(byte: Buffer) {\n    this.setGlobal(psbtGlobal.TX_MODIFIABLE, byte);\n  }\n  getGlobalTxModifiable(): Buffer | undefined {\n    return this.getGlobalOptional(psbtGlobal.TX_MODIFIABLE);\n  }\n  setGlobalPsbtVersion(psbtVersion: number) {\n    this.setGlobal(psbtGlobal.VERSION, uint32LE(psbtVersion));\n  }\n  getGlobalPsbtVersion(): number {\n    return this.getGlobal(psbtGlobal.VERSION).readUInt32LE(0);\n  }\n\n  setInputNonWitnessUtxo(inputIndex: number, transaction: Buffer) {\n    this.setInput(inputIndex, psbtIn.NON_WITNESS_UTXO, b(), transaction);\n  }\n  getInputNonWitnessUtxo(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.NON_WITNESS_UTXO, b());\n  }\n  setInputWitnessUtxo(inputIndex: number, amount: Buffer, scriptPubKey: Buffer) {\n    const buf = new BufferWriter();\n    buf.writeSlice(amount);\n    buf.writeVarSlice(scriptPubKey);\n    this.setInput(inputIndex, psbtIn.WITNESS_UTXO, b(), buf.buffer());\n  }\n  getInputWitnessUtxo(inputIndex: number): { amount: Buffer; scriptPubKey: Buffer } | undefined {\n    const utxo = this.getInputOptional(inputIndex, psbtIn.WITNESS_UTXO, b());\n    if (!utxo) return undefined;\n    const buf = new BufferReader(utxo);\n    return { amount: buf.readSlice(8), scriptPubKey: buf.readVarSlice() };\n  }\n  setInputPartialSig(inputIndex: number, pubkey: Buffer, signature: Buffer) {\n    this.setInput(inputIndex, psbtIn.PARTIAL_SIG, pubkey, signature);\n  }\n  getInputPartialSig(inputIndex: number, pubkey: Buffer): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.PARTIAL_SIG, pubkey);\n  }\n  setInputSighashType(inputIndex: number, sigHashtype: number) {\n    this.setInput(inputIndex, psbtIn.SIGHASH_TYPE, b(), uint32LE(sigHashtype));\n  }\n  getInputSighashType(inputIndex: number): number | undefined {\n    const result = this.getInputOptional(inputIndex, psbtIn.SIGHASH_TYPE, b());\n    if (!result) return undefined;\n    return result.readUInt32LE(0);\n  }\n  setInputRedeemScript(inputIndex: number, redeemScript: Buffer) {\n    this.setInput(inputIndex, psbtIn.REDEEM_SCRIPT, b(), redeemScript);\n  }\n  getInputRedeemScript(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.REDEEM_SCRIPT, b());\n  }\n  setInputBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    if (pubkey.length != 33) throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n    this.setInput(\n      inputIndex,\n      psbtIn.BIP32_DERIVATION,\n      pubkey,\n      this.encodeBip32Derivation(masterFingerprint, path),\n    );\n  }\n  getInputBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n  ): { masterFingerprint: Buffer; path: number[] } | undefined {\n    const buf = this.getInputOptional(inputIndex, psbtIn.BIP32_DERIVATION, pubkey);\n    if (!buf) return undefined;\n    return this.decodeBip32Derivation(buf);\n  }\n  setInputFinalScriptsig(inputIndex: number, scriptSig: Buffer) {\n    this.setInput(inputIndex, psbtIn.FINAL_SCRIPTSIG, b(), scriptSig);\n  }\n  getInputFinalScriptsig(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.FINAL_SCRIPTSIG, b());\n  }\n  setInputFinalScriptwitness(inputIndex: number, scriptWitness: Buffer) {\n    this.setInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b(), scriptWitness);\n  }\n  getInputFinalScriptwitness(inputIndex: number): Buffer {\n    return this.getInput(inputIndex, psbtIn.FINAL_SCRIPTWITNESS, b());\n  }\n  setInputPreviousTxId(inputIndex: number, txid: Buffer) {\n    this.setInput(inputIndex, psbtIn.PREVIOUS_TXID, b(), txid);\n  }\n  getInputPreviousTxid(inputIndex: number): Buffer {\n    return this.getInput(inputIndex, psbtIn.PREVIOUS_TXID, b());\n  }\n  setInputOutputIndex(inputIndex: number, outputIndex: number) {\n    this.setInput(inputIndex, psbtIn.OUTPUT_INDEX, b(), uint32LE(outputIndex));\n  }\n  getInputOutputIndex(inputIndex: number): number {\n    return this.getInput(inputIndex, psbtIn.OUTPUT_INDEX, b()).readUInt32LE(0);\n  }\n  setInputSequence(inputIndex: number, sequence: number) {\n    this.setInput(inputIndex, psbtIn.SEQUENCE, b(), uint32LE(sequence));\n  }\n  getInputSequence(inputIndex: number): number {\n    return this.getInputOptional(inputIndex, psbtIn.SEQUENCE, b())?.readUInt32LE(0) ?? 0xffffffff;\n  }\n  setInputTapKeySig(inputIndex: number, sig: Buffer) {\n    this.setInput(inputIndex, psbtIn.TAP_KEY_SIG, b(), sig);\n  }\n  getInputTapKeySig(inputIndex: number): Buffer | undefined {\n    return this.getInputOptional(inputIndex, psbtIn.TAP_KEY_SIG, b());\n  }\n  setInputTapBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n    hashes: Buffer[],\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    if (pubkey.length != 32) throw new Error(\"Invalid pubkey length: \" + pubkey.length);\n    const buf = this.encodeTapBip32Derivation(hashes, masterFingerprint, path);\n    this.setInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey, buf);\n  }\n  getInputTapBip32Derivation(\n    inputIndex: number,\n    pubkey: Buffer,\n  ): { hashes: Buffer[]; masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getInput(inputIndex, psbtIn.TAP_BIP32_DERIVATION, pubkey);\n    return this.decodeTapBip32Derivation(buf);\n  }\n  getInputKeyDatas(inputIndex: number, keyType: KeyType): Buffer[] {\n    return this.getKeyDatas(this.inputMaps[inputIndex], keyType);\n  }\n\n  setOutputRedeemScript(outputIndex: number, redeemScript: Buffer) {\n    this.setOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b(), redeemScript);\n  }\n  getOutputRedeemScript(outputIndex: number): Buffer {\n    return this.getOutput(outputIndex, psbtOut.REDEEM_SCRIPT, b());\n  }\n  setOutputBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n    masterFingerprint: Buffer,\n    path: number[],\n  ) {\n    this.setOutput(\n      outputIndex,\n      psbtOut.BIP_32_DERIVATION,\n      pubkey,\n      this.encodeBip32Derivation(masterFingerprint, path),\n    );\n  }\n  getOutputBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n  ): { masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getOutput(outputIndex, psbtOut.BIP_32_DERIVATION, pubkey);\n    return this.decodeBip32Derivation(buf);\n  }\n  setOutputAmount(outputIndex: number, amount: number) {\n    this.setOutput(outputIndex, psbtOut.AMOUNT, b(), uint64LE(amount));\n  }\n  getOutputAmount(outputIndex: number): number {\n    const buf = this.getOutput(outputIndex, psbtOut.AMOUNT, b());\n    return unsafeFrom64bitLE(buf);\n  }\n  setOutputScript(outputIndex: number, scriptPubKey: Buffer) {\n    this.setOutput(outputIndex, psbtOut.SCRIPT, b(), scriptPubKey);\n  }\n  getOutputScript(outputIndex: number): Buffer {\n    return this.getOutput(outputIndex, psbtOut.SCRIPT, b());\n  }\n  setOutputTapBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n    hashes: Buffer[],\n    fingerprint: Buffer,\n    path: number[],\n  ) {\n    const buf = this.encodeTapBip32Derivation(hashes, fingerprint, path);\n    this.setOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey, buf);\n  }\n  getOutputTapBip32Derivation(\n    outputIndex: number,\n    pubkey: Buffer,\n  ): { hashes: Buffer[]; masterFingerprint: Buffer; path: number[] } {\n    const buf = this.getOutput(outputIndex, psbtOut.TAP_BIP32_DERIVATION, pubkey);\n    return this.decodeTapBip32Derivation(buf);\n  }\n\n  deleteInputEntries(inputIndex: number, keyTypes: psbtIn[]) {\n    const map = this.inputMaps[inputIndex];\n    map.forEach((_v, k, m) => {\n      if (this.isKeyType(k, keyTypes)) {\n        m.delete(k);\n      }\n    });\n  }\n\n  copy(to: PsbtV2) {\n    this.copyMap(this.globalMap, to.globalMap);\n    this.copyMaps(this.inputMaps, to.inputMaps);\n    this.copyMaps(this.outputMaps, to.outputMaps);\n  }\n  copyMaps(from: Map<string, Buffer>[], to: Map<string, Buffer>[]) {\n    from.forEach((m, index) => {\n      const to_index = new Map();\n      this.copyMap(m, to_index);\n      to[index] = to_index;\n    });\n  }\n  copyMap(from: Map<string, Buffer>, to: Map<string, Buffer>) {\n    from.forEach((v, k) => to.set(k, Buffer.from(v)));\n  }\n  serialize(): Buffer {\n    const buf = new BufferWriter();\n    buf.writeSlice(Buffer.from([0x70, 0x73, 0x62, 0x74, 0xff]));\n    serializeMap(buf, this.globalMap);\n    this.inputMaps.forEach(map => {\n      serializeMap(buf, map);\n    });\n    this.outputMaps.forEach(map => {\n      serializeMap(buf, map);\n    });\n    return buf.buffer();\n  }\n  deserialize(psbt: Buffer) {\n    const buf = new BufferReader(psbt);\n    if (!buf.readSlice(5).equals(PSBT_MAGIC_BYTES)) {\n      throw new Error(\"Invalid magic bytes\");\n    }\n    while (this.readKeyPair(this.globalMap, buf));\n    for (let i = 0; i < this.getGlobalInputCount(); i++) {\n      this.inputMaps[i] = new Map();\n      while (this.readKeyPair(this.inputMaps[i], buf));\n    }\n    for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n      this.outputMaps[i] = new Map();\n      while (this.readKeyPair(this.outputMaps[i], buf));\n    }\n  }\n  private readKeyPair(map: Map<string, Buffer>, buf: BufferReader): boolean {\n    const keyLen = buf.readVarInt();\n    if (keyLen == 0) {\n      return false;\n    }\n    const keyType = buf.readUInt8();\n    const keyData = buf.readSlice(keyLen - 1);\n    const value = buf.readVarSlice();\n    set(map, keyType, keyData, value);\n    return true;\n  }\n  private getKeyDatas(map: Map<string, Buffer>, keyType: KeyType): Buffer[] {\n    const result: Buffer[] = [];\n    map.forEach((_v, k) => {\n      if (this.isKeyType(k, [keyType])) {\n        result.push(Buffer.from(k.substring(2), \"hex\"));\n      }\n    });\n    return result;\n  }\n  private isKeyType(hexKey: string, keyTypes: KeyType[]): boolean {\n    const keyType = Buffer.from(hexKey.substring(0, 2), \"hex\").readUInt8(0);\n    return keyTypes.some(k => k == keyType);\n  }\n  private setGlobal(keyType: KeyType, value: Buffer) {\n    const key = new Key(keyType, Buffer.from([]));\n    this.globalMap.set(key.toString(), value);\n  }\n  private getGlobal(keyType: KeyType): Buffer {\n    return get(this.globalMap, keyType, b(), false)!;\n  }\n  private getGlobalOptional(keyType: KeyType): Buffer | undefined {\n    return get(this.globalMap, keyType, b(), true);\n  }\n  private setInput(index: number, keyType: KeyType, keyData: Buffer, value: Buffer) {\n    set(this.getMap(index, this.inputMaps), keyType, keyData, value);\n  }\n  private getInput(index: number, keyType: KeyType, keyData: Buffer): Buffer {\n    return get(this.inputMaps[index], keyType, keyData, false)!;\n  }\n  private getInputOptional(index: number, keyType: KeyType, keyData: Buffer): Buffer | undefined {\n    return get(this.inputMaps[index], keyType, keyData, true);\n  }\n  private setOutput(index: number, keyType: KeyType, keyData: Buffer, value: Buffer) {\n    set(this.getMap(index, this.outputMaps), keyType, keyData, value);\n  }\n  private getOutput(index: number, keyType: KeyType, keyData: Buffer): Buffer {\n    return get(this.outputMaps[index], keyType, keyData, false)!;\n  }\n  private getMap(index: number, maps: Map<string, Buffer>[]): Map<string, Buffer> {\n    if (maps[index]) {\n      return maps[index];\n    }\n    return (maps[index] = new Map());\n  }\n  private encodeBip32Derivation(masterFingerprint: Buffer, path: number[]) {\n    const buf = new BufferWriter();\n    this.writeBip32Derivation(buf, masterFingerprint, path);\n    return buf.buffer();\n  }\n  private decodeBip32Derivation(buffer: Buffer): {\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const buf = new BufferReader(buffer);\n    return this.readBip32Derivation(buf);\n  }\n  private writeBip32Derivation(buf: BufferWriter, masterFingerprint: Buffer, path: number[]) {\n    buf.writeSlice(masterFingerprint);\n    path.forEach(element => {\n      buf.writeUInt32(element);\n    });\n  }\n  private readBip32Derivation(buf: BufferReader): {\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const masterFingerprint = buf.readSlice(4);\n    const path: number[] = [];\n    while (buf.offset < buf.buffer.length) {\n      path.push(buf.readUInt32());\n    }\n    return { masterFingerprint, path };\n  }\n  private encodeTapBip32Derivation(\n    hashes: Buffer[],\n    masterFingerprint: Buffer,\n    path: number[],\n  ): Buffer {\n    const buf = new BufferWriter();\n    buf.writeVarInt(hashes.length);\n    hashes.forEach(h => {\n      buf.writeSlice(h);\n    });\n    this.writeBip32Derivation(buf, masterFingerprint, path);\n    return buf.buffer();\n  }\n  private decodeTapBip32Derivation(buffer: Buffer): {\n    hashes: Buffer[];\n    masterFingerprint: Buffer;\n    path: number[];\n  } {\n    const buf = new BufferReader(buffer);\n    const hashCount = buf.readVarInt();\n    const hashes: Buffer[] = [];\n    for (let i = 0; i < hashCount; i++) {\n      hashes.push(buf.readSlice(32));\n    }\n    const deriv = this.readBip32Derivation(buf);\n    return { hashes, ...deriv };\n  }\n}\nfunction get(\n  map: Map<string, Buffer>,\n  keyType: KeyType,\n  keyData: Buffer,\n  acceptUndefined: boolean,\n): Buffer | undefined {\n  if (!map) throw Error(\"No such map\");\n  const key = new Key(keyType, keyData);\n  const value = map.get(key.toString());\n  if (!value) {\n    if (acceptUndefined) {\n      return undefined;\n    }\n    throw new NoSuchEntry(key.toString());\n  }\n  // Make sure to return a copy, to protect the underlying data.\n  return Buffer.from(value);\n}\ntype KeyType = number;\n\nclass Key {\n  keyType: KeyType;\n  keyData: Buffer;\n  constructor(keyType: KeyType, keyData: Buffer) {\n    this.keyType = keyType;\n    this.keyData = keyData;\n  }\n  toString(): string {\n    const buf = new BufferWriter();\n    this.toBuffer(buf);\n    return buf.buffer().toString(\"hex\");\n  }\n  serialize(buf: BufferWriter) {\n    buf.writeVarInt(1 + this.keyData.length);\n    this.toBuffer(buf);\n  }\n  private toBuffer(buf: BufferWriter) {\n    buf.writeUInt8(this.keyType);\n    buf.writeSlice(this.keyData);\n  }\n}\nclass KeyPair {\n  key: Key;\n  value: Buffer;\n  constructor(key: Key, value: Buffer) {\n    this.key = key;\n    this.value = value;\n  }\n  serialize(buf: BufferWriter) {\n    this.key.serialize(buf);\n    buf.writeVarSlice(this.value);\n  }\n}\nfunction createKey(buf: Buffer): Key {\n  return new Key(buf.readUInt8(0), buf.slice(1));\n}\nfunction serializeMap(buf: BufferWriter, map: Map<string, Buffer>) {\n  for (const k of map.keys()) {\n    const value = map.get(k)!;\n    const keyPair = new KeyPair(createKey(Buffer.from(k, \"hex\")), value);\n    keyPair.serialize(buf);\n  }\n  buf.writeUInt8(0);\n}\n\nfunction b(): Buffer {\n  return Buffer.from([]);\n}\nfunction set(map: Map<string, Buffer>, keyType: KeyType, keyData: Buffer, value: Buffer) {\n  const key = new Key(keyType, keyData);\n  map.set(key.toString(), value);\n}\nfunction uint32LE(n: number): Buffer {\n  const b = Buffer.alloc(4);\n  b.writeUInt32LE(n, 0);\n  return b;\n}\nfunction uint64LE(n: number): Buffer {\n  return unsafeTo64bitLE(n);\n}\nfunction varint(n: number): Buffer {\n  const b = new BufferWriter();\n  b.writeVarInt(n);\n  return b.buffer();\n}\nfunction fromVarint(buf: Buffer): number {\n  return new BufferReader(buf).readVarInt();\n}\n","import { BufferWriter } from \"../buffertools\";\nimport { psbtIn, PsbtV2 } from \"./psbtv2\";\n\n/**\n * This roughly implements the \"input finalizer\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki). However\n * the role is documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki).\n *\n * Verify that all inputs have a signature, and set inputFinalScriptwitness\n * and/or inputFinalScriptSig depending on the type of the spent outputs. Clean\n * fields that aren't useful anymore, partial signatures, redeem script and\n * derivation paths.\n *\n * @param psbt The psbt with all signatures added as partial sigs, either\n * through PSBT_IN_PARTIAL_SIG or PSBT_IN_TAP_KEY_SIG\n */\nexport function finalize(psbt: PsbtV2): void {\n  // First check that each input has a signature\n  const inputCount = psbt.getGlobalInputCount();\n  for (let i = 0; i < inputCount; i++) {\n    const legacyPubkeys = psbt.getInputKeyDatas(i, psbtIn.PARTIAL_SIG);\n    const taprootSig = psbt.getInputTapKeySig(i);\n    if (legacyPubkeys.length == 0 && !taprootSig) {\n      throw Error(`No signature for input ${i} present`);\n    }\n    if (legacyPubkeys.length > 0) {\n      if (legacyPubkeys.length > 1) {\n        throw Error(`Expected exactly one signature, got ${legacyPubkeys.length}`);\n      }\n      if (taprootSig) {\n        throw Error(\"Both taproot and non-taproot signatures present.\");\n      }\n\n      const isSegwitV0 = !!psbt.getInputWitnessUtxo(i);\n      const redeemScript = psbt.getInputRedeemScript(i);\n      const isWrappedSegwit = !!redeemScript;\n      const signature = psbt.getInputPartialSig(i, legacyPubkeys[0]);\n      if (!signature) throw new Error(\"Expected partial signature for input \" + i);\n      if (isSegwitV0) {\n        const witnessBuf = new BufferWriter();\n        witnessBuf.writeVarInt(2);\n        witnessBuf.writeVarInt(signature.length);\n        witnessBuf.writeSlice(signature);\n        witnessBuf.writeVarInt(legacyPubkeys[0].length);\n        witnessBuf.writeSlice(legacyPubkeys[0]);\n        psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n        if (isWrappedSegwit) {\n          if (!redeemScript || redeemScript.length == 0) {\n            throw new Error(\"Expected non-empty redeemscript. Can't finalize intput \" + i);\n          }\n          const scriptSigBuf = new BufferWriter();\n          // Push redeemScript length\n          scriptSigBuf.writeUInt8(redeemScript.length);\n          scriptSigBuf.writeSlice(redeemScript);\n          psbt.setInputFinalScriptsig(i, scriptSigBuf.buffer());\n        }\n      } else {\n        // Legacy input\n        const scriptSig = new BufferWriter();\n        writePush(scriptSig, signature);\n        writePush(scriptSig, legacyPubkeys[0]);\n        psbt.setInputFinalScriptsig(i, scriptSig.buffer());\n      }\n    } else {\n      // Taproot input\n      const signature = psbt.getInputTapKeySig(i);\n      if (!signature) {\n        throw Error(\"No taproot signature found\");\n      }\n      if (signature.length != 64 && signature.length != 65) {\n        throw Error(\"Unexpected length of schnorr signature.\");\n      }\n      const witnessBuf = new BufferWriter();\n      witnessBuf.writeVarInt(1);\n      witnessBuf.writeVarSlice(signature);\n      psbt.setInputFinalScriptwitness(i, witnessBuf.buffer());\n    }\n    clearFinalizedInput(psbt, i);\n  }\n}\n\n/**\n * Deletes fields that are no longer neccesary from the psbt.\n *\n * Note, the spec doesn't say anything about removing ouput fields\n * like PSBT_OUT_BIP32_DERIVATION_PATH and others, so we keep them\n * without actually knowing why. I think we should remove them too.\n */\nfunction clearFinalizedInput(psbt: PsbtV2, inputIndex: number) {\n  const keyTypes = [\n    psbtIn.BIP32_DERIVATION,\n    psbtIn.PARTIAL_SIG,\n    psbtIn.TAP_BIP32_DERIVATION,\n    psbtIn.TAP_KEY_SIG,\n  ];\n  const witnessUtxoAvailable = !!psbt.getInputWitnessUtxo(inputIndex);\n  const nonWitnessUtxoAvailable = !!psbt.getInputNonWitnessUtxo(inputIndex);\n  if (witnessUtxoAvailable && nonWitnessUtxoAvailable) {\n    // Remove NON_WITNESS_UTXO for segwit v0 as it's only needed while signing.\n    // Segwit v1 doesn't have NON_WITNESS_UTXO set.\n    // See https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#cite_note-7\n    keyTypes.push(psbtIn.NON_WITNESS_UTXO);\n  }\n  psbt.deleteInputEntries(inputIndex, keyTypes);\n}\n\n/**\n * Writes a script push operation to buf, which looks different\n * depending on the size of the data. See\n * https://en.bitcoin.it/wiki/Script#Constants\n *\n * @param buf the BufferWriter to write to\n * @param data the Buffer to be pushed.\n */\nfunction writePush(buf: BufferWriter, data: Buffer) {\n  if (data.length <= 75) {\n    buf.writeUInt8(data.length);\n  } else if (data.length <= 256) {\n    buf.writeUInt8(76);\n    buf.writeUInt8(data.length);\n  } else if (data.length <= 256 * 256) {\n    buf.writeUInt8(77);\n    const b = Buffer.alloc(2);\n    b.writeUInt16LE(data.length, 0);\n    buf.writeSlice(b);\n  }\n  buf.writeSlice(data);\n}\n","export function getVarint(data: Buffer, offset: number): [number, number] {\n  if (data[offset] < 0xfd) {\n    return [data[offset], 1];\n  }\n\n  if (data[offset] === 0xfd) {\n    return [(data[offset + 2] << 8) + data[offset + 1], 3];\n  }\n\n  if (data[offset] === 0xfe) {\n    return [\n      (data[offset + 4] << 24) +\n        (data[offset + 3] << 16) +\n        (data[offset + 2] << 8) +\n        data[offset + 1],\n      5,\n    ];\n  }\n\n  throw new Error(\"getVarint called with unexpected parameters\");\n}\nexport function createVarint(value: number): Buffer {\n  if (value < 0xfd) {\n    const buffer = Buffer.alloc(1);\n    buffer[0] = value;\n    return buffer;\n  }\n\n  if (value <= 0xffff) {\n    const buffer = Buffer.alloc(3);\n    buffer[0] = 0xfd;\n    buffer[1] = value & 0xff;\n    buffer[2] = (value >> 8) & 0xff;\n    return buffer;\n  }\n\n  const buffer = Buffer.alloc(5);\n  buffer[0] = 0xfe;\n  buffer[1] = value & 0xff;\n  buffer[2] = (value >> 8) & 0xff;\n  buffer[3] = (value >> 16) & 0xff;\n  buffer[4] = (value >> 24) & 0xff;\n  return buffer;\n}\n","import type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\n\n/**\n  @example\nconst tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\nconst outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\nexport function serializeTransactionOutputs({ outputs }: Transaction): Buffer {\n  let outputBuffer = Buffer.alloc(0);\n\n  if (typeof outputs !== \"undefined\") {\n    outputBuffer = Buffer.concat([outputBuffer, createVarint(outputs.length)]);\n    outputs.forEach(output => {\n      outputBuffer = Buffer.concat([\n        outputBuffer,\n        output.amount,\n        createVarint(output.script.length),\n        output.script,\n      ]);\n    });\n  }\n\n  return outputBuffer;\n}\nexport function serializeTransaction(\n  transaction: Transaction,\n  skipWitness: boolean,\n  timestamp?: Buffer,\n  additionals: string[] = [],\n) {\n  const isDecred = additionals.includes(\"decred\");\n  const isZcash = additionals.includes(\"zcash\");\n  const isBech32 = additionals.includes(\"bech32\");\n  let inputBuffer = Buffer.alloc(0);\n  const useWitness = typeof transaction[\"witness\"] != \"undefined\" && !skipWitness;\n  transaction.inputs.forEach(input => {\n    inputBuffer =\n      isDecred || isBech32\n        ? Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            Buffer.from([0x00]), //tree\n            input.sequence,\n          ])\n        : Buffer.concat([\n            inputBuffer,\n            input.prevout,\n            createVarint(input.script.length),\n            input.script,\n            input.sequence,\n          ]);\n  });\n  let outputBuffer = serializeTransactionOutputs(transaction);\n\n  if (typeof transaction.outputs !== \"undefined\" && typeof transaction.locktime !== \"undefined\") {\n    outputBuffer = Buffer.concat([\n      outputBuffer,\n      (useWitness && transaction.witness) || Buffer.alloc(0),\n      transaction.locktime,\n      transaction.nExpiryHeight || Buffer.alloc(0),\n      transaction.extraData || Buffer.alloc(0),\n    ]);\n  }\n  // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n  if (isZcash) {\n    return Buffer.concat([\n      transaction.version,\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      Buffer.from([0xb4, 0xd0, 0xd6, 0xc2]), // Zcash Consensus Branch ID: 0xC2D6D0B4 refer to https://z.cash/upgrade/nu5/\n      transaction.locktime || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n      transaction.nExpiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n      useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n      createVarint(transaction.inputs.length),\n      inputBuffer,\n      outputBuffer,\n    ]);\n  }\n  return Buffer.concat([\n    transaction.version,\n    timestamp ? timestamp : Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    useWitness ? Buffer.from(\"0001\", \"hex\") : Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n    inputBuffer,\n    outputBuffer,\n  ]);\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { pointCompress } from \"tiny-secp256k1\";\nimport {\n  getXpubComponents,\n  hardenedPathOf,\n  pathArrayToString,\n  pathStringToArray,\n  pubkeyFromXpub,\n} from \"./bip32\";\nimport { BufferReader } from \"./buffertools\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport {\n  AccountType,\n  p2pkh,\n  p2tr,\n  p2wpkh,\n  p2wpkhWrapped,\n  SpendingCondition,\n} from \"./newops/accounttype\";\nimport { AppClient as Client } from \"./newops/appClient\";\nimport { createKey, DefaultDescriptorTemplate, WalletPolicy } from \"./newops/policy\";\nimport { extract } from \"./newops/psbtExtractor\";\nimport { finalize } from \"./newops/psbtFinalizer\";\nimport { psbtIn, PsbtV2 } from \"./newops/psbtv2\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport type { Transaction } from \"./types\";\n\n/**\n * @class BtcNew\n * @description This class implements the same interface as BtcOld (formerly\n * named Btc), but interacts with Bitcoin hardware app version 2.1.0+\n * which uses a totally new APDU protocol. This new\n * protocol is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n *\n * Since the interface must remain compatible with BtcOld, the methods\n * of this class are quite clunky, because it needs to adapt legacy\n * input data into the PSBT process. In the future, a new interface should\n * be developed that exposes PSBT to the outer world, which would render\n * a much cleaner implementation.\n *\n */\nexport default class BtcNew {\n  constructor(private client: Client) {}\n\n  /**\n   * This is a new method that allow users to get an xpub at a standard path.\n   * Standard paths are described at\n   * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#description\n   *\n   * This boils down to paths (N=0 for Bitcoin, N=1 for Testnet):\n   * M/44'/N'/x'/**\n   * M/48'/N'/x'/y'/**\n   * M/49'/N'/x'/**\n   * M/84'/N'/x'/**\n   * M/86'/N'/x'/**\n   *\n   * The method was added because of added security in the hardware app v2+. The\n   * new hardware app will allow export of any xpub up to and including the\n   * deepest hardened key of standard derivation paths, whereas the old app\n   * would allow export of any key.\n   *\n   * This caused an issue for callers of this class, who only had\n   * getWalletPublicKey() to call which means they have to constuct xpub\n   * themselves:\n   *\n   * Suppose a user of this class wants to create an account xpub on a standard\n   * path, M/44'/0'/Z'. The user must get the parent key fingerprint (see BIP32)\n   * by requesting the parent key M/44'/0'. The new app won't allow that, because\n   * it only allows exporting deepest level hardened path. So the options are to\n   * allow requesting M/44'/0' from the app, or to add a new function\n   * \"getWalletXpub\".\n   *\n   * We opted for adding a new function, which can greatly simplify client code.\n   */\n  async getWalletXpub({\n    path,\n    xpubVersion,\n  }: {\n    path: string;\n    xpubVersion: number;\n  }): Promise<string> {\n    const pathElements: number[] = pathStringToArray(path);\n    const xpub = await this.client.getExtendedPubkey(false, pathElements);\n    const xpubComponents = getXpubComponents(xpub);\n    if (xpubComponents.version != xpubVersion) {\n      throw new Error(\n        `Expected xpub version ${xpubVersion} doesn't match the xpub version from the device ${xpubComponents.version}`,\n      );\n    }\n    return xpub;\n  }\n\n  /**\n   * This method returns a public key, a bitcoin address, and and a chaincode\n   * for a specific derivation path.\n   *\n   * Limitation: If the path is not a leaf node of a standard path, the address\n   * will be the empty string \"\", see this.getWalletAddress() for details.\n   */\n  async getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    if (!isPathNormal(path)) {\n      throw Error(`non-standard path: ${path}`);\n    }\n    const pathElements: number[] = pathStringToArray(path);\n    const xpub = await this.client.getExtendedPubkey(false, pathElements);\n\n    const display = opts?.verify ?? false;\n\n    const address = await this.getWalletAddress(\n      pathElements,\n      descrTemplFrom(opts?.format ?? \"legacy\"),\n      display,\n    );\n    const components = getXpubComponents(xpub);\n    const uncompressedPubkey = Buffer.from(pointCompress(components.pubkey, false));\n    return {\n      publicKey: uncompressedPubkey.toString(\"hex\"),\n      bitcoinAddress: address,\n      chainCode: components.chaincode.toString(\"hex\"),\n    };\n  }\n\n  /**\n   * Get an address for the specified path.\n   *\n   * If display is true, we must get the address from the device, which would require\n   * us to determine WalletPolicy. This requires two *extra* queries to the device, one\n   * for the account xpub and one for master key fingerprint.\n   *\n   * If display is false we *could* generate the address ourselves, but chose to\n   * get it from the device to save development time. However, it shouldn't take\n   * too much time to implement local address generation.\n   *\n   * Moreover, if the path is not for a leaf, ie accountPath+/X/Y, there is no\n   * way to get the address from the device. In this case we have to create it\n   * ourselves, but we don't at this time, and instead return an empty (\"\") address.\n   */\n  private async getWalletAddress(\n    pathElements: number[],\n    descrTempl: DefaultDescriptorTemplate,\n    display: boolean,\n  ): Promise<string> {\n    const accountPath = hardenedPathOf(pathElements);\n    if (accountPath.length + 2 != pathElements.length) {\n      return \"\";\n    }\n    const accountXpub = await this.client.getExtendedPubkey(false, accountPath);\n    const masterFingerprint = await this.client.getMasterFingerprint();\n    const policy = new WalletPolicy(\n      descrTempl,\n      createKey(masterFingerprint, accountPath, accountXpub),\n    );\n    const changeAndIndex = pathElements.slice(-2, pathElements.length);\n    return this.client.getWalletAddress(\n      policy,\n      Buffer.alloc(32, 0),\n      changeAndIndex[0],\n      changeAndIndex[1],\n      display,\n    );\n  }\n\n  /**\n   * Build and sign a transaction. See Btc.createPaymentTransaction for\n   * details on how to use this method.\n   *\n   * This method will convert the legacy arguments, CreateTransactionArg, into\n   * a psbt which is finally signed and finalized, and the extracted fully signed\n   * transaction is returned.\n   */\n  async createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    const inputCount = arg.inputs.length;\n    if (inputCount == 0) {\n      throw Error(\"No inputs\");\n    }\n    const psbt = new PsbtV2();\n    // The master fingerprint is needed when adding BIP32 derivation paths on\n    // the psbt.\n    const masterFp = await this.client.getMasterFingerprint();\n\n    const accountType = accountTypeFromArg(arg, psbt, masterFp);\n\n    if (arg.lockTime != undefined) {\n      // The signer will assume locktime 0 if unset\n      psbt.setGlobalFallbackLocktime(arg.lockTime);\n    }\n    psbt.setGlobalInputCount(inputCount);\n    psbt.setGlobalPsbtVersion(2);\n    psbt.setGlobalTxVersion(2);\n\n    let notifyCount = 0;\n    const progress = () => {\n      if (!arg.onDeviceStreaming) return;\n      arg.onDeviceStreaming({\n        total: 2 * inputCount,\n        index: notifyCount,\n        progress: ++notifyCount / (2 * inputCount),\n      });\n    };\n\n    let accountXpub = \"\";\n    let accountPath: number[] = [];\n    for (let i = 0; i < inputCount; i++) {\n      progress();\n      const pathElems: number[] = pathStringToArray(arg.associatedKeysets[i]);\n      if (accountXpub == \"\") {\n        // We assume all inputs belong to the same account so we set\n        // the account xpub and path based on the first input.\n        accountPath = pathElems.slice(0, -2);\n        accountXpub = await this.client.getExtendedPubkey(false, accountPath);\n      }\n      await this.setInput(\n        psbt,\n        i,\n        arg.inputs[i],\n        pathElems,\n        accountType,\n        masterFp,\n        arg.sigHashType,\n      );\n    }\n\n    const outputsConcat = Buffer.from(arg.outputScriptHex, \"hex\");\n    const outputsBufferReader = new BufferReader(outputsConcat);\n    const outputCount = outputsBufferReader.readVarInt();\n    psbt.setGlobalOutputCount(outputCount);\n    const changeData = await this.outputScriptAt(accountPath, accountType, arg.changePath);\n    // If the caller supplied a changePath, we must make sure there actually is\n    // a change output. If no change output found, we'll throw an error.\n    let changeFound = !changeData;\n    for (let i = 0; i < outputCount; i++) {\n      const amount = Number(outputsBufferReader.readUInt64());\n      const outputScript = outputsBufferReader.readVarSlice();\n      psbt.setOutputAmount(i, amount);\n      psbt.setOutputScript(i, outputScript);\n\n      // We won't know if we're paying to ourselves, because there's no\n      // information in arg to support multiple \"change paths\". One exception is\n      // if there are multiple outputs to the change address.\n      const isChange = changeData && outputScript.equals(changeData?.cond.scriptPubKey);\n      if (isChange) {\n        changeFound = true;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const changePath = pathStringToArray(arg.changePath!);\n        const pubkey = changeData.pubkey;\n\n        accountType.setOwnOutput(i, changeData.cond, [pubkey], [changePath]);\n      }\n    }\n    if (!changeFound) {\n      throw new Error(\n        \"Change script not found among outputs! \" + changeData?.cond.scriptPubKey.toString(\"hex\"),\n      );\n    }\n\n    const key = createKey(masterFp, accountPath, accountXpub);\n    const p = new WalletPolicy(accountType.getDescriptorTemplate(), key);\n    // This is cheating, because it's not actually requested on the\n    // device yet, but it will be, soonish.\n    if (arg.onDeviceSignatureRequested) arg.onDeviceSignatureRequested();\n\n    let firstSigned = false;\n    // This callback will be called once for each signature yielded.\n    const progressCallback = () => {\n      if (!firstSigned) {\n        firstSigned = true;\n        arg.onDeviceSignatureGranted && arg.onDeviceSignatureGranted();\n      }\n      progress();\n    };\n\n    await this.signPsbt(psbt, p, progressCallback);\n    finalize(psbt);\n    const serializedTx = extract(psbt);\n    return serializedTx.toString(\"hex\");\n  }\n\n  /**\n   * Signs an arbitrary hex-formatted message with the private key at\n   * the provided derivation path according to the Bitcoin Signature format\n   * and returns v, r, s.\n   */\n  async signMessage({ path, messageHex }: { path: string; messageHex: string }): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    const pathElements: number[] = pathStringToArray(path);\n    const message = Buffer.from(messageHex, \"hex\");\n    const sig = await this.client.signMessage(message, pathElements);\n    const buf = Buffer.from(sig, \"base64\");\n\n    const v = buf.readUInt8() - 27 - 4;\n    const r = buf.slice(1, 33).toString(\"hex\");\n    const s = buf.slice(33, 65).toString(\"hex\");\n\n    return {\n      v,\n      r,\n      s,\n    };\n  }\n\n  /**\n   * Calculates an output script along with public key and possible redeemScript\n   * from a path and accountType. The accountPath must be a prefix of path.\n   *\n   * @returns an object with output script (property \"script\"), redeemScript (if\n   * wrapped p2wpkh), and pubkey at provided path. The values of these three\n   * properties depend on the accountType used.\n   */\n  private async outputScriptAt(\n    accountPath: number[],\n    accountType: AccountType,\n    path: string | undefined,\n  ): Promise<{ cond: SpendingCondition; pubkey: Buffer } | undefined> {\n    if (!path) return undefined;\n    const pathElems = pathStringToArray(path);\n    // Make sure path is in our account, otherwise something fishy is probably\n    // going on.\n    for (let i = 0; i < accountPath.length; i++) {\n      if (accountPath[i] != pathElems[i]) {\n        throw new Error(`Path ${path} not in account ${pathArrayToString(accountPath)}`);\n      }\n    }\n    const xpub = await this.client.getExtendedPubkey(false, pathElems);\n    const pubkey = pubkeyFromXpub(xpub);\n    const cond = accountType.spendingCondition([pubkey]);\n    return { cond, pubkey };\n  }\n\n  /**\n   * Adds relevant data about an input to the psbt. This includes sequence,\n   * previous txid, output index, spent UTXO, redeem script for wrapped p2wpkh,\n   * public key and its derivation path.\n   */\n  private async setInput(\n    psbt: PsbtV2,\n    i: number,\n    input: [Transaction, number, string | null | undefined, number | null | undefined],\n    pathElements: number[],\n    accountType: AccountType,\n    masterFP: Buffer,\n    sigHashType?: number,\n  ): Promise<void> {\n    const inputTx = input[0];\n    const spentOutputIndex = input[1];\n    // redeemScript will be null for wrapped p2wpkh, we need to create it\n    // ourselves. But if set, it should be used.\n    const redeemScript = input[2] ? Buffer.from(input[2], \"hex\") : undefined;\n    const sequence = input[3];\n    if (sequence != undefined) {\n      psbt.setInputSequence(i, sequence);\n    }\n    if (sigHashType != undefined) {\n      psbt.setInputSighashType(i, sigHashType);\n    }\n    const inputTxBuffer = serializeTransaction(inputTx, true);\n    const inputTxid = crypto.hash256(inputTxBuffer);\n    const xpubBase58 = await this.client.getExtendedPubkey(false, pathElements);\n\n    const pubkey = pubkeyFromXpub(xpubBase58);\n    if (!inputTx.outputs) throw Error(\"Missing outputs array in transaction to sign\");\n    const spentTxOutput = inputTx.outputs[spentOutputIndex];\n    const spendCondition: SpendingCondition = {\n      scriptPubKey: spentTxOutput.script,\n      redeemScript: redeemScript,\n    };\n    const spentOutput = { cond: spendCondition, amount: spentTxOutput.amount };\n    accountType.setInput(i, inputTxBuffer, spentOutput, [pubkey], [pathElements]);\n\n    psbt.setInputPreviousTxId(i, inputTxid);\n    psbt.setInputOutputIndex(i, spentOutputIndex);\n  }\n\n  /**\n   * This implements the \"Signer\" role of the BIP370 transaction signing\n   * process.\n   *\n   * It ssks the hardware device to sign the a psbt using the specified wallet\n   * policy. This method assumes BIP32 derived keys are used for all inputs, see\n   * comment in-line. The signatures returned from the hardware device is added\n   * to the appropriate input fields of the PSBT.\n   */\n  private async signPsbt(\n    psbt: PsbtV2,\n    walletPolicy: WalletPolicy,\n    progressCallback: () => void,\n  ): Promise<void> {\n    const sigs: Map<number, Buffer> = await this.client.signPsbt(\n      psbt,\n      walletPolicy,\n      Buffer.alloc(32, 0),\n      progressCallback,\n    );\n    sigs.forEach((v, k) => {\n      // Note: Looking at BIP32 derivation does not work in the generic case,\n      // since some inputs might not have a BIP32-derived pubkey.\n      const pubkeys = psbt.getInputKeyDatas(k, psbtIn.BIP32_DERIVATION);\n      let pubkey;\n      if (pubkeys.length != 1) {\n        // No legacy BIP32_DERIVATION, assume we're using taproot.\n        pubkey = psbt.getInputKeyDatas(k, psbtIn.TAP_BIP32_DERIVATION);\n        if (pubkey.length == 0) {\n          throw Error(`Missing pubkey derivation for input ${k}`);\n        }\n        psbt.setInputTapKeySig(k, v);\n      } else {\n        pubkey = pubkeys[0];\n        psbt.setInputPartialSig(k, pubkey, v);\n      }\n    });\n  }\n}\n\n/**\n * This function returns a descriptor template based on the address format.\n * See https://github.com/LedgerHQ/app-bitcoin-new/blob/develop/doc/wallet.md for details of\n * the bitcoin descriptor template.\n */\nfunction descrTemplFrom(addressFormat: AddressFormat): DefaultDescriptorTemplate {\n  if (addressFormat == \"legacy\") return \"pkh(@0)\";\n  if (addressFormat == \"p2sh\") return \"sh(wpkh(@0))\";\n  if (addressFormat == \"bech32\") return \"wpkh(@0)\";\n  if (addressFormat == \"bech32m\") return \"tr(@0)\";\n  throw new Error(\"Unsupported address format \" + addressFormat);\n}\n\nfunction accountTypeFromArg(\n  arg: CreateTransactionArg,\n  psbt: PsbtV2,\n  masterFp: Buffer,\n): AccountType {\n  if (arg.additionals.includes(\"bech32m\")) return new p2tr(psbt, masterFp);\n  if (arg.additionals.includes(\"bech32\")) return new p2wpkh(psbt, masterFp);\n  if (arg.segwit) return new p2wpkhWrapped(psbt, masterFp);\n  return new p2pkh(psbt, masterFp);\n}\n\n/*\n  The new protocol only allows standard path.\n  Standard paths are (currently):\n  M/44'/(1|0|88)'/X'\n  M/49'/(1|0|88)'/X'\n  M/84'/(1|0|88)'/X'\n  M/86'/(1|0|88)'/X'\n  M/48'/(1|0|88)'/X'/Y'\n  followed by \"\", \"(0|1)\", or \"(0|1)/b\", where a and b are \n  non-hardened. For example, the following paths are standard\n  M/48'/1'/99'/7'\n  M/86'/1'/99'/0\n  M/48'/0'/99'/7'/1/17\n  The following paths are non-standard\n  M/48'/0'/99'           // Not deepest hardened path\n  M/48'/0'/99'/7'/1/17/2 // Too many non-hardened derivation steps\n  M/199'/0'/1'/0/88      // Not a known purpose 199\n  M/86'/1'/99'/2         // Change path item must be 0 or 1\n\n  Useful resource on derivation paths: https://learnmeabitcoin.com/technical/derivation-paths\n*/\n\n//path is not deepest hardened node of a standard path or deeper, use BtcOld\nconst H = 0x80000000; //HARDENED from bip32\n\nconst VALID_COIN_TYPES = [\n  0, // Bitcoin\n  1, // Bitcoin (Testnet)\n  88, // Qtum\n];\n\nconst VALID_SINGLE_SIG_PURPOSES = [\n  44, // BIP44 - https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\n  49, // BIP49 - https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki\n  84, // BIP84 - https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki\n  86, // BIP86 - https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki\n];\n\nconst VALID_MULTISIG_PURPOSES = [\n  48, // BIP48 - https://github.com/bitcoin/bips/blob/master/bip-0048.mediawiki\n];\n\nconst hard = (n: number) => n >= H;\nconst soft = (n: number | undefined) => n === undefined || n < H;\nconst change = (n: number | undefined) => n === undefined || n === 0 || n === 1;\n\nconst validCoinPathPartsSet = new Set(VALID_COIN_TYPES.map(t => t + H));\nconst validSingleSigPurposePathPartsSet = new Set(VALID_SINGLE_SIG_PURPOSES.map(t => t + H));\nconst validMultiSigPurposePathPartsSet = new Set(VALID_MULTISIG_PURPOSES.map(t => t + H));\n\nexport function isPathNormal(path: string): boolean {\n  const pathElems = pathStringToArray(path);\n\n  // Single sig\n  if (\n    pathElems.length >= 3 &&\n    pathElems.length <= 5 &&\n    validSingleSigPurposePathPartsSet.has(pathElems[0]) &&\n    validCoinPathPartsSet.has(pathElems[1]) &&\n    hard(pathElems[2]) &&\n    change(pathElems[3]) &&\n    soft(pathElems[4])\n  ) {\n    return true;\n  }\n\n  // Multi sig\n  if (\n    pathElems.length >= 4 &&\n    pathElems.length <= 6 &&\n    validMultiSigPurposePathPartsSet.has(pathElems[0]) &&\n    validCoinPathPartsSet.has(pathElems[1]) &&\n    hard(pathElems[2]) &&\n    hard(pathElems[3]) &&\n    change(pathElems[4]) &&\n    soft(pathElems[5])\n  ) {\n    return true;\n  }\n  return false;\n}\n","import { BufferWriter } from \"../buffertools\";\nimport { PsbtV2 } from \"./psbtv2\";\n\n/**\n * This implements the \"Transaction Extractor\" role of BIP370 (PSBTv2\n * https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#transaction-extractor). However\n * the role is partially documented in BIP174 (PSBTv0\n * https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#transaction-extractor).\n */\nexport function extract(psbt: PsbtV2): Buffer {\n  const tx = new BufferWriter();\n  tx.writeUInt32(psbt.getGlobalTxVersion());\n\n  const isSegwit = !!psbt.getInputWitnessUtxo(0);\n  if (isSegwit) {\n    tx.writeSlice(Buffer.from([0, 1]));\n  }\n  const inputCount = psbt.getGlobalInputCount();\n  tx.writeVarInt(inputCount);\n  const witnessWriter = new BufferWriter();\n  for (let i = 0; i < inputCount; i++) {\n    tx.writeSlice(psbt.getInputPreviousTxid(i));\n    tx.writeUInt32(psbt.getInputOutputIndex(i));\n    tx.writeVarSlice(psbt.getInputFinalScriptsig(i) ?? Buffer.from([]));\n    tx.writeUInt32(psbt.getInputSequence(i));\n    if (isSegwit) {\n      witnessWriter.writeSlice(psbt.getInputFinalScriptwitness(i));\n    }\n  }\n  const outputCount = psbt.getGlobalOutputCount();\n  tx.writeVarInt(outputCount);\n  for (let i = 0; i < outputCount; i++) {\n    tx.writeUInt64(psbt.getOutputAmount(i));\n    tx.writeVarSlice(psbt.getOutputScript(i));\n  }\n  tx.writeSlice(witnessWriter.buffer());\n  tx.writeUInt32(psbt.getGlobalFallbackLocktime() ?? 0);\n  return tx.buffer();\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\n\n/**\n * address format is one of legacy | p2sh | bech32 | bech32m | cashaddr\n */\nexport type AddressFormat = \"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\";\nconst addressFormatMap = {\n  legacy: 0,\n  p2sh: 1,\n  bech32: 2,\n  cashaddr: 3,\n};\nexport async function getWalletPublicKey(\n  transport: Transport,\n  options: {\n    path: string;\n    verify?: boolean;\n    format?: AddressFormat;\n  },\n): Promise<{\n  publicKey: string;\n  bitcoinAddress: string;\n  chainCode: string;\n}> {\n  const { path, verify, format } = {\n    verify: false,\n    format: \"legacy\",\n    ...options,\n  };\n\n  if (!(format in addressFormatMap)) {\n    throw new Error(\"btc.getWalletPublicKey invalid format=\" + format);\n  }\n\n  const buffer = bip32asBuffer(path);\n  const p1 = verify ? 1 : 0;\n  const p2 = addressFormatMap[format];\n  const response = await transport.send(0xe0, 0x40, p1, p2, buffer);\n  const publicKeyLength = response[0];\n  const addressLength = response[1 + publicKeyLength];\n  const publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n  const bitcoinAddress = response\n    .slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength)\n    .toString(\"ascii\");\n  const chainCode = response\n    .slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32)\n    .toString(\"hex\");\n  return {\n    publicKey,\n    bitcoinAddress,\n    chainCode,\n  };\n}\n","import invariant from \"invariant\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nimport { createVarint } from \"./varint\";\nexport async function getTrustedInputRaw(\n  transport: Transport,\n  transactionData: Buffer,\n  indexLookup?: number | null | undefined,\n): Promise<string> {\n  let data;\n  let firstRound = false;\n\n  if (typeof indexLookup === \"number\") {\n    firstRound = true;\n    const prefix = Buffer.alloc(4);\n    prefix.writeUInt32BE(indexLookup, 0);\n    data = Buffer.concat([prefix, transactionData], transactionData.length + 4);\n  } else {\n    data = transactionData;\n  }\n\n  const trustedInput = await transport.send(0xe0, 0x42, firstRound ? 0x00 : 0x80, 0x00, data);\n  const res = trustedInput.slice(0, trustedInput.length - 2).toString(\"hex\");\n  return res;\n}\nexport async function getTrustedInput(\n  transport: Transport,\n  indexLookup: number,\n  transaction: Transaction,\n  additionals: Array<string> = [],\n): Promise<string> {\n  const { version, inputs, outputs, locktime, nExpiryHeight, extraData } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInput: locktime & outputs is expected\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n  const isXST = additionals.includes(\"stealthcoin\");\n\n  const processScriptBlocks = async (script, sequence?: Buffer) => {\n    const seq = sequence || Buffer.alloc(0);\n    const scriptBlocks: Buffer[] = [];\n    let offset = 0;\n\n    while (offset !== script.length) {\n      const blockSize =\n        script.length - offset > MAX_SCRIPT_BLOCK ? MAX_SCRIPT_BLOCK : script.length - offset;\n\n      if (offset + blockSize !== script.length) {\n        scriptBlocks.push(script.slice(offset, offset + blockSize));\n      } else {\n        scriptBlocks.push(Buffer.concat([script.slice(offset, offset + blockSize), seq]));\n      }\n\n      offset += blockSize;\n    }\n\n    // Handle case when no script length: we still want to pass the sequence\n    // relatable: https://github.com/LedgerHQ/ledger-live-desktop/issues/1386\n    if (script.length === 0) {\n      scriptBlocks.push(seq);\n    }\n\n    let res;\n\n    for (const scriptBlock of scriptBlocks) {\n      res = await getTrustedInputRaw(transport, scriptBlock);\n    }\n\n    return res;\n  };\n\n  const processWholeScriptBlock = block => getTrustedInputRaw(transport, block);\n\n  await getTrustedInputRaw(\n    transport,\n    Buffer.concat([\n      transaction.version,\n      transaction.timestamp || Buffer.alloc(0),\n      transaction.nVersionGroupId || Buffer.alloc(0),\n      createVarint(inputs.length),\n    ]),\n    indexLookup,\n  );\n\n  for (const input of inputs) {\n    const isXSTV2 = isXST && Buffer.compare(version, Buffer.from([0x02, 0x00, 0x00, 0x00])) === 0;\n    const treeField = isDecred ? input.tree || Buffer.from([0x00]) : Buffer.alloc(0);\n    const data = Buffer.concat([\n      input.prevout,\n      treeField,\n      isXSTV2 ? Buffer.from([0x00]) : createVarint(input.script.length),\n    ]);\n    await getTrustedInputRaw(transport, data);\n    // iteration (eachSeries) ended\n    // TODO notify progress\n    // deferred.notify(\"input\");\n    // Reference: https://github.com/StealthSend/Stealth/commit/5be35d6c2c500b32ed82e5d6913d66d18a4b0a7f#diff-e8db9b851adc2422aadfffca88f14c91R566\n    await (isDecred\n      ? processWholeScriptBlock(Buffer.concat([input.script, input.sequence]))\n      : isXSTV2\n        ? processWholeScriptBlock(input.sequence)\n        : processScriptBlocks(input.script, input.sequence));\n  }\n\n  await getTrustedInputRaw(transport, createVarint(outputs.length));\n\n  for (const output of outputs) {\n    const data = Buffer.concat([\n      output.amount,\n      isDecred ? Buffer.from([0x00, 0x00]) : Buffer.alloc(0), //Version script\n      createVarint(output.script.length),\n      output.script,\n    ]);\n    await getTrustedInputRaw(transport, data);\n  }\n\n  const endData: Buffer[] = [];\n\n  if (nExpiryHeight && nExpiryHeight.length > 0) {\n    endData.push(nExpiryHeight);\n  }\n\n  if (extraData && extraData.length > 0) {\n    endData.push(extraData);\n  }\n\n  let extraPart;\n\n  if (endData.length) {\n    const data = Buffer.concat(endData);\n    extraPart = isDecred ? data : Buffer.concat([createVarint(data.length), data]);\n  }\n\n  const res = await processScriptBlocks(Buffer.concat([locktime, extraPart || Buffer.alloc(0)]));\n  invariant(res, \"missing result in processScriptBlocks\");\n  return res;\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport type { Transaction } from \"./types\";\nimport { createVarint } from \"./varint\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function startUntrustedHashTransactionInputRaw(\n  transport: Transport,\n  newTransaction: boolean,\n  firstRound: boolean,\n  transactionData: Buffer,\n  bip143 = false,\n  overwinter = false,\n  additionals: Array<string> = [],\n): Promise<Buffer> {\n  const p2 = additionals.includes(\"cashaddr\")\n    ? 0x03\n    : bip143\n      ? additionals.includes(\"sapling\")\n        ? 0x05\n        : overwinter\n          ? 0x04\n          : 0x02\n      : 0x00;\n  return transport.send(\n    0xe0,\n    0x44,\n    firstRound ? 0x00 : 0x80,\n    newTransaction ? p2 : 0x80,\n    transactionData,\n  );\n}\nexport async function startUntrustedHashTransactionInput(\n  transport: Transport,\n  newTransaction: boolean,\n  transaction: Transaction,\n  inputs: Array<{\n    trustedInput: boolean;\n    value: Buffer;\n  }>,\n  bip143 = false,\n  overwinter = false,\n  additionals: Array<string> = [],\n  useTrustedInputForSegwit = false,\n): Promise<any> {\n  let data = Buffer.concat([\n    transaction.version,\n    transaction.timestamp || Buffer.alloc(0),\n    transaction.nVersionGroupId || Buffer.alloc(0),\n    createVarint(transaction.inputs.length),\n  ]);\n  await startUntrustedHashTransactionInputRaw(\n    transport,\n    newTransaction,\n    true,\n    data,\n    bip143,\n    overwinter,\n    additionals,\n  );\n  let i = 0;\n  const isDecred = additionals.includes(\"decred\");\n\n  for (const input of transaction.inputs) {\n    let prefix;\n    const inputValue = inputs[i].value;\n\n    if (bip143) {\n      if (useTrustedInputForSegwit && inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputValue.length]);\n      } else {\n        prefix = Buffer.from([0x02]);\n      }\n    } else {\n      if (inputs[i].trustedInput) {\n        prefix = Buffer.from([0x01, inputs[i].value.length]);\n      } else {\n        prefix = Buffer.from([0x00]);\n      }\n    }\n\n    data = Buffer.concat([\n      prefix,\n      inputValue,\n      isDecred ? Buffer.from([0x00]) : Buffer.alloc(0),\n      createVarint(input.script.length),\n    ]);\n    await startUntrustedHashTransactionInputRaw(\n      transport,\n      newTransaction,\n      false,\n      data,\n      bip143,\n      overwinter,\n      additionals,\n    );\n    const scriptBlocks: Buffer[] = [];\n    let offset = 0;\n\n    if (input.script.length === 0) {\n      scriptBlocks.push(input.sequence);\n    } else {\n      while (offset !== input.script.length) {\n        const blockSize =\n          input.script.length - offset > MAX_SCRIPT_BLOCK\n            ? MAX_SCRIPT_BLOCK\n            : input.script.length - offset;\n\n        if (offset + blockSize !== input.script.length) {\n          scriptBlocks.push(input.script.slice(offset, offset + blockSize));\n        } else {\n          scriptBlocks.push(\n            Buffer.concat([input.script.slice(offset, offset + blockSize), input.sequence]),\n          );\n        }\n\n        offset += blockSize;\n      }\n    }\n\n    for (const scriptBlock of scriptBlocks) {\n      await startUntrustedHashTransactionInputRaw(\n        transport,\n        newTransaction,\n        false,\n        scriptBlock,\n        bip143,\n        overwinter,\n        additionals,\n      );\n    }\n\n    i++;\n  }\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport shajs from \"sha.js\";\nimport type { Transaction } from \"./types\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nexport function getTrustedInputBIP143(\n  transport: Transport,\n  indexLookup: number,\n  transaction: Transaction,\n  additionals: Array<string> = [],\n): string {\n  if (!transaction) {\n    throw new Error(\"getTrustedInputBIP143: missing tx\");\n  }\n\n  const isDecred = additionals.includes(\"decred\");\n\n  if (isDecred) {\n    throw new Error(\"Decred does not implement BIP143\");\n  }\n\n  let hash = shajs(\"sha256\")\n    .update(shajs(\"sha256\").update(serializeTransaction(transaction, true)).digest())\n    .digest();\n  const data = Buffer.alloc(4);\n  data.writeUInt32LE(indexLookup, 0);\n  const { outputs, locktime } = transaction;\n\n  if (!outputs || !locktime) {\n    throw new Error(\"getTrustedInputBIP143: locktime & outputs is expected\");\n  }\n\n  if (!outputs[indexLookup]) {\n    throw new Error(\"getTrustedInputBIP143: wrong index\");\n  }\n\n  hash = Buffer.concat([hash, data, outputs[indexLookup].amount]);\n  return hash.toString(\"hex\");\n}\n","export function compressPublicKey(publicKey: Buffer): Buffer {\n  const prefix = (publicKey[64] & 1) !== 0 ? 0x03 : 0x02;\n  const prefixBuffer = Buffer.alloc(1);\n  prefixBuffer[0] = prefix;\n  return Buffer.concat([prefixBuffer, publicKey.slice(1, 1 + 32)]);\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\nexport function signTransaction(\n  transport: Transport,\n  path: string,\n  lockTime: number,\n  sigHashType: number,\n  expiryHeight?: Buffer,\n  additionals: Array<string> = [],\n): Promise<Buffer> {\n  const isDecred = additionals.includes(\"decred\");\n  const pathsBuffer = bip32asBuffer(path);\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32BE(lockTime, 0);\n  let buffer = isDecred\n    ? Buffer.concat([\n        pathsBuffer,\n        lockTimeBuffer,\n        expiryHeight || Buffer.from([0x00, 0x00, 0x00, 0x00]),\n        Buffer.from([sigHashType]),\n      ])\n    : Buffer.concat([pathsBuffer, Buffer.from([0x00]), lockTimeBuffer, Buffer.from([sigHashType])]);\n\n  if (expiryHeight && !isDecred) {\n    buffer = Buffer.concat([buffer, expiryHeight]);\n  }\n\n  return transport.send(0xe0, 0x48, 0x00, 0x00, buffer).then(result => {\n    if (result.length > 0) {\n      result[0] = 0x30;\n      return result.slice(0, result.length - 2);\n    }\n\n    return result;\n  });\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport { bip32asBuffer } from \"./bip32\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport function provideOutputFullChangePath(transport: Transport, path: string): Promise<Buffer> {\n  const buffer = bip32asBuffer(path);\n  return transport.send(0xe0, 0x4a, 0xff, 0x00, buffer);\n}\nexport async function hashOutputFull(\n  transport: Transport,\n  outputScript: Buffer,\n  additionals: Array<string> = [],\n): Promise<Buffer | void> {\n  let offset = 0;\n  const p1 = Number(0x80);\n  const isDecred = additionals.includes(\"decred\");\n\n  ///WARNING: Decred works only with one call (without chunking)\n  //TODO: test without this for Decred\n  if (isDecred) {\n    return transport.send(0xe0, 0x4a, p1, 0x00, outputScript);\n  }\n\n  while (offset < outputScript.length) {\n    const blockSize =\n      offset + MAX_SCRIPT_BLOCK >= outputScript.length\n        ? outputScript.length - offset\n        : MAX_SCRIPT_BLOCK;\n    const p1 = offset + blockSize === outputScript.length ? 0x80 : 0x00;\n    const data = outputScript.slice(offset, offset + blockSize);\n    await transport.send(0xe0, 0x4a, p1, 0x00, data);\n    offset += blockSize;\n  }\n}\n","import invariant from \"invariant\";\nimport Transport from \"@ledgerhq/hw-transport\";\n\nexport type AppAndVersion = {\n  name: string;\n  version: string;\n  flags: number | Buffer;\n};\n\nexport const getAppAndVersion = async (transport: Transport): Promise<AppAndVersion> => {\n  const r = await transport.send(0xb0, 0x01, 0x00, 0x00);\n  let i = 0;\n  const format = r[i++];\n  invariant(format === 1, \"getAppAndVersion: format not supported\");\n  const nameLength = r[i++];\n  const name = r.slice(i, (i += nameLength)).toString(\"ascii\");\n  const versionLength = r[i++];\n  const version = r.slice(i, (i += versionLength)).toString(\"ascii\");\n  const flagLength = r[i++];\n  const flags = r.slice(i, (i += flagLength));\n  return {\n    name,\n    version,\n    flags,\n  };\n};\n\nexport const checkIsBtcLegacy = async (transport: Transport): Promise<boolean> => {\n  try {\n    // Call old btc API, it will throw an exception with new btc app. It is a workaround to differentiate new/old btc nano app\n    await transport.send(0xe0, 0xc4, 0, 0);\n  } catch (e: unknown) {\n    return false;\n  }\n  return true;\n};\n","import { log } from \"@ledgerhq/logs\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { hashPublicKey } from \"./hashPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { serializeTransaction } from \"./serializeTransaction\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { compressPublicKey } from \"./compressPublicKey\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull, provideOutputFullChangePath } from \"./finalizeInput\";\nimport { getAppAndVersion } from \"./getAppAndVersion\";\nimport type { TransactionOutput, Transaction } from \"./types\";\nimport {\n  DEFAULT_LOCKTIME,\n  DEFAULT_SEQUENCE,\n  SIGHASH_ALL,\n  OP_DUP,\n  OP_HASH160,\n  HASH_SIZE,\n  OP_EQUALVERIFY,\n  OP_CHECKSIG,\n} from \"./constants\";\nimport { shouldUseTrustedInputForSegwit } from \"./shouldUseTrustedInputForSegwit\";\nexport type { AddressFormat };\nconst defaultsSignTransaction = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  additionals: [],\n  onDeviceStreaming: _e => {},\n  onDeviceSignatureGranted: () => {},\n  onDeviceSignatureRequested: () => {},\n};\n\n/**\n *\n */\nexport type CreateTransactionArg = {\n  inputs: Array<[Transaction, number, string | null | undefined, number | null | undefined]>;\n  associatedKeysets: string[];\n  changePath?: string;\n  outputScriptHex: string;\n  lockTime?: number;\n  sigHashType?: number;\n  segwit?: boolean;\n  initialTimestamp?: number;\n  additionals: Array<string>;\n  expiryHeight?: Buffer;\n  useTrustedInputForSegwit?: boolean;\n  onDeviceStreaming?: (arg0: { progress: number; total: number; index: number }) => void;\n  onDeviceSignatureRequested?: () => void;\n  onDeviceSignatureGranted?: () => void;\n};\nexport async function createTransaction(\n  transport: Transport,\n  arg: CreateTransactionArg,\n): Promise<string> {\n  const signTx = { ...defaultsSignTransaction, ...arg };\n  const {\n    inputs,\n    associatedKeysets,\n    changePath,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    initialTimestamp,\n    additionals,\n    expiryHeight,\n    onDeviceStreaming,\n    onDeviceSignatureGranted,\n    onDeviceSignatureRequested,\n  } = signTx;\n  let useTrustedInputForSegwit = signTx.useTrustedInputForSegwit;\n\n  if (useTrustedInputForSegwit === undefined) {\n    try {\n      const a = await getAppAndVersion(transport);\n      useTrustedInputForSegwit = shouldUseTrustedInputForSegwit(a);\n    } catch (e: any) {\n      if (e.statusCode === 0x6d00) {\n        useTrustedInputForSegwit = false;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // loop: 0 or 1 (before and after)\n  // i: index of the input being streamed\n  // i goes on 0...n, inluding n. in order for the progress value to go to 1\n  // we normalize the 2 loops to make a global percentage\n  const notify = (loop, i) => {\n    const { length } = inputs;\n    if (length < 3) return; // there is not enough significant event to worth notifying (aka just use a spinner)\n\n    const index = length * loop + i;\n    const total = 2 * length;\n    const progress = index / total;\n    onDeviceStreaming({\n      progress,\n      total,\n      index,\n    });\n  };\n\n  const isDecred = additionals.includes(\"decred\");\n  const isZcash = additionals.includes(\"zcash\");\n  const isXST = additionals.includes(\"stealthcoin\");\n  const startTime = Date.now();\n  const sapling = additionals.includes(\"sapling\");\n  const bech32 = segwit && additionals.includes(\"bech32\");\n  const useBip143 =\n    segwit ||\n    (!!additionals &&\n      (additionals.includes(\"abc\") ||\n        additionals.includes(\"gold\") ||\n        additionals.includes(\"bip143\"))) ||\n    (!!expiryHeight && !isDecred);\n  // Inputs are provided as arrays of [transaction, output_index, optional redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n  const lockTimeBuffer = Buffer.alloc(4);\n  lockTimeBuffer.writeUInt32LE(lockTime, 0);\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  !!expiryHeight && !isDecred\n    ? defaultVersion.writeUInt32LE(isZcash ? 0x80000005 : sapling ? 0x80000004 : 0x80000003, 0) // v5 format for zcash refer to https://zips.z.cash/zip-0225\n    : isXST\n      ? defaultVersion.writeUInt32LE(2, 0)\n      : defaultVersion.writeUInt32LE(1, 0);\n  // Default version to 2 for XST not to have timestamp\n  const trustedInputs: Array<any> = [];\n  const regularOutputs: Array<TransactionOutput> = [];\n  const signatures: Buffer[] = [];\n  const publicKeys: Buffer[] = [];\n  let firstRun = true;\n  const resuming = false;\n  const targetTransaction: Transaction = {\n    inputs: [],\n    version: defaultVersion,\n    timestamp: Buffer.alloc(0),\n  };\n  const getTrustedInputCall =\n    useBip143 && !useTrustedInputForSegwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n  notify(0, 0);\n  // first pass on inputs to get trusted inputs\n  for (const input of inputs) {\n    if (!resuming) {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0], additionals);\n      log(\"hw\", \"got trustedInput=\" + trustedInput);\n      const sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(\n        input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n        0,\n      );\n      trustedInputs.push({\n        trustedInput: true,\n        value: Buffer.from(trustedInput, \"hex\"),\n        sequence,\n      });\n    }\n\n    const { outputs } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n\n    if (expiryHeight && !isDecred) {\n      targetTransaction.nVersionGroupId = Buffer.from(\n        // nVersionGroupId is 0x26A7270A for zcash NU5 upgrade\n        // refer to https://github.com/zcash/zcash/blob/master/src/primitives/transaction.h\n        isZcash\n          ? [0x0a, 0x27, 0xa7, 0x26]\n          : sapling\n            ? [0x85, 0x20, 0x2f, 0x89]\n            : [0x70, 0x82, 0xc4, 0x03],\n      );\n      targetTransaction.nExpiryHeight = expiryHeight;\n      // For sapling : valueBalance (8), nShieldedSpend (1), nShieldedOutput (1), nJoinSplit (1)\n      // Overwinter : use nJoinSplit (1)\n      targetTransaction.extraData = Buffer.from(\n        sapling ? [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] : [0x00],\n      );\n    } else if (isDecred) {\n      targetTransaction.nExpiryHeight = expiryHeight;\n    }\n  }\n\n  targetTransaction.inputs = inputs.map((input, idx) => {\n    const sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(\n      input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n      0,\n    );\n    return {\n      script: isZcash ? regularOutputs[idx].script : nullScript,\n      prevout: nullPrevout,\n      sequence,\n    };\n  });\n\n  if (!resuming) {\n    // Collect public keys\n    const result: {\n      publicKey: string;\n      bitcoinAddress: string;\n      chainCode: string;\n    }[] = [];\n\n    for (let i = 0; i < inputs.length; i++) {\n      const r = await getWalletPublicKey(transport, {\n        path: associatedKeysets[i],\n      });\n      notify(0, i + 1);\n      result.push(r);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      publicKeys.push(compressPublicKey(Buffer.from(result[i].publicKey, \"hex\")));\n    }\n  }\n\n  if (initialTimestamp !== undefined) {\n    targetTransaction.timestamp = Buffer.alloc(4);\n    targetTransaction.timestamp.writeUInt32LE(\n      Math.floor(initialTimestamp + (Date.now() - startTime) / 1000),\n      0,\n    );\n  }\n\n  onDeviceSignatureRequested();\n\n  if (useBip143) {\n    // Do the first run with all inputs\n    await startUntrustedHashTransactionInput(\n      transport,\n      true,\n      targetTransaction,\n      trustedInputs,\n      true,\n      !!expiryHeight,\n      additionals,\n      useTrustedInputForSegwit,\n    );\n\n    if (!resuming && changePath) {\n      await provideOutputFullChangePath(transport, changePath);\n    }\n\n    await hashOutputFull(transport, outputScript);\n  }\n\n  if (!!expiryHeight && !isDecred) {\n    await signTransaction(transport, \"\", lockTime, SIGHASH_ALL, expiryHeight);\n  }\n\n  // Do the second run with the individual transaction\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const script =\n      inputs[i].length >= 3 && typeof input[2] === \"string\"\n        ? Buffer.from(input[2], \"hex\")\n        : !segwit\n          ? regularOutputs[i].script\n          : Buffer.concat([\n              Buffer.from([OP_DUP, OP_HASH160, HASH_SIZE]),\n              hashPublicKey(publicKeys[i]),\n              Buffer.from([OP_EQUALVERIFY, OP_CHECKSIG]),\n            ]);\n    const pseudoTX = Object.assign({}, targetTransaction);\n    const pseudoTrustedInputs = useBip143 ? [trustedInputs[i]] : trustedInputs;\n\n    if (useBip143) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(\n      transport,\n      !useBip143 && firstRun,\n      pseudoTX,\n      pseudoTrustedInputs,\n      useBip143,\n      !!expiryHeight && !isDecred,\n      additionals,\n      useTrustedInputForSegwit,\n    );\n\n    if (!useBip143) {\n      if (!resuming && changePath) {\n        await provideOutputFullChangePath(transport, changePath);\n      }\n\n      await hashOutputFull(transport, outputScript, additionals);\n    }\n\n    if (firstRun) {\n      onDeviceSignatureGranted();\n      notify(1, 0);\n    }\n\n    const signature = await signTransaction(\n      transport,\n      associatedKeysets[i],\n      lockTime,\n      sigHashType,\n      expiryHeight,\n      additionals,\n    );\n    notify(1, i + 1);\n    signatures.push(signature);\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  // Populate the final input scripts\n  for (let i = 0; i < inputs.length; i++) {\n    if (segwit) {\n      targetTransaction.witness = Buffer.alloc(0);\n\n      if (!bech32) {\n        targetTransaction.inputs[i].script = Buffer.concat([\n          Buffer.from(\"160014\", \"hex\"),\n          hashPublicKey(publicKeys[i]),\n        ]);\n      }\n    } else {\n      const signatureSize = Buffer.alloc(1);\n      const keySize = Buffer.alloc(1);\n      signatureSize[0] = signatures[i].length;\n      keySize[0] = publicKeys[i].length;\n      targetTransaction.inputs[i].script = Buffer.concat([\n        signatureSize,\n        signatures[i],\n        keySize,\n        publicKeys[i],\n      ]);\n    }\n\n    const offset = useBip143 && !useTrustedInputForSegwit ? 0 : 4;\n    targetTransaction.inputs[i].prevout = trustedInputs[i].value.slice(offset, offset + 0x24);\n  }\n  targetTransaction.locktime = lockTimeBuffer;\n  let result = Buffer.concat([\n    serializeTransaction(targetTransaction, false, targetTransaction.timestamp, additionals),\n    outputScript,\n  ]);\n\n  if (segwit && !isDecred) {\n    let witness = Buffer.alloc(0);\n\n    for (let i = 0; i < inputs.length; i++) {\n      const tmpScriptData = Buffer.concat([\n        Buffer.from(\"02\", \"hex\"),\n        Buffer.from([signatures[i].length]),\n        signatures[i],\n        Buffer.from([publicKeys[i].length]),\n        publicKeys[i],\n      ]);\n      witness = Buffer.concat([witness, tmpScriptData]);\n    }\n\n    result = Buffer.concat([result, witness]);\n  }\n\n  // from to https://zips.z.cash/zip-0225, zcash is different with other coins, the lock_time and nExpiryHeight fields are before the inputs and outputs\n  if (!isZcash) {\n    result = Buffer.concat([result, lockTimeBuffer]);\n    if (expiryHeight) {\n      result = Buffer.concat([\n        result,\n        targetTransaction.nExpiryHeight || Buffer.alloc(0),\n        targetTransaction.extraData || Buffer.alloc(0),\n      ]);\n    }\n  }\n  if (isDecred) {\n    let decredWitness = Buffer.from([targetTransaction.inputs.length]);\n    inputs.forEach((input, inputIndex) => {\n      decredWitness = Buffer.concat([\n        decredWitness,\n        Buffer.from([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),\n        Buffer.from([0x00, 0x00, 0x00, 0x00]), //Block height\n        Buffer.from([0xff, 0xff, 0xff, 0xff]), //Block index\n        Buffer.from([targetTransaction.inputs[inputIndex].script.length]),\n        targetTransaction.inputs[inputIndex].script,\n      ]);\n    });\n    result = Buffer.concat([result, decredWitness]);\n  }\n  if (isZcash) {\n    result = Buffer.concat([result, Buffer.from([0x00, 0x00, 0x00])]);\n  }\n  return result.toString(\"hex\");\n}\n","import semver from \"semver\";\nexport function shouldUseTrustedInputForSegwit({\n  version,\n  name,\n}: {\n  version: string;\n  name: string;\n}): boolean {\n  if (name === \"Decred\") return false;\n  if (name === \"Exchange\") return true;\n  return semver.gte(version, \"1.4.0\");\n}\n","import bs58 from \"bs58\";\nimport RIPEMD160 from \"ripemd160\";\nimport sha from \"sha.js\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport { createTransaction } from \"./createTransaction\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { getWalletPublicKey } from \"./getWalletPublicKey\";\nimport { pathArrayToString, pathStringToArray } from \"./bip32\";\nimport { signMessage } from \"./signMessage\";\nexport type { AddressFormat };\n\n/**\n * @class BtcOld\n * @description This Bitcoin old API is compatible with versions of the Bitcoin nano app that are earlier than 2.1.0\n *\n */\n\nexport default class BtcOld {\n  constructor(private transport: Transport) {}\n\n  private derivationsCache = {};\n  private async derivatePath(path: string) {\n    if (this.derivationsCache[path]) return this.derivationsCache[path];\n    const res = await getWalletPublicKey(this.transport, {\n      path,\n    });\n    this.derivationsCache[path] = res;\n    return res;\n  }\n\n  async getWalletXpub({\n    path,\n    xpubVersion,\n  }: {\n    path: string;\n    xpubVersion: number;\n  }): Promise<string> {\n    const pathElements = pathStringToArray(path);\n    const parentPath = pathElements.slice(0, -1);\n    const parentDerivation = await this.derivatePath(pathArrayToString(parentPath));\n    const accountDerivation = await this.derivatePath(path);\n    const fingerprint = makeFingerprint(\n      compressPublicKeySECP256(Buffer.from(parentDerivation.publicKey, \"hex\")),\n    );\n    const xpub = makeXpub(\n      xpubVersion,\n      pathElements.length,\n      fingerprint,\n      pathElements[pathElements.length - 1],\n      Buffer.from(accountDerivation.chainCode, \"hex\"),\n      compressPublicKeySECP256(Buffer.from(accountDerivation.publicKey, \"hex\")),\n    );\n    return xpub;\n  }\n\n  /**\n   * @param path a BIP 32 path\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) will ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 84' paths\n   *\n   * - bech32m format with 86' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    if (opts?.format === \"bech32m\") {\n      throw new Error(\"Unsupported address format bech32m\");\n    }\n    return getWalletPublicKey(this.transport, { ...opts, path });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"decred\" for decred\n   * - \"zcash\" for zcash\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n  createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    if (arguments.length > 1) {\n      throw new Error(\n        \"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\",\n      );\n    }\n    return createTransaction(this.transport, arg);\n  }\n\n  async signMessage({ path, messageHex }: { path: string; messageHex: string }): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    return signMessage(this.transport, {\n      path,\n      messageHex,\n    });\n  }\n}\n\nfunction makeFingerprint(compressedPubKey) {\n  return hash160(compressedPubKey).slice(0, 4);\n}\n\nfunction asBufferUInt32BE(n: number): Buffer {\n  const buf = Buffer.allocUnsafe(4);\n  buf.writeUInt32BE(n, 0);\n  return buf;\n}\n\nconst compressPublicKeySECP256 = (publicKey: Buffer) =>\n  Buffer.concat([Buffer.from([0x02 + (publicKey[64] & 0x01)]), publicKey.slice(1, 33)]);\n\nfunction makeXpub(\n  version: number,\n  depth: number,\n  parentFingerprint: Buffer,\n  index: number,\n  chainCode: Buffer,\n  pubKey: Buffer,\n) {\n  const indexBuffer = asBufferUInt32BE(index);\n  indexBuffer[0] |= 0x80;\n  const extendedKeyBytes = Buffer.concat([\n    asBufferUInt32BE(version),\n    Buffer.from([depth]),\n    parentFingerprint,\n    indexBuffer,\n    chainCode,\n    pubKey,\n  ]);\n  const checksum = hash256(extendedKeyBytes).slice(0, 4);\n  return bs58.encode(Buffer.concat([extendedKeyBytes, checksum]));\n}\n\nfunction sha256(buffer: Buffer | string) {\n  return sha(\"sha256\").update(buffer).digest();\n}\nfunction hash256(buffer: Buffer | string) {\n  return sha256(sha256(buffer));\n}\nfunction ripemd160(buffer: Buffer | string) {\n  return new RIPEMD160().update(buffer).digest();\n}\nfunction hash160(buffer: Buffer | string) {\n  return ripemd160(sha256(buffer));\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport bippath from \"bip32-path\";\nimport { MAX_SCRIPT_BLOCK } from \"./constants\";\nexport async function signMessage(\n  transport: Transport,\n  {\n    path,\n    messageHex,\n  }: {\n    path: string;\n    messageHex: string;\n  },\n): Promise<{\n  v: number;\n  r: string;\n  s: string;\n}> {\n  const paths = bippath.fromString(path).toPathArray();\n  const message = Buffer.from(messageHex, \"hex\");\n  let offset = 0;\n\n  while (offset !== message.length) {\n    const maxChunkSize =\n      offset === 0 ? MAX_SCRIPT_BLOCK - 1 - paths.length * 4 - 4 : MAX_SCRIPT_BLOCK;\n    const chunkSize =\n      offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n    const buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 2 + chunkSize : chunkSize);\n\n    if (offset === 0) {\n      buffer[0] = paths.length;\n      paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n      });\n      buffer.writeUInt16BE(message.length, 1 + 4 * paths.length);\n      message.copy(buffer, 1 + 4 * paths.length + 2, offset, offset + chunkSize);\n    } else {\n      message.copy(buffer, 0, offset, offset + chunkSize);\n    }\n\n    await transport.send(0xe0, 0x4e, 0x00, offset === 0 ? 0x01 : 0x80, buffer);\n    offset += chunkSize;\n  }\n\n  const res = await transport.send(0xe0, 0x4e, 0x80, 0x00, Buffer.from([0x00]));\n  const v = res[0] - 0x30;\n  let r: Buffer | string = res.slice(4, 4 + res[3]);\n\n  if (r[0] === 0) {\n    r = r.slice(1);\n  }\n\n  r = r.toString(\"hex\");\n  offset = 4 + res[3] + 2;\n  let s: Buffer | string = res.slice(offset, offset + res[offset - 1]);\n\n  if (s[0] === 0) {\n    s = s.slice(1);\n  }\n\n  s = s.toString(\"hex\");\n  return {\n    v,\n    r,\n    s,\n  };\n}\n","import { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\n/**\n * This implements \"Merkelized Maps\", documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/merkle.md#merkleized-maps\n *\n * A merkelized map consist of two merkle trees, one for the keys of\n * a map and one for the values of the same map, thus the two merkle\n * trees have the same shape. The commitment is the number elements\n * in the map followed by the keys' merkle root followed by the\n * values' merkle root.\n */\nexport class MerkleMap {\n  keys: Buffer[];\n  keysTree: Merkle;\n  values: Buffer[];\n  valuesTree: Merkle;\n  /**\n   * @param keys Sorted list of (unhashed) keys\n   * @param values values, in corresponding order as the keys, and of equal length\n   */\n  constructor(keys: Buffer[], values: Buffer[]) {\n    if (keys.length != values.length) {\n      throw new Error(\"keys and values should have the same length\");\n    }\n\n    // Sanity check: verify that keys are actually sorted and with no duplicates\n    for (let i = 0; i < keys.length - 1; i++) {\n      if (keys[i].toString(\"hex\") >= keys[i + 1].toString(\"hex\")) {\n        throw new Error(\"keys must be in strictly increasing order\");\n      }\n    }\n\n    this.keys = keys;\n    this.keysTree = new Merkle(keys.map(k => hashLeaf(k)));\n    this.values = values;\n    this.valuesTree = new Merkle(values.map(v => hashLeaf(v)));\n  }\n\n  commitment(): Buffer {\n    // returns a buffer between 65 and 73 (included) bytes long\n    return Buffer.concat([\n      createVarint(this.keys.length),\n      this.keysTree.getRoot(),\n      this.valuesTree.getRoot(),\n    ]);\n  }\n}\n","import { MerkleMap } from \"./merkleMap\";\nimport { PsbtV2 } from \"./psbtv2\";\n\n/**\n * This class merkelizes a PSBTv2, by merkelizing the different\n * maps of the psbt. This is used during the transaction signing process,\n * where the hardware app can request specific parts of the psbt from the\n * client code and be sure that the response data actually belong to the psbt.\n * The reason for this is the limited amount of memory available to the app,\n * so it can't always store the full psbt in memory.\n *\n * The signing process is documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md#sign_psbt\n */\nexport class MerkelizedPsbt extends PsbtV2 {\n  public globalMerkleMap: MerkleMap;\n  public inputMerkleMaps: MerkleMap[] = [];\n  public outputMerkleMaps: MerkleMap[] = [];\n  public inputMapCommitments: Buffer[];\n  public outputMapCommitments: Buffer[];\n  constructor(psbt: PsbtV2) {\n    super();\n    psbt.copy(this);\n    this.globalMerkleMap = MerkelizedPsbt.createMerkleMap(this.globalMap);\n\n    for (let i = 0; i < this.getGlobalInputCount(); i++) {\n      this.inputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.inputMaps[i]));\n    }\n    this.inputMapCommitments = [...this.inputMerkleMaps.values()].map(v => v.commitment());\n\n    for (let i = 0; i < this.getGlobalOutputCount(); i++) {\n      this.outputMerkleMaps.push(MerkelizedPsbt.createMerkleMap(this.outputMaps[i]));\n    }\n    this.outputMapCommitments = [...this.outputMerkleMaps.values()].map(v => v.commitment());\n  }\n  // These public functions are for MerkelizedPsbt.\n  getGlobalSize(): number {\n    return this.globalMap.size;\n  }\n  getGlobalKeysValuesRoot(): Buffer {\n    return this.globalMerkleMap.commitment();\n  }\n\n  private static createMerkleMap(map: Map<string, Buffer>): MerkleMap {\n    const sortedKeysStrings = [...map.keys()].sort();\n    const values = sortedKeysStrings.map(k => {\n      const v = map.get(k);\n      if (!v) {\n        throw new Error(\"No value for key \" + k);\n      }\n      return v;\n    });\n    const sortedKeys = sortedKeysStrings.map(k => Buffer.from(k, \"hex\"));\n\n    const merkleMap = new MerkleMap(sortedKeys, values);\n    return merkleMap;\n  }\n}\n","import { crypto } from \"bitcoinjs-lib\";\nimport { BufferReader } from \"../buffertools\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\nimport { MerkleMap } from \"./merkleMap\";\n\nenum ClientCommandCode {\n  YIELD = 0x10,\n  GET_PREIMAGE = 0x40,\n  GET_MERKLE_LEAF_PROOF = 0x41,\n  GET_MERKLE_LEAF_INDEX = 0x42,\n  GET_MORE_ELEMENTS = 0xa0,\n}\n\nabstract class ClientCommand {\n  abstract code: ClientCommandCode;\n  abstract execute(request: Buffer): Buffer;\n}\n\nexport class YieldCommand extends ClientCommand {\n  private results: Buffer[];\n\n  code = ClientCommandCode.YIELD;\n\n  constructor(\n    results: Buffer[],\n    private progressCallback: () => void,\n  ) {\n    super();\n    this.results = results;\n  }\n\n  execute(request: Buffer): Buffer {\n    this.results.push(Buffer.from(request.subarray(1)));\n    this.progressCallback();\n    return Buffer.from(\"\");\n  }\n}\n\nexport class GetPreimageCommand extends ClientCommand {\n  private known_preimages: Map<string, Buffer>;\n  private queue: Buffer[];\n\n  code = ClientCommandCode.GET_PREIMAGE;\n\n  constructor(known_preimages: Map<string, Buffer>, queue: Buffer[]) {\n    super();\n    this.known_preimages = known_preimages;\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    // we expect no more data to read\n    if (req.length != 1 + 32) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    if (req[0] != 0) {\n      throw new Error(\"Unsupported request, the first byte should be 0\");\n    }\n\n    // read the hash\n    const hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      hash[i] = req[1 + i];\n    }\n    const req_hash_hex = hash.toString(\"hex\");\n\n    const known_preimage = this.known_preimages.get(req_hash_hex);\n    if (known_preimage != undefined) {\n      const preimage_len_varint = createVarint(known_preimage.length);\n\n      // We can send at most 255 - len(preimage_len_out) - 1 bytes in a single message;\n      // the rest will be stored in the queue for GET_MORE_ELEMENTS\n      const max_payload_size = 255 - preimage_len_varint.length - 1;\n\n      const payload_size = Math.min(max_payload_size, known_preimage.length);\n\n      if (payload_size < known_preimage.length) {\n        for (let i = payload_size; i < known_preimage.length; i++) {\n          this.queue.push(Buffer.from([known_preimage[i]]));\n        }\n      }\n\n      return Buffer.concat([\n        preimage_len_varint,\n        Buffer.from([payload_size]),\n        Buffer.from(known_preimage.subarray(0, payload_size)),\n      ]);\n    }\n\n    throw Error(`Requested unknown preimage for: ${req_hash_hex}`);\n  }\n}\n\nexport class GetMerkleLeafProofCommand extends ClientCommand {\n  private known_trees: Map<string, Merkle>;\n  private queue: Buffer[];\n\n  code = ClientCommandCode.GET_MERKLE_LEAF_PROOF;\n\n  constructor(known_trees: Map<string, Merkle>, queue: Buffer[]) {\n    super();\n    this.known_trees = known_trees;\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    if (req.length < 32 + 1 + 1) {\n      throw new Error(\"Invalid request, expected at least 34 bytes\");\n    }\n\n    const reqBuf = new BufferReader(req);\n    const hash = reqBuf.readSlice(32);\n    const hash_hex = hash.toString(\"hex\");\n\n    let tree_size;\n    let leaf_index;\n    try {\n      tree_size = reqBuf.readVarInt();\n      leaf_index = reqBuf.readVarInt();\n    } catch (e: any) {\n      throw new Error(\"Invalid request, couldn't parse tree_size or leaf_index\");\n    }\n\n    const mt = this.known_trees.get(hash_hex);\n    if (!mt) {\n      throw Error(`Requested Merkle leaf proof for unknown tree: ${hash_hex}`);\n    }\n\n    if (leaf_index >= tree_size || mt.size() != tree_size) {\n      throw Error(\"Invalid index or tree size.\");\n    }\n\n    if (this.queue.length != 0) {\n      throw Error(\"This command should not execute when the queue is not empty.\");\n    }\n\n    const proof = mt.getProof(leaf_index);\n\n    const n_response_elements = Math.min(Math.floor((255 - 32 - 1 - 1) / 32), proof.length);\n    const n_leftover_elements = proof.length - n_response_elements;\n\n    // Add to the queue any proof elements that do not fit the response\n    if (n_leftover_elements > 0) {\n      this.queue.push(...proof.slice(-n_leftover_elements));\n    }\n\n    return Buffer.concat([\n      mt.getLeafHash(leaf_index),\n      Buffer.from([proof.length]),\n      Buffer.from([n_response_elements]),\n      ...proof.slice(0, n_response_elements),\n    ]);\n  }\n}\n\nexport class GetMerkleLeafIndexCommand extends ClientCommand {\n  private known_trees: Map<string, Merkle>;\n\n  code = ClientCommandCode.GET_MERKLE_LEAF_INDEX;\n\n  constructor(known_trees: Map<string, Merkle>) {\n    super();\n    this.known_trees = known_trees;\n  }\n\n  execute(request: Buffer): Buffer {\n    const req = Buffer.from(request.subarray(1));\n\n    if (req.length != 32 + 32) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    // read the root hash\n    const root_hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      root_hash[i] = req.readUInt8(i);\n    }\n    const root_hash_hex = root_hash.toString(\"hex\");\n\n    // read the leaf hash\n    const leef_hash = Buffer.alloc(32);\n    for (let i = 0; i < 32; i++) {\n      leef_hash[i] = req.readUInt8(32 + i);\n    }\n    const leef_hash_hex = leef_hash.toString(\"hex\");\n\n    const mt = this.known_trees.get(root_hash_hex);\n    if (!mt) {\n      throw Error(`Requested Merkle leaf index for unknown root: ${root_hash_hex}`);\n    }\n\n    let leaf_index = 0;\n    let found = 0;\n    for (let i = 0; i < mt.size(); i++) {\n      if (mt.getLeafHash(i).toString(\"hex\") == leef_hash_hex) {\n        found = 1;\n        leaf_index = i;\n        break;\n      }\n    }\n    return Buffer.concat([Buffer.from([found]), createVarint(leaf_index)]);\n  }\n}\n\nexport class GetMoreElementsCommand extends ClientCommand {\n  queue: Buffer[];\n\n  code = ClientCommandCode.GET_MORE_ELEMENTS;\n\n  constructor(queue: Buffer[]) {\n    super();\n    this.queue = queue;\n  }\n\n  execute(request: Buffer): Buffer {\n    if (request.length != 1) {\n      throw new Error(\"Invalid request, unexpected trailing data\");\n    }\n\n    if (this.queue.length === 0) {\n      throw new Error(\"No elements to get\");\n    }\n\n    // all elements should have the same length\n    const element_len = this.queue[0].length;\n    if (this.queue.some(el => el.length != element_len)) {\n      throw new Error(\n        \"The queue contains elements with different byte length, which is not expected\",\n      );\n    }\n\n    const max_elements = Math.floor(253 / element_len);\n    const n_returned_elements = Math.min(max_elements, this.queue.length);\n\n    const returned_elements = this.queue.splice(0, n_returned_elements);\n\n    return Buffer.concat([\n      Buffer.from([n_returned_elements]),\n      Buffer.from([element_len]),\n      ...returned_elements,\n    ]);\n  }\n}\n\n/**\n * This class will dispatch a client command coming from the hardware device to\n * the appropriate client command implementation. Those client commands\n * typically requests data from a merkle tree or merkelized maps.\n *\n * A ClientCommandInterpreter is prepared by adding the merkle trees and\n * merkelized maps it should be able to serve to the hardware device. This class\n * doesn't know anything about the semantics of the data it holds, it just\n * serves merkle data. It doesn't even know in what context it is being\n * executed, ie SignPsbt, getWalletAddress, etc.\n *\n * If the command yelds results to the client, as signPsbt does, the yielded\n * data will be accessible after the command completed by calling getYielded(),\n * which will return the yields in the same order as they came in.\n */\nexport class ClientCommandInterpreter {\n  private roots: Map<string, Merkle> = new Map();\n  private preimages: Map<string, Buffer> = new Map();\n\n  private yielded: Buffer[] = [];\n\n  private queue: Buffer[] = [];\n\n  private commands: Map<ClientCommandCode, ClientCommand> = new Map();\n\n  constructor(progressCallback: () => void) {\n    const commands = [\n      new YieldCommand(this.yielded, progressCallback),\n      new GetPreimageCommand(this.preimages, this.queue),\n      new GetMerkleLeafIndexCommand(this.roots),\n      new GetMerkleLeafProofCommand(this.roots, this.queue),\n      new GetMoreElementsCommand(this.queue),\n    ];\n\n    for (const cmd of commands) {\n      if (this.commands.has(cmd.code)) {\n        throw new Error(`Multiple commands with code ${cmd.code}`);\n      }\n      this.commands.set(cmd.code, cmd);\n    }\n  }\n\n  getYielded(): Buffer[] {\n    return this.yielded;\n  }\n\n  addKnownPreimage(preimage: Buffer): void {\n    this.preimages.set(crypto.sha256(preimage).toString(\"hex\"), preimage);\n  }\n\n  addKnownList(elements: Buffer[]): void {\n    for (const el of elements) {\n      const preimage = Buffer.concat([Buffer.from([0]), el]);\n      this.addKnownPreimage(preimage);\n    }\n    const mt = new Merkle(elements.map(el => hashLeaf(el)));\n    this.roots.set(mt.getRoot().toString(\"hex\"), mt);\n  }\n\n  addKnownMapping(mm: MerkleMap): void {\n    this.addKnownList(mm.keys);\n    this.addKnownList(mm.values);\n  }\n\n  execute(request: Buffer): Buffer {\n    if (request.length == 0) {\n      throw new Error(\"Unexpected empty command\");\n    }\n\n    const cmdCode = request[0];\n    const cmd = this.commands.get(cmdCode);\n    if (!cmd) {\n      throw new Error(`Unexpected command code ${cmdCode}`);\n    }\n\n    return cmd.execute(request);\n  }\n}\n","import Transport from \"@ledgerhq/hw-transport\";\nimport { pathElementsToBuffer } from \"../bip32\";\nimport { PsbtV2 } from \"./psbtv2\";\nimport { MerkelizedPsbt } from \"./merkelizedPsbt\";\nimport { ClientCommandInterpreter } from \"./clientCommands\";\nimport { WalletPolicy } from \"./policy\";\nimport { createVarint } from \"../varint\";\nimport { hashLeaf, Merkle } from \"./merkle\";\n\nconst CLA_BTC = 0xe1;\nconst CLA_FRAMEWORK = 0xf8;\n\nenum BitcoinIns {\n  GET_PUBKEY = 0x00,\n  // GET_ADDRESS = 0x01, // Removed from app\n  REGISTER_WALLET = 0x02,\n  GET_WALLET_ADDRESS = 0x03,\n  SIGN_PSBT = 0x04,\n  GET_MASTER_FINGERPRINT = 0x05,\n  SIGN_MESSAGE = 0x10,\n}\n\nenum FrameworkIns {\n  CONTINUE_INTERRUPTED = 0x01,\n}\n\n/**\n * This class encapsulates the APDU protocol documented at\n * https://github.com/LedgerHQ/app-bitcoin-new/blob/master/doc/bitcoin.md\n */\nexport class AppClient {\n  transport: Transport;\n\n  constructor(transport: Transport) {\n    this.transport = transport;\n  }\n\n  private async makeRequest(\n    ins: BitcoinIns,\n    data: Buffer,\n    cci?: ClientCommandInterpreter,\n  ): Promise<Buffer> {\n    let response: Buffer = await this.transport.send(CLA_BTC, ins, 0, 0, data, [0x9000, 0xe000]);\n    while (response.readUInt16BE(response.length - 2) === 0xe000) {\n      if (!cci) {\n        throw new Error(\"Unexpected SW_INTERRUPTED_EXECUTION\");\n      }\n\n      const hwRequest = response.slice(0, -2);\n      const commandResponse = cci.execute(hwRequest);\n\n      response = await this.transport.send(\n        CLA_FRAMEWORK,\n        FrameworkIns.CONTINUE_INTERRUPTED,\n        0,\n        0,\n        commandResponse,\n        [0x9000, 0xe000],\n      );\n    }\n    return response.slice(0, -2); // drop the status word (can only be 0x9000 at this point)\n  }\n\n  async getExtendedPubkey(display: boolean, pathElements: number[]): Promise<string> {\n    if (pathElements.length > 6) {\n      throw new Error(\"Path too long. At most 6 levels allowed.\");\n    }\n    const response = await this.makeRequest(\n      BitcoinIns.GET_PUBKEY,\n      Buffer.concat([Buffer.from(display ? [1] : [0]), pathElementsToBuffer(pathElements)]),\n    );\n    return response.toString(\"ascii\");\n  }\n\n  async getWalletAddress(\n    walletPolicy: WalletPolicy,\n    walletHMAC: Buffer | null,\n    change: number,\n    addressIndex: number,\n    display: boolean,\n  ): Promise<string> {\n    if (change !== 0 && change !== 1) throw new Error(\"Change can only be 0 or 1\");\n    if (addressIndex < 0 || !Number.isInteger(addressIndex))\n      throw new Error(\"Invalid address index\");\n\n    if (walletHMAC != null && walletHMAC.length != 32) {\n      throw new Error(\"Invalid HMAC length\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(() => {});\n    clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n    clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n\n    const addressIndexBuffer = Buffer.alloc(4);\n    addressIndexBuffer.writeUInt32BE(addressIndex, 0);\n\n    const response = await this.makeRequest(\n      BitcoinIns.GET_WALLET_ADDRESS,\n      Buffer.concat([\n        Buffer.from(display ? [1] : [0]),\n        walletPolicy.getWalletId(),\n        walletHMAC || Buffer.alloc(32, 0),\n        Buffer.from([change]),\n        addressIndexBuffer,\n      ]),\n      clientInterpreter,\n    );\n\n    return response.toString(\"ascii\");\n  }\n\n  async signPsbt(\n    psbt: PsbtV2,\n    walletPolicy: WalletPolicy,\n    walletHMAC: Buffer | null,\n    progressCallback: () => void,\n  ): Promise<Map<number, Buffer>> {\n    const merkelizedPsbt = new MerkelizedPsbt(psbt);\n\n    if (walletHMAC != null && walletHMAC.length != 32) {\n      throw new Error(\"Invalid HMAC length\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(progressCallback);\n\n    // prepare ClientCommandInterpreter\n    clientInterpreter.addKnownList(walletPolicy.keys.map(k => Buffer.from(k, \"ascii\")));\n    clientInterpreter.addKnownPreimage(walletPolicy.serialize());\n\n    clientInterpreter.addKnownMapping(merkelizedPsbt.globalMerkleMap);\n    for (const map of merkelizedPsbt.inputMerkleMaps) {\n      clientInterpreter.addKnownMapping(map);\n    }\n    for (const map of merkelizedPsbt.outputMerkleMaps) {\n      clientInterpreter.addKnownMapping(map);\n    }\n\n    clientInterpreter.addKnownList(merkelizedPsbt.inputMapCommitments);\n    const inputMapsRoot = new Merkle(\n      merkelizedPsbt.inputMapCommitments.map(m => hashLeaf(m)),\n    ).getRoot();\n    clientInterpreter.addKnownList(merkelizedPsbt.outputMapCommitments);\n    const outputMapsRoot = new Merkle(\n      merkelizedPsbt.outputMapCommitments.map(m => hashLeaf(m)),\n    ).getRoot();\n\n    await this.makeRequest(\n      BitcoinIns.SIGN_PSBT,\n      Buffer.concat([\n        merkelizedPsbt.getGlobalKeysValuesRoot(),\n        createVarint(merkelizedPsbt.getGlobalInputCount()),\n        inputMapsRoot,\n        createVarint(merkelizedPsbt.getGlobalOutputCount()),\n        outputMapsRoot,\n        walletPolicy.getWalletId(),\n        walletHMAC || Buffer.alloc(32, 0),\n      ]),\n      clientInterpreter,\n    );\n\n    const yielded = clientInterpreter.getYielded();\n\n    const ret: Map<number, Buffer> = new Map();\n    for (const inputAndSig of yielded) {\n      ret.set(inputAndSig[0], inputAndSig.slice(1));\n    }\n    return ret;\n  }\n\n  async getMasterFingerprint(): Promise<Buffer> {\n    return this.makeRequest(BitcoinIns.GET_MASTER_FINGERPRINT, Buffer.from([]));\n  }\n\n  async signMessage(message: Buffer, pathElements: number[]): Promise<string> {\n    if (pathElements.length > 6) {\n      throw new Error(\"Path too long. At most 6 levels allowed.\");\n    }\n\n    const clientInterpreter = new ClientCommandInterpreter(() => {});\n\n    // prepare ClientCommandInterpreter\n    const nChunks = Math.ceil(message.length / 64);\n    const chunks: Buffer[] = [];\n    for (let i = 0; i < nChunks; i++) {\n      chunks.push(message.subarray(64 * i, 64 * i + 64));\n    }\n\n    clientInterpreter.addKnownList(chunks);\n    const chunksRoot = new Merkle(chunks.map(m => hashLeaf(m))).getRoot();\n\n    const response = await this.makeRequest(\n      BitcoinIns.SIGN_MESSAGE,\n      Buffer.concat([pathElementsToBuffer(pathElements), createVarint(message.length), chunksRoot]),\n      clientInterpreter,\n    );\n\n    return response.toString(\"base64\");\n  }\n}\n","import type { Transaction } from \"./types\";\nexport function formatTransactionDebug(transaction: Transaction): string {\n  let str = \"TX\";\n  str += \" version \" + transaction.version.toString(\"hex\");\n\n  if (transaction.locktime) {\n    str += \" locktime \" + transaction.locktime.toString(\"hex\");\n  }\n\n  if (transaction.witness) {\n    str += \" witness \" + transaction.witness.toString(\"hex\");\n  }\n\n  if (transaction.timestamp) {\n    str += \" timestamp \" + transaction.timestamp.toString(\"hex\");\n  }\n\n  if (transaction.nVersionGroupId) {\n    str += \" nVersionGroupId \" + transaction.nVersionGroupId.toString(\"hex\");\n  }\n\n  if (transaction.nExpiryHeight) {\n    str += \" nExpiryHeight \" + transaction.nExpiryHeight.toString(\"hex\");\n  }\n\n  if (transaction.extraData) {\n    str += \" extraData \" + transaction.extraData.toString(\"hex\");\n  }\n\n  transaction.inputs.forEach(({ prevout, script, sequence }, i) => {\n    str += `\\ninput ${i}:`;\n    str += ` prevout ${prevout.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n    str += ` sequence ${sequence.toString(\"hex\")}`;\n  });\n  (transaction.outputs || []).forEach(({ amount, script }, i) => {\n    str += `\\noutput ${i}:`;\n    str += ` amount ${amount.toString(\"hex\")}`;\n    str += ` script ${script.toString(\"hex\")}`;\n  });\n  return str;\n}\nexport function displayTransactionDebug(transaction: Transaction): void {\n  console.log(formatTransactionDebug(transaction));\n}\n","import type Transport from \"@ledgerhq/hw-transport\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { startUntrustedHashTransactionInput } from \"./startUntrustedHashTransactionInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport { signTransaction } from \"./signTransaction\";\nimport { hashOutputFull } from \"./finalizeInput\";\nimport type { TransactionOutput, Transaction, TrustedInput } from \"./types\";\nimport { DEFAULT_LOCKTIME, DEFAULT_VERSION, DEFAULT_SEQUENCE, SIGHASH_ALL } from \"./constants\";\nconst defaultArg = {\n  lockTime: DEFAULT_LOCKTIME,\n  sigHashType: SIGHASH_ALL,\n  segwit: false,\n  transactionVersion: DEFAULT_VERSION,\n};\n\n/**\n *\n */\nexport type SignP2SHTransactionArg = {\n  inputs: Array<[Transaction, number, string | null | undefined, number | null | undefined]>;\n  associatedKeysets: string[];\n  outputScriptHex: string;\n  lockTime?: number;\n  sigHashType?: number;\n  segwit?: boolean;\n  transactionVersion?: number;\n};\nexport async function signP2SHTransaction(transport: Transport, arg: SignP2SHTransactionArg) {\n  const {\n    inputs,\n    associatedKeysets,\n    outputScriptHex,\n    lockTime,\n    sigHashType,\n    segwit,\n    transactionVersion,\n  } = { ...defaultArg, ...arg };\n  // Inputs are provided as arrays of [transaction, output_index, redeem script, optional sequence]\n  // associatedKeysets are provided as arrays of [path]\n  const nullScript = Buffer.alloc(0);\n  const nullPrevout = Buffer.alloc(0);\n  const defaultVersion = Buffer.alloc(4);\n  defaultVersion.writeUInt32LE(transactionVersion, 0);\n  const trustedInputs: TrustedInput[] = [];\n  const regularOutputs: Array<TransactionOutput> = [];\n  const signatures: string[] = [];\n  let firstRun = true;\n  const resuming = false;\n  const targetTransaction: Transaction = {\n    inputs: [],\n    version: defaultVersion,\n  };\n  const getTrustedInputCall = segwit ? getTrustedInputBIP143 : getTrustedInput;\n  const outputScript = Buffer.from(outputScriptHex, \"hex\");\n\n  for (const input of inputs) {\n    if (!resuming) {\n      const trustedInput = await getTrustedInputCall(transport, input[1], input[0]);\n      const sequence = Buffer.alloc(4);\n      sequence.writeUInt32LE(\n        input.length >= 4 && typeof input[3] === \"number\" ? input[3] : DEFAULT_SEQUENCE,\n        0,\n      );\n      trustedInputs.push({\n        trustedInput: false,\n        value: segwit\n          ? Buffer.from(trustedInput, \"hex\")\n          : Buffer.from(trustedInput, \"hex\").slice(4, 4 + 0x24),\n        sequence,\n      });\n    }\n\n    const { outputs } = input[0];\n    const index = input[1];\n\n    if (outputs && index <= outputs.length - 1) {\n      regularOutputs.push(outputs[index]);\n    }\n  }\n\n  // Pre-build the target transaction\n  for (let i = 0; i < inputs.length; i++) {\n    const sequence = Buffer.alloc(4);\n    sequence.writeUInt32LE(\n      inputs[i].length >= 4 && typeof inputs[i][3] === \"number\"\n        ? (inputs[i][3] as number)\n        : DEFAULT_SEQUENCE,\n      0,\n    );\n    targetTransaction.inputs.push({\n      script: nullScript,\n      prevout: nullPrevout,\n      sequence,\n    });\n  }\n\n  if (segwit) {\n    await startUntrustedHashTransactionInput(\n      transport,\n      true,\n      targetTransaction,\n      trustedInputs,\n      true,\n    );\n    await hashOutputFull(transport, outputScript);\n  }\n\n  for (let i = 0; i < inputs.length; i++) {\n    const input = inputs[i];\n    const script =\n      inputs[i].length >= 3 && typeof input[2] === \"string\"\n        ? Buffer.from(input[2], \"hex\")\n        : regularOutputs[i].script;\n    const pseudoTX = Object.assign({}, targetTransaction);\n    const pseudoTrustedInputs = segwit ? [trustedInputs[i]] : trustedInputs;\n\n    if (segwit) {\n      pseudoTX.inputs = [{ ...pseudoTX.inputs[i], script }];\n    } else {\n      pseudoTX.inputs[i].script = script;\n    }\n\n    await startUntrustedHashTransactionInput(\n      transport,\n      !segwit && firstRun,\n      pseudoTX,\n      pseudoTrustedInputs,\n      segwit,\n    );\n\n    if (!segwit) {\n      await hashOutputFull(transport, outputScript);\n    }\n\n    const signature = await signTransaction(transport, associatedKeysets[i], lockTime, sigHashType);\n    signatures.push(\n      segwit ? signature.toString(\"hex\") : signature.slice(0, signature.length - 1).toString(\"hex\"),\n    );\n    targetTransaction.inputs[i].script = nullScript;\n\n    if (firstRun) {\n      firstRun = false;\n    }\n  }\n\n  return signatures;\n}\n","import semver from \"semver\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport BtcNew from \"./BtcNew\";\nimport BtcOld from \"./BtcOld\";\nimport type { CreateTransactionArg } from \"./createTransaction\";\nimport { getTrustedInput } from \"./getTrustedInput\";\nimport { getTrustedInputBIP143 } from \"./getTrustedInputBIP143\";\nimport type { AddressFormat } from \"./getWalletPublicKey\";\nimport { AppClient } from \"./newops/appClient\";\nimport { serializeTransactionOutputs } from \"./serializeTransaction\";\nimport type { SignP2SHTransactionArg } from \"./signP2SHTransaction\";\nimport { splitTransaction } from \"./splitTransaction\";\nimport type { Transaction } from \"./types\";\nexport type { AddressFormat };\nimport { signP2SHTransaction } from \"./signP2SHTransaction\";\nimport { checkIsBtcLegacy, getAppAndVersion } from \"./getAppAndVersion\";\n\n/**\n * @class Btc\n * @description Bitcoin API.\n * @param transport The transport layer used for communication.\n * @param scrambleKey This parameter is deprecated and no longer needed.\n * @param currency The currency to use, defaults to \"bitcoin\".\n * @example\n * import Btc from \"@ledgerhq/hw-app-btc\";\n * const btc = new Btc({ transport, currency: \"bitcoin\" });\n */\n\nexport default class Btc {\n  // Transport instance\n  private _transport: Transport;\n  // The specific implementation used, determined by the nano app and its version.\n  // It chooses between BtcNew (new interface) and BtcOld (old interface).\n  private _impl: BtcOld | BtcNew;\n  constructor({\n    transport,\n    scrambleKey = \"BTC\",\n    currency = \"bitcoin\",\n  }: {\n    transport: Transport;\n    scrambleKey?: string;\n    currency?: string;\n  }) {\n    this._transport = transport;\n    this._transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getWalletXpub\",\n        \"getWalletPublicKey\",\n        \"signP2SHTransaction\",\n        \"signMessage\",\n        \"createPaymentTransaction\",\n        \"getTrustedInput\",\n        \"getTrustedInputBIP143\",\n      ],\n      scrambleKey,\n    );\n\n    this._impl = (() => {\n      switch (currency) {\n        case \"bitcoin\":\n        case \"bitcoin_testnet\":\n        case \"qtum\":\n          // new APDU (nano app API) for currencies using app-bitcoin-new implementation\n          return new BtcNew(new AppClient(this._transport));\n        default:\n          // old APDU (legacy API) for currencies using legacy bitcoin app implementation\n          return new BtcOld(this._transport);\n      }\n    })();\n  }\n\n  /**\n   * Get an XPUB with a ledger device\n   * @param arg derivation parameter\n   * - path: a BIP 32 path of the account level. (e.g. The derivation path `84'/0'/0'`\n   * follows the `purpose' / coin_type' / account'` standard, with purpose=84, coin_type=0, account=0)\n   * - xpubVersion: the XPUBVersion of the coin used. (refer to ledgerjs/packages/cryptoassets/src/currencies.ts\n   * for the XPUBVersion value if needed)\n   * @returns XPUB of the account\n   */\n  getWalletXpub(arg: { path: string; xpubVersion: number }): Promise<string> {\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.getWalletXpub(arg);\n    });\n  }\n\n  /**\n   * @param path a BIP 32 path (i.e. the `purpose / coin_type / account / change / address_index` standard)\n   * @param options an object with optional these fields:\n   *\n   * - verify (boolean) whether ask user to confirm the address on the device\n   *\n   * - format (\"legacy\" | \"p2sh\" | \"bech32\" | \"bech32m\" | \"cashaddr\") to use different bitcoin address formatter.\n   *\n   * NB The normal usage is to use:\n   *\n   * - legacy format with 44' paths\n   *\n   * - p2sh format with 49' paths\n   *\n   * - bech32 format with 84' paths\n   *\n   * - bech32m format with 86' paths\n   *\n   * - cashaddr in case of Bitcoin Cash\n   *\n   * @example\n   * btc.getWalletPublicKey(\"44'/0'/0'/0/0\").then(o => o.bitcoinAddress)\n   * btc.getWalletPublicKey(\"49'/0'/0'/0/0\", { format: \"p2sh\" }).then(o => o.bitcoinAddress)\n   */\n  getWalletPublicKey(\n    path: string,\n    opts?: {\n      verify?: boolean;\n      format?: AddressFormat;\n    },\n  ): Promise<{\n    publicKey: string;\n    bitcoinAddress: string;\n    chainCode: string;\n  }> {\n    let options;\n    if (arguments.length > 2 || typeof opts === \"boolean\") {\n      console.warn(\n        \"btc.getWalletPublicKey deprecated signature used. Please switch to getWalletPublicKey(path, { format, verify })\",\n      );\n      options = {\n        verify: !!opts,\n        // eslint-disable-next-line prefer-rest-params\n        format: arguments[2] ? \"p2sh\" : \"legacy\",\n      };\n    } else {\n      options = opts || {};\n    }\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.getWalletPublicKey(path, options);\n    });\n  }\n\n  /**\n   * You can sign a message according to the Bitcoin Signature format and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n   * @example\n   btc.signMessage(\"44'/60'/0'/0'/0\", Buffer.from(\"test\").toString(\"hex\")).then(function(result) {\n     var v = result['v'] + 27 + 4;\n     var signature = Buffer.from(v.toString(16) + result['r'] + result['s'], 'hex').toString('base64');\n     console.log(\"Signature : \" + signature);\n   }).catch(function(ex) {console.log(ex);});\n   */\n  signMessage(\n    path: string,\n    messageHex: string,\n  ): Promise<{\n    v: number;\n    r: string;\n    s: string;\n  }> {\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.signMessage({\n        path,\n        messageHex,\n      });\n    });\n  }\n\n  /**\n   * To sign a transaction involving standard (P2PKH) inputs, call createTransaction with the following parameters\n   * @param inputs is an array of [ transaction, output_index, optional redeem script, optional sequence ] where\n   *\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the optional redeem script to use when consuming a Segregated Witness input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param changePath is an optional BIP 32 path pointing to the path to the public key used to compute the change address\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign, including leading vararg voutCount\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @param segwit is an optional boolean indicating wether to use segwit or not. This includes wrapped segwit.\n   * @param initialTimestamp is an optional timestamp of the function call to use for coins that necessitate timestamps only, (not the one that the tx will include)\n   * @param additionals list of additionnal options\n   *\n   * - \"bech32\" for spending native segwit outputs\n   * - \"bech32m\" for spending segwit v1+ outputs\n   * - \"abc\" for bch\n   * - \"gold\" for btg\n   * - \"decred\" for decred\n   * - \"zcash\" for zcash\n   * - \"bipxxx\" for using BIPxxx\n   * - \"sapling\" to indicate a zec transaction is supporting sapling (to be set over block 419200)\n   * @param expiryHeight is an optional Buffer for zec overwinter / sapling Txs\n   * @param useTrustedInputForSegwit trust inputs for segwit transactions. If app version >= 1.4.0 this should be true.\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.createTransaction({\n   inputs: [ [tx1, 1] ],\n   associatedKeysets: [\"0'/0/0\"],\n   outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(res => ...);\n   */\n  createPaymentTransaction(arg: CreateTransactionArg): Promise<string> {\n    if (arguments.length > 1) {\n      throw new Error(\n        \"@ledgerhq/hw-app-btc: createPaymentTransaction multi argument signature is deprecated. please switch to named parameters.\",\n      );\n    }\n    return this.changeImplIfNecessary().then(impl => {\n      return impl.createPaymentTransaction(arg);\n    });\n  }\n\n  /**\n   * To obtain the signature of multisignature (P2SH) inputs, call signP2SHTransaction_async with the folowing parameters\n   * @param inputs is an array of [ transaction, output_index, redeem script, optional sequence ] where\n   * * transaction is the previously computed transaction object for this UTXO\n   * * output_index is the output in the transaction used as input for this UTXO (counting from 0)\n   * * redeem script is the mandatory redeem script associated to the current P2SH input\n   * * sequence is the sequence number to use for this input (when using RBF), or non present\n   * @param associatedKeysets is an array of BIP 32 paths pointing to the path to the private key used for each UTXO\n   * @param outputScriptHex is the hexadecimal serialized outputs of the transaction to sign\n   * @param lockTime is the optional lockTime of the transaction to sign, or default (0)\n   * @param sigHashType is the hash type of the transaction to sign, or default (all)\n   * @return the signed transaction ready to be broadcast\n   * @example\n  btc.signP2SHTransaction({\n  inputs: [ [tx, 1, \"52210289b4a3ad52a919abd2bdd6920d8a6879b1e788c38aa76f0440a6f32a9f1996d02103a3393b1439d1693b063482c04bd40142db97bdf139eedd1b51ffb7070a37eac321030b9a409a1e476b0d5d17b804fcdb81cf30f9b99c6f3ae1178206e08bc500639853ae\"] ],\n  associatedKeysets: [\"0'/0/0\"],\n  outputScriptHex: \"01905f0100000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88ac\"\n  }).then(result => ...);\n   */\n  signP2SHTransaction(arg: SignP2SHTransactionArg): Promise<string[]> {\n    return signP2SHTransaction(this._transport, arg);\n  }\n\n  /**\n   * For each UTXO included in your transaction, create a transaction object from the raw serialized version of the transaction used in this UTXO.\n   * @param transactionHex a raw hexadecimal serialized transaction\n   * @param isSegwitSupported is a boolean indicating if the segwit is supported\n   * @param hasTimestamp is a boolean (peercoin includes timestamp in their transactions, others don't)\n   * @param hasExtraData is a boolean (komodo, zencash and zcash include extraData in their transactions, others don't)\n   * @param additionals list of additionnal options\n   * @return the transaction object deserialized from the raw hexadecimal transaction\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n   */\n  splitTransaction(\n    transactionHex: string,\n    isSegwitSupported: boolean | null | undefined = false,\n    hasTimestamp = false,\n    hasExtraData = false,\n    additionals: Array<string> = [],\n  ): Transaction {\n    return splitTransaction(\n      transactionHex,\n      isSegwitSupported,\n      hasTimestamp,\n      hasExtraData,\n      additionals,\n    );\n  }\n\n  /**\n   * Serialize a transaction's outputs to hexadecimal\n   * @example\n  const tx1 = btc.splitTransaction(\"01000000014ea60aeac5252c14291d428915bd7ccd1bfc4af009f4d4dc57ae597ed0420b71010000008a47304402201f36a12c240dbf9e566bc04321050b1984cd6eaf6caee8f02bb0bfec08e3354b022012ee2aeadcbbfd1e92959f57c15c1c6debb757b798451b104665aa3010569b49014104090b15bde569386734abf2a2b99f9ca6a50656627e77de663ca7325702769986cf26cc9dd7fdea0af432c8e2becc867c932e1b9dd742f2a108997c2252e2bdebffffffff0281b72e00000000001976a91472a5d75c8d2d0565b656a5232703b167d50d5a2b88aca0860100000000001976a9144533f5fb9b4817f713c48f0bfe96b9f50c476c9b88ac00000000\");\n  const outputScript = btc.serializeTransactionOutputs(tx1).toString('hex');\n  */\n  serializeTransactionOutputs(t: Transaction): Buffer {\n    return serializeTransactionOutputs(t);\n  }\n\n  /**\n   * Trusted input is the hash of a UTXO that needs to be signed\n   * For Legacy transactions, the app has some APDUs flows that do the amount check for an UTXO,\n   * by parsing the transaction that created this UTXO\n   */\n  getTrustedInput(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = [],\n  ): Promise<string> {\n    return getTrustedInput(this._transport, indexLookup, transaction, additionals);\n  }\n\n  /**\n   * Trusted input is the hash of a UTXO that needs to be signed. BIP143 is used for Segwit inputs.\n   */\n  getTrustedInputBIP143(\n    indexLookup: number,\n    transaction: Transaction,\n    additionals: Array<string> = [],\n  ): string {\n    return getTrustedInputBIP143(this._transport, indexLookup, transaction, additionals);\n  }\n\n  async changeImplIfNecessary(): Promise<BtcOld | BtcNew> {\n    // if BtcOld was instantiated, stick with it\n    if (this._impl instanceof BtcOld) return this._impl;\n\n    const { name, version } = await getAppAndVersion(this._transport);\n\n    const isBtcLegacy = await (async () => {\n      switch (name) {\n        case \"Bitcoin\":\n        case \"Bitcoin Test\": {\n          // we use the legacy protocol for versions below 2.1.0 of the Bitcoin app.\n          return semver.lt(version, \"2.1.0\");\n        }\n        case \"Bitcoin Legacy\":\n        case \"Bitcoin Test Legacy\":\n          // the \"Bitcoin Legacy\" and \"Bitcoin Testnet Legacy\" app use the legacy protocol, regardless of the version\n          return true;\n        case \"Exchange\":\n          // We can't query the version of the Bitcoin app if we're coming from Exchange;\n          // therefore, we use a workaround to distinguish legacy and new versions.\n          // This can be removed once Ledger Live enforces minimum bitcoin version >= 2.1.0.\n          return await checkIsBtcLegacy(this._transport);\n        case \"Qtum\":\n          // we use the legacy protocol for versions below 3.0.0 of the Qtum app.\n          return semver.lt(version, \"3.0.0\");\n        default:\n          return true;\n      }\n    })();\n\n    if (isBtcLegacy) {\n      this._impl = new BtcOld(this._transport);\n    }\n    return this._impl;\n  }\n}\n","import { log } from \"@ledgerhq/logs\";\nimport type { Transaction, TransactionInput, TransactionOutput } from \"./types\";\nimport { getVarint } from \"./varint\";\nimport { formatTransactionDebug } from \"./debug\";\nexport function splitTransaction(\n  transactionHex: string,\n  isSegwitSupported: boolean | null | undefined = false,\n  hasTimestamp = false,\n  hasExtraData = false,\n  additionals: Array<string> = [],\n): Transaction {\n  const inputs: TransactionInput[] = [];\n  const outputs: TransactionOutput[] = [];\n  let witness = false;\n  let offset = 0;\n  let timestamp = Buffer.alloc(0);\n  let nExpiryHeight = Buffer.alloc(0);\n  let nVersionGroupId = Buffer.alloc(0);\n  let extraData = Buffer.alloc(0);\n  let witnessScript, locktime;\n  const isDecred = additionals.includes(\"decred\");\n  const isZencash = additionals.includes(\"zencash\");\n  const isZcash = additionals.includes(\"zcash\");\n  const transaction = Buffer.from(transactionHex, \"hex\");\n  const version = transaction.slice(offset, offset + 4);\n  const overwinter =\n    version.equals(Buffer.from([0x03, 0x00, 0x00, 0x80])) ||\n    version.equals(Buffer.from([0x04, 0x00, 0x00, 0x80])) ||\n    version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n  const isZcashv5 = isZcash && version.equals(Buffer.from([0x05, 0x00, 0x00, 0x80]));\n  offset += 4;\n  if (\n    !hasTimestamp &&\n    isSegwitSupported &&\n    transaction[offset] === 0 &&\n    transaction[offset + 1] !== 0 &&\n    !isZencash\n  ) {\n    offset += 2;\n    witness = true;\n  }\n\n  if (hasTimestamp) {\n    timestamp = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n\n  if (overwinter) {\n    nVersionGroupId = transaction.slice(offset, 4 + offset);\n    offset += 4;\n  }\n  if (isZcashv5) {\n    locktime = transaction.slice(offset + 4, offset + 8);\n    nExpiryHeight = transaction.slice(offset + 8, offset + 12);\n    offset += 12;\n  }\n  let varint = getVarint(transaction, offset);\n  const numberInputs = varint[0];\n  offset += varint[1];\n\n  for (let i = 0; i < numberInputs; i++) {\n    const prevout = transaction.slice(offset, offset + 36);\n    offset += 36;\n    let script = Buffer.alloc(0);\n    let tree = Buffer.alloc(0);\n\n    //No script for decred, it has a witness\n    if (!isDecred) {\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n    } else {\n      //Tree field\n      tree = transaction.slice(offset, offset + 1);\n      offset += 1;\n    }\n\n    const sequence = transaction.slice(offset, offset + 4);\n    offset += 4;\n    inputs.push({\n      prevout,\n      script,\n      sequence,\n      tree,\n    });\n  }\n  varint = getVarint(transaction, offset);\n  const numberOutputs = varint[0];\n  offset += varint[1];\n  for (let i = 0; i < numberOutputs; i++) {\n    const amount = transaction.slice(offset, offset + 8);\n    offset += 8;\n\n    if (isDecred) {\n      //Script version\n      offset += 2;\n    }\n\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n    const script = transaction.slice(offset, offset + varint[0]);\n    offset += varint[0];\n    outputs.push({\n      amount,\n      script,\n    });\n  }\n\n  if (witness) {\n    witnessScript = transaction.slice(offset, -4);\n    locktime = transaction.slice(transaction.length - 4);\n  } else if (!isZcashv5) {\n    locktime = transaction.slice(offset, offset + 4);\n  }\n\n  offset += 4;\n\n  if ((overwinter || isDecred) && !isZcashv5) {\n    nExpiryHeight = transaction.slice(offset, offset + 4);\n    offset += 4;\n  }\n\n  if (hasExtraData) {\n    extraData = transaction.slice(offset);\n  }\n\n  //Get witnesses for Decred\n  if (isDecred) {\n    varint = getVarint(transaction, offset);\n    offset += varint[1];\n\n    if (varint[0] !== numberInputs) {\n      throw new Error(\"splitTransaction: incoherent number of witnesses\");\n    }\n\n    for (let i = 0; i < numberInputs; i++) {\n      //amount\n      offset += 8;\n      //block height\n      offset += 4;\n      //block index\n      offset += 4;\n      //Script size\n      varint = getVarint(transaction, offset);\n      offset += varint[1];\n      const script = transaction.slice(offset, offset + varint[0]);\n      offset += varint[0];\n      inputs[i].script = script;\n    }\n  }\n\n  const t: Transaction = {\n    version,\n    inputs,\n    outputs,\n    locktime,\n    witness: witnessScript,\n    timestamp,\n    nVersionGroupId,\n    nExpiryHeight,\n    extraData,\n  };\n  log(\"btc\", `splitTransaction ${transactionHex}:\\n${formatTransactionDebug(t)}`);\n  return t;\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types = require('./types');\nconst bech32 = require('bech32');\nconst bs58check = require('bs58check');\nconst typeforce = require('typeforce');\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst script_1 = require('./script');\nconst multisig = require('./templates/multisig');\nconst nullData = require('./templates/nulldata');\nconst pubKey = require('./templates/pubkey');\nconst pubKeyHash = require('./templates/pubkeyhash');\nconst scriptHash = require('./templates/scripthash');\nconst witnessCommitment = require('./templates/witnesscommitment');\nconst witnessPubKeyHash = require('./templates/witnesspubkeyhash');\nconst witnessScriptHash = require('./templates/witnessscripthash');\nconst types = {\n  P2MS: 'multisig',\n  NONSTANDARD: 'nonstandard',\n  NULLDATA: 'nulldata',\n  P2PK: 'pubkey',\n  P2PKH: 'pubkeyhash',\n  P2SH: 'scripthash',\n  P2WPKH: 'witnesspubkeyhash',\n  P2WSH: 'witnessscripthash',\n  WITNESS_COMMITMENT: 'witnesscommitment',\n};\nexports.types = types;\nfunction classifyOutput(script) {\n  if (witnessPubKeyHash.output.check(script)) return types.P2WPKH;\n  if (witnessScriptHash.output.check(script)) return types.P2WSH;\n  if (pubKeyHash.output.check(script)) return types.P2PKH;\n  if (scriptHash.output.check(script)) return types.P2SH;\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (multisig.output.check(chunks)) return types.P2MS;\n  if (pubKey.output.check(chunks)) return types.P2PK;\n  if (witnessCommitment.output.check(chunks)) return types.WITNESS_COMMITMENT;\n  if (nullData.output.check(chunks)) return types.NULLDATA;\n  return types.NONSTANDARD;\n}\nexports.output = classifyOutput;\nfunction classifyInput(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (pubKeyHash.input.check(chunks)) return types.P2PKH;\n  if (scriptHash.input.check(chunks, allowIncomplete)) return types.P2SH;\n  if (multisig.input.check(chunks, allowIncomplete)) return types.P2MS;\n  if (pubKey.input.check(chunks)) return types.P2PK;\n  return types.NONSTANDARD;\n}\nexports.input = classifyInput;\nfunction classifyWitness(script, allowIncomplete) {\n  // XXX: optimization, below functions .decompile before use\n  const chunks = script_1.decompile(script);\n  if (!chunks) throw new TypeError('Invalid script');\n  if (witnessPubKeyHash.input.check(chunks)) return types.P2WPKH;\n  if (witnessScriptHash.input.check(chunks, allowIncomplete))\n    return types.P2WSH;\n  return types.NONSTANDARD;\n}\nexports.witness = classifyWitness;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst createHash = require('create-hash');\nfunction ripemd160(buffer) {\n  try {\n    return createHash('rmd160')\n      .update(buffer)\n      .digest();\n  } catch (err) {\n    return createHash('ripemd160')\n      .update(buffer)\n      .digest();\n  }\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return createHash('sha1')\n    .update(buffer)\n    .digest();\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return createHash('sha256')\n    .update(buffer)\n    .digest();\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexports.hash256 = hash256;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst NETWORKS = require('./networks');\nconst types = require('./types');\nconst ecc = require('tiny-secp256k1');\nconst randomBytes = require('randombytes');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst isOptions = typeforce.maybe(\n  typeforce.compile({\n    compressed: types.maybe(types.Boolean),\n    network: types.maybe(types.Network),\n  }),\n);\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed =\n      options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n  get privateKey() {\n    return this.__D;\n  }\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0;\n      // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n      return sig;\n    }\n  }\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n}\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer))\n    throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version;\n  // list of networks?\n  if (types.Array(network)) {\n    network = network\n      .filter(x => {\n        return version === x.wif;\n      })\n      .pop();\n    if (!network) throw new Error('Unknown network version');\n    // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network,\n  });\n}\nexports.fromWIF = fromWIF;\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n  return fromPrivateKey(d, options);\n}\nexports.makeRandom = makeRandom;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip32 = require('bip32');\nexports.bip32 = bip32;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst ECPair = require('./ecpair');\nexports.ECPair = ECPair;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nexports.Block = block_1.Block;\nvar psbt_1 = require('./psbt');\nexports.Psbt = psbt_1.Psbt;\nvar script_1 = require('./script');\nexports.opcodes = script_1.OPS;\nvar transaction_1 = require('./transaction');\nexports.Transaction = transaction_1.Transaction;\nvar transaction_builder_1 = require('./transaction_builder');\nexports.TransactionBuilder = transaction_builder_1.TransactionBuilder;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.bitcoin = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bc',\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4,\n  },\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  wif: 0x80,\n};\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// output: OP_RETURN ...\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      data: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(typef.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst embed_1 = require('./embed');\nexports.embed = embed_1.p2data;\nconst p2ms_1 = require('./p2ms');\nexports.p2ms = p2ms_1.p2ms;\nconst p2pk_1 = require('./p2pk');\nexports.p2pk = p2pk_1.p2pk;\nconst p2pkh_1 = require('./p2pkh');\nexports.p2pkh = p2pkh_1.p2pkh;\nconst p2sh_1 = require('./p2sh');\nexports.p2sh = p2sh_1.p2sh;\nconst p2wpkh_1 = require('./p2wpkh');\nexports.p2wpkh = p2wpkh_1.p2wpkh;\nconst p2wsh_1 = require('./p2wsh');\nexports.p2wsh = p2wsh_1.p2wsh;\n// TODO\n// witness commitment\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst typef = require('typeforce');\nconst ecc = require('tiny-secp256k1');\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      m: typef.maybe(typef.Number),\n      n: typef.maybe(typef.Number),\n      output: typef.maybe(typef.Buffer),\n      pubkeys: typef.maybe(typef.arrayOf(ecc.isPoint)),\n      signatures: typef.maybe(typef.arrayOf(isAcceptableSignature)),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!typef.Number(chunks[0])) throw new TypeError('Output is invalid');\n      if (!typef.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => ecc.isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.Buffer),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!ecc.isPoint(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bs58check = require('bs58check');\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(25)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      input: typef.maybe(typef.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!ecc.isPoint(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst bs58check = require('bs58check');\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      output: typef.maybe(typef.BufferN(23)),\n      redeem: typef.maybe({\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        input: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.Buffer),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    return {\n      network,\n      output: chunks[chunks.length - 1],\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(20)),\n      input: typef.maybe(typef.BufferN(0)),\n      network: typef.maybe(typef.Object),\n      output: typef.maybe(typef.BufferN(22)),\n      pubkey: typef.maybe(ecc.isPoint),\n      signature: typef.maybe(bscript.isCanonicalScriptSignature),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!ecc.isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!ecc.isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst lazy = require('./lazy');\nconst typef = require('typeforce');\nconst OPS = bscript.OPS;\nconst ecc = require('tiny-secp256k1');\nconst bech32 = require('bech32');\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    ecc.isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  typef(\n    {\n      network: typef.maybe(typef.Object),\n      address: typef.maybe(typef.String),\n      hash: typef.maybe(typef.BufferN(32)),\n      output: typef.maybe(typef.BufferN(34)),\n      redeem: typef.maybe({\n        input: typef.maybe(typef.Buffer),\n        network: typef.maybe(typef.Object),\n        output: typef.maybe(typef.Buffer),\n        witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n      }),\n      input: typef.maybe(typef.BufferN(0)),\n      witness: typef.maybe(typef.arrayOf(typef.Buffer)),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined) nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty?\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst crypto_1 = require('./crypto');\nconst ecpair_1 = require('./ecpair');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000,\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Old TransactionBuilder behavior was to not confirm input values\n      // before signing. Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: bufferutils_1.cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = address_1.fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: bufferutils_1.cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, { script });\n    }\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc = getFinalScripts) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = utils_1.checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const { hash, sighashType } = getHashAndSighashType(\n        this.data.inputs,\n        inputIndex,\n        keyPair.publicKey,\n        this.__CACHE,\n        sighashTypes,\n      );\n      return Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [\n          {\n            pubkey: keyPair.publicKey,\n            signature: bscript.signature.encode(signature, sighashType),\n          },\n        ];\n        this.data.updateInput(inputIndex, { partialSig });\n      });\n    });\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = ecpair_1.fromPublicKey(pkey, { compressed: true })\n          .publicKey;\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\nconst isP2SHScript = isPaymentFactory(payments.p2sh);\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n    pSigs.forEach(pSig => {\n      const { hashType } = bscript.signature.decode(pSig.signature);\n      const whitelist = [];\n      const isAnyoneCanPay =\n        hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({ hash: meaningfulScript.slice(2) })\n      .output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          'to trick you into paying large fees. This behavior is the same as the old ' +\n          'TransactionBuilder class when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return input.witnessUtxo.script;\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    return nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index].script;\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction pubkeyInScript(pubkey, script) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst ecc = require('tiny-secp256k1');\nconst pushdata = require('pushdata-bitcoin');\nconst typeforce = require('typeforce');\nexports.OPS = require('bitcoin-ops');\nconst REVERSE_OPS = require('bitcoin-ops/map');\nconst OP_INT_BASE = exports.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === exports.OPS.OP_0 ||\n      (value >= exports.OPS.OP_1 && value <= exports.OPS.OP_16) ||\n      value === exports.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return exports.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return exports.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > exports.OPS.OP_0 && opcode <= exports.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (exports.OPS[chunkStr] !== undefined) return exports.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === exports.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return ecc.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\n// tslint:disable-next-line variable-name\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst types = require('./types');\nconst bip66 = require('bip66');\nconst typeforce = require('typeforce');\nconst ZERO = Buffer.alloc(1, 0);\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  const hashTypeMod = hashType & ~0x80;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4)\n    throw new Error('Invalid hashType ' + hashType);\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_0 [signatures ...]\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction partialSignature(value) {\n  return (\n    value === script_1.OPS.OP_0 || bscript.isCanonicalScriptSignature(value)\n  );\n}\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 2) return false;\n  if (chunks[0] !== script_1.OPS.OP_0) return false;\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature);\n  }\n  return chunks.slice(1).every(bscript.isCanonicalScriptSignature);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multisig input';\n};\n","'use strict';\n// m [pubKeys ...] n OP_CHECKMULTISIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst OP_INT_BASE = script_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 4) return false;\n  if (chunks[chunks.length - 1] !== script_1.OPS.OP_CHECKMULTISIG) return false;\n  if (!types.Number(chunks[0])) return false;\n  if (!types.Number(chunks[chunks.length - 2])) return false;\n  const m = chunks[0] - OP_INT_BASE;\n  const n = chunks[chunks.length - 2] - OP_INT_BASE;\n  if (m <= 0) return false;\n  if (n > 16) return false;\n  if (m > n) return false;\n  if (n !== chunks.length - 3) return false;\n  if (allowIncomplete) return true;\n  const keys = chunks.slice(1, -2);\n  return keys.every(bscript.isCanonicalPubKey);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'multi-sig output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// OP_RETURN {data}\nconst bscript = require('../script');\nconst OPS = bscript.OPS;\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return buffer.length > 1 && buffer[0] === OPS.OP_RETURN;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'null data output';\n};\nconst output = { check };\nexports.output = output;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return chunks.length === 1 && bscript.isCanonicalScriptSignature(chunks[0]);\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey input';\n};\n","'use strict';\n// {pubKey} OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalPubKey(chunks[0]) &&\n    chunks[1] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKey output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    bscript.isCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash input';\n};\n","'use strict';\n// OP_DUP OP_HASH160 {pubKeyHash} OP_EQUALVERIFY OP_CHECKSIG\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 25 &&\n    buffer[0] === script_1.OPS.OP_DUP &&\n    buffer[1] === script_1.OPS.OP_HASH160 &&\n    buffer[2] === 0x14 &&\n    buffer[23] === script_1.OPS.OP_EQUALVERIFY &&\n    buffer[24] === script_1.OPS.OP_CHECKSIG\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nconst p2wpkho = require('../witnesspubkeyhash/output');\nconst p2wsho = require('../witnessscripthash/output');\nfunction check(script, allowIncomplete) {\n  const chunks = bscript.decompile(script);\n  if (chunks.length < 1) return false;\n  const lastChunk = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(lastChunk)) return false;\n  const scriptSigChunks = bscript.decompile(\n    bscript.compile(chunks.slice(0, -1)),\n  );\n  const redeemScriptChunks = bscript.decompile(lastChunk);\n  // is redeemScript a valid script?\n  if (!redeemScriptChunks) return false;\n  // is redeemScriptSig push only?\n  if (!bscript.isPushOnly(scriptSigChunks)) return false;\n  // is witness?\n  if (chunks.length === 1) {\n    return (\n      p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks)\n    );\n  }\n  // match types\n  if (\n    p2pkh.input.check(scriptSigChunks) &&\n    p2pkh.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(scriptSigChunks, allowIncomplete) &&\n    p2ms.output.check(redeemScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(scriptSigChunks) &&\n    p2pk.output.check(redeemScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash input';\n};\n","'use strict';\n// OP_HASH160 {scriptHash} OP_EQUAL\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 23 &&\n    buffer[0] === script_1.OPS.OP_HASH160 &&\n    buffer[1] === 0x14 &&\n    buffer[22] === script_1.OPS.OP_EQUAL\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// OP_RETURN {aa21a9ed} {commitment}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nconst types = require('../../types');\nconst typeforce = require('typeforce');\nconst HEADER = Buffer.from('aa21a9ed', 'hex');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length > 37 &&\n    buffer[0] === script_1.OPS.OP_RETURN &&\n    buffer[1] === 0x24 &&\n    buffer.slice(2, 6).equals(HEADER)\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness commitment output';\n};\nfunction encode(commitment) {\n  typeforce(types.Hash256bit, commitment);\n  const buffer = Buffer.allocUnsafe(36);\n  HEADER.copy(buffer, 0);\n  commitment.copy(buffer, 4);\n  return bscript.compile([script_1.OPS.OP_RETURN, buffer]);\n}\nexports.encode = encode;\nfunction decode(buffer) {\n  typeforce(check, buffer);\n  return bscript.decompile(buffer)[1].slice(4, 36);\n}\nexports.decode = decode;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// {signature} {pubKey}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nfunction isCompressedCanonicalPubKey(pubKey) {\n  return bscript.isCanonicalPubKey(pubKey) && pubKey.length === 33;\n}\nfunction check(script) {\n  const chunks = bscript.decompile(script);\n  return (\n    chunks.length === 2 &&\n    bscript.isCanonicalScriptSignature(chunks[0]) &&\n    isCompressedCanonicalPubKey(chunks[1])\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessPubKeyHash input';\n};\n","'use strict';\n// OP_0 {pubKeyHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 22 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x14\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness pubKeyHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst input = require('./input');\nexports.input = input;\nconst output = require('./output');\nexports.output = output;\n","'use strict';\n// <scriptSig> {serialized scriptPubKey script}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst typeforce = require('typeforce');\nconst p2ms = require('../multisig');\nconst p2pk = require('../pubkey');\nconst p2pkh = require('../pubkeyhash');\nfunction check(chunks, allowIncomplete) {\n  typeforce(typeforce.Array, chunks);\n  if (chunks.length < 1) return false;\n  const witnessScript = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(witnessScript)) return false;\n  const witnessScriptChunks = bscript.decompile(witnessScript);\n  // is witnessScript a valid script?\n  if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false;\n  const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1));\n  // match types\n  if (\n    p2pkh.input.check(witnessRawScriptSig) &&\n    p2pkh.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&\n    p2ms.output.check(witnessScriptChunks)\n  )\n    return true;\n  if (\n    p2pk.input.check(witnessRawScriptSig) &&\n    p2pk.output.check(witnessScriptChunks)\n  )\n    return true;\n  return false;\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'witnessScriptHash input';\n};\n","'use strict';\n// OP_0 {scriptHash}\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bscript = require('../../script');\nconst script_1 = require('../../script');\nfunction check(script) {\n  const buffer = bscript.compile(script);\n  return (\n    buffer.length === 34 &&\n    buffer[0] === script_1.OPS.OP_0 &&\n    buffer[1] === 0x20\n  );\n}\nexports.check = check;\ncheck.toJSON = () => {\n  return 'Witness scriptHash output';\n};\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst varuint = require('varuint-bitcoin');\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_SCRIPT,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_SCRIPT;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeUInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return bufferutils_1.reverseBuffer(this.getHash(false)).toString('hex');\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nexports.Transaction = Transaction;\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst baddress = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst classify = require('./classify');\nconst bcrypto = require('./crypto');\nconst ECPair = require('./ecpair');\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst typeforce = require('typeforce');\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([\n  // Raw\n  'p2pkh',\n  'p2pk',\n  'p2wpkh',\n  'p2ms',\n  // P2SH wrapped\n  'p2sh-p2pkh',\n  'p2sh-p2pk',\n  'p2sh-p2wpkh',\n  'p2sh-p2ms',\n  // P2WSH wrapped\n  'p2wsh-p2pkh',\n  'p2wsh-p2pk',\n  'p2wsh-p2ms',\n  // P2SH-P2WSH wrapper\n  'p2sh-p2wsh-p2pkh',\n  'p2sh-p2wsh-p2pk',\n  'p2sh-p2wsh-p2ms',\n]);\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn(\n      'Deprecation Warning: TransactionBuilder will be removed in the future. ' +\n        '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' +\n        'are available in the transactions-psbt.js integration test file on our ' +\n        'Github. A high level explanation is available in the psbt.ts and psbt.js ' +\n        'files as well.',\n    );\n  }\n  static fromTransaction(transaction, network) {\n    const txb = new TransactionBuilder(network);\n    // Copy transaction fields\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime);\n    // Copy outputs (done first to avoid signature invalidation)\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    });\n    // Copy inputs\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness,\n      });\n    });\n    // fix some things not possible through the public API\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i);\n    });\n    return txb;\n  }\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n    if (setting === undefined) {\n      setting = true;\n    }\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime);\n    // if any signatures exist, throw\n    if (\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(s => s !== undefined);\n      })\n    ) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    this.__TX.locktime = locktime;\n  }\n  setVersion(version) {\n    typeforce(types.UInt32, version);\n    // XXX: this might eventually become more complex depending on what the versions represent\n    this.__TX.version = version;\n  }\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    let value;\n    // is it a hex string?\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex'));\n      // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value,\n    });\n  }\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n    // Attempt to get a script if it's a base58 or bech32 address string\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n  build() {\n    return this.__build(false);\n  }\n  buildIncomplete() {\n    return this.__build(true);\n  }\n  sign(\n    signParams,\n    keyPair,\n    redeemScript,\n    hashType,\n    witnessValue,\n    witnessScript,\n  ) {\n    trySign(\n      getSigningData(\n        this.network,\n        this.__INPUTS,\n        this.__needsOutputs.bind(this),\n        this.__TX,\n        signParams,\n        keyPair,\n        redeemScript,\n        hashType,\n        witnessValue,\n        witnessScript,\n        this.__USE_LOW_R,\n      ),\n    );\n  }\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined)\n      throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {};\n    // derive what we can from the scriptSig\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    }\n    // if an input value was given, retain it\n    if (options.value !== undefined) {\n      input.value = options.value;\n    }\n    // derive what we can from the previous transactions output script\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n        prevOutType = expanded.type;\n      }\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n    const vin = this.__TX.addInput(\n      txHash,\n      vout,\n      options.sequence,\n      options.scriptSig,\n    );\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n    const tx = this.__TX.clone();\n    // create script signatures from inputs\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete)\n        throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD)\n          throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n    return tx;\n  }\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n        return (\n          (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0\n        );\n      });\n    });\n  }\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    }\n    // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n    return (\n      this.__TX.outs.length === 0 &&\n      this.__INPUTS.some(input => {\n        if (!input.signatures) return false;\n        return input.signatures.some(signature => {\n          if (!signature) return false; // no signature, no issue\n          const hashType = signatureHashType(signature);\n          if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n          return true; // SIGHASH_* does care\n        });\n      })\n    );\n  }\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n        return false;\n      });\n    });\n  }\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0);\n    // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n}\nexports.TransactionBuilder = TransactionBuilder;\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH: {\n      const { output, pubkey, signature } = payments.p2wpkh({\n        witness: witnessStack,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2WPKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PKH: {\n      const { output, pubkey, signature } = payments.p2pkh({\n        input: scriptSig,\n      });\n      return {\n        prevOutScript: output,\n        prevOutType: SCRIPT_TYPES.P2PKH,\n        pubkeys: [pubkey],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const { signature } = payments.p2pk({ input: scriptSig });\n      return {\n        prevOutType: SCRIPT_TYPES.P2PK,\n        pubkeys: [undefined],\n        signatures: [signature],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const { m, pubkeys, signatures } = payments.p2ms(\n        {\n          input: scriptSig,\n          output: scriptPubKey,\n        },\n        { allowIncomplete: true },\n      );\n      return {\n        prevOutType: SCRIPT_TYPES.P2MS,\n        pubkeys,\n        signatures,\n        maxSignatures: m,\n      };\n    }\n  }\n  if (type === SCRIPT_TYPES.P2SH) {\n    const { output, redeem } = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(\n      redeem.input,\n      redeem.witness,\n      outputType,\n      redeem.output,\n    );\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const { output, redeem } = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack,\n    });\n    const outputType = classify.output(redeem.output);\n    let expanded;\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(\n        bscript.compile(redeem.witness),\n        [],\n        outputType,\n        redeem.output,\n      );\n    }\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n    };\n  }\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig,\n  };\n}\n// could be done in expandInput, but requires the original Transaction for hashForSignature\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript)\n    return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match;\n    // check for a signature\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false;\n      // TODO: avoid O(n) hashForSignature\n      const parsed = bscript.signature.decode(signature);\n      const hash = transaction.hashForSignature(\n        vin,\n        input.redeemScript,\n        parsed.hashType,\n      );\n      // skip if signature does not match pubKey\n      if (!keyPair.verify(hash, parsed.signature)) return false;\n      // remove matched signature from unmatched\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const pkh1 = payments.p2pkh({ output: script }).hash;\n      const pkh2 = bcrypto.hash160(ourPubKey);\n      if (!pkh1.equals(pkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (!ourPubKey) return { type };\n      // does our hash160(pubKey) match the output scripts?\n      const wpkh1 = payments.p2wpkh({ output: script }).hash;\n      const wpkh2 = bcrypto.hash160(ourPubKey);\n      if (!wpkh1.equals(wpkh2)) return { type };\n      return {\n        type,\n        pubkeys: [ourPubKey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2PK: {\n      const p2pk = payments.p2pk({ output: script });\n      return {\n        type,\n        pubkeys: [p2pk.pubkey],\n        signatures: [undefined],\n      };\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const p2ms = payments.p2ms({ output: script });\n      return {\n        type,\n        pubkeys: p2ms.pubkeys,\n        signatures: p2ms.pubkeys.map(() => undefined),\n        maxSignatures: p2ms.m,\n      };\n    }\n  }\n  return { type };\n}\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: { output: witnessScript },\n    });\n    const p2wshAlt = payments.p2wsh({ output: redeemScript });\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    const p2shAlt = payments.p2sh({ redeem: p2wsh });\n    // enforces P2SH(P2WSH(...))\n    if (!p2wsh.hash.equals(p2wshAlt.hash))\n      throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash))\n      throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (redeemScript) {\n    const p2sh = payments.p2sh({ redeem: { output: redeemScript } });\n    if (input.prevOutScript) {\n      let p2shAlt;\n      try {\n        p2shAlt = payments.p2sh({ output: input.prevOutScript });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n      if (!p2sh.hash.equals(p2shAlt.hash))\n        throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as redeemScript (' +\n          bscript.toASM(redeemScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = redeemScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({ redeem: { output: witnessScript } });\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({ output: input.prevOutScript });\n      if (!p2wsh.hash.equals(p2wshAlt.hash))\n        throw new Error('Witness script inconsistent with prevOutScript');\n    }\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported as witnessScript (' +\n          bscript.toASM(witnessScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH)\n      throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires redeemScript',\n      );\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH)\n      throw new Error(\n        'PrevOutScript is ' + input.prevOutType + ', requires witnessScript',\n      );\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys)\n      throw new Error(\n        expanded.type +\n          ' not supported (' +\n          bscript.toASM(input.prevOutScript) +\n          ')',\n      );\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n    let signScript = input.prevOutScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({ pubkey: expanded.pubkeys[0] }).output;\n    }\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures,\n    };\n  }\n  const prevOutScript = payments.p2pkh({ pubkey: ourPubKey }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined],\n  };\n}\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2WPKH: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2wpkh({ pubkey: pubkeys[0], signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2PK: {\n      if (pubkeys.length === 0) break;\n      if (signatures.length === 0) break;\n      return payments.p2pk({ signature: signatures[0] });\n    }\n    case SCRIPT_TYPES.P2MS: {\n      const m = input.maxSignatures;\n      if (allowIncomplete) {\n        signatures = signatures.map(x => x || script_1.OPS.OP_0);\n      } else {\n        signatures = signatures.filter(x => x);\n      }\n      // if the transaction is not not complete (complete), or if signatures.length === m, validate\n      // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n      const validate = !allowIncomplete || m === signatures.length;\n      return payments.p2ms(\n        { m, pubkeys, signatures },\n        { allowIncomplete, validate },\n      );\n    }\n    case SCRIPT_TYPES.P2SH: {\n      const redeem = build(input.redeemScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2sh({\n        redeem: {\n          output: redeem.output || input.redeemScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n    case SCRIPT_TYPES.P2WSH: {\n      const redeem = build(input.witnessScriptType, input, allowIncomplete);\n      if (!redeem) return;\n      return payments.p2wsh({\n        redeem: {\n          output: input.witnessScript,\n          input: redeem.input,\n          witness: redeem.witness,\n        },\n      });\n    }\n  }\n}\nfunction canSign(input) {\n  return (\n    input.signScript !== undefined &&\n    input.signType !== undefined &&\n    input.pubkeys !== undefined &&\n    input.signatures !== undefined &&\n    input.signatures.length === input.pubkeys.length &&\n    input.pubkeys.length > 0 &&\n    (input.hasWitness === false || input.value !== undefined)\n  );\n}\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\n      `Unknown prevOutScriptType \"${signParams.prevOutScriptType}\"`,\n    );\n  }\n  tfMessage(\n    typeforce.Number,\n    signParams.vin,\n    `sign must include vin parameter as Number (input index)`,\n  );\n  tfMessage(\n    types.Signer,\n    signParams.keyPair,\n    `sign must include keyPair parameter as Signer interface`,\n  );\n  tfMessage(\n    typeforce.maybe(typeforce.Number),\n    signParams.hashType,\n    `sign hashType parameter must be a number`,\n  );\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2pk: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2ms: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type p2sh-p2wpkh: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessScript,\n        `${posType} requires NO witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires redeemScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.witnessValue,\n        `${posType} requires NO witnessValue`,\n      );\n      break;\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.value(undefined),\n        signParams.redeemScript,\n        `${posType} requires NO redeemScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessValue`,\n      );\n      break;\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\n          `input #${signParams.vin} is not of type ${posType}: ${prevOutType}`,\n        );\n      }\n      tfMessage(\n        typeforce.Buffer,\n        signParams.witnessScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        typeforce.Buffer,\n        signParams.redeemScript,\n        `${posType} requires witnessScript`,\n      );\n      tfMessage(\n        types.Satoshi,\n        signParams.witnessValue,\n        `${posType} requires witnessScript`,\n      );\n      break;\n  }\n}\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR,\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n  for (const [i, pubKey] of input.pubkeys.entries()) {\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    // TODO: add tests\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error(\n        'BIP143 rejects uncompressed public keys in P2WPKH or P2WSH',\n      );\n    }\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\nfunction getSigningData(\n  network,\n  inputs,\n  needsOutputs,\n  tx,\n  signParams,\n  keyPair,\n  redeemScript,\n  hashType,\n  witnessValue,\n  witnessScript,\n  useLowR,\n) {\n  let vin;\n  if (typeof signParams === 'number') {\n    console.warn(\n      'DEPRECATED: TransactionBuilder sign method arguments ' +\n        'will change in v6, please use the TxbSignArg interface',\n    );\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    ({\n      vin,\n      keyPair,\n      redeemScript,\n      hashType,\n      witnessValue,\n      witnessScript,\n    } = signParams);\n  } else {\n    throw new TypeError(\n      'TransactionBuilder sign first arg must be TxbSignArg or number',\n    );\n  }\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  }\n  // TODO: remove keyPair.network matching in 4.0.0\n  if (keyPair.network && keyPair.network !== network)\n    throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin];\n  // if redeemScript was previously provided, enforce consistency\n  if (\n    input.redeemScript !== undefined &&\n    redeemScript &&\n    !input.redeemScript.equals(redeemScript)\n  ) {\n    throw new Error('Inconsistent redeemScript');\n  }\n  const ourPubKey =\n    keyPair.publicKey || (keyPair.getPublicKey && keyPair.getPublicKey());\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue)\n        throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n    if (!canSign(input)) {\n      const prepared = prepareInput(\n        input,\n        ourPubKey,\n        redeemScript,\n        witnessScript,\n      );\n      // updates inline\n      Object.assign(input, prepared);\n    }\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  }\n  // ready to sign\n  let signatureHash;\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(\n      vin,\n      input.signScript,\n      input.value,\n      hashType,\n    );\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR,\n  };\n}\n","'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeforce = require('typeforce');\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nexports.UInt31 = UInt31;\nfunction BIP32Path(value) {\n  return typeforce.String(value) && !!value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\nexports.BIP32Path = BIP32Path;\nBIP32Path.toJSON = () => {\n  return 'BIP32 derivation path';\n};\nfunction Signer(obj) {\n  return (\n    (typeforce.Buffer(obj.publicKey) ||\n      typeof obj.getPublicKey === 'function') &&\n    typeof obj.sign === 'function'\n  );\n}\nexports.Signer = Signer;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\n// external dependent types\nexports.ECPoint = typeforce.quacksLike('Point');\n// exposed, external API\nexports.Network = typeforce.compile({\n  messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32,\n  },\n  pubKeyHash: typeforce.UInt8,\n  scriptHash: typeforce.UInt8,\n  wif: typeforce.UInt8,\n});\nexports.Buffer256bit = typeforce.BufferN(32);\nexports.Hash160bit = typeforce.BufferN(20);\nexports.Hash256bit = typeforce.BufferN(32);\nexports.Number = typeforce.Number; // tslint:disable-line variable-name\nexports.Array = typeforce.Array;\nexports.Boolean = typeforce.Boolean; // tslint:disable-line variable-name\nexports.String = typeforce.String; // tslint:disable-line variable-name\nexports.Buffer = typeforce.Buffer;\nexports.Hex = typeforce.Hex;\nexports.maybe = typeforce.maybe;\nexports.tuple = typeforce.tuple;\nexports.UInt8 = typeforce.UInt8;\nexports.UInt32 = typeforce.UInt32;\nexports.Function = typeforce.Function;\nexports.BufferN = typeforce.BufferN;\nexports.Null = typeforce.Null;\nexports.oneOf = typeforce.oneOf;\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","const ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { safeRe: re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.format()\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range\n      .trim()\n      .split(/\\s+/)\n      .join(' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.format()\n  }\n\n  format () {\n    this.range = this.set\n      .map((comps) => comps.join(' ').trim())\n      .join('||')\n      .trim()\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = require('../internal/lrucache')\nconst cache = new LRU()\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","const debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n          version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    return (\n      compareIdentifiers(this.major, other.major) ||\n      compareIdentifiers(this.minor, other.minor) ||\n      compareIdentifiers(this.patch, other.patch)\n    )\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (!identifier && identifierBase === false) {\n          throw new Error('invalid increment argument: identifier is empty')\n        }\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","const parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","const eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","const SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n","const SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","const compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","const SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","const parse = require('./parse.js')\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // Otherwise it can be determined by checking the high version\n\n    if (highVersion.patch) {\n      // anything higher than a patch bump would result in the wrong version\n      return 'patch'\n    }\n\n    if (highVersion.minor) {\n      // anything higher than a minor bump would result in the wrong version\n      return 'minor'\n    }\n\n    // bumping major/minor/patch all have same result\n    return 'major'\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n","const compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","const compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","const compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","const SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","const compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","const compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","const SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","const SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","const compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","const SemVer = require('../classes/semver')\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n","const SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","const parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","const compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","const compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","const Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","const compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","const parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nconst constants = require('./internal/constants')\nconst SemVer = require('./classes/semver')\nconst identifiers = require('./internal/identifiers')\nconst parse = require('./functions/parse')\nconst valid = require('./functions/valid')\nconst clean = require('./functions/clean')\nconst inc = require('./functions/inc')\nconst diff = require('./functions/diff')\nconst major = require('./functions/major')\nconst minor = require('./functions/minor')\nconst patch = require('./functions/patch')\nconst prerelease = require('./functions/prerelease')\nconst compare = require('./functions/compare')\nconst rcompare = require('./functions/rcompare')\nconst compareLoose = require('./functions/compare-loose')\nconst compareBuild = require('./functions/compare-build')\nconst sort = require('./functions/sort')\nconst rsort = require('./functions/rsort')\nconst gt = require('./functions/gt')\nconst lt = require('./functions/lt')\nconst eq = require('./functions/eq')\nconst neq = require('./functions/neq')\nconst gte = require('./functions/gte')\nconst lte = require('./functions/lte')\nconst cmp = require('./functions/cmp')\nconst coerce = require('./functions/coerce')\nconst Comparator = require('./classes/comparator')\nconst Range = require('./classes/range')\nconst satisfies = require('./functions/satisfies')\nconst toComparators = require('./ranges/to-comparators')\nconst maxSatisfying = require('./ranges/max-satisfying')\nconst minSatisfying = require('./ranges/min-satisfying')\nconst minVersion = require('./ranges/min-version')\nconst validRange = require('./ranges/valid')\nconst outside = require('./ranges/outside')\nconst gtr = require('./ranges/gtr')\nconst ltr = require('./ranges/ltr')\nconst intersects = require('./ranges/intersects')\nconst simplifyRange = require('./ranges/simplify')\nconst subset = require('./ranges/subset')\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n","// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n","const debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","const numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n","class LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n","// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n","const {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]\n}|${src[t.NONNUMERICIDENTIFIER]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n","// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","const Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n","const outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","const SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","const SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","const Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","const Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","const Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n","/*\n * Bitcoin BIP32 path helpers\n * (C) 2016 Alex Beregszaszi\n */\n\nconst HARDENED = 0x80000000\n\nvar BIPPath = function (path) {\n  if (!Array.isArray(path)) {\n    throw new Error('Input must be an Array')\n  }\n  if (path.length === 0) {\n    throw new Error('Path must contain at least one level')\n  }\n  for (var i = 0; i < path.length; i++) {\n    if (typeof path[i] !== 'number') {\n      throw new Error('Path element is not a number')\n    }\n  }\n  this.path = path\n}\n\nBIPPath.validatePathArray = function (path) {\n  try {\n    BIPPath.fromPathArray(path)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.validateString = function (text, reqRoot) {\n  try {\n    BIPPath.fromString(text, reqRoot)\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\nBIPPath.fromPathArray = function (path) {\n  return new BIPPath(path)\n}\n\nBIPPath.fromString = function (text, reqRoot) {\n  // skip the root\n  if (/^m\\//i.test(text)) {\n    text = text.slice(2)\n  } else if (reqRoot) {\n    throw new Error('Root element is required')\n  }\n\n  var path = text.split('/')\n  var ret = new Array(path.length)\n  for (var i = 0; i < path.length; i++) {\n    var tmp = /(\\d+)([hH\\']?)/.exec(path[i])\n    if (tmp === null) {\n      throw new Error('Invalid input')\n    }\n    ret[i] = parseInt(tmp[1], 10)\n\n    if (ret[i] >= HARDENED) {\n      throw new Error('Invalid child index')\n    }\n\n    if (tmp[2] === 'h' || tmp[2] === 'H' || tmp[2] === '\\'') {\n      ret[i] += HARDENED\n    } else if (tmp[2].length != 0) {\n      throw new Error('Invalid modifier')\n    }\n  }\n  return new BIPPath(ret)\n}\n\nBIPPath.prototype.toPathArray = function () {\n  return this.path\n}\n\nBIPPath.prototype.toString = function (noRoot, oldStyle) {\n  var ret = new Array(this.path.length)\n  for (var i = 0; i < this.path.length; i++) {\n    var tmp = this.path[i]\n    if (tmp & HARDENED) {\n      ret[i] = (tmp & ~HARDENED) + (oldStyle ? 'h' : '\\'')\n    } else {\n      ret[i] = tmp\n    }\n  }\n  return (noRoot ? '' : 'm/') + ret.join('/')\n}\n\nBIPPath.prototype.inspect = function () {\n  return 'BIPPath <' + this.toString() + '>'\n}\n\nmodule.exports = BIPPath\n","'use strict'\n\nvar base58 = require('bs58')\nvar Buffer = require('safe-buffer').Buffer\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var checksum = checksumFn(payload)\n\n    return base58.encode(Buffer.concat([\n      payload,\n      checksum\n    ], payload.length + 4))\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n","'use strict'\n\nvar createHash = require('create-hash')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  var tmp = createHash('sha256').update(buffer).digest()\n  return createHash('sha256').update(tmp).digest()\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto = require(\"./crypto\");\nconst bs58check = require('bs58check');\nconst ecc = require('tiny-secp256k1');\nconst typeforce = require('typeforce');\nconst wif = require('wif');\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require('create-hash');\nconst createHmac = require('create-hmac');\nfunction hash160(buffer) {\n    const sha256Hash = createHash('sha256')\n        .update(buffer)\n        .digest();\n    try {\n        return createHash('rmd160')\n            .update(sha256Hash)\n            .digest();\n    }\n    catch (err) {\n        return createHash('ripemd160')\n            .update(sha256Hash)\n            .digest();\n    }\n}\nexports.hash160 = hash160;\nfunction hmacSHA512(key, data) {\n    return createHmac('sha512', key)\n        .update(data)\n        .digest();\n}\nexports.hmacSHA512 = hmacSHA512;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bip32_1 = require(\"./bip32\");\nexports.fromSeed = bip32_1.fromSeed;\nexports.fromBase58 = bip32_1.fromBase58;\nexports.fromPublicKey = bip32_1.fromPublicKey;\nexports.fromPrivateKey = bip32_1.fromPrivateKey;\n","var OPS = require('./index.json')\n\nvar map = {}\nfor (var op in OPS) {\n  var code = OPS[op]\n  map[code] = op\n}\n\nmodule.exports = map\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var OPS = require('bitcoin-ops')\n\nfunction encodingLength (i) {\n  return i < OPS.OP_PUSHDATA1 ? 1\n  : i <= 0xff ? 2\n  : i <= 0xffff ? 3\n  : 5\n}\n\nfunction encode (buffer, number, offset) {\n  var size = encodingLength(number)\n\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(number, offset)\n\n  // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)\n    buffer.writeUInt8(number, offset + 1)\n\n  // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n\n  // 32 bit\n  } else {\n    buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n  }\n\n  return size\n}\n\nfunction decode (buffer, offset) {\n  var opcode = buffer.readUInt8(offset)\n  var number, size\n\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    number = opcode\n    size = 1\n\n  // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null\n    number = buffer.readUInt8(offset + 1)\n    size = 2\n\n  // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null\n    number = buffer.readUInt16LE(offset + 1)\n    size = 3\n\n  // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')\n\n    number = buffer.readUInt32LE(offset + 1)\n    size = 5\n  }\n\n  return {\n    opcode: opcode,\n    number: number,\n    size: size\n  }\n}\n\nmodule.exports = {\n  encodingLength: encodingLength,\n  encode: encode,\n  decode: decode\n}\n"],"names":["pathElementsToBuffer","paths","buffer","Buffer","alloc","length","forEach","element","index","writeUInt32BE","bip32asBuffer","path","pathStringToArray","pathArrayToString","pathElements","bippath","toString","toPathArray","pubkeyFromXpub","xpub","xpubBuf","bs58check","slice","getXpubComponents","chaincode","pubkey","version","readUInt32BE","unsafeTo64bitLE","n","Number","MAX_SAFE_INTEGER","Error","byteArray","byte","unsafeFrom64bitLE","value","i","BufferWriter","constructor","bufs","write","fn","b","this","push","writeUInt8","writeInt32","writeInt32LE","writeUInt32","writeUInt32LE","writeUInt64","bytes","writeSlice","writeVarInt","varuint","from","writeVarSlice","concat","BufferReader","offset","available","readUInt8","result","readInt32","readInt32LE","readUInt32","readUInt32LE","readUInt64","readSlice","readVarInt","vi","readVarSlice","readVector","count","vector","MAX_SCRIPT_BLOCK","DEFAULT_SEQUENCE","hashPublicKey","RIPEMD160","update","sha","digest","BaseAccount","psbt","masterFp","SingleKeyAccount","spendingCondition","pubkeys","singleKeyCondition","setInput","inputTx","spentOutput","pathElems","setSingleKeyInput","setOwnOutput","cond","setSingleKeyOutput","p2pkh","buf","pubkeyHash","scriptPubKey","_spentOutput","setInputNonWitnessUtxo","setInputBip32Derivation","setOutputBip32Derivation","getDescriptorTemplate","p2tr","xonlyPubkey","outputKey","getTaprootOutputKey","_inputTx","xonly","setInputTapBip32Derivation","setInputWitnessUtxo","amount","setOutputTapBip32Derivation","hashTapTweak","x","h","crypto","sha256","internalPubkey","evenEcdsaPubkey","tweak","pointAddScalar","p2wpkhWrapped","redeemScript","createRedeemScript","scriptHash","userSuppliedRedeemScript","expectedRedeemScript","equals","setInputRedeemScript","setOutputRedeemScript","p2wpkh","Merkle","leaves","hasher","nodes","calculateRoot","rootNode","root","leafNodes","getRoot","hash","size","getLeaves","getLeafHash","getProof","proveNode","Node","undefined","newNode","leftCount","isPowerOf2","Math","floor","log2","highestPowerOf2LessThan","leftBranch","rightBranch","leftChild","rightChild","hashNode","node","parent","left","right","hashLeaf","hashFunction","bufA","bufB","hashConcat","isLeaf","WalletPolicy","descriptorTemplate","key","keys","getWalletId","serialize","keyBuffers","map","k","m","createKey","masterFingerprint","accountPath","substring","psbtGlobal","psbtIn","psbtOut","PSBT_MAGIC_BYTES","NoSuchEntry","PsbtV2","globalMap","Map","inputMaps","outputMaps","setGlobalTxVersion","setGlobal","TX_VERSION","uint32LE","getGlobalTxVersion","getGlobal","setGlobalFallbackLocktime","locktime","FALLBACK_LOCKTIME","getGlobalFallbackLocktime","_a","getGlobalOptional","setGlobalInputCount","inputCount","INPUT_COUNT","varint","getGlobalInputCount","fromVarint","setGlobalOutputCount","outputCount","OUTPUT_COUNT","getGlobalOutputCount","setGlobalTxModifiable","TX_MODIFIABLE","getGlobalTxModifiable","setGlobalPsbtVersion","psbtVersion","VERSION","getGlobalPsbtVersion","inputIndex","transaction","NON_WITNESS_UTXO","getInputNonWitnessUtxo","getInputOptional","WITNESS_UTXO","getInputWitnessUtxo","utxo","setInputPartialSig","signature","PARTIAL_SIG","getInputPartialSig","setInputSighashType","sigHashtype","SIGHASH_TYPE","getInputSighashType","REDEEM_SCRIPT","getInputRedeemScript","BIP32_DERIVATION","encodeBip32Derivation","getInputBip32Derivation","decodeBip32Derivation","setInputFinalScriptsig","scriptSig","FINAL_SCRIPTSIG","getInputFinalScriptsig","setInputFinalScriptwitness","scriptWitness","FINAL_SCRIPTWITNESS","getInputFinalScriptwitness","getInput","setInputPreviousTxId","txid","PREVIOUS_TXID","getInputPreviousTxid","setInputOutputIndex","outputIndex","OUTPUT_INDEX","getInputOutputIndex","setInputSequence","sequence","SEQUENCE","getInputSequence","_b","setInputTapKeySig","sig","TAP_KEY_SIG","getInputTapKeySig","hashes","encodeTapBip32Derivation","TAP_BIP32_DERIVATION","getInputTapBip32Derivation","decodeTapBip32Derivation","getInputKeyDatas","keyType","getKeyDatas","setOutput","getOutputRedeemScript","getOutput","BIP_32_DERIVATION","getOutputBip32Derivation","setOutputAmount","AMOUNT","getOutputAmount","setOutputScript","SCRIPT","getOutputScript","fingerprint","getOutputTapBip32Derivation","deleteInputEntries","keyTypes","_v","isKeyType","delete","copy","to","copyMap","copyMaps","to_index","v","set","serializeMap","deserialize","readKeyPair","keyLen","hexKey","some","Key","get","keyData","getMap","maps","writeBip32Derivation","readBip32Derivation","hashCount","deriv","Object","assign","acceptUndefined","toBuffer","KeyPair","clearFinalizedInput","witnessUtxoAvailable","nonWitnessUtxoAvailable","writePush","data","writeUInt16LE","getVarint","createVarint","serializeTransactionOutputs","outputs","outputBuffer","output","script","serializeTransaction","skipWitness","timestamp","additionals","isDecred","includes","isZcash","isBech32","inputBuffer","useWitness","inputs","input","prevout","witness","nExpiryHeight","extraData","nVersionGroupId","BtcNew","client","getWalletXpub","xpubVersion","getExtendedPubkey","xpubComponents","getWalletPublicKey","opts","validSingleSigPurposePathPartsSet","has","validCoinPathPartsSet","hard","change","soft","validMultiSigPurposePathPartsSet","isPathNormal","display","verify","address","getWalletAddress","addressFormat","descrTemplFrom","format","components","publicKey","pointCompress","bitcoinAddress","chainCode","descrTempl","hardenedPathOf","accountXpub","getMasterFingerprint","policy","changeAndIndex","createPaymentTransaction","arg","accountType","segwit","accountTypeFromArg","lockTime","notifyCount","progress","onDeviceStreaming","total","associatedKeysets","sigHashType","outputsConcat","outputScriptHex","outputsBufferReader","changeData","outputScriptAt","changePath","changeFound","outputScript","p","onDeviceSignatureRequested","firstSigned","signPsbt","progressCallback","onDeviceSignatureGranted","legacyPubkeys","taprootSig","isSegwitV0","isWrappedSegwit","witnessBuf","scriptSigBuf","finalize","serializedTx","tx","isSegwit","witnessWriter","extract","signMessage","messageHex","message","r","s","masterFP","spentOutputIndex","inputTxBuffer","inputTxid","hash256","spentTxOutput","walletPolicy","H","Set","t","addressFormatMap","legacy","p2sh","bech32","cashaddr","transport","options","p1","p2","response","send","publicKeyLength","addressLength","getTrustedInputRaw","transactionData","indexLookup","firstRound","prefix","trustedInput","getTrustedInput","transport_1","indexLookup_1","transaction_1","isXST","processScriptBlocks","__awaiter","seq","scriptBlocks","res","blockSize","scriptBlock","processWholeScriptBlock","block","isXSTV2","compare","treeField","tree","endData","extraPart","invariant","startUntrustedHashTransactionInputRaw","newTransaction","bip143","overwinter","startUntrustedHashTransactionInput","newTransaction_1","inputs_1","useTrustedInputForSegwit","inputValue","getTrustedInputBIP143","shajs","compressPublicKey","prefixBuffer","signTransaction","expiryHeight","pathsBuffer","lockTimeBuffer","then","provideOutputFullChangePath","hashOutputFull","outputScript_1","getAppAndVersion","nameLength","name","versionLength","flagLength","flags","defaultsSignTransaction","_e","createTransaction","signTx","initialTimestamp","semver","shouldUseTrustedInputForSegwit","e","statusCode","notify","loop","startTime","Date","now","sapling","useBip143","nullScript","nullPrevout","defaultVersion","trustedInputs","regularOutputs","signatures","publicKeys","firstRun","targetTransaction","getTrustedInputCall","log","idx","pseudoTX","pseudoTrustedInputs","signatureSize","keySize","tmpScriptData","decredWitness","BtcOld","derivationsCache","derivatePath","parentPath","parentDerivation","accountDerivation","compressedPubKey","ripemd160","makeFingerprint","compressPublicKeySECP256","depth","parentFingerprint","pubKey","indexBuffer","asBufferUInt32BE","extendedKeyBytes","checksum","bs58","makeXpub","arguments","maxChunkSize","chunkSize","writeUInt16BE","allocUnsafe","MerkleMap","values","keysTree","valuesTree","commitment","MerkelizedPsbt","super","inputMerkleMaps","outputMerkleMaps","globalMerkleMap","createMerkleMap","inputMapCommitments","outputMapCommitments","getGlobalSize","getGlobalKeysValuesRoot","sortedKeysStrings","sort","sortedKeys","ClientCommandCode","ClientCommand","YieldCommand","results","code","YIELD","execute","request","subarray","GetPreimageCommand","known_preimages","queue","GET_PREIMAGE","req","req_hash_hex","known_preimage","preimage_len_varint","max_payload_size","payload_size","min","GetMerkleLeafProofCommand","known_trees","GET_MERKLE_LEAF_PROOF","reqBuf","hash_hex","tree_size","leaf_index","mt","proof","n_response_elements","n_leftover_elements","GetMerkleLeafIndexCommand","GET_MERKLE_LEAF_INDEX","root_hash","root_hash_hex","leef_hash","leef_hash_hex","found","GetMoreElementsCommand","GET_MORE_ELEMENTS","element_len","el","max_elements","n_returned_elements","returned_elements","splice","ClientCommandInterpreter","roots","preimages","yielded","commands","cmd","getYielded","addKnownPreimage","preimage","addKnownList","elements","addKnownMapping","mm","cmdCode","BitcoinIns","FrameworkIns","AppClient","makeRequest","ins","cci","readUInt16BE","hwRequest","commandResponse","CONTINUE_INTERRUPTED","GET_PUBKEY","walletHMAC","addressIndex","isInteger","clientInterpreter","addressIndexBuffer","GET_WALLET_ADDRESS","merkelizedPsbt","inputMapsRoot","outputMapsRoot","SIGN_PSBT","ret","inputAndSig","GET_MASTER_FINGERPRINT","nChunks","ceil","chunks","chunksRoot","SIGN_MESSAGE","formatTransactionDebug","str","defaultArg","transactionVersion","Btc","scrambleKey","currency","_transport","decorateAppAPIMethods","_impl","changeImplIfNecessary","impl","console","warn","signP2SHTransaction","splitTransaction","transactionHex","isSegwitSupported","hasTimestamp","hasExtraData","witnessScript","isZencash","isZcashv5","numberInputs","numberOutputs","defineProperty","exports","networks","require","payments","bscript","types","typeforce","fromBase58Check","payload","decode","TypeError","fromBech32","fromWords","words","toBase58Check","tuple","Hash160bit","UInt8","encode","toBech32","toWords","unshift","fromOutputScript","network","bitcoin","p2wsh","toASM","toOutputScript","decodeBase58","decodeBech32","pubKeyHash","bufferutils_1","bcrypto","fastMerkleRoot","errorMerkleNoTxes","errorWitnessNotSegwit","Block","prevHash","merkleRoot","witnessCommit","bits","nonce","transactions","fromBuffer","bufferReader","readTransaction","Transaction","byteLength","nTransactions","getWitnessCommit","fromHex","hex","calculateTarget","exponent","mantissa","target","writeUIntBE","calculateMerkleRoot","forWitness","getHash","Function","txesHaveWitnessCommit","rootHash","witnessCommits","outs","filter","out","hasWitnessCommit","hasWitness","Array","weight","headersOnly","allowWitness","encodingLength","reduce","a","getId","reverseBuffer","getUTCDate","date","setUTCSeconds","bufferWriter","txSize","toHex","checkTxRoots","__checkMerkleRoot","__checkWitnessCommit","checkProofOfWork","actualMerkleRoot","actualWitnessCommit","verifuint","max","readUInt64LE","writeUInt64LE","j","tmp","cloneBuffer","clone","UInt32","writeVector","script_1","multisig","nullData","witnessCommitment","witnessPubKeyHash","witnessScriptHash","P2MS","NONSTANDARD","NULLDATA","P2PK","P2PKH","P2SH","P2WPKH","P2WSH","WITNESS_COMMITMENT","check","decompile","allowIncomplete","createHash","err","sha1","hash160","NETWORKS","ecc","randomBytes","wif","isOptions","maybe","compile","compressed","Boolean","Network","ECPair","__D","__Q","lowR","privateKey","pointFromScalar","toWIF","sign","counter","writeUIntLE","signWithEntropy","fromPrivateKey","Buffer256bit","isPrivate","fromPublicKey","isPoint","fromWIF","wifString","decoded","pop","makeRandom","rng","d","Psbt","OPS","TransactionBuilder","messagePrefix","bip32","public","private","regtest","testnet","networks_1","lazy","typef","p2data","validate","arrayOf","o","prop","OP_RETURN","every","stacksEqual","embed_1","embed","p2ms_1","p2ms","p2pk_1","p2pk","p2pkh_1","p2sh_1","p2wpkh_1","p2wsh_1","object","f","configurable","enumerable","_value","call","writable","OP_INT_BASE","OP_RESERVED","isAcceptableSignature","isCanonicalScriptSignature","OP_0","OP_CHECKMULTISIG","_chunks","OP_CHECKSIG","String","BufferN","_address","OP_DUP","OP_HASH160","OP_EQUALVERIFY","hash2","pkh","redeem","_redeem","OP_EQUAL","nameParts","join","checkRedeem","hasInput","richunks","isPushOnly","isBuffer","EMPTY_BUFFER","shift","chunkHasUncompressedPubkey","chunk","_rchunks","stack","toStack","wScript","bip174_1","utils_1","address_1","crypto_1","ecpair_1","DEFAULT_OPTS","maximumFeeRate","PsbtTransaction","__CACHE","__NON_WITNESS_UTXO_TX_CACHE","__NON_WITNESS_UTXO_BUF_CACHE","__TX_IN_CACHE","__TX","unsignedTx","__UNSAFE_SIGN_NONSEGWIT","setVersion","dpew","obj","attr","fromBase64","psbtBase","transactionFromBuffer","cache","checkTxInputCache","setLocktime","txInputs","txOutputs","_","combine","those","JSON","parse","stringify","setMaximumFeeRate","satoshiPerByte","check32Bit","checkInputsForPartialSig","c","__EXTRACTED_TX","addInputs","inputDatas","inputData","addInput","checkInvalidP2WSH","nonWitnessUtxo","addNonWitnessTxCache","__FEE","__FEE_RATE","addOutputs","outputDatas","outputData","addOutput","extractTransaction","disableFeeCheck","isFinalized","feeRate","getFeeRate","vsize","virtualSize","satoshis","toFixed","checkFees","inputFinalizeGetAmts","getTxCacheValue","getFee","finalizeAllInputs","checkForInput","range","finalizeInput","finalScriptsFunc","getFinalScripts","isP2SH","isP2WSH","nonWitnessUtxoTx","nonWitnessUtxoTxFromCache","prevoutIndex","witnessUtxo","isP2WPKH","getScriptFromInput","sighashType","partialSig","pSig","hashType","checkPartialSigSighashes","finalScriptSig","finalScriptWitness","updateInput","getInputType","getMeaningfulScript","getScriptFromUtxo","finalScript","decomp","lastItem","isPubkeyLike","redeemFromFinalScriptSig","scriptWitnessToWitnessStack","redeemFromFinalWitnessScript","type","classifyScript","meaningfulScript","inputHasPubkey","pubkeyInScript","pubkeyInInput","inputHasHDKey","derivationIsMine","bip32DerivationIsMine","bip32Derivation","outputHasPubkey","pubkeyInOutput","checkForOutput","outputHasHDKey","validateSignaturesOfAllInputs","validateSignaturesOfInput","final","mySigs","hashCache","scriptCache","sighashCache","getHashForSig","checkScriptForPubkey","keypair","signAllInputsHD","hdKeyPair","sighashTypes","SIGHASH_ALL","signInputHD","signAllInputsHDAsync","Promise","resolve","reject","promises","signInputHDAsync","all","getSignersFromHD","signer","signInput","signInputAsync","catch","signAllInputs","keyPair","signAllInputsAsync","entries","getHashAndSighashType","checkCache","toBase64","updateGlobal","updateData","updateOutput","addUnknownKeyValToGlobal","keyVal","addUnknownKeyValToInput","addUnknownKeyValToOutput","checkTxEmpty","getInputOutputCounts","hasSigs","neededSigs","sigs","pkey","find","isPaymentFactory","payment","isP2MS","isP2PK","isP2PKH","isP2WSHScript","isP2SHScript","derivePath","num","action","throws","pSigs","scriptItems","witnessItems","item","getPsigsFromInputFinalScripts","whitelist","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","indexOf","scriptCheckerFactory","paymentScriptName","ioType","redeemScriptOutput","checkRedeemScript","checkWitnessScript","mustFinalize","scriptType","canFinalize","pk","ps","getSortedSigs","getPayment","witnessStackToScriptWitness","prepareFinalScripts","forValidate","text","sighashTypeToString","prevoutHash","utxoHash","hashForWitnessV0","signingScript","hashForSignature","myDerivations","bipDv","currentLen","varintLen","self","selfIndex","txCache","newBuf","inputAmount","nwTx","vout","outputAmount","fee","isCanonicalPubKey","isP2SHP2WSH","decompiled","scriptNumber","scriptSignature","bip66","pushdata","REVERSE_OPS","isPushOnlyChunk","OP_1","OP_16","OP_1NEGATE","isOPInt","asMinimalOP","chunksIsBuffer","singleChunkIsBuffer","bufferSize","accum","opcode","OP_PUSHDATA4","number","op","isDefinedHashType","hashTypeMod","fromASM","asm","split","chunkStr","Hex","maxLength","minimal","_number","abs","negative","ZERO","toDER","fromDER","bstart","hashTypeBuffer","partialSignature","toJSON","p2wpkho","p2wsho","lastChunk","scriptSigChunks","redeemScriptChunks","HEADER","Hash256bit","witnessScriptChunks","witnessRawScriptSig","varSliceSize","someScript","EMPTY_SCRIPT","EMPTY_WITNESS","ONE","VALUE_UINT64_MAX","BLANK_OUTPUT","valueBuffer","_NO_STRICT","marker","flag","hasWitnesses","ADVANCED_TRANSACTION_MARKER","ADVANCED_TRANSACTION_FLAG","vinLen","voutLen","isCoinbaseHash","isCoinbase","Null","Satoshi","_ALLOW_WITNESS","sum","someVector","vectorSize","newTx","txIn","txOut","inIndex","prevOutScript","ourScript","OP_CODESEPARATOR","txTmp","y","__toBuffer","tbuffer","hashOutputs","hashPrevouts","hashSequence","txOutsSize","initialOffset","setInputScript","setWitness","baddress","classify","SCRIPT_TYPES","PREVOUT_TYPES","tfMessage","__PREV_TX_SET","__INPUTS","__USE_LOW_R","fromTransaction","txb","setLockTime","__addInputUnsafe","vin","redeemScriptType","unmatched","match","parsed","fixMultisigOrder","setLowR","setting","txHash","__canModifyInputs","txIsTransaction","__canModifyOutputs","build","__build","buildIncomplete","signParams","witnessValue","ourPubKey","signatureHash","useLowR","signed","trySign","needsOutputs","prevOutScriptType","Signer","prevOutType","posType","checkSignArgs","getPublicKey","canSign","prepared","p2wshAlt","p2shAlt","expanded","expandOutput","signScript","witnessScriptType","signType","maxSignatures","prepareInput","getSigningData","__needsOutputs","bind","prevTxOut","expandInput","__overMaximumFees","signatureHashType","signingHashType","nInputs","nOutputs","witnessStack","ssType","wsType","outputType","pkh1","pkh2","wpkh1","wpkh2","UINT31_MAX","pow","BIP32Path","UInt31","UInt53","ECPoint","quacksLike","oneOf","base58","module","checksumFn","decodeRaw","newChecksum","string","decodeUnsafe","bs58checkBase","ANY","Symbol","Comparator","comp","parseOptions","loose","trim","debug","operator","re","COMPARATORLOOSE","COMPARATOR","SemVer","test","er","cmp","intersects","Range","includePrerelease","startsWith","safeRe","raw","parseRange","first","isNullSet","isAny","comps","memoKey","FLAG_INCLUDE_PRERELEASE","FLAG_LOOSE","cached","hr","HYPHENRANGELOOSE","HYPHENRANGE","replace","hyphenReplace","COMPARATORTRIM","comparatorTrimReplace","TILDETRIM","tildeTrimReplace","CARETTRIM","caretTrimReplace","rangeList","parseComparator","replaceGTE0","rangeMap","comparators","thisComparators","isSatisfiable","rangeComparators","thisComparator","rangeComparator","testSet","remainingComparators","testComparator","otherComparator","replaceCarets","replaceTildes","replaceXRanges","replaceStars","isX","id","toLowerCase","replaceTilde","TILDELOOSE","TILDE","M","pr","replaceCaret","CARETLOOSE","CARET","z","replaceXRange","XRANGELOOSE","XRANGE","gtlt","xM","xm","xp","anyX","STAR","GTE0PRE","GTE0","incPr","$0","fM","fm","fp","fpr","fb","tM","tm","tp","tpr","prerelease","allowed","major","minor","patch","MAX_LENGTH","compareIdentifiers","LOOSE","FULL","other","compareMain","comparePre","compareBuild","inc","release","identifier","identifierBase","base","isNaN","clean","eq","neq","gt","gte","lt","lte","coerce","rtl","coerceRtlRegex","COERCERTLFULL","COERCERTL","next","exec","lastIndex","COERCEFULL","COERCE","versionA","versionB","compareLoose","diff","version1","version2","v1","v2","comparison","v1Higher","highVersion","lowVersion","highHasPre","throwErrors","rcompare","rsort","list","satisfies","valid","internalRe","constants","identifiers","toComparators","maxSatisfying","minSatisfying","minVersion","validRange","outside","gtr","ltr","simplifyRange","subset","src","tokens","SEMVER_SPEC_VERSION","RELEASE_TYPES","rcompareIdentifiers","MAX_SAFE_COMPONENT_LENGTH","MAX_SAFE_BUILD_LENGTH","process","NODE_DEBUG","args","error","numeric","anum","bnum","firstKey","looseOption","freeze","emptyOpts","R","LETTERDASHNUMBER","safeRegexReplacements","createToken","isGlobal","safe","token","makeSafeRegex","RegExp","NUMERICIDENTIFIER","NUMERICIDENTIFIERLOOSE","NONNUMERICIDENTIFIER","PRERELEASEIDENTIFIER","PRERELEASEIDENTIFIERLOOSE","BUILDIDENTIFIER","MAINVERSION","PRERELEASE","BUILD","FULLPLAIN","MAINVERSIONLOOSE","PRERELEASELOOSE","LOOSEPLAIN","XRANGEIDENTIFIER","XRANGEIDENTIFIERLOOSE","GTLT","XRANGEPLAIN","XRANGEPLAINLOOSE","COERCEPLAIN","LONETILDE","LONECARET","r1","r2","versions","maxSV","rangeObj","minSV","minver","setMin","comparator","compver","hilo","gtfn","ltefn","ltfn","ecomp","high","low","prev","ranges","simplified","original","minimumVersionWithPreRelease","minimumVersion","simpleSubset","sub","dom","eqSet","gtltComp","higher","lower","hasDomLT","hasDomGT","higherGT","lowerLT","add","needDomLTPre","needDomGTPre","sawNonNull","OUTER","simpleSub","simpleDom","isSub","subscribers","dispatch","LocalTracer","context","trace","getContext","setContext","updateContext","contextToAdd","getType","setType","withType","withContext","withUpdatedContext","listen","cb","window","__ledgerLogsListen","HARDENED","BIPPath","isArray","validatePathArray","fromPathArray","validateString","reqRoot","fromString","parseInt","prototype","noRoot","oldStyle","inspect","UINT256_TYPE","NETWORK_TYPE","BITCOIN","HIGHEST_BIT","BIP32","__DEPTH","__INDEX","__PARENT_FINGERPRINT","isNeutered","neutered","fromPublicKeyLocal","toBase58","derive","isHardened","I","hmacSHA512","IL","IR","hd","Ki","ki","privateAdd","fromPrivateKeyLocal","deriveHardened","splitPath","prevHd","indexStr","fromBase58","inString","fromSeed","seed","createHmac","sha256Hash","bip32_1","condition","argIndex","framesToPop","OP_PUSHDATA1","OP_PUSHDATA2","readUInt16LE"],"sourceRoot":""}